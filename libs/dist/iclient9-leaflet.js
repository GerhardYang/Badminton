/*!
 * 
 *     iclient9-leaflet.(http://iclient.supermap.io)
 *     Copyright© 2000-2017 SuperMap Software Co. Ltd
 *     license: Apache-2.0
 *     version: v9.0.0
 * 
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 550);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var SuperMap = exports.SuperMap = window.SuperMap = window.SuperMap || {};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Util = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _SuperMap = __webpack_require__(0);

__webpack_require__(46);

var Util = exports.Util = _SuperMap.SuperMap.Util = _SuperMap.SuperMap.Util || {};
/**
 * @name Util
 * @memberOf SuperMap
 * @namespace
 * @description common工具类。
 */

/**
 * @description 复制源对象的所有属性到目标对象上，源对象上的没有定义的属性在目标对象上也不会被设置。
 * @example
 * 要复制SuperMap.Size对象的所有属性到自定义对象上，使用方法如下:
 *     var size = new SuperMap.Size(100, 100);
 *     var obj = {}；
 *     SuperMap.Util.extend(obj, size);
 * @param destination - {Object} 目标对象。
 * @param source - {Object} 源对象，其属性将被设置到目标对象上。
 * @return {Object} 目标对象。
 */

_SuperMap.SuperMap.Util.extend = function (destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }

        /**
         * IE doesn't include the toString property when iterating over an object's
         * properties with the for(property in object) syntax.  Explicitly check if
         * the source has its own toString property.
         */

        /*
         * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
         * prototype object" when calling hawOwnProperty if the source object
         * is an instance of window.Event.
         */

        var sourceIsEvt = typeof window.Event === "function" && source instanceof window.Event;

        if (!sourceIsEvt && source.hasOwnProperty && source.hasOwnProperty("toString")) {
            destination.toString = source.toString;
        }
    }
    return destination;
};
/**
 * @description 对象拷贝。
 * @param des - {Object} 目标对象。
 * @param soc - {Object} 源对象
 */
_SuperMap.SuperMap.Util.copy = function (des, soc) {
    des = des || {};
    var v;
    if (soc) {
        for (var p in des) {
            v = soc[p];
            if (typeof v !== 'undefined') {
                des[p] = v;
            }
        }
    }
};
/**
 * @description 销毁对象，将其属性置空
 * @param obj - {Object} 目标对象。
 */
_SuperMap.SuperMap.Util.reset = function (obj) {
    obj = obj || {};
    for (var p in obj) {
        if (obj.hasOwnProperty(p)) {
            if (_typeof(obj[p]) === "object" && obj[p] instanceof Array) {
                for (var i in obj[p]) {
                    if (obj[p][i].destroy) {
                        obj[p][i].destroy();
                    }
                }
                obj[p].length = 0;
            } else if (_typeof(obj[p]) === "object" && obj[p] instanceof Object) {
                if (obj[p].destroy) {
                    obj[p].destroy();
                }
            }
            obj[p] = null;
        }
    }
};

/**
 * @description 获取HTML元素数组。
 * @param argument - {String | HTMLElement | Window}
 * @return {Array<HTMLElement>} HTML元素数组。
 */
_SuperMap.SuperMap.Util.getElement = function () {
    var elements = [];

    for (var i = 0, len = arguments.length; i < len; i++) {
        var element = arguments[i];
        if (typeof element === 'string') {
            element = document.getElementById(element);
        }
        if (arguments.length === 1) {
            return element;
        }
        elements.push(element);
    }
    return elements;
};

/**
 * @description instance of的跨浏览器实现。
 * @param o - {Object} 对象。
 * @return {boolean} 是否是页面元素
 */
_SuperMap.SuperMap.Util.isElement = function (o) {
    return !!(o && o.nodeType === 1);
};

/**
 * @description 判断一个对象是否是数组。
 * @param a - {Object} 对象。
 * @return {boolean} 是否是数组。
 */
_SuperMap.SuperMap.Util.isArray = function (a) {
    return Object.prototype.toString.call(a) === '[object Array]';
};

/**
 * @description 从数组中删除某一项。
 * @param array - {Array} 数组。
 * @param item - {Object} 数组中要删除的一项。
 * @return {Array} 执行删除操作后的数组。
 */
_SuperMap.SuperMap.Util.removeItem = function (array, item) {
    for (var i = array.length - 1; i >= 0; i--) {
        if (array[i] === item) {
            array.splice(i, 1);
            //break;more than once??
        }
    }
    return array;
};

/**
 * @description 获取某对象再数组中的索引值。
 * @param array - {Array} 数组。
 * @param obj - {Object} 对象。
 * @return {number} 某对象再数组中的索引值。
 */
_SuperMap.SuperMap.Util.indexOf = function (array, obj) {
    if (array == null) {
        return -1;
    } else {
        // use the build-in function if available.
        if (typeof array.indexOf === "function") {
            return array.indexOf(obj);
        } else {
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === obj) {
                    return i;
                }
            }
            return -1;
        }
    }
};

/**
 * @description 修改某DOM元素的许多属性。
 * @param element - {HTMLElement} 待修改的DOM元素。
 * @param id - {string} DOM元素的id。
 * @param px - {SuperMap.Pixel} 包含DOM元素的style属性的left和top属性。
 * @param sz - {SuperMap.Size} 包含DOM元素的width和height属性。
 * @param position - {string} DOM元素的position属性。
 * @param border - {string} DOM元素的style属性的border属性。
 * @param overflow - {string} DOM元素的style属性的overflow属性。
 * @param opacity - {number} 不透明度值。取值范围为 (0.0 - 1.0)。
 */
_SuperMap.SuperMap.Util.modifyDOMElement = function (element, id, px, sz, position, border, overflow, opacity) {

    if (id) {
        element.id = id;
    }
    if (px) {
        element.style.left = px.x + "px";
        element.style.top = px.y + "px";
    }
    if (sz) {
        element.style.width = sz.w + "px";
        element.style.height = sz.h + "px";
    }
    if (position) {
        element.style.position = position;
    }
    if (border) {
        element.style.border = border;
    }
    if (overflow) {
        element.style.overflow = overflow;
    }
    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
        element.style.filter = 'alpha(opacity=' + opacity * 100 + ')';
        element.style.opacity = opacity;
    } else if (parseFloat(opacity) === 1.0) {
        element.style.filter = '';
        element.style.opacity = '';
    }
};

/**
 * @description Takes an object and copies any properties that don't exist from
 *     another properties, by analogy with SuperMap.Util.extend() from
 *     Prototype.js.
 *
 * @param to -{Object} The destination object.
 * @param from -{Object} The source object.  Any properties of this object that
 *     are undefined in the to object will be set on the to object.
 *
 * @return {Object} A reference to the to object.  Note that the to argument is modified
 *     in place and returned by this function.
 */
_SuperMap.SuperMap.Util.applyDefaults = function (to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */
    var fromIsEvt = typeof window.Event === "function" && from instanceof window.Event;

    for (var key in from) {
        if (to[key] === undefined || !fromIsEvt && from.hasOwnProperty && from.hasOwnProperty(key) && !to.hasOwnProperty(key)) {
            to[key] = from[key];
        }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */
    if (!fromIsEvt && from && from.hasOwnProperty && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
        to.toString = from.toString;
    }

    return to;
};

/**
 * @param params - {Object} 参数对象。
 * @return {string} HTTP的GEI请求中的参数字符串。
 * @description 将参数对象转换为HTTP的GEI请求中的参数字符串。例如："key1=value1&key2=value2&key3=value3"。
 */
_SuperMap.SuperMap.Util.getParameterString = function (params) {
    var paramsArray = [];

    for (var key in params) {
        var value = params[key];
        if (value != null && typeof value !== 'function') {
            var encodedValue;
            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Array) {
                /* value is an array; encode items and separate with "," */
                var encodedItemArray = [];
                var item;
                for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
                    item = value[itemIndex];
                    encodedItemArray.push(encodeURIComponent(item === null || item === undefined ? "" : item));
                }
                encodedValue = encodedItemArray.join(",");
            } else {
                /* value is a string; simply encode */
                encodedValue = encodeURIComponent(value);
            }
            paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
        }
    }

    return paramsArray.join("&");
};

/**
 * @description 给url追加参数。
 * @param url - {string} 待追加参数的url字符串。
 * @param paramStr - {string} 待追加的参数。
 * @return {string} The new url
 */
_SuperMap.SuperMap.Util.urlAppend = function (url, paramStr) {
    var newUrl = url;
    if (paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += parts.pop() === " " ? paramStr : parts.length ? "&" + paramStr : "?" + paramStr;
    }
    return newUrl;
};

/**
 * @description 为了避免浮点精度错误而保留的有效位数。
 * @type {number}
 * @default 14
 */
_SuperMap.SuperMap.Util.DEFAULT_PRECISION = 14;

/**
 * @description 将字符串以接近的精度转换为数字。
 * @param number - {string} 字符串。
 * @param precision - {number} 精度。
 * @return {number} 数字。
 */
_SuperMap.SuperMap.Util.toFloat = function (number, precision) {
    if (precision == null) {
        precision = _SuperMap.SuperMap.Util.DEFAULT_PRECISION;
    }
    if (typeof number !== "number") {
        number = parseFloat(number);
    }
    return precision === 0 ? number : parseFloat(number.toPrecision(precision));
};

/**
 * @description 角度转弧度。
 * @param x - {number} 角度。
 * @return {number} 弧度。
 */
_SuperMap.SuperMap.Util.rad = function (x) {
    return x * Math.PI / 180;
};

/**
 * @description 从URL字符串中解析出参数对象。
 * @param url - {string} url。
 * @return {Object} 解析出的参数对象。
 */
_SuperMap.SuperMap.Util.getParameters = function (url) {
    // if no url specified, take it from the location bar
    url = url === null || url === undefined ? window.location.href : url;

    //parse out parameters portion of url string
    var paramsString = "";
    if (_SuperMap.SuperMap.String.contains(url, '?')) {
        var start = url.indexOf('?') + 1;
        var end = _SuperMap.SuperMap.String.contains(url, "#") ? url.indexOf('#') : url.length;
        paramsString = url.substring(start, end);
    }

    var parameters = {};
    var pairs = paramsString.split(/[&;]/);
    for (var i = 0, len = pairs.length; i < len; ++i) {
        var keyValue = pairs[i].split('=');
        if (keyValue[0]) {

            var key = keyValue[0];
            try {
                key = decodeURIComponent(key);
            } catch (err) {
                key = unescape(key);
            }

            // being liberal by replacing "+" with " "
            var value = (keyValue[1] || '').replace(/\+/g, " ");

            try {
                value = decodeURIComponent(value);
            } catch (err) {
                value = unescape(value);
            }

            // follow OGC convention of comma delimited values
            value = value.split(",");

            //if there's only one value, do not return as array                    
            if (value.length == 1) {
                value = value[0];
            }

            parameters[key] = value;
        }
    }
    return parameters;
};

/**
 * @description 不断递增计数变量，用于生成唯一ID。
 * @type {number}
 * @default 0
 */
_SuperMap.SuperMap.Util.lastSeqID = 0;

/**
 * @description 创建唯一ID值。
 * @param prefix {string} 前缀。
 * @return {string} 唯一的ID值。
 */
_SuperMap.SuperMap.Util.createUniqueID = function (prefix) {
    if (prefix == null) {
        prefix = "id_";
    }
    _SuperMap.SuperMap.Util.lastSeqID += 1;
    return prefix + _SuperMap.SuperMap.Util.lastSeqID;
};

/**
 * @memberOf SuperMap
 * @description 每单位的英尺数。
 * @type {Object}
 * @constant
 */
_SuperMap.SuperMap.INCHES_PER_UNIT = {
    'inches': 1.0,
    'ft': 12.0,
    'mi': 63360.0,
    'm': 39.3701,
    'km': 39370.1,
    'dd': 4374754,
    'yd': 36
};
_SuperMap.SuperMap.INCHES_PER_UNIT["in"] = _SuperMap.SuperMap.INCHES_PER_UNIT.inches;
_SuperMap.SuperMap.INCHES_PER_UNIT["degrees"] = _SuperMap.SuperMap.INCHES_PER_UNIT.dd;
_SuperMap.SuperMap.INCHES_PER_UNIT["nmi"] = 1852 * _SuperMap.SuperMap.INCHES_PER_UNIT.m;

// Units from CS-Map
_SuperMap.SuperMap.METERS_PER_INCH = 0.02540005080010160020;
_SuperMap.SuperMap.Util.extend(_SuperMap.SuperMap.INCHES_PER_UNIT, {
    "Inch": _SuperMap.SuperMap.INCHES_PER_UNIT.inches,
    "Meter": 1.0 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9001
    "Foot": 0.30480060960121920243 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9003
    "IFoot": 0.30480000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9002
    "ClarkeFoot": 0.3047972651151 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9005
    "SearsFoot": 0.30479947153867624624 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9041
    "GoldCoastFoot": 0.30479971018150881758 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9094
    "IInch": 0.02540000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "MicroInch": 0.00002540000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Mil": 0.00000002540000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Centimeter": 0.01000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Kilometer": 1000.00000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9036
    "Yard": 0.91440182880365760731 / _SuperMap.SuperMap.METERS_PER_INCH,
    "SearsYard": 0.914398414616029 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9040
    "IndianYard": 0.91439853074444079983 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9084
    "IndianYd37": 0.91439523 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9085
    "IndianYd62": 0.9143988 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9086
    "IndianYd75": 0.9143985 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9087
    "IndianFoot": 0.30479951 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9080
    "IndianFt37": 0.30479841 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9081
    "IndianFt62": 0.3047996 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9082
    "IndianFt75": 0.3047995 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9083
    "Mile": 1609.34721869443738887477 / _SuperMap.SuperMap.METERS_PER_INCH,
    "IYard": 0.91440000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9096
    "IMile": 1609.34400000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9093
    "NautM": 1852.00000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9030
    "Lat-66": 110943.316488932731 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Lat-83": 110946.25736872234125 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Decimeter": 0.10000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Millimeter": 0.00100000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Dekameter": 10.00000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Decameter": 10.00000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Hectometer": 100.00000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "GermanMeter": 1.0000135965 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9031
    "CaGrid": 0.999738 / _SuperMap.SuperMap.METERS_PER_INCH,
    "ClarkeChain": 20.1166194976 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9038
    "GunterChain": 20.11684023368047 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9033
    "BenoitChain": 20.116782494375872 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9062
    "SearsChain": 20.11676512155 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9042
    "ClarkeLink": 0.201166194976 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9039
    "GunterLink": 0.2011684023368047 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9034
    "BenoitLink": 0.20116782494375872 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9063
    "SearsLink": 0.2011676512155 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9043
    "Rod": 5.02921005842012 / _SuperMap.SuperMap.METERS_PER_INCH,
    "IntnlChain": 20.1168 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9097
    "IntnlLink": 0.201168 / _SuperMap.SuperMap.METERS_PER_INCH, //EPSG:9098
    "Perch": 5.02921005842012 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Pole": 5.02921005842012 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Furlong": 201.1684023368046 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Rood": 3.778266898 / _SuperMap.SuperMap.METERS_PER_INCH,
    "CapeFoot": 0.3047972615 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Brealey": 375.00000000000000000000 / _SuperMap.SuperMap.METERS_PER_INCH,
    "ModAmFt": 0.304812252984505969011938 / _SuperMap.SuperMap.METERS_PER_INCH,
    "Fathom": 1.8288 / _SuperMap.SuperMap.METERS_PER_INCH,
    "NautM-UK": 1853.184 / _SuperMap.SuperMap.METERS_PER_INCH,
    "50kilometers": 50000.0 / _SuperMap.SuperMap.METERS_PER_INCH,
    "150kilometers": 150000.0 / _SuperMap.SuperMap.METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
_SuperMap.SuperMap.Util.extend(_SuperMap.SuperMap.INCHES_PER_UNIT, {
    "mm": _SuperMap.SuperMap.INCHES_PER_UNIT["Meter"] / 1000.0,
    "cm": _SuperMap.SuperMap.INCHES_PER_UNIT["Meter"] / 100.0,
    "dm": _SuperMap.SuperMap.INCHES_PER_UNIT["Meter"] * 100.0,
    "km": _SuperMap.SuperMap.INCHES_PER_UNIT["Meter"] * 1000.0,
    "kmi": _SuperMap.SuperMap.INCHES_PER_UNIT["nmi"], //International Nautical Mile
    "fath": _SuperMap.SuperMap.INCHES_PER_UNIT["Fathom"], //International Fathom
    "ch": _SuperMap.SuperMap.INCHES_PER_UNIT["IntnlChain"], //International Chain
    "link": _SuperMap.SuperMap.INCHES_PER_UNIT["IntnlLink"], //International Link
    "us-in": _SuperMap.SuperMap.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
    "us-ft": _SuperMap.SuperMap.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
    "us-yd": _SuperMap.SuperMap.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
    "us-ch": _SuperMap.SuperMap.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
    "us-mi": _SuperMap.SuperMap.INCHES_PER_UNIT["Mile"], //U.S. Surveyor's Statute Mile
    "ind-yd": _SuperMap.SuperMap.INCHES_PER_UNIT["IndianYd37"], //Indian Yard
    "ind-ft": _SuperMap.SuperMap.INCHES_PER_UNIT["IndianFt37"], //Indian Foot
    "ind-ch": 20.11669506 / _SuperMap.SuperMap.METERS_PER_INCH //Indian Chain
});

/**
 * @memberOf SuperMap
 * @description 分辨率与比例尺之间转换的常量，默认值96。
 * @type {Object}
 * @default 96
 */
_SuperMap.SuperMap.DOTS_PER_INCH = 96;

/**
 * @param scale - {number}
 * @return {number} 返回正常的scale值
 */
_SuperMap.SuperMap.Util.normalizeScale = function (scale) {
    var normScale = scale > 1.0 ? 1.0 / scale : scale;
    return normScale;
};

/**
 * @param scale - {number} 比例尺。
 * @param units - {string} 比例尺单位。
 * @return {number} 分辨率。
 */
_SuperMap.SuperMap.Util.getResolutionFromScale = function (scale, units) {
    var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = _SuperMap.SuperMap.Util.normalizeScale(scale);
        resolution = 1 / (normScale * _SuperMap.SuperMap.INCHES_PER_UNIT[units] * _SuperMap.SuperMap.DOTS_PER_INCH);
    }
    return resolution;
};

/**
 * @description 分辨率转比例尺。
 * @param resolution - {number} 分辨率。
 * @param units - {string} 分辨率单位。
 * @return {number} 比例尺。
 */
_SuperMap.SuperMap.Util.getScaleFromResolution = function (resolution, units) {

    if (units == null) {
        units = "degrees";
    }

    var scale = resolution * _SuperMap.SuperMap.INCHES_PER_UNIT[units] * _SuperMap.SuperMap.DOTS_PER_INCH;
    return scale;
};

/**
 * @memberOf SuperMap
 * @description 如果userAgent捕获到浏览器使用的是Gecko引擎则返回true。
 * @constant
 */
_SuperMap.SuperMap.IS_GECKO = function () {
    var ua = navigator.userAgent.toLowerCase();
    return ua.indexOf("webkit") === -1 && ua.indexOf("gecko") !== -1;
}();

/**
 * @memberOf SuperMap
 * @description 浏览器名称，依赖于userAgent属性，BROWSER_NAME可以是空，或者以下浏览器：
 *     * "opera" -- Opera
 *     * "msie"  -- Internet Explorer
 *     * "safari" -- Safari
 *     * "firefox" -- Firefox
 *     * "mozilla" -- Mozilla
 * @constant
 */
_SuperMap.SuperMap.Browser = function () {
    var name = '',
        version = '',
        device = 'pc',
        uaMatch;
    //以下进行测试
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf("msie") > -1 || ua.indexOf("trident") > -1 && ua.indexOf("rv") > -1) {
        name = 'msie';
        uaMatch = ua.match(/msie ([\d.]+)/) || ua.match(/rv:([\d.]+)/);
    } else if (ua.indexOf("chrome") > -1) {
        name = 'chrome';
        uaMatch = ua.match(/chrome\/([\d.]+)/);
    } else if (ua.indexOf("firefox") > -1) {
        name = 'firefox';
        uaMatch = ua.match(/firefox\/([\d.]+)/);
    } else if (ua.indexOf("opera") > -1) {
        name = 'opera';
        uaMatch = ua.match(/version\/([\d.]+)/);
    } else if (ua.indexOf("safari") > -1) {
        name = 'safari';
        uaMatch = ua.match(/version\/([\d.]+)/);
    }
    version = uaMatch ? uaMatch[1] : '';

    if (ua.indexOf("ipad") > -1 || ua.indexOf("ipod") > -1 || ua.indexOf("iphone") > -1) {
        device = 'apple';
    } else if (ua.indexOf("android") > -1) {
        uaMatch = ua.match(/version\/([\d.]+)/);
        version = uaMatch ? uaMatch[1] : '';
        device = 'android';
    }
    return { name: name, version: version, device: device };
}();

/**
 * @description 获取浏览器相关信息。支持的浏览器包括：Opera，Internet Explorer，Safari，Firefox。
 * @return {Object} 获取浏览器名称、版本、设备名称。对应的属性分别为 name, version, device。
 */
_SuperMap.SuperMap.Util.getBrowser = function () {
    return _SuperMap.SuperMap.Browser;
};

/**
 * @description 浏览器是否支持Canvas。
 * @return {boolean} 获取当前浏览器是否支持 HTML5 Canvas 。
 */
_SuperMap.SuperMap.Util.isSupportCanvas = function () {
    var checkRes = true,
        broz = _SuperMap.SuperMap.Util.getBrowser();
    if (document.createElement("canvas").getContext) {
        if (broz.name === 'firefox' && parseFloat(broz.version) < 5) {
            checkRes = false;
        }
        if (broz.name === 'safari' && parseFloat(broz.version) < 4) {
            checkRes = false;
        }
        if (broz.name === 'opera' && parseFloat(broz.version) < 10) {
            checkRes = false;
        }
        if (broz.name === 'msie' && parseFloat(broz.version) < 9) {
            checkRes = false;
        }
    } else {
        checkRes = false;
    }
    return checkRes;
}();

/**
 * @description 判断；浏览器是否支持Canvas。
 * @return {boolean} 获取当前浏览器是否支持 HTML5 Canvas 。
 */
_SuperMap.SuperMap.Util.supportCanvas = function () {
    return _SuperMap.SuperMap.Util.isSupportCanvas;
};

//将服务端的地图单位转成SuperMap的地图单位
_SuperMap.SuperMap.INCHES_PER_UNIT["degree"] = _SuperMap.SuperMap.INCHES_PER_UNIT.dd;
_SuperMap.SuperMap.INCHES_PER_UNIT["meter"] = _SuperMap.SuperMap.INCHES_PER_UNIT.m;
_SuperMap.SuperMap.INCHES_PER_UNIT["foot"] = _SuperMap.SuperMap.INCHES_PER_UNIT.ft;
_SuperMap.SuperMap.INCHES_PER_UNIT["inch"] = _SuperMap.SuperMap.INCHES_PER_UNIT.inches;
_SuperMap.SuperMap.INCHES_PER_UNIT["mile"] = _SuperMap.SuperMap.INCHES_PER_UNIT.mi;
_SuperMap.SuperMap.INCHES_PER_UNIT["kilometer"] = _SuperMap.SuperMap.INCHES_PER_UNIT.km;
_SuperMap.SuperMap.INCHES_PER_UNIT["yard"] = _SuperMap.SuperMap.INCHES_PER_UNIT.yd;

/**
 * @description 判断一个 URL 请求是否在当前域中。
 * @param url - {string}  URL 请求字符串。
 * @return {boolean} URL请求是否在当前域中。
 */
_SuperMap.SuperMap.Util.isInTheSameDomain = function (url) {
    if (!url) {
        return true;
    }
    var index = url.indexOf("//");
    var documentUrl = document.location.toString();
    var documentIndex = documentUrl.indexOf("//");
    if (index === -1) {
        return true;
    } else {
        var protocol;
        var substring = protocol = url.substring(0, index);
        var documentSubString = documentUrl.substring(documentIndex + 2);
        documentIndex = documentSubString.indexOf("/");
        var documentPortIndex = documentSubString.indexOf(":");
        var documentDomainWithPort = documentSubString.substring(0, documentIndex);
        //var documentPort;

        var documentprotocol = document.location.protocol;
        if (documentPortIndex !== -1) {
            // documentPort = +documentSubString.substring(documentPortIndex, documentIndex);
        } else {
            documentDomainWithPort += ':' + (documentprotocol.toLowerCase() === 'http:' ? 80 : 443);
        }
        if (documentprotocol.toLowerCase() !== substring.toLowerCase()) {
            return false;
        }
        substring = url.substring(index + 2);
        var portIndex = substring.indexOf(":");
        index = substring.indexOf("/");
        var domainWithPort = substring.substring(0, index);
        var domain;
        if (portIndex !== -1) {
            domain = substring.substring(0, portIndex);
        } else {
            domain = substring.substring(0, index);
            domainWithPort += ':' + (protocol.toLowerCase() === 'http:' ? 80 : 443);
        }
        var documentDomain = document.domain;
        if (domain === documentDomain && domainWithPort === documentDomainWithPort) {
            return true;
        }
    }
    return false;
};

/**
 * @description 计算iServer服务的REST图层的显示分辨率，需要从iServer的REST图层表述中获取viewBounds、viewer、scale、coordUnit、datumAxis 五个参数，来进行计算。
 * @param viewBounds - {SuperMap.Bounds} 地图的参照可视范围，即地图初始化时默认的地图显示范围。
 * @param viewer - {SuperMap.Size} 地图初始化时默认的地图图片的尺寸。
 * @param scale - {number} 地图初始化时默认的显示比例尺。
 * @param coordUnit - {string} 投影坐标系统的地图单位。
 * @param datumAxis - {number} 地理坐标系统椭球体长半轴。用户自定义地图的Options时，若未指定该参数的值，则系统默认为WGS84参考系的椭球体长半轴6378137。
 * @return {number} 返回图层显示分辨率。
 */
_SuperMap.SuperMap.Util.calculateDpi = function (viewBounds, viewer, scale, coordUnit, datumAxis) {
    //10000 是 0.1毫米与米的转换。DPI的计算公式：Viewer / DPI *  0.0254 * 10000 = ViewBounds * scale ，公式中的10000是为了提高计算结果的精度，以下出现的ratio皆为如此。
    if (!viewBounds || !viewer || !scale) {
        return;
    }
    var ratio = 10000,
        rvbWidth = viewBounds.getWidth(),
        rvbHeight = viewBounds.getHeight(),
        rvWidth = viewer.w,
        rvHeight = viewer.h;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "degrees";
    var dpi;
    if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
        var num1 = rvbWidth / rvWidth,
            num2 = rvbHeight / rvHeight,
            resolution = num1 > num2 ? num1 : num2;
        dpi = 0.0254 * ratio / resolution / scale / (Math.PI * 2 * datumAxis / 360) / ratio;
    } else {
        var _resolution = rvbWidth / rvWidth;
        dpi = 0.0254 * ratio / _resolution / scale / ratio;
    }
    return dpi;
};

/**
 * @description 将对象转换成 JSON 字符串。
 * @param obj - {Object} 要转换成 JSON 的 Object 对象。
 * @return {string} 返回转换后的 JSON 对象。
 */
_SuperMap.SuperMap.Util.toJSON = function (obj) {
    var objInn = obj;
    if (objInn == null) {
        return null;
    }
    switch (objInn.constructor) {
        case String:
            //s = "'" + str.replace(/(["\\])/g, "\\$1") + "'";   string含有单引号出错
            objInn = '"' + objInn.replace(/(["\\])/g, '\\$1') + '"';
            objInn = objInn.replace(/\n/g, "\\n");
            objInn = objInn.replace(/\r/g, "\\r");
            objInn = objInn.replace("<", "&lt;");
            objInn = objInn.replace(">", "&gt;");
            objInn = objInn.replace(/%/g, "%25");
            objInn = objInn.replace(/&/g, "%26");
            return objInn;
        case Array:
            var arr = [];
            for (var i = 0, len = objInn.length; i < len; i++) {
                arr.push(_SuperMap.SuperMap.Util.toJSON(objInn[i]));
            }
            return "[" + arr.join(",") + "]";
        case Number:
            return isFinite(objInn) ? String(objInn) : null;
        case Boolean:
            return String(objInn);
        case Date:
            var dateStr = "{" + "'__type':\"System.DateTime\"," + "'Year':" + objInn.getFullYear() + "," + "'Month':" + (objInn.getMonth() + 1) + "," + "'Day':" + objInn.getDate() + "," + "'Hour':" + objInn.getHours() + "," + "'Minute':" + objInn.getMinutes() + "," + "'Second':" + objInn.getSeconds() + "," + "'Millisecond':" + objInn.getMilliseconds() + "," + "'TimezoneOffset':" + objInn.getTimezoneOffset() + "}";
            return dateStr;
        default:
            if (objInn["toJSON"] != null && typeof objInn["toJSON"] === "function") {
                return objInn.toJSON();
            }
            if ((typeof objInn === 'undefined' ? 'undefined' : _typeof(objInn)) === "object") {
                if (objInn.length) {
                    var _arr2 = [];
                    for (var _i = 0, _len = objInn.length; _i < _len; _i++) {
                        _arr2.push(_SuperMap.SuperMap.Util.toJSON(objInn[_i]));
                    }
                    return "[" + _arr2.join(",") + "]";
                }
                var _arr = [];
                for (var attr in objInn) {
                    //为解决SuperMap.Geometry类型头json时堆栈溢出的问题，attr == "parent"时不进行json转换
                    if (typeof objInn[attr] !== "function" && attr !== "CLASS_NAME" && attr !== "parent") {
                        _arr.push("'" + attr + "':" + _SuperMap.SuperMap.Util.toJSON(objInn[attr]));
                    }
                }

                if (_arr.length > 0) {
                    return "{" + _arr.join(",") + "}";
                } else {
                    return "{}";
                }
            }
            return objInn.toString();
    }
};

/**
 * @description 根据比例尺和dpi计算屏幕分辨率。
 * @param scale - {number} 比例尺。
 * @param dpi - {number} 图像分辨率，表示每英寸内的像素个数。
 * @param coordUnit - {string} 投影坐标系统的地图单位。
 * @param datumAxis - {number} 地理坐标系统椭球体长半轴。用户自定义地图的Options时，若未指定该参数的值，则DPI默认按照WGS84参考系的椭球体长半轴6378137来计算。
 * @return {number} 返回当前比例尺下的屏幕分辨率。
 */
_SuperMap.SuperMap.Util.getResolutionFromScaleDpi = function (scale, dpi, coordUnit, datumAxis) {
    var resolution = null,
        ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "";
    if (scale > 0 && dpi > 0) {
        scale = _SuperMap.SuperMap.Util.normalizeScale(scale);
        if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
            //scale = SuperMap.Util.normalizeScale(scale);
            resolution = 0.0254 * ratio / dpi / scale / (Math.PI * 2 * datumAxis / 360) / ratio;
            return resolution;
        } else {
            resolution = 0.0254 * ratio / dpi / scale / ratio;
            return resolution;
        }
    }
    return -1;
};

/**
 * @description 根据resolution、dpi、coordUnit和datumAxis计算比例尺。
 * @param resolution - {number} 用于计算比例尺的地图分辨率。
 * @param dpi - {number} 图像分辨率，表示每英寸内的像素个数。
 * @param coordUnit - {string} 投影坐标系统的地图单位。
 * @param datumAxis - {number} 地理坐标系统椭球体长半轴。用户自定义地图的Options时，若未指定该参数的值，则DPI默认按照WGS84参考系的椭球体长半轴6378137来计算。
 * @return {number} 返回当前屏幕分辨率下的比例尺。
 */
_SuperMap.SuperMap.Util.getScaleFromResolutionDpi = function (resolution, dpi, coordUnit, datumAxis) {
    var scale = null,
        ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "";
    if (resolution > 0 && dpi > 0) {
        if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
            scale = 0.0254 * ratio / dpi / resolution / (Math.PI * 2 * datumAxis / 360) / ratio;
            return scale;
        } else {
            scale = 0.0254 * ratio / dpi / resolution / ratio;
            return scale;
        }
    }
    return -1;
};

/**
 * @description 转换查询结果。
 * @param result - {Object} 查询结果。
 * @return {Object} 转换后的查询结果。
 */
_SuperMap.SuperMap.Util.transformResult = function (result) {
    if (result.responseText && typeof result.responseText === "string") {
        result = JSON.parse(result.responseText);
    }
    return result;
};

/**
 * @description 属性拷贝，不拷贝方法类名(CLASS_NAME)等。
 * @param destination - {Object} 拷贝目标。
 * @param source - {Object} 源对象。
 *
 */
_SuperMap.SuperMap.Util.copyAttributes = function (destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined && property !== "CLASS_NAME" && typeof value !== "function") {
                destination[property] = value;
            }
        }
    }
    return destination;
};

/**
 * @description 将源对象上的属性拷贝到目标对象上。（不拷贝 CLASS_NAME 和方法）
 * @param destination - {Object} 目标对象。
 * @param source - {Object} 源对象。
 * @param clip - {Array<string>} 源对象中禁止拷贝到目标对象的属性，目的是防止目标对象上不可修改的属性被篡改。
 *
 */
_SuperMap.SuperMap.Util.copyAttributesWithClip = function (destination, source, clip) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            //去掉禁止拷贝的属性
            var isInClip = false;
            if (clip && clip.length) {
                for (var i = 0, len = clip.length; i < len; i++) {
                    if (property === clip[i]) {
                        isInClip = true;
                        break;
                    }
                }
            }
            if (isInClip === true) {
                continue;
            }

            var value = source[property];
            if (value !== undefined && property !== "CLASS_NAME" && typeof value !== "function") {
                destination[property] = value;
            }
        }
    }
    return destination;
};

/**
 * @description 克隆一份Object对象
 * @param obj - {Object}  需要克隆的对象。
 * @return {Object} 返回对象的拷贝对象，注意是新的对象，不是指向。
 */
_SuperMap.SuperMap.Util.cloneObject = function (obj) {
    // Handle the 3 simple types, and null or undefined
    if (null === obj || "object" !== (typeof obj === 'undefined' ? 'undefined' : _typeof(obj))) {
        return obj;
    }

    // Handle Date
    if (obj instanceof Date) {
        var copy = new Date();
        copy.setTime(obj.getTime());
        return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
        var _copy = obj.slice(0);
        return _copy;
    }

    // Handle Object
    if (obj instanceof Object) {
        var _copy2 = {};
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) {
                _copy2[attr] = _SuperMap.SuperMap.Util.cloneObject(obj[attr]);
            }
        }
        return _copy2;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
};

/**
 * @description 判断两条线段是不是有交点。
 * @param a1 - {SuperMap.Geometry.Point}  第一条线段的起始节点。
 * @param a2 - {SuperMap.Geometry.Point}  第一条线段的结束节点。
 * @param b1 - {SuperMap.Geometry.Point}  第二条线段的起始节点。
 * @param b2 - {SuperMap.Geometry.Point}  第二条线段的结束节点。
 * @return {Object} 如果相交返回交点，如果不相交返回两条线段的位置关系。
 */
_SuperMap.SuperMap.Util.lineIntersection = function (a1, a2, b1, b2) {
    var intersectValue = null;
    var k1;
    var k2;
    var b = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var a = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var ab = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    //ab==0代表两条线断的斜率一样
    if (ab != 0) {
        k1 = b / ab;
        k2 = a / ab;

        if (k1 >= 0 && k2 <= 1 && k1 <= 1 && k2 >= 0) {
            intersectValue = new _SuperMap.SuperMap.Geometry.Point(a1.x + k1 * (a2.x - a1.x), a1.y + k1 * (a2.y - a1.y));
        } else {
            intersectValue = "No Intersection";
        }
    } else {

        if (b == 0 && a == 0) {
            var maxy = Math.max(a1.y, a2.y);
            var miny = Math.min(a1.y, a2.y);
            var maxx = Math.max(a1.x, a2.x);
            var minx = Math.min(a1.x, a2.x);
            if ((b1.y >= miny && b1.y <= maxy || b2.y >= miny && b2.y <= maxy) && b1.x >= minx && b1.x <= maxx || b2.x >= minx && b2.x <= maxx) {
                intersectValue = "Coincident"; //重合
            } else {
                intersectValue = "Parallel"; //平行
            }
        } else {
            intersectValue = "Parallel"; //平行
        }
    }
    return intersectValue;
};

/**
 * @description 获取文本外接矩形宽度与高度。
 * @param style - {SuperMap.Style} 文本样式。
 * @param text - {string} 文本内容。
 * @param element - {Object} DOM元素。
 * @return {Object} 返回裁剪后的宽度，高度信息。
 */
_SuperMap.SuperMap.Util.getTextBounds = function (style, text, element) {
    document.body.appendChild(element);
    element.style.width = 'auto';
    element.style.height = 'auto';
    if (style.fontSize) {
        element.style.fontSize = style.fontSize;
    }
    if (style.fontFamily) {
        element.style.fontFamily = style.fontFamily;
    }
    if (style.fontWeight) {
        element.style.fontWeight = style.fontWeight;
    }
    element.style.position = 'relative';
    element.style.visibility = 'hidden';
    //fix 在某些情况下，element内的文本变成竖起排列，导致宽度计算不正确的bug
    element.style.display = 'inline-block';
    element.innerHTML = text;
    var textWidth = element.clientWidth;
    var textHeight = element.clientHeight;
    document.body.removeChild(element);
    return {
        textWidth: textWidth,
        textHeight: textHeight
    };
};

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = L;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TopologyValidatorRule = exports.SummaryType = exports.StatisticAnalystMode = exports.AnalystSizeUnit = exports.AnalystAreaUnit = exports.ClipAnalystMode = exports.ChartType = exports.ClientType = exports.Exponent = exports.VariogramMode = exports.InterpolationAlgorithmType = exports.SearchMode = exports.PixelFormat = exports.StatisticMode = exports.UGCLayerType = exports.LayerType = exports.ColorSpaceType = exports.GridType = exports.TransferPreference = exports.TransferTactic = exports.EditType = exports.DataReturnMode = exports.SurfaceAnalystMethod = exports.SmoothMethod = exports.OverlayOperationType = exports.BufferEndType = exports.TurnType = exports.SupplyCenterType = exports.SideType = exports.DirectionType = exports.LabelOverLengthMode = exports.LabelBackShape = exports.AlongLineDirection = exports.FillGradientMode = exports.TextAlignment = exports.ColorGradientType = exports.ThemeType = exports.RangeMode = exports.GraduatedMode = exports.GraphAxesTextDisplayMode = exports.ThemeGraphType = exports.ThemeGraphTextFormat = exports.EngineType = exports.BufferRadiusUnit = exports.Unit = exports.MeasureMode = exports.SpatialRelationType = exports.SpatialQueryMode = exports.JoinType = exports.QueryOption = exports.GeometryType = exports.ServerType = exports.DataFormat = undefined;

var _SuperMap = __webpack_require__(0);

/**
 * @name DataFormat
 * @memberOf SuperMap
 * @description 服务请求返回结果数据类型
 *
 * @property {string} GEOJSON  GEOJSON
 * @property {string} ISERVER  ISERVER
 */
var DataFormat = exports.DataFormat = _SuperMap.SuperMap.DataFormat = {
  GEOJSON: "GEOJSON",
  ISERVER: "ISERVER"
};

/**
 * @name ServerType
 * @memberOf SuperMap
 * @description 服务器类型
 *
 * @property {string} ISERVER  ISERVER
 * @property {string} IPORTAL  IPORTAL
 * @property {string} ONLINE  ONLINE
 */
var ServerType = exports.ServerType = _SuperMap.SuperMap.ServerType = {
  ISERVER: "ISERVER",
  IPORTAL: "IPORTAL",
  ONLINE: "ONLINE"
};

/**
 * @name GeometryType
 * @memberOf SuperMap
 * @description 几何对象枚举,定义了一系列几何对象类型。
 *
 * @property {string} LINE  LINE
 * @property {string} LINEM  LINEM
 * @property {string} POINT  POINT
 * @property {string} REGION  REGION
 * @property {string} ELLIPSE  ELLIPSE
 * @property {string} CIRCLE  CIRCLE
 * @property {string} TEXT  TEXT
 * @property {string} UNKNOWN  UNKNOWN
 */
var GeometryType = exports.GeometryType = _SuperMap.SuperMap.GeometryType = {
  LINE: "LINE",
  LINEM: "LINEM",
  POINT: "POINT",
  REGION: "REGION",
  ELLIPSE: "ELLIPSE",
  CIRCLE: "CIRCLE",
  TEXT: "TEXT",
  UNKNOWN: "UNKNOWN"
};

/**
 * @name QueryOption
 * @memberOf SuperMap
 * @description 查询结果类型枚举,描述查询结果返回类型，包括只返回属性、只返回几何实体以及返回属性和几何实体。
 *
 * @property {string} ATTRIBUTE  ATTRIBUTE
 * @property {string} ATTRIBUTEANDGEOMETRY  ATTRIBUTEANDGEOMETRY
 * @property {string} GEOMETRY  GEOMETRY
 */
var QueryOption = exports.QueryOption = _SuperMap.SuperMap.QueryOption = {
  ATTRIBUTE: "ATTRIBUTE",
  ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
  GEOMETRY: "GEOMETRY"
};

/**
 * @name JoinType
 * @memberOf SuperMap
 * @description 关联查询时的关联类型常量。
 * 该类定义了两个表之间的连接类型常量，决定了对两个表之间进行连接查询时，查询结果中得到的记录的情况。
 *
 * @property {string} INNERJOIN  INNERJOIN
 * @property {string} LEFTJOIN  LEFTJOIN
 */
var JoinType = exports.JoinType = _SuperMap.SuperMap.JoinType = {
  INNERJOIN: "INNERJOIN",
  LEFTJOIN: "LEFTJOIN"
};

/**
 * @name SpatialQueryMode
 * @memberOf SuperMap
 * @description  空间查询模式枚举。该类定义了空间查询操作模式常量。
 *
 * @property {string} CONTAIN  CONTAIN
 * @property {string} CROSS  CROSS
 * @property {string} DISJOINT  DISJOINT
 * @property {string} IDENTITY  IDENTITY
 * @property {string} INTERSECT  INTERSECT
 * @property {string} NONE  NONE
 * @property {string} OVERLAP  OVERLAP
 * @property {string} TOUCH  TOUCH
 * @property {string} WITHIN  WITHIN
 */
var SpatialQueryMode = exports.SpatialQueryMode = _SuperMap.SuperMap.SpatialQueryMode = {
  CONTAIN: "CONTAIN",
  CROSS: "CROSS",
  DISJOINT: "DISJOINT",
  IDENTITY: "IDENTITY",
  INTERSECT: "INTERSECT",
  NONE: "NONE",
  OVERLAP: "OVERLAP",
  TOUCH: "TOUCH",
  WITHIN: "WITHIN"
};

/**
 * @name SpatialRelationType
 * @memberOf SuperMap
 * @description  数据集对象间的空间关系枚举。
 * 该类定义了数据集对象间的空间关系类型常量。
 *
 * @property {string} CONTAIN 包含关系 CONTAIN  CONTAIN
 * @property {string} INTERSECT 相交关系 INTERSECT  INTERSECT
 * @property {string} INTERSECT 被包含关系 WITHIN  WITHIN
 */
var SpatialRelationType = exports.SpatialRelationType = _SuperMap.SuperMap.SpatialRelationType = {
  CONTAIN: "CONTAIN",
  INTERSECT: "INTERSECT",
  WITHIN: "WITHIN"
};

/**
 * @name MeasureMode
 * @memberOf SuperMap
 * @property {string} DISTANCE DISTANCE
 * @property {string} AREA AREA
 * @description  量算模式枚举。
 * 该类定义了两种测量模式：距离测量和面积测量。
 */
var MeasureMode = exports.MeasureMode = _SuperMap.SuperMap.MeasureMode = {
  DISTANCE: "DISTANCE",
  AREA: "AREA"
};

/**
 * @name Unit
 * @memberOf SuperMap
 * @description  距离单位枚举。
 * 该类定义了一系列距离单位类型。
 *
 * @property {string} METER  METER
 * @property {string} KILOMETER  KILOMETER
 * @property {string} MILE  MILE
 * @property {string} YARD  YARD
 * @property {string} DEGREE  DEGREE
 * @property {string} MILLIMETER  MILLIMETER
 * @property {string} CENTIMETER  CENTIMETER
 * @property {string} INCH  INCH
 * @property {string} DECIMETER  DECIMETER
 * @property {string} FOOT  FOOT
 * @property {string} SECOND  SECOND
 * @property {string} MINUTE  MINUTE
 * @property {string} RADIAN  RADIAN
 */
var Unit = exports.Unit = _SuperMap.SuperMap.Unit = {
  METER: "METER",
  KILOMETER: "KILOMETER",
  MILE: "MILE",
  YARD: "YARD",
  DEGREE: "DEGREE",
  MILLIMETER: "MILLIMETER",
  CENTIMETER: "CENTIMETER",
  INCH: "INCH",
  DECIMETER: "DECIMETER",
  FOOT: "FOOT",
  SECOND: "SECOND",
  MINUTE: "MINUTE",
  RADIAN: "RADIAN"
};

/**
 * @name BufferRadiusUnit
 * @memberOf SuperMap
 * @description  缓冲区距离单位枚举。
 * 该类定义了一系列缓冲距离单位类型。
 *
 * @property {string} CENTIMETER   厘米
 * @property {string} DECIMETER   分米
 * @property {string} FOOT   英尺
 * @property {string} INCH  英寸
 * @property {string} KILOMETER  千米
 * @property {string} METER   米
 * @property {string} MILE   英里
 * @property {string} MILLIMETER    毫米
 * @property {string} YARD    码
 */
var BufferRadiusUnit = exports.BufferRadiusUnit = _SuperMap.SuperMap.BufferRadiusUnit = {
  CENTIMETER: "CENTIMETER",
  DECIMETER: "DECIMETER",
  FOOT: "FOOT",
  INCH: "INCH",
  KILOMETER: "KILOMETER",
  METER: "METER",
  MILE: "MILE",
  MILLIMETER: "MILLIMETER",
  YARD: "YARD"

  /**
   * @name EngineType
   * @memberOf SuperMap
   * @description  数据源引擎类型枚举。
   *
   * @property {string} IMAGEPLUGINS  IMAGEPLUGINS
   * @property {string} OGC  OGC
   * @property {string} ORACLEPLUS  ORACLEPLUS
   * @property {string} SDBPLUS  SDBPLUS
   * @property {string} SQLPLUS  SQLPLUS
   * @property {string} UDB  UDB
   */
};var EngineType = exports.EngineType = _SuperMap.SuperMap.EngineType = {
  IMAGEPLUGINS: "IMAGEPLUGINS",
  OGC: "OGC",
  ORACLEPLUS: "ORACLEPLUS",
  SDBPLUS: "SDBPLUS",
  SQLPLUS: "SQLPLUS",
  UDB: "UDB"
};

/**
 * @name ThemeGraphTextFormat
 * @memberOf SuperMap
 * @description  统计专题图文本显示格式枚举。
 *
 * @property {string} CAPTION  CAPTION
 * @property {string} CAPTION_PERCENT  CAPTION_PERCENT
 * @property {string} CAPTION_VALUE  CAPTION_VALUE
 * @property {string} PERCENT  PERCENT
 * @property {string} VALUE  VALUE
 */
var ThemeGraphTextFormat = exports.ThemeGraphTextFormat = _SuperMap.SuperMap.ThemeGraphTextFormat = {
  CAPTION: "CAPTION",
  CAPTION_PERCENT: "CAPTION_PERCENT",
  CAPTION_VALUE: "CAPTION_VALUE",
  PERCENT: "PERCENT",
  VALUE: "VALUE"
};

/**
 * @name ThemeGraphType
 * @memberOf SuperMap
 * @description  统计专题图类型枚举。
 *
 * @property {string} AREA  AREA
 * @property {string} BAR  BAR
 * @property {string} BAR3D  BAR3D
 * @property {string} LINE  LINE
 * @property {string} PIE  PIE
 * @property {string} PIE3D  PIE3D
 * @property {string} POINT  POINT
 * @property {string} RING  RING
 * @property {string} ROSE  ROSE
 * @property {string} ROSE3D  ROSE3D
 * @property {string} STACK_BAR  STACK_BAR
 * @property {string} STACK_BAR3D  STACK_BAR3D
 * @property {string} STEP  STEP
 */
var ThemeGraphType = exports.ThemeGraphType = _SuperMap.SuperMap.ThemeGraphType = {
  AREA: "AREA",
  BAR: "BAR",
  BAR3D: "BAR3D",
  LINE: "LINE",
  PIE: "PIE",
  PIE3D: "PIE3D",
  POINT: "POINT",
  RING: "RING",
  ROSE: "ROSE",
  ROSE3D: "ROSE3D",
  STACK_BAR: "STACK_BAR",
  STACK_BAR3D: "STACK_BAR3D",
  STEP: "STEP"
};

/**
 * @name GraphAxesTextDisplayMode
 * @memberOf SuperMap
 * @description  统计专题图坐标轴文本显示模式。
 *
 * @property {string} ALL  ALL, 显示全部文本
 * @property {string} NONE  NONE, 没有显示
 * @property {string} YAXES  YAXES. 显示Y轴的文本
 */
var GraphAxesTextDisplayMode = exports.GraphAxesTextDisplayMode = _SuperMap.SuperMap.GraphAxesTextDisplayMode = {
  ALL: "ALL",
  NONE: "NONE",
  YAXES: "YAXES"
};

/**
 * @name GraduatedMode
 * @memberOf SuperMap
 * @description  专题图分级模式枚举。
 *
 * @property {string} CONSTANT  CONSTANT
 * @property {string} LOGARITHM  LOGARITHM
 * @property {string} SQUAREROOT  SQUAREROOT
 */
var GraduatedMode = exports.GraduatedMode = _SuperMap.SuperMap.GraduatedMode = {
  CONSTANT: "CONSTANT",
  LOGARITHM: "LOGARITHM",
  SQUAREROOT: "SQUAREROOT"
};

/**
 * @name RangeMode
 * @memberOf SuperMap
 * @description  范围分段专题图分段方式枚举。
 *
 * @property {string} CUSTOMINTERVAL  CUSTOMINTERVAL
 * @property {string} EQUALINTERVAL  EQUALINTERVAL
 * @property {string} LOGARITHM  LOGARITHM
 * @property {string} QUANTILE  QUANTILE
 * @property {string} SQUAREROOT  SQUAREROOT
 * @property {string} STDDEVIATION  STDDEVIATION
 */
var RangeMode = exports.RangeMode = _SuperMap.SuperMap.RangeMode = {
  CUSTOMINTERVAL: "CUSTOMINTERVAL",
  EQUALINTERVAL: "EQUALINTERVAL",
  LOGARITHM: "LOGARITHM",
  QUANTILE: "QUANTILE",
  SQUAREROOT: "SQUAREROOT",
  STDDEVIATION: "STDDEVIATION"
};

/**
 * @name ThemeType
 * @memberOf SuperMap
 * @description  专题图类型枚举。
 *
 * @property {string} DOTDENSITY  DOTDENSITY
 * @property {string} GRADUATEDSYMBOL  GRADUATEDSYMBOL
 * @property {string} GRAPH  GRAPH
 * @property {string} LABEL  LABEL
 * @property {string} RANGE  RANGE
 * @property {string} UNIQUE  UNIQUE
 */
var ThemeType = exports.ThemeType = _SuperMap.SuperMap.ThemeType = {
  DOTDENSITY: "DOTDENSITY",
  GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
  GRAPH: "GRAPH",
  LABEL: "LABEL",
  RANGE: "RANGE",
  UNIQUE: "UNIQUE"
};

/**
 * @name ColorGradientType
 * @memberOf SuperMap
 * @description  渐变颜色枚举。
 *
 * @property {string} BLACK_WHITE  BLACKWHITE
 * @property {string} BLUE_BLACK  BLUEBLACK
 * @property {string} BLUE_RED   BLUERED
 * @property {string} BLUE_WHITE  BLUEWHITE
 * @property {string} CYAN_BLACK  CYANBLACK
 * @property {string} CYAN_BLUE  CYANBLUE
 * @property {string} CYAN_GREEN  CYANGREEN
 * @property {string} CYAN_WHITE  CYANWHITE
 * @property {string} GREEN_BLACK  GREENBLACK
 * @property {string} GREEN_BLUE  GREENBLUE
 * @property {string} GREEN_ORANGE_VIOLET  GREENORANGEVIOLET
 * @property {string} GREEN_RED  GREENRED
 * @property {string} GREEN_WHITE  GREENWHITE
 * @property {string} PINK_BLACK  PINKBLACK
 * @property {string} PINK_BLUE  PINKBLUE
 * @property {string} PINK_RED  PINKRED
 * @property {string} PINK_WHITE  PINKWHITE
 * @property {string} RAIN_BOW  RAINBOW
 * @property {string} RED_BLACK  REDBLACK
 * @property {string} RED_WHITE  REDWHITE
 * @property {string} SPECTRUM  SPECTRUM
 * @property {string} TERRAIN  TERRAIN
 * @property {string} YELLOW_BLACK  YELLOWBLACK
 * @property {string} YELLOW_BLUE  YELLOWBLUE
 * @property {string} YELLOW_GREEN  YELLOWGREEN
 * @property {string} YELLOW_RED  YELLOWRED
 * @property {string} YELLOW_WHITE  YELLOWWHITE
 */
var ColorGradientType = exports.ColorGradientType = _SuperMap.SuperMap.ColorGradientType = {
  BLACK_WHITE: "BLACKWHITE",
  BLUE_BLACK: "BLUEBLACK",
  BLUE_RED: "BLUERED",
  BLUE_WHITE: "BLUEWHITE",
  CYAN_BLACK: "CYANBLACK",
  CYAN_BLUE: "CYANBLUE",
  CYAN_GREEN: "CYANGREEN",
  CYAN_WHITE: "CYANWHITE",
  GREEN_BLACK: "GREENBLACK",
  GREEN_BLUE: "GREENBLUE",
  GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
  GREEN_RED: "GREENRED",
  GREEN_WHITE: "GREENWHITE",
  PINK_BLACK: "PINKBLACK",
  PINK_BLUE: "PINKBLUE",
  PINK_RED: "PINKRED",
  PINK_WHITE: "PINKWHITE",
  RAIN_BOW: "RAINBOW",
  RED_BLACK: "REDBLACK",
  RED_WHITE: "REDWHITE",
  SPECTRUM: "SPECTRUM",
  TERRAIN: "TERRAIN",
  YELLOW_BLACK: "YELLOWBLACK",
  YELLOW_BLUE: "YELLOWBLUE",
  YELLOW_GREEN: "YELLOWGREEN",
  YELLOW_RED: "YELLOWRED",
  YELLOW_WHITE: "YELLOWWHITE"
};

/**
 * @name TextAlignment
 * @memberOf SuperMap
 * @description  文本对齐枚举。
 *
 * @property {string} TOPLEFT  TOPLEFT
 * @property {string} TOPCENTER  TOPCENTER
 * @property {string} TOPRIGHT  TOPRIGHT
 * @property {string} BASELINELEFT  BASELINELEFT
 * @property {string} BASELINECENTER  BASELINECENTER
 * @property {string} BASELINERIGHT  BASELINERIGHT
 * @property {string} BOTTOMLEFT  BOTTOMLEFT
 * @property {string} BOTTOMCENTER  BOTTOMCENTER
 * @property {string} BOTTOMRIGHT  BOTTOMRIGHT
 * @property {string} MIDDLELEFT  MIDDLELEFT
 * @property {string} MIDDLECENTER  MIDDLECENTER
 * @property {string} MIDDLERIGHT  MIDDLERIGHT
 */
var TextAlignment = exports.TextAlignment = _SuperMap.SuperMap.TextAlignment = {
  TOPLEFT: "TOPLEFT",
  TOPCENTER: "TOPCENTER",
  TOPRIGHT: "TOPRIGHT",
  BASELINELEFT: "BASELINELEFT",
  BASELINECENTER: "BASELINECENTER",
  BASELINERIGHT: "BASELINERIGHT",
  BOTTOMLEFT: "BOTTOMLEFT",
  BOTTOMCENTER: "BOTTOMCENTER",
  BOTTOMRIGHT: "BOTTOMRIGHT",
  MIDDLELEFT: "MIDDLELEFT",
  MIDDLECENTER: "MIDDLECENTER",
  MIDDLERIGHT: "MIDDLERIGHT"
};

/**
 * @name FillGradientMode
 * @memberOf SuperMap
 * @description  渐变填充风格的渐变类型枚举。
 *
 * @property {string} NONE  NONE
 * @property {string} LINEAR  LINEAR
 * @property {string} RADIAL  RADIAL
 * @property {string} CONICAL  CONICAL
 * @property {string} SQUARE  SQUARE
 */
var FillGradientMode = exports.FillGradientMode = _SuperMap.SuperMap.FillGradientMode = {
  NONE: "NONE",
  LINEAR: "LINEAR",
  RADIAL: "RADIAL",
  CONICAL: "CONICAL",
  SQUARE: "SQUARE"
};

/**
 * @name AlongLineDirection
 * @memberOf SuperMap
 * @name AlongLineDirection
 * @memberOf SuperMap
 * @description  标签沿线标注方向枚举。
 *
 * @property {string} NORMAL  ALONG_LINE_NORMAL
 * @property {string} LB_TO_RT  LEFT_BOTTOM_TO_RIGHT_TOP
 * @property {string} LT_TO_RB  LEFT_TOP_TO_RIGHT_BOTTOM
 * @property {string} RB_TO_LT  RIGHT_BOTTOM_TO_LEFT_TOP
 * @property {string} RT_TO_LB  RIGHT_TOP_TO_LEFT_BOTTOM
 */
var AlongLineDirection = exports.AlongLineDirection = _SuperMap.SuperMap.AlongLineDirection = {
  NORMAL: "ALONG_LINE_NORMAL",
  LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
  LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
  RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
  RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM"
};

/**
 * @name LabelBackShape
 * @memberOf SuperMap
 * @description  标签专题图中标签背景的形状枚举。
 *
 * @property {string} DIAMOND  DIAMOND
 * @property {string} ELLIPSE  ELLIPSE
 * @property {string} MARKER  MARKER
 * @property {string} NONE  NONE
 * @property {string} RECT  RECT
 * @property {string} ROUNDRECT  ROUNDRECT
 * @property {string} TRIANGLE  TRIANGLE
 */
var LabelBackShape = exports.LabelBackShape = _SuperMap.SuperMap.LabelBackShape = {
  DIAMOND: "DIAMOND",
  ELLIPSE: "ELLIPSE",
  MARKER: "MARKER",
  NONE: "NONE",
  RECT: "RECT",
  ROUNDRECT: "ROUNDRECT",
  TRIANGLE: "TRIANGLE"
};

/**
 * @name LabelOverLengthMode
 * @memberOf SuperMap
 * @description  标签专题图中超长标签的处理模式枚举。
 *
 * @property {string} NEWLINE  NEWLINE
 * @property {string} NONE  NONE
 * @property {string} OMIT  OMIT
 */
var LabelOverLengthMode = exports.LabelOverLengthMode = _SuperMap.SuperMap.LabelOverLengthMode = {
  NEWLINE: "NEWLINE",
  NONE: "NONE",
  OMIT: "OMIT"
};

/**
 * @name DirectionType
 * @memberOf SuperMap
 * @description  网络分析中方向枚举。
 * 在行驶引导子项中使用。
 *
 * @property {string} EAST  EAST
 * @property {string} NONE  NONE
 * @property {string} NORTH  NORTH
 * @property {string} SOURTH  SOURTH
 * @property {string} WEST  WEST
 */
var DirectionType = exports.DirectionType = _SuperMap.SuperMap.DirectionType = {
  EAST: "EAST",
  NONE: "NONE",
  NORTH: "NORTH",
  SOURTH: "SOURTH",
  WEST: "WEST"
};

/**
 * @name SideType
 * @memberOf SuperMap
 * @description  行驶位置枚举。
 * 表示在行驶在路的左边、右边或者路上的枚举,该类用在行驶导引子项类中。
 *
 * @property {string} LEFT  LEFT
 * @property {string} MIDDLE  MIDDLE
 * @property {string} NONE  NONE
 * @property {string} RIGHT  RIGHT
 */
var SideType = exports.SideType = _SuperMap.SuperMap.SideType = {
  LEFT: "LEFT",
  MIDDLE: "MIDDLE",
  NONE: "NONE",
  RIGHT: "RIGHT"
};

/**
 * @name SupplyCenterType
 * @memberOf SuperMap
 * @description  资源供给中心类型枚举。
 * 该枚举定义了网络分析中资源中心点的类型，主要用于资源分配和选址分区。
 * 资源供给中心点的类型包括非中心，固定中心和可选中心。固定中心用于资源分配分析； 固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
 *
 * @property {string} FIXEDCENTER  FIXEDCENTER
 * @property {string} NULL  NULL
 * @property {string} OPTIONALCENTER  OPTIONALCENTER
 */
var SupplyCenterType = exports.SupplyCenterType = _SuperMap.SuperMap.SupplyCenterType = {
  FIXEDCENTER: "FIXEDCENTER",
  NULL: "NULL",
  OPTIONALCENTER: "OPTIONALCENTER"
};

/**
 * @name TurnType
 * @memberOf SuperMap
 * @description  转弯方向枚举。
 * 用在行驶引导子项类中，表示转弯的方向。
 *
 * @property {string} AHEAD  AHEAD
 * @property {string} BACK  BACK
 * @property {string} END  END
 * @property {string} LEFT  LEFT
 * @property {string} NONE  NONE
 * @property {string} RIGHT  RIGHT
 */
var TurnType = exports.TurnType = _SuperMap.SuperMap.TurnType = {
  AHEAD: "AHEAD",
  BACK: "BACK",
  END: "END",
  LEFT: "LEFT",
  NONE: "NONE",
  RIGHT: "RIGHT"
};

/**
 * @name BufferEndType
 * @memberOf SuperMap
 * @description  缓冲区分析BufferEnd类型。
 *
 * @property {string} FLAT  FLAT
 * @property {string} ROUND  ROUND
 */
var BufferEndType = exports.BufferEndType = _SuperMap.SuperMap.BufferEndType = {
  FLAT: "FLAT",
  ROUND: "ROUND"
};

/**
 * @name OverlayOperationType
 * @memberOf SuperMap
 * @description  叠加分析类型枚举。
 *
 * @property {string} CLIP  CLIP
 * @property {string} ERASE  ERASE
 * @property {string} IDENTITY  IDENTITY
 * @property {string} INTERSECT  INTERSECT
 * @property {string} UNION  UNION
 * @property {string} UPDATE  UPDATE
 * @property {string} XOR  XOR
 */
var OverlayOperationType = exports.OverlayOperationType = _SuperMap.SuperMap.OverlayOperationType = {
  CLIP: "CLIP",
  ERASE: "ERASE",
  IDENTITY: "IDENTITY",
  INTERSECT: "INTERSECT",
  UNION: "UNION",
  UPDATE: "UPDATE",
  XOR: "XOR"
};

/**
 * @name SmoothMethod
 * @memberOf SuperMap
 * @description  光滑方法枚举。
 * 用于从Grid 或DEM数据生成等值线或等值面时对等值线或者等值面的边界线进行平滑处理的方法。
 *
 * @property {string} BSPLINE  BSPLINE
 * @property {string} POLISH  POLISH
 */
var SmoothMethod = exports.SmoothMethod = _SuperMap.SuperMap.SmoothMethod = {
  BSPLINE: "BSPLINE",
  POLISH: "POLISH"
};

/**
 * @name SurfaceAnalystMethod
 * @memberOf SuperMap
 * @description  表面分析方法枚举。
 * 通过对数据进行表面分析，能够挖掘原始数据所包含的信息，使某些细节明显化，易于分析。
 *
 * @property {string} ISOLINE  ISOLINE
 * @property {string} ISOREGION  ISOREGION
 */
var SurfaceAnalystMethod = exports.SurfaceAnalystMethod = _SuperMap.SuperMap.SurfaceAnalystMethod = {
  ISOLINE: "ISOLINE",
  ISOREGION: "ISOREGION"
};
/**
 * @name DataReturnMode
 * @memberOf SuperMap
 * @description  数据返回模式枚举。
 * 该枚举用于指定空间分析返回结果模式,包含返回数据集标识和记录集、只返回数据集标识(数据集名称@数据源名称)及只返回记录集三种模式。
 *
 * @property {string} DATASET_AND_RECORDSET  DATASET_AND_RECORDSET
 * @property {string} DATASET_ONLY  DATASET_ONLY
 * @property {string} RECORDSET_ONLY  RECORDSET_ONLY
 */
var DataReturnMode = exports.DataReturnMode = _SuperMap.SuperMap.DataReturnMode = {
  DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
  DATASET_ONLY: "DATASET_ONLY",
  RECORDSET_ONLY: "RECORDSET_ONLY"
};

/**
 * @name EditType
 * @memberOf SuperMap
 * @description  要素集更新模式枚举。
 * 该枚举用于指定数据服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
 *
 * @property {string} ADD  add
 * @property {string} UPDATE  update
 * @property {string} DELETE  delete
 */
var EditType = exports.EditType = _SuperMap.SuperMap.EditType = {
  ADD: "add",
  UPDATE: "update",
  DELETE: "delete"
};

/**
 * @name TransferTactic
 * @memberOf SuperMap
 * @description  公交换乘策略枚举。
 * 该枚举用于指定公交服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
 *
 * @property {string} LESS_TIME  LESS_TIME
 * @property {string} LESS_TRANSFER  LESS_TRANSFER
 * @property {string} LESS_WALK  LESS_WALK
 * @property {string} MIN_DISTANCE  MIN_DISTANCE
 */
var TransferTactic = exports.TransferTactic = _SuperMap.SuperMap.TransferTactic = {
  LESS_TIME: "LESS_TIME",
  LESS_TRANSFER: "LESS_TRANSFER",
  LESS_WALK: "LESS_WALK",
  MIN_DISTANCE: "MIN_DISTANCE"
};

/**
 * @name TransferPreference
 * @memberOf SuperMap
 * @description  公交换乘策略枚举。
 * 该枚举用于指定交通换乘服务中设置地铁优先、公交优先、不乘地铁、无偏好等偏好设置。
 *
 * @property {string} BUS  BUS
 * @property {string} SUBWAY  SUBWAY
 * @property {string} NO_SUBWAY  NO_SUBWAY
 * @property {string} NONE  NONE
 */
var TransferPreference = exports.TransferPreference = _SuperMap.SuperMap.TransferPreference = {
  BUS: "BUS",
  SUBWAY: "SUBWAY",
  NO_SUBWAY: "NO_SUBWAY",
  NONE: "NONE"
};

/**
 * @name GridType
 * @memberOf SuperMap
 * @description  地图背景格网类型枚举。
 *
 * @property {string} CROSS  CROSS
 * @property {string} GRID  GRID
 * @property {string} POINT  POINT
 */
var GridType = exports.GridType = _SuperMap.SuperMap.GridType = {
  CROSS: "CROSS",
  GRID: "GRID",
  POINT: "POINT"
};

/**
 * @name ColorSpaceType
 * @memberOf SuperMap
 * @description  色彩空间枚举。
 * 由于成色原理的不同，决定了显示器、投影仪这类靠色光直接合成颜色的颜色设备和打印机、
 * 印刷机这类靠使用颜料的印刷设备在生成颜色方式上的区别。
 * 针对上述不同成色方式，SuperMap 提供两种色彩空间，
 * 分别为 RGB 和 CMYK。RGB 主要用于显示系统中，CMYK 主要用于印刷系统中。
 *
 * @property {string} CMYK  CMYK
 * @property {string} RGB  RGB
 */
var ColorSpaceType = exports.ColorSpaceType = _SuperMap.SuperMap.ColorSpaceType = {
  CMYK: "CMYK",
  RGB: "RGB"
};

/**
 * @name LayerType
 * @memberOf SuperMap
 * @description  图层类型。
 *
 * @property {string} UGC  UGC
 * @property {string} WMS  WMS
 * @property {string} WFS  WFS
 * @property {string} CUSTOM  CUSTOM
 */
var LayerType = exports.LayerType = _SuperMap.SuperMap.LayerType = {
  UGC: "UGC",
  WMS: "WMS",
  WFS: "WFS",
  CUSTOM: "CUSTOM"

};

/**
 * @name UGCLayerType
 * @memberOf SuperMap
 * @description  UGC图层类型。
 *
 * @property {string} THEME  THEME
 * @property {string} VECTOR  VECTOR
 * @property {string} GRID  GRID
 * @property {string} IMAGE  IMAGE
 */
var UGCLayerType = exports.UGCLayerType = _SuperMap.SuperMap.UGCLayerType = {
  THEME: "THEME",
  VECTOR: "VECTOR",
  GRID: "GRID",
  IMAGE: "IMAGE"

};

/**
 * @name StatisticMode
 * @memberOf SuperMap
 * @description  字段统计方法类型。
 *
 * @property {string} AVERAGE  AVERAGE, 统计所选字段的平均值
 * @property {string} MAX  MAX, 统计所选字段的最大值
 * @property {string} MIN  MIN, 统计所选字段的最小值
 * @property {string} STDDEVIATION  STDDEVIATION, 统计所选字段的标准差
 * @property {string} SUM  SUM, 统计所选字段的总和
 * @property {string} VARIANCE  VARIANCE, 统计所选字段的方差
 */
var StatisticMode = exports.StatisticMode = _SuperMap.SuperMap.StatisticMode = {
  AVERAGE: "AVERAGE",
  MAX: "MAX",
  MIN: "MIN",
  STDDEVIATION: "STDDEVIATION",
  SUM: "SUM",
  VARIANCE: "VARIANCE"
};

/**
 * @name PixelFormat
 * @memberOf SuperMap
 * @description  栅格与影像数据存储的像素格式枚举。
 *
 * @property {string} BIT16  BIT16, 每个像元用16个比特(即2个字节)表示
 * @property {string} BIT32  BIT32, 每个像元用32个比特(即4个字节)表示
 * @property {string} BIT64  BIT64, 每个像元用64个比特(即8个字节)表示，只提供给栅格数据集使用
 * @property {string} SINGLE  SINGLE, 每个像元用4个字节来表示，只提供给栅格数据集使用
 * @property {string} DOUBLE  DOUBLE, 每个像元用8个字节来表示，只提供给栅格数据集使用
 * @property {string} UBIT1  UBIT1, 每个像元用1个比特表示
 * @property {string} UBIT4  UBIT4, 每个像元用4个比特来表示
 * @property {string} UBIT8  UBIT8, 每个像元用8个比特(即1个字节)来表示
 * @property {string} UBIT24  UBIT24, 每个像元用24个比特(即3个字节)来表示
 * @property {string} UBIT32  UBIT32, 每个像元用32个比特(即4个字节)来表示
 */
var PixelFormat = exports.PixelFormat = _SuperMap.SuperMap.PixelFormat = {
  BIT16: "BIT16",
  BIT32: "BIT32",
  BIT64: "BIT64",
  SINGLE: "SINGLE",
  DOUBLE: "DOUBLE",
  UBIT1: "UBIT1",
  UBIT4: "UBIT4",
  UBIT8: "UBIT8",
  UBIT24: "UBIT24",
  UBIT32: "UBIT32"
};

/**
 * @name SearchMode
 * @memberOf SuperMap
 * @description  内插时使用的样本点的查找方式枚举
 *
 * @property {string} KDTREE_FIXED_COUNT  KDTREE_FIXED_COUNT, 使用 KDTREE 的固定点数方式查找参与内插分析的点
 * @property {string} KDTREE_FIXED_RADIUS  KDTREE_FIXED_RADIUS, 使用 KDTREE 的定长方式查找参与内插分析的点
 * @property {string} NONE  NONE, 不进行查找，使用所有的输入点进行内插分析
 * @property {string} QUADTREE  QUADTREE, 使用 QUADTREE 方式查找参与内插分析的点，仅对样条（RBF）插值和普通克吕金（Kriging）有用
 */
var SearchMode = exports.SearchMode = _SuperMap.SuperMap.SearchMode = {
  KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT",
  KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS",
  NONE: "NONE",
  QUADTREE: "QUADTREE"
};

/**
 * @name InterpolationAlgorithmType
 * @memberOf SuperMap
 * @description  插值分析的算法的类型
 *
 * @property {string} KRIGING  KRIGING, 普通克吕金插值法
 * @property {string} SimpleKriging  SimpleKriging, 简单克吕金插值法
 * @property {string} UniversalKriging  UniversalKriging, 泛克吕金插值法
 */
var InterpolationAlgorithmType = exports.InterpolationAlgorithmType = _SuperMap.SuperMap.InterpolationAlgorithmType = {
  KRIGING: "KRIGING",
  SimpleKriging: "SimpleKriging",
  UniversalKriging: "UniversalKriging"
};

/**
 * @name VariogramMode
 * @memberOf SuperMap
 * @description  克吕金（Kriging）插值时的半变函数类型枚举
 *
 * @property {string} EXPONENTIAL  EXPONENTIAL, 指数函数（Exponential Variogram Mode）
 * @property {string} GAUSSIAN  GAUSSIAN,  高斯函数（Gaussian Variogram Mode）
 * @property {string} SPHERICAL  SPHERICAL, 球型函数（Spherical Variogram Mode）
 */
var VariogramMode = exports.VariogramMode = _SuperMap.SuperMap.VariogramMode = {
  EXPONENTIAL: "EXPONENTIAL",
  GAUSSIAN: "GAUSSIAN",
  SPHERICAL: "SPHERICAL"
};

/**
 * @name Exponent
 * @memberOf SuperMap
 * @description  定义了泛克吕金（UniversalKriging）插值时样点数据中趋势面方程的阶数
 *
 * @property {string} EXP1  EXP1, 阶数为1
 * @property {string} EXP2  EXP2, 阶数为2
 */
var Exponent = exports.Exponent = _SuperMap.SuperMap.Exponent = {
  EXP1: "EXP1",
  EXP2: "EXP2"
};

/**
 * @name ClientType
 * @memberOf SuperMap
 * @description token申请的客户端标识类型
 *
 * @property {string} IP  IP
 * @property {string} REFERER  Referer
 * @property {string} REQUESTIP  RequestIP
 * @property {string} NONE  NONE
 * @property {string} SERVER  SERVER
 * @property {string} WEB  WEB
 */
var ClientType = exports.ClientType = _SuperMap.SuperMap.ClientType = {
  IP: "IP",
  REFERER: "Referer",
  REQUESTIP: "RequestIP",
  NONE: "NONE",
  SERVER: "SERVER",
  WEB: "WEB"
};

/**
 * @name ChartType
 * @memberOf SuperMap
 * @description 客户端专题图图表类型
 *
 * @property {string} BAR  Bar
 * @property {string} BAR3D  Bar3D
 * @property {string} CIRCLE  Circle
 * @property {string} PIE  Pie
 * @property {string} POINT  Point
 * @property {string} LINE  Line
 * @property {string} RING  Ring
 */
var ChartType = exports.ChartType = _SuperMap.SuperMap.ChartType = {
  BAR: "Bar",
  BAR3D: "Bar3D",
  CIRCLE: "Circle",
  PIE: "Pie",
  POINT: "Point",
  LINE: "Line",
  RING: "Ring"
};

/**
 * @name ClipAnalystMode
 * @memberOf SuperMap
 * @description  裁剪分析模式
 *
 * @property {string} CLIP  clip
 * @property {string} INTERSECT  intersect
 */
var ClipAnalystMode = exports.ClipAnalystMode = _SuperMap.SuperMap.ClipAnalystMode = {
  CLIP: "clip",
  INTERSECT: "intersect"
};
/**
 * @name AnalystAreaUnit
 * @memberOf SuperMap
 * @description 分布式分析面积单位
 *
 * @property {string} SQUAREMETER  SquareMeter
 * @property {string} SQUAREKILOMETER   SquareKiloMeter
 * @property {string} HECTARE  Hectare
 * @property {string} ARE   Are
 * @property {string} ACRE   Acre
 * @property {string} SQUAREFOOT   SquareFoot
 * @property {string} SQUAREYARD   SquareYard
 * @property {string} SQUAREMILE   SquareMile
 */
var AnalystAreaUnit = exports.AnalystAreaUnit = _SuperMap.SuperMap.AnalystAreaUnit = {
  "SQUAREMETER": "SquareMeter",
  "SQUAREKILOMETER": "SquareKiloMeter",
  "HECTARE": "Hectare",
  "ARE": "Are",
  "ACRE": "Acre",
  "SQUAREFOOT": "SquareFoot",
  "SQUAREYARD": "SquareYard",
  "SQUAREMILE": "SquareMile"
};
/**
 * @name AnalystSizeUnit
 * @memberOf SuperMap
 * @description 分布式分析单位
 *
 * @property {string} METER   Meter
 * @property {string} KILOMETER   Kilometer
 * @property {string} YARD   Yard
 * @property {string} FOOT   Foot
 * @property {string} MILE   Mile
 */
var AnalystSizeUnit = exports.AnalystSizeUnit = _SuperMap.SuperMap.AnalystSizeUnit = {
  "METER": "Meter",
  "KILOMETER": "Kilometer",
  "YARD": "Yard",
  "FOOT": "Foot",
  "MILE": "Mile"
};
/**
 * @name StatisticAnalystMode
 * @memberOf SuperMap
 * @description 分布式分析统计模式
 *
 * @property {string} MAX   max
 * @property {string} MIN   min
 * @property {string} AVERAGE   average
 * @property {string} SUM   sum
 * @property {string} VARIANCE   variance
 * @property {string} STDDEVIATION   stdDeviation
 */
var StatisticAnalystMode = exports.StatisticAnalystMode = _SuperMap.SuperMap.StatisticAnalystMode = {
  "MAX": "max",
  "MIN": "min",
  "AVERAGE": "average",
  "SUM": "sum",
  "VARIANCE": "variance",
  "STDDEVIATION": "stdDeviation"
};
/**
 * @name SummaryType
 * @memberOf SuperMap
 * @description 分布式分析聚合类型
 *
 * @property {string} SUMMARYMESH   SUMMARYMESH
 * @property {string} SUMMARYREGION SUMMARYREGION
 */
var SummaryType = exports.SummaryType = _SuperMap.SuperMap.SummaryType = {
  "SUMMARYMESH": "SUMMARYMESH",
  "SUMMARYREGION": "SUMMARYREGION"
};
/**
 * @name TopologyValidatorRule
 * @memberOf SuperMap
 * @description  拓扑检查模式枚举。该类定义了拓扑检查操作模式常量。
 *
 * @property {string} RegionNoOverlap  RegionNoOverlap
 * @property {string} RegionNoOverlapWith  RegionNoOverlapWith
 * @property {string} RegionContainedByRegion  RegionContainedByRegion
 * @property {string} RegionCoveredByRegion  RegionCoveredByRegion
 * @property {string} LineNoOverlap  LineNoOverlap
 * @property {string} LineNoOverlapWith  LineNoOverlapWith
 * @property {string} PointNoIdentical  PointNoIdentical
 */
var TopologyValidatorRule = exports.TopologyValidatorRule = _SuperMap.SuperMap.TopologyValidatorRule = {
  RegionNoOverlap: "RegionNoOverlap",
  RegionNoOverlapWith: "RegionNoOverlapWith",
  RegionContainedByRegion: "RegionContainedByRegion",
  RegionCoveredByRegion: "RegionCoveredByRegion",
  LineNoOverlap: "LineNoOverlap",
  LineNoOverlapWith: "LineNoOverlapWith",
  PointNoIdentical: "PointNoIdentical"
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(281);

__webpack_require__(445);

__webpack_require__(444);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 *SuperMap Leaflet基类
 * 定义命名空间
 * 提供公共模块
 */
_leaflet2["default"].supermap = _leaflet2["default"].supermap || {};
_leaflet2["default"].supermap.control = _leaflet2["default"].supermap.control || {};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SuperMap = exports.REST = undefined;

var _SuperMap = __webpack_require__(0);

Object.defineProperty(exports, 'SuperMap', {
  enumerable: true,
  get: function get() {
    return _SuperMap.SuperMap;
  }
});

var _REST = __webpack_require__(3);

Object.keys(_REST).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _REST[key];
    }
  });
});

var _commontypes = __webpack_require__(338);

Object.keys(_commontypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _commontypes[key];
    }
  });
});

var _control = __webpack_require__(339);

Object.keys(_control).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _control[key];
    }
  });
});

var _format = __webpack_require__(341);

Object.keys(_format).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _format[key];
    }
  });
});

var _iManager = __webpack_require__(342);

Object.keys(_iManager).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _iManager[key];
    }
  });
});

var _iPortal = __webpack_require__(343);

Object.keys(_iPortal).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _iPortal[key];
    }
  });
});

var _iServer = __webpack_require__(414);

Object.keys(_iServer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _iServer[key];
    }
  });
});

var _online = __webpack_require__(416);

Object.keys(_online).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _online[key];
    }
  });
});

var _overlay = __webpack_require__(426);

Object.keys(_overlay).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _overlay[key];
    }
  });
});

var _security = __webpack_require__(436);

Object.keys(_security).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _security[key];
    }
  });
});

var _style = __webpack_require__(439);

Object.keys(_style).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _style[key];
    }
  });
});

var _thirdparty = __webpack_require__(441);

Object.keys(_thirdparty).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _thirdparty[key];
    }
  });
});

var _util = __webpack_require__(443);

Object.keys(_util).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _util[key];
    }
  });
});

var REST = _interopRequireWildcard(_REST);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

exports.REST = REST;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CommonServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _FetchRequest = __webpack_require__(21);

var _Events = __webpack_require__(62);

var _Credential = __webpack_require__(89);

var _SecurityManager = __webpack_require__(35);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _JSON = __webpack_require__(93);

var _BaseTypes = __webpack_require__(46);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.CommonServiceBase
 * @classdesc 对接iServer各种服务的Service的基类。
 * @param url - {string} 服务地址。
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var CommonServiceBase = exports.CommonServiceBase = function () {
    function CommonServiceBase(url, options) {
        _classCallCheck(this, CommonServiceBase);

        var me = this;

        this.EVENT_TYPES = ["processCompleted", "processFailed"];

        this.events = null;

        this.eventListeners = null;

        this.url = null;

        this.urls = null;

        this.serverType = null;

        this.index = null;

        this.length = null;

        this.options = null;

        this.totalTimes = null;

        this.POLLING_TIMES = 3;

        this._processSuccess = null;

        this._processFailed = null;

        this.isInTheSameDomain = null;

        if (_Util.Util.isArray(url)) {
            me.urls = url;
            me.length = url.length;
            me.totalTimes = me.length;
            if (me.length === 1) {
                me.url = url[0];
            } else {
                me.index = parseInt(Math.random() * me.length);
                me.url = url[me.index];
            }
        } else {
            me.totalTimes = 1;
            me.url = url;
        }

        if (_Util.Util.isArray(url) && !me.isServiceSupportPolling()) {
            me.url = url[0];
            me.totalTimes = 1;
        }

        me.serverType = me.serverType || _REST.ServerType.ISERVER;

        options = options || {};

        if (options) {
            _Util.Util.extend(this, options);
        }

        me.isInTheSameDomain = _Util.Util.isInTheSameDomain(me.url);

        me.events = new _Events.Events(me, null, me.EVENT_TYPES, true);
        if (me.eventListeners instanceof Object) {
            me.events.on(me.eventListeners);
        }

        this.CLASS_NAME = "SuperMap.CommonServiceBase";
    }

    /**
     * @function SuperMap.CommonServiceBase.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */


    _createClass(CommonServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (_Util.Util.isArray(me.urls)) {
                me.urls = null;
                me.index = null;
                me.length = null;
                me.totalTimes = null;
            }
            me.url = null;
            me.options = null;
            me._processSuccess = null;
            me._processFailed = null;
            me.isInTheSameDomain = null;

            me.EVENT_TYPES = null;
            if (me.events) {
                me.events.destroy();
                me.events = null;
            }
            if (me.eventListeners) {
                me.eventListeners = null;
            }
        }

        /**
         * @function  SuperMap.CommonServiceBase.prototype.request
         * @description: 该方法用于向服务发送请求。
         * @param options - {Object} 参数。
         *        method - {string} 请求方式，包括"GET"，"POST"，"PUT"，"DELETE"。<br>
         *        url - {string}  发送请求的地址。<br>
         *        params - {Object} 作为查询字符串添加到url中的一组键值对，此参数只适用于GET方式发送的请求。<br>
         *        data - {String } 发送到服务器的数据。<br>
         *        success - {function} 请求成功后的回调函数。<br>
         *        failure - {function} 请求失败后的回调函数。<br>
         *        scope - {Object} 如果回调函数是对象的一个公共方法，设定该对象的范围。<br>
         *        isInTheSameDomain - {boolean} 请求是否在当前域中。<br>
         */

    }, {
        key: 'request',
        value: function request(options) {
            var me = this;
            options.url = options.url || me.url;
            options.isInTheSameDomain = me.isInTheSameDomain;
            //为url添加安全认证信息片段
            var credential = this.getCredential(options.url);
            if (credential) {
                //当url中含有?，并且?在url末尾的时候直接添加token *网络分析等服务请求url会出现末尾是?的情况*
                //当url中含有?，并且?不在url末尾的时候添加&token
                //当url中不含有?，在url末尾添加?token
                var endStr = options.url.substring(options.url.length - 1, options.url.length);
                if (options.url.indexOf("?") > -1 && endStr === "?") {
                    options.url += credential.getUrlParameters();
                } else if (options.url.indexOf("?") > -1 && endStr !== "?") {
                    options.url += "&" + credential.getUrlParameters();
                } else {
                    options.url += "?" + credential.getUrlParameters();
                }
            }
            me.calculatePollingTimes();
            me._processSuccess = options.success;
            me._processFailed = options.failure;
            options.scope = me;
            options.success = me.getUrlCompleted;
            options.failure = me.getUrlFailed;
            me.options = options;
            me._commit(me.options);
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.getCredential
         * @description  获取凭据信息
         * @param url - {string} 服务地址。
         * @return {SuperMap.Credential} 凭据信息对象。
         */

    }, {
        key: 'getCredential',
        value: function getCredential(url) {
            var keyUrl = url,
                credential = void 0,
                value = void 0;
            switch (this.serverType) {
                case _REST.ServerType.IPORTAL:
                    value = _SecurityManager.SecurityManager.getToken(keyUrl);
                    credential = value ? new _Credential.Credential(value, "token") : null;
                    if (!credential) {
                        value = _SecurityManager.SecurityManager.getKey(keyUrl);
                        credential = value ? new _Credential.Credential(value, "key") : null;
                    }
                    break;
                case _REST.ServerType.ONLINE:
                    value = _SecurityManager.SecurityManager.getKey(keyUrl);
                    credential = value ? new _Credential.Credential(value, "key") : null;
                    break;
                default:
                    //iServer or others
                    value = _SecurityManager.SecurityManager.getToken(keyUrl);
                    credential = value ? new _Credential.Credential(value, "token") : null;
                    break;
            }
            return credential;
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.getUrlCompleted
         * @description 请求成功后执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getUrlCompleted',
        value: function getUrlCompleted(result) {
            var me = this;
            me._processSuccess(result);
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.getUrlFailed
         * @description 请求失败后执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getUrlFailed',
        value: function getUrlFailed(result) {
            var me = this;
            if (me.totalTimes > 0) {
                me.totalTimes--;
                me.ajaxPolling();
            } else {
                me._processFailed(result);
            }
        }

        /**
         *
         * @function SuperMap.CommonServiceBase.prototype.ajaxPolling
         * @description 请求失败后，如果剩余请求失败次数不为0，重新获取url发送请求
         */

    }, {
        key: 'ajaxPolling',
        value: function ajaxPolling() {
            var me = this,
                url = me.options.url,
                re = /^http:\/\/([a-z]{9}|(\d+\.){3}\d+):\d{0,4}/;
            me.index = parseInt(Math.random() * me.length);
            me.url = me.urls[me.index];
            url = url.replace(re, re.exec(me.url)[0]);
            me.options.url = url;
            me.options.isInTheSameDomain = _Util.Util.isInTheSameDomain(url);
            me._commit(me.options);
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.calculatePollingTimes
         * @description 计算剩余请求失败执行次数。
         */

    }, {
        key: 'calculatePollingTimes',
        value: function calculatePollingTimes() {
            var me = this;
            if (me.times) {
                if (me.totalTimes > me.POLLING_TIMES) {
                    if (me.times > me.POLLING_TIMES) {
                        me.totalTimes = me.POLLING_TIMES;
                    } else {
                        me.totalTimes = me.times;
                    }
                } else {
                    if (me.times < me.totalTimes) {
                        me.totalTimes = me.times;
                    }
                }
            } else {
                if (me.totalTimes > me.POLLING_TIMES) {
                    me.totalTimes = me.POLLING_TIMES;
                }
            }
            me.totalTimes--;
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.isServiceSupportPolling
         * @description 判断服务是否支持轮询。
         */

    }, {
        key: 'isServiceSupportPolling',
        value: function isServiceSupportPolling() {
            var me = this;
            return !(me.CLASS_NAME === "SuperMap.REST.ThemeService" || me.CLASS_NAME === "SuperMap.REST.EditFeaturesService");
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.serviceProcessCompleted
         * @description 状态完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            result = _Util.Util.transformResult(result);
            this.events.triggerEvent("processCompleted", { result: result });
        }

        /**
         * @function SuperMap.CommonServiceBase.prototype.serviceProcessFailed
         * @description 状态失败，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessFailed',
        value: function serviceProcessFailed(result) {
            result = _Util.Util.transformResult(result);
            var error = result.error || result;
            this.events.triggerEvent("processFailed", { error: error });
        }
    }, {
        key: '_commit',
        value: function _commit(options) {
            if (options.method === "POST" || options.method === "PUT") {
                if (options.params) {
                    options.url = _Util.Util.urlAppend(options.url, _Util.Util.getParameterString(options.params || {}));
                }
                options.params = options.data;
            }
            _FetchRequest.FetchRequest.commit(options.method, options.url, options.params, {
                headers: options.headers,
                withCredentials: options.withCredentials,
                timeout: options.async ? 0 : null,
                proxy: options.proxy
            }).then(function (response) {
                if (response.text) {
                    return response.text();
                }
                return response.json();
            }).then(function (text) {
                var result = text;
                if (typeof text === "string") {
                    result = new _JSON.JSONFormat().read(text);
                }
                if (!result || result.error || result.code >= 300 && result.code !== 304) {
                    if (result && result.error) {
                        result = { error: result.error };
                    } else {
                        result = { error: result };
                    }
                }
                if (result.error) {
                    var failure = options.scope ? _BaseTypes.FunctionExt.bind(options.failure, options.scope) : options.failure;
                    failure(result);
                } else {
                    result.succeed = result.succeed == undefined ? true : result.succeed;
                    var success = options.scope ? _BaseTypes.FunctionExt.bind(options.success, options.scope) : options.success;
                    success(result);
                }
            });
        }
    }]);

    return CommonServiceBase;
}();

_SuperMap.SuperMap.CommonServiceBase = CommonServiceBase;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;
var sign = __webpack_require__(61);

module.exports = function(x) {
  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServiceBase = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.ServiceBase
 * @private
 * @description L.supermap服务基类
 * @param url - {string} 与客户端交互的服务地址。
 * @param options - {Object} 可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 */
var ServiceBase = exports.ServiceBase = _leaflet2["default"].Evented.extend({

    options: {
        url: null,
        //服务来源 iServer|iPortal|online
        serverType: null
    },

    initialize: function initialize(url, options) {
        if (url) {
            url = url.indexOf("/") !== url.length - 1 ? url : url.substr(0, url.length - 1);
        }
        this.url = url;
        _leaflet2["default"].setOptions(this, options);
        this.fire("initialized", this);
    },

    /**
     * @function L.supermap.ServiceBase.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */
    destroy: function destroy() {
        this.fire("destroy", this);
    }

});

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerGeometry = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Point = __webpack_require__(18);

var _MultiPoint = __webpack_require__(38);

var _LinearRing = __webpack_require__(31);

var _LineString = __webpack_require__(17);

var _MultiLineString = __webpack_require__(47);

var _Polygon = __webpack_require__(49);

var _MultiPolygon = __webpack_require__(48);

var _ServerStyle = __webpack_require__(11);

var _Route = __webpack_require__(68);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class SuperMap.ServerGeometry
 * @description 服务端几何对象类。
 * 该类描述几何对象（矢量）的特征数据（坐标点对、几何对象的类型等）。
 * 基于服务端的空间分析、空间关系运算、查询等 GIS 服务功能使用服务端几何对象。
 */
var ServerGeometry = exports.ServerGeometry = function () {

    /*
     * Constructor: SuperMap.ServerGeometry
     * 服务端几何对象类构造函数。
     *
     * Parameters:
     * options - {Object} 参数。
     *
     * Allowed options properties:
     * id - {String} 服务端几何对象唯一标识符。
     * style - {<SuperMap.ServerStyle>}  服务端几何对象的风格。
     * parts - {Array(Number)} 服务端几何对象中各个子对象所包含的节点个数。
     * points - {Array(<Point>)} 组成几何对象的节点的坐标对数组。
     * type - {<SuperMap.GeometryType>} 几何对象的类型。
     */
    function ServerGeometry(options) {
        _classCallCheck(this, ServerGeometry);

        /*
         * APIProperty: id
         * {String} 服务端几何对象唯一标识符。
         */
        this.id = 0;

        /*
         * APIProperty: style
         * {<SuperMap.ServerStyle>} 服务端几何对象的风格(ServerStyle)。
         */
        this.style = null;
        /*
         * APIProperty: parts
         * {Array(Number)} 服务端几何对象中各个子对象所包含的节点个数。
         * 1.几何对象从结构上可以分为简单几何对象和复杂几何对象。
         * 简单几何对象与复杂几何对象的区别：简单的几何对象一般为单一对象，
         * 而复杂的几何对象由多个简单对象组成或经过一定的空间运算之后产生，
         * 如：矩形为简单的区域对象，而中空的矩形为复杂的区域对象。
         * 2.通常情况，一个简单几何对象的子对象就是它本身，
         * 因此对于简单对象来说的该字段为长度为1的整型数组，
         * 该字段的值就是这个简单对象节点的个数。
         * 如果一个几何对象是由几个简单对象组合而成的，
         * 例如，一个岛状几何对象由3个简单的多边形组成而成，
         * 那么这个岛状的几何对象的 Parts 字段值就是一个长度为3的整型数组，
         * 数组中每个成员的值分别代表这三个多边形所包含的节点个数。
         */
        this.parts = null;
        /*
         * APIProperty: points
         * {Array(<Point>)} 组成几何对象的节点的坐标对数组。
         * 1.所有几何对象（点、线、面）都是由一些简单的点坐标组成的，
         * 该字段存放了组成几何对象的点坐标的数组。
         * 对于简单的面对象，他的起点和终点的坐标点相同。
         * 2.对于复杂的几何对象，根据 Parts 属性来确定每一个组成复杂几何对象的简单对象所对应的节点的个数，
         * 从而确定 Points 字段中坐标对的分配归属问题。
         */
        this.points = null;
        /*
         * APIProperty: type
         * {<SuperMap.GeometryType>} 几何对象的类型(GeometryType)。
         */
        this.type = null;
        /*
         * APIProperty: prjCoordSys
         * {Object}投影坐标参数,现仅在缓冲区分析中有效。
         */
        this.prjCoordSys = null;
        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ServerGeometry";
    }

    /*
     * APIMethod: destroy
     * 释放资源，将引用资源的属性置空。
     */


    _createClass(ServerGeometry, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.id = null;
            me.style = null;
            me.parts = null;
            me.partTopo = null;
            me.points = null;
            me.type = null;
            me.prjCoordSys = null;
        }

        /*
         * APIMethod: toGeometry
         * 将服务端几何对象 ServerGeometry 转换为客户端几何对象 Geometry。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeometry',
        value: function toGeometry() {
            var me = this,
                geoType = me.type;
            switch (geoType) {
                case _REST.GeometryType.POINT:
                    return me.toGeoPoint();
                case _REST.GeometryType.LINE:
                    return me.toGeoLine();
                case _REST.GeometryType.LINEM:
                    return me.toGeoLinem();
                case _REST.GeometryType.REGION:
                    return me.toGeoRegion();
                case _REST.GeometryType.POINTEPS:
                    return me.toGeoPoint();
                case _REST.GeometryType.LINEEPS:
                    return me.toGeoLineEPS();
                case _REST.GeometryType.REGIONEPS:
                    return me.toGeoRegionEPS();
            }
        }

        /*
         * Method: toGeoPoint
         * 将服务端的点几何对象转换为客户端几何对象。
         * 包括 Point 、MultiPoint。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeoPoint',
        value: function toGeoPoint() {
            var me = this,
                geoParts = me.parts || [],
                geoPoints = me.points || [],
                len = geoParts.length;
            if (len > 0) {
                if (len === 1) {
                    return new _Point.Point(geoPoints[0].x, geoPoints[0].y);
                } else {
                    var pointList = [];
                    for (var i = 0; i < len; i++) {
                        pointList.push(new _Point.Point(geoPoints[i].x, geoPoints[i].y));
                    }
                    return new _MultiPoint.MultiPoint(pointList);
                }
            } else {
                return null;
            }
        }

        /*
         * Method: toGeoLine
         * 将服务端的线几何对象转换为客户端几何对象。
         * 包括LinearRing、LineString、MultiLineString。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeoLine',
        value: function toGeoLine() {
            var me = this,
                geoParts = me.parts || [],
                geoPoints = me.points || [],
                len = geoParts.length;
            if (len > 0) {
                if (len === 1) {
                    var pointList = [];
                    for (var i = 0; i < geoParts[0]; i++) {
                        pointList.push(new _Point.Point(geoPoints[i].x, geoPoints[i].y));
                    }
                    //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                    if (pointList[0].equals(pointList[geoParts[0] - 1])) {
                        return new _LinearRing.LinearRing(pointList);
                    } else {
                        return new _LineString.LineString(pointList);
                    }
                } else {
                    var lineList = [];
                    for (var _i = 0; _i < len; _i++) {
                        var _pointList = [];
                        for (var j = 0; j < geoParts[_i]; j++) {
                            _pointList.push(new _Point.Point(geoPoints[j].x, geoPoints[j].y));
                        }
                        lineList.push(new _LineString.LineString(_pointList));
                        geoPoints.splice(0, geoParts[_i]);
                    }
                    return new _MultiLineString.MultiLineString(lineList);
                }
            } else {
                return null;
            }
        }

        /*
         * Method: toGeoLineEPS
         * 将服务端的线几何对象转换为客户端几何对象。
         * 包括LinearRing、LineString、MultiLineString。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeoLineEPS',
        value: function toGeoLineEPS() {
            var me = this,
                geoParts = me.parts || [],
                geoPoints = me.points || [],
                i,
                j,
                pointList,
                lineList,
                lineEPS,
                len = geoParts.length;
            if (len > 0) {
                if (len === 1) {
                    for (i = 0, pointList = []; i < geoParts[0]; i++) {
                        pointList.push(new _Point.Point(geoPoints[i].x, geoPoints[i].y, geoPoints[i].type));
                    }
                    //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                    if (pointList[0].equals(pointList[geoParts[0] - 1])) {
                        lineEPS = _LineString.LineString.createLineEPS(pointList);
                        return new _LinearRing.LinearRing(lineEPS);
                    } else {
                        lineEPS = _LineString.LineString.createLineEPS(pointList);
                        return new _LineString.LineString(lineEPS);
                    }
                } else {
                    for (i = 0, lineList = []; i < len; i++) {
                        for (j = 0, pointList = []; j < geoParts[i]; j++) {
                            pointList.push(new _Point.Point(geoPoints[j].x, geoPoints[j].y));
                        }
                        lineEPS = _LineString.LineString.createLineEPS(pointList);
                        lineList.push(new _LineString.LineString(lineEPS));
                        geoPoints.splice(0, geoParts[i]);
                    }
                    return new _MultiLineString.MultiLineString(lineList);
                }
            } else {
                return null;
            }
        }

        /*
         * Method: toGeoLine
         * 将服务端的路由线几何对象转换为客户端几何对象。
         * 包括LinearRing、LineString、MultiLineString。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeoLinem',
        value: function toGeoLinem() {
            var me = this;
            return new _Route.Route.fromJson(me);
        }

        /*
         * Method: toGeoRegion
         * 将服务端的面几何对象转换为客户端几何对象。
         * 类型为Polygon。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeoRegion',
        value: function toGeoRegion() {
            var me = this,
                geoParts = me.parts || [],
                geoTopo = me.partTopo || [],
                geoPoints = me.points || [],
                len = geoParts.length;
            if (len <= 0) {
                return null;
            }
            var polygonArray = [];
            var pointList = [];
            if (len == 1) {
                for (var i = 0; i < geoPoints.length; i++) {
                    pointList.push(new _Point.Point(geoPoints[i].x, geoPoints[i].y));
                }
                polygonArray.push(new _Polygon.Polygon([new _LinearRing.LinearRing(pointList)]));
                return new _MultiPolygon.MultiPolygon(polygonArray);
            }
            //处理复杂面
            var CCWArray = [];
            var areaArray = [];
            var polygonArrayTemp = [];
            //polyon岛洞标识数组，初始都是岛。
            var CCWIdent = [];
            for (var _i2 = 0, pointIndex = 0; _i2 < len; _i2++) {
                for (var j = 0; j < geoParts[_i2]; j++) {
                    pointList.push(new _Point.Point(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));
                }
                pointIndex += geoParts[_i2];
                var polygon = new _Polygon.Polygon([new _LinearRing.LinearRing(pointList)]);
                pointList = [];
                polygonArrayTemp.push(polygon);
                CCWIdent.push(1);
                areaArray.push(polygon.getArea());
            }
            //根据面积排序
            ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo);
            //iServer 9D新增字段
            if (geoTopo.length === 0) {
                //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，
                // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），
                // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞
                //目标polygon索引列表 -1标示没有被任何polygon包含，
                var targetArray = [];
                for (var _i3 = 1; _i3 < polygonArrayTemp.length; _i3++) {
                    for (var _j = _i3 - 1; _j >= 0; _j--) {
                        targetArray[_i3] = -1;
                        if (polygonArrayTemp[_j].getBounds().containsBounds(polygonArrayTemp[_i3].getBounds())) {
                            CCWIdent[_i3] = CCWIdent[_j] * -1;
                            if (CCWIdent[_i3] < 0) {
                                targetArray[_i3] = _j;
                            }
                            break;
                        }
                    }
                }
                for (var _i4 = 0; _i4 < polygonArrayTemp.length; _i4++) {
                    if (CCWIdent[_i4] > 0) {
                        polygonArray.push(polygonArrayTemp[_i4]);
                    } else {
                        polygonArray[targetArray[_i4]].components = polygonArray[targetArray[_i4]].components.concat(polygonArrayTemp[_i4].components);
                        //占位
                        polygonArray.push('');
                    }
                }
            } else {
                //根据面积排序
                //ServerGeometry.bubbleSort(areaArray, polygonArrayTemp,geoTopo);
                polygonArray = new Array();
                for (var _i5 = 0; _i5 < polygonArrayTemp.length; _i5++) {
                    if (geoTopo[_i5] && geoTopo[_i5] == -1) {
                        CCWArray = CCWArray.concat(polygonArrayTemp[_i5].components);
                    } else {
                        if (CCWArray.length > 0 && polygonArray.length > 0) {
                            polygonArray[polygonArray.length - 1].components = polygonArray[polygonArray.length - 1].components.concat(CCWArray);
                            CCWArray = [];
                        }
                        polygonArray.push(polygonArrayTemp[_i5]);
                    }
                    if (_i5 == len - 1) {
                        var polyLength = polygonArray.length;
                        if (polyLength) {
                            polygonArray[polyLength - 1].components = polygonArray[polyLength - 1].components.concat(CCWArray);
                        } else {
                            for (var k = 0, length = CCWArray.length; k < length; k++) {
                                polygonArray.push(new _Polygon.Polygon(CCWArray));
                            }
                        }
                    }
                }
            }
            return new _MultiPolygon.MultiPolygon(polygonArray);
        }

        /*
         * Method: toGeoRegionEPS
         * 将服务端的面几何对象转换为客户端几何对象。
         * 类型为Polygon。
         *
         * Returns
         * {<SuperMap.Geometry>} 转换后的客户端几何对象。
         */

    }, {
        key: 'toGeoRegionEPS',
        value: function toGeoRegionEPS() {
            var me = this,
                geoParts = me.parts || [],
                geoTopo = me.partTopo || [],
                geoPoints = me.points || [],
                len = geoParts.length;

            if (len <= 0) {
                return null;
            }
            var polygonArray = [];
            var pointList = [];
            var lineEPS;
            if (len == 1) {
                for (var i = 0; i < geoPoints.length; i++) {
                    pointList.push(new _Point.Point(geoPoints[i].x, geoPoints[i].y));
                }

                lineEPS = _LineString.LineString.createLineEPS(pointList);
                polygonArray.push(new _Polygon.Polygon([new _LinearRing.LinearRing(lineEPS)]));
                return new _MultiPolygon.MultiPolygon(polygonArray);
            }
            //处理复杂面
            var CCWArray = [];
            var areaArray = [];
            var polygonArrayTemp = [];
            //polyon岛洞标识数组，初始都是岛。
            var CCWIdent = [];
            for (var _i6 = 0, pointIndex = 0; _i6 < len; _i6++) {
                for (var j = 0; j < geoParts[_i6]; j++) {
                    pointList.push(new _Point.Point(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));
                }
                pointIndex += geoParts[_i6];

                lineEPS = _LineString.LineString.createLineEPS(pointList);
                var polygon = new _Polygon.Polygon([new _LinearRing.LinearRing(lineEPS)]);
                pointList = [];
                polygonArrayTemp.push(polygon);
                CCWIdent.push(1);
                areaArray.push(polygon.getArea());
            }
            //根据面积排序
            ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo);
            //iServer 9D新增字段
            if (geoTopo.length === 0) {
                //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，
                // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），
                // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞
                //目标polygon索引列表 -1标示没有被任何polygon包含，
                var targetArray = [];
                for (var _i7 = 1; _i7 < polygonArrayTemp.length; _i7++) {
                    for (var _j2 = _i7 - 1; _j2 >= 0; _j2--) {
                        targetArray[_i7] = -1;
                        if (polygonArrayTemp[_j2].getBounds().containsBounds(polygonArrayTemp[_i7].getBounds())) {
                            CCWIdent[_i7] = CCWIdent[_j2] * -1;
                            if (CCWIdent[_i7] < 0) {
                                targetArray[_i7] = _j2;
                            }
                            break;
                        }
                    }
                }
                for (var _i8 = 0; _i8 < polygonArrayTemp.length; _i8++) {
                    if (CCWIdent[_i8] > 0) {
                        polygonArray.push(polygonArrayTemp[_i8]);
                    } else {
                        polygonArray[targetArray[_i8]].components = polygonArray[targetArray[_i8]].components.concat(polygonArrayTemp[_i8].components);
                        //占位
                        polygonArray.push('');
                    }
                }
            } else {
                //根据面积排序
                polygonArray = new Array();
                for (var _i9 = 0; _i9 < polygonArrayTemp.length; _i9++) {
                    if (geoTopo[_i9] && geoTopo[_i9] == -1) {
                        CCWArray = CCWArray.concat(polygonArrayTemp[_i9].components);
                    } else {
                        if (CCWArray.length > 0 && polygonArray.length > 0) {
                            polygonArray[polygonArray.length - 1].components = polygonArray[polygonArray.length - 1].components.concat(CCWArray);
                            CCWArray = [];
                        }
                        polygonArray.push(polygonArrayTemp[_i9]);
                    }
                    if (_i9 == len - 1) {
                        var polyLength = polygonArray.length;
                        if (polyLength) {
                            polygonArray[polyLength - 1].components = polygonArray[polyLength - 1].components.concat(CCWArray);
                        } else {
                            for (var k = 0, length = CCWArray.length; k < length; k++) {
                                polygonArray.push(new _Polygon.Polygon(CCWArray));
                            }
                        }
                    }
                }
            }
            return new _MultiPolygon.MultiPolygon(polygonArray);
        }

        /*
         * Function: ServerGeometry.fromJson
         * 将 JSON 对象表示服务端几何对象转换为 ServerGeometry。
         *
         * Parameters:
         * jsonObject - {Object} 要转换的 JSON 对象。
         *
         * Returns:
         * {<SuperMap.ServerGeometry>} 转化后的 ServerGeometry 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new ServerGeometry({
                id: jsonObject.id,
                style: _ServerStyle.ServerStyle.fromJson(jsonObject.style),
                parts: jsonObject.parts,
                partTopo: jsonObject.partTopo,
                points: jsonObject.points,
                center: jsonObject.center,
                length: jsonObject.length,
                maxM: jsonObject.maxM,
                minM: jsonObject.minM,
                type: jsonObject.type
            });
        }

        /*
         * Function: ServerGeometry.fromGeometry
         * 将客户端Geometry转换成服务端ServerGeometry。
         *
         * Parameters:
         * geometry - {<SuperMap.Geometry>} 要转换的客户端Geometry对象。
           *
         * Returns:
         * {<SuperMap.ServerGeometry>} 转化后的 ServerGeometry 对象。
         */

    }, {
        key: 'fromGeometry',
        value: function fromGeometry(geometry) {
            if (!geometry) {
                return;
            }
            var id = 0,
                parts = [],
                points = [],
                type = null,
                icomponents = geometry.components,
                className = geometry.CLASS_NAME,
                prjCoordSys = { "epsgCode": geometry.SRID };

            if (!isNaN(geometry.id)) {
                id = geometry.id;
            }
            //坑爹的改法，没法，为了支持态势标绘，有时间就得全改
            if (className != "SuperMap.Geometry.LinearRing" && className != "SuperMap.Geometry.LineString" && (geometry instanceof _MultiPoint.MultiPoint || geometry instanceof _MultiLineString.MultiLineString)) {
                var ilen = icomponents.length;
                for (var i = 0; i < ilen; i++) {
                    var partPointsCount = icomponents[i].getVertices().length;
                    parts.push(partPointsCount);
                    for (var j = 0; j < partPointsCount; j++) {
                        points.push(new _Point.Point(icomponents[i].getVertices()[j].x, icomponents[i].getVertices()[j].y));
                    }
                }
                //这里className不是多点就全部是算线
                type = className == "SuperMap.Geometry.MultiPoint" ? _REST.GeometryType.POINT : _REST.GeometryType.LINE;
            } else if (geometry instanceof _MultiPolygon.MultiPolygon) {
                var _ilen = icomponents.length;
                for (var _i10 = 0; _i10 < _ilen; _i10++) {
                    var polygon = icomponents[_i10],
                        linearRingOfPolygon = polygon.components,
                        linearRingOfPolygonLen = linearRingOfPolygon.length;
                    for (var _j3 = 0; _j3 < linearRingOfPolygonLen; _j3++) {
                        var _partPointsCount = linearRingOfPolygon[_j3].getVertices().length + 1;
                        parts.push(_partPointsCount);
                        for (var k = 0; k < _partPointsCount - 1; k++) {
                            points.push(new _Point.Point(linearRingOfPolygon[_j3].getVertices()[k].x, linearRingOfPolygon[_j3].getVertices()[k].y));
                        }
                        points.push(new _Point.Point(linearRingOfPolygon[_j3].getVertices()[0].x, linearRingOfPolygon[_j3].getVertices()[0].y));
                    }
                }
                type = _REST.GeometryType.REGION;
            } else if (geometry instanceof _Polygon.Polygon) {
                var _ilen2 = icomponents.length;
                for (var _i11 = 0; _i11 < _ilen2; _i11++) {
                    var _partPointsCount2 = icomponents[_i11].getVertices().length + 1;
                    parts.push(_partPointsCount2);
                    for (var _j4 = 0; _j4 < _partPointsCount2 - 1; _j4++) {
                        points.push(new _Point.Point(icomponents[_i11].getVertices()[_j4].x, icomponents[_i11].getVertices()[_j4].y));
                    }
                    points.push(new _Point.Point(icomponents[_i11].getVertices()[0].x, icomponents[_i11].getVertices()[0].y));
                }
                type = _REST.GeometryType.REGION;
            } else {
                var geometryVerticesCount = geometry.getVertices().length;
                for (var _j5 = 0; _j5 < geometryVerticesCount; _j5++) {
                    points.push(new _Point.Point(geometry.getVertices()[_j5].x, geometry.getVertices()[_j5].y));
                }
                if (geometry instanceof _LinearRing.LinearRing) {
                    points.push(new _Point.Point(geometry.getVertices()[0].x, geometry.getVertices()[0].y));
                    geometryVerticesCount++;
                }
                parts.push(geometryVerticesCount);
                type = geometry instanceof _Point.Point ? _REST.GeometryType.POINT : _REST.GeometryType.LINE;
            }

            return new ServerGeometry({
                id: id,
                style: null,
                parts: parts,
                points: points,
                type: type,
                prjCoordSys: prjCoordSys
            });
        }

        /*
         * Function: SuperMap.Geometry.IsClockWise
         * 判断linearRing中的点的顺序，顺时针？逆时针
         * 返回值大于0 逆时针; 小于0 顺时针
         *
         * Parameters:
         * geometry - {<SuperMap.Geometry>} 要转换的客户端Geometry对象。
           *
         * Returns:
         * {<Number>}。
         */

    }, {
        key: 'IsClockWise',
        value: function IsClockWise(points) {
            var length = points.length;
            if (length < 3) {
                return 0.0;
            }
            var s = points[0].y * (points[length - 1].x - points[1].x);
            points.push(points[0]);
            for (var i = 1; i < length; i++) {
                s += points[i].y * (points[i - 1].x - points[i + 1].x);
            }
            return s * 0.5;
        }
    }, {
        key: 'bubbleSort',
        value: function bubbleSort(areaArray, pointList, geoTopo) {
            for (var i = 0; i < areaArray.length; i++) {
                for (var j = 0; j < areaArray.length; j++) {
                    if (areaArray[i] > areaArray[j]) {
                        var d = areaArray[j];
                        areaArray[j] = areaArray[i];
                        areaArray[i] = d;
                        var b = pointList[j];
                        pointList[j] = pointList[i];
                        pointList[i] = b;
                        if (geoTopo && geoTopo.length > 0) {
                            var c = geoTopo[j];
                            geoTopo[j] = geoTopo[i];
                            geoTopo[i] = c;
                        }
                    }
                }
            }
        }
    }]);

    return ServerGeometry;
}();

_SuperMap.SuperMap.ServerGeometry = ServerGeometry;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpatialAnalystBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _CommonServiceBase2 = __webpack_require__(6);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SpatialAnalystBase
 * @classdesc 空间分析服务基类。
 * @param url -{string} 地址d。
 * @param options -{Object} 参数。
 * @extends SuperMap.CommonServiceBase
 */
var SpatialAnalystBase = exports.SpatialAnalystBase = function (_CommonServiceBase) {
    _inherits(SpatialAnalystBase, _CommonServiceBase);

    function SpatialAnalystBase(url, options) {
        _classCallCheck(this, SpatialAnalystBase);

        /**
         * @member SuperMap.SpatialAnalystBase.prototype.format -{string}
         * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式，参数格式为"ISERVER","GEOJSON",GEOJSON
         */
        var _this = _possibleConstructorReturn(this, (SpatialAnalystBase.__proto__ || Object.getPrototypeOf(SpatialAnalystBase)).call(this, url, options));

        _this.format = _REST.DataFormat.GEOJSON;
        _this.CLASS_NAME = "SuperMap.SpatialAnalystBase";
        return _this;
    }

    /**
     * @function SuperMap.SpatialAnalystBase.prototype.destroy
     * @override
     */


    _createClass(SpatialAnalystBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(SpatialAnalystBase.prototype.__proto__ || Object.getPrototypeOf(SpatialAnalystBase.prototype), 'destroy', this).call(this);
            this.format = null;
        }

        /**
         * @function SuperMap.SpatialAnalystBase.prototype.serviceProcessCompleted
         * @description 分析完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this,
                analystResult;
            result = _Util.Util.transformResult(result);
            if (result && me.format === _REST.DataFormat.GEOJSON && typeof me.toGeoJSONResult === 'function') {
                analystResult = me.toGeoJSONResult(result);
            }
            if (!analystResult) {
                analystResult = result;
            }
            me.events.triggerEvent("processCompleted", { result: analystResult });
        }

        /**
         * @function SuperMap.SpatialAnalystBase.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         *
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON.GeoJSON();
            if (result.recordsets) {
                for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                    if (recordsets[i].features) {
                        recordsets[i].features = JSON.parse(geoJSONFormat.write(recordsets[i].features));
                    }
                }
            } else if (result.recordset && result.recordset.features) {
                result.recordset.features = JSON.parse(geoJSONFormat.write(result.recordset.features));
            }
            if (result.resultGeometry) {
                result.resultGeometry = JSON.parse(geoJSONFormat.write(result.resultGeometry));
            }

            return result;
        }
    }]);

    return SpatialAnalystBase;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.SpatialAnalystBase = SpatialAnalystBase;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerColor = __webpack_require__(20);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerStyle
 * @classdesc 服务端矢量要素风格类。
 * @description 该类用于定义点状符号、线状符号、填充符号风格及其相关属性。
 * @param options - {Object} 可选参数。如：<br>
 *        fillBackColor - {{@link SuperMap.ServerColor}} 填充背景颜色。<br>
 *        fillBackOpaque - {boolean} 背景是否不透明。<br>
 *        fillForeColor - {{@link SuperMap.ServerColor}} 填充颜色。<br>
 *        fillGradientMode - {{@link SuperMap.FillGradientMode}} 渐变填充风格的渐变类型。<br>
 *        fillGradientAngle - {number}渐变填充的旋转角度。<br>
 *        fillGradientOffsetRatioX - {number}渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。<br>
 *        fillGradientOffsetRatioY - {number}填充中心点相对于填充区域范围中心点的垂直偏移百分比。<br>
 *        fillOpaqueRate - {number}填充不透明度。<br>
 *        fillSymbolID - {integer} 填充符号的编码。<br>
 *        lineColor - {{@link SuperMap.ServerColor}} 矢量要素的边线颜色。<br>
 *        lineSymbolID - {integer} 线状符号的编码。<br>
 *        lineWidth - {number}边线的宽度。<br>
 *        markerAngle - {number}点状符号的旋转角度。<br>
 *        markerSize - {number}点状符号的大小。<br>
 *        markerSymbolID - {integer} 点状符号的编码。
 */
var ServerStyle = exports.ServerStyle = function () {
  function ServerStyle(options) {
    _classCallCheck(this, ServerStyle);

    /**
     * @member SuperMap.ServerStyle.prototype.fillBackColor -{SuperMap.ServerColor}
     * @description 填充背景颜色。当填充模式为渐变填充时，该颜色为填充终止色。默认为白色。
     */
    this.fillBackColor = new _ServerColor.ServerColor(255, 255, 255);

    /**
     * @member SuperMap.ServerStyle.prototype.fillBackOpaque -{boolean}
     * @description 背景是否不透明。false 表示透明。默认值为 false。
     */
    this.fillBackOpaque = false;

    /**
     * @member SuperMap.ServerStyle.prototype.fillForeColor -{SuperMap.ServerColor}
     * @description 填充颜色。当填充模式为渐变填充时，该颜色为填充起始颜色。默认为红色。
     */
    this.fillForeColor = new _ServerColor.ServerColor(255, 0, 0);

    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientMode -{SuperMap.FillGradientMode}
     * @description 渐变填充风格的渐变类型。
     */
    this.fillGradientMode = null;

    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientAngle -{number}
     * @description 渐变填充的旋转角度。单位为度，精确到0.1度，逆时针方向为正方向。
     */
    this.fillGradientAngle = 0;

    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientOffsetRatioX -{number}
     * @description 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。它们的关系如下：设填充区域范围中心点的坐标为（x0, y0），
     *              填充中心点的坐标为（x, y），填充区域范围的宽度为 a，水平偏移百分比为 dx，则 x=x0 + a*dx/100。
     */
    this.fillGradientOffsetRatioX = 0;

    /**
     * @member SuperMap.ServerStyle.prototype.fillGradientOffsetRatioY -{number}
     * @description 填充中心点相对于填充区域范围中心点的垂直偏移百分比。它们的关系如下：<br>
     *           设填充区域范围中心点的坐标为（x0, y0），填充中心点的坐标为（x, y），填充区域范围的高度为 b，垂直偏移百分比为 dy，则 y=y0 + b*dx/100。
     */
    this.fillGradientOffsetRatioY = 0;

    /**
     * @member SuperMap.ServerStyle.prototype.fillOpaqueRate -{number}
     * @description 填充不透明度。合法值为0--100的数值。其中为0表示完全透明；
     *              100表示完全不透明。赋值小于0时按照0处理，大于100时按照100处理。默认值为 100。
     */
    this.fillOpaqueRate = 100;

    /**
     * @member SuperMap.ServerStyle.prototype.fillSymbolID -{integer}
     * @description 填充符号的编码。此编码用于唯一标识各普通填充风格的填充符号。
     *              关于填充符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
     */
    this.fillSymbolID = 0;

    /**
     * @member SuperMap.ServerStyle.prototype.lineColor -{SuperMap.ServerColor}
     * @description 矢量要素的边线颜色。默认为黑色。如果等级符号是点符号，点符号的颜色由lineColor控制
     */
    this.lineColor = new _ServerColor.ServerColor(0, 0, 0);

    /**
     * @member SuperMap.ServerStyle.prototype.lineSymbolID -{integer}
     * @description 线状符号的编码。此编码用于唯一标识各普通填充风格的填充符号，默认值为0。
     *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
     */
    this.lineSymbolID = 0;

    /**
     * @member SuperMap.ServerStyle.prototype.lineWidth -{number}
     * @description 边线的宽度。单位为毫米，精度到0.1，默认值为1.0。
     */
    this.lineWidth = 1;

    /**
     * @member SuperMap.ServerStyle.prototype.markerAngle -{number}
     * @description 点状符号的旋转角度。以度为单位，精确到0.1度，逆时针方向为正方向，默认值为0。
     */
    this.markerAngle = 0;

    /**
     * @member SuperMap.ServerStyle.prototype.markerSize -{number}
     * @description 点状符号的大小。单位为毫米，精度为0.1，默认值为1.0。当该属性设置为0时，采用符号默认大小1.0显示。
     *              当该属性设置为非法值时，交由服务器默认处理。
     */
    this.markerSize = 1;

    /**
     * @member SuperMap.ServerStyle.prototype.markerSymbolID -{integer}
     * @description 点状符号的编码。此编码用于唯一标识各点状符号。默认为 -1。
     *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
     */
    this.markerSymbolID = -1;
    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.ServerStyle";
  }

  /**
   * @function SuperMap.ServerStyle.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ServerStyle, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.fillBackColor) {
        me.fillBackColor.destroy();
        me.fillBackColor = null;
      }
      me.fillBackOpaque = null;

      if (me.fillForeColor) {
        me.fillForeColor.destroy();
        me.fillForeColor = null;
      }
      me.fillGradientMode = null;
      me.fillGradientAngle = null;
      me.fillGradientOffsetRatioX = null;
      me.fillGradientOffsetRatioY = null;
      me.fillOpaqueRate = null;
      me.fillSymbolID = null;
      if (me.lineColor) {
        me.lineColor.destroy();
        me.lineColor = null;
      }
      me.lineSymbolID = null;
      me.lineWidth = null;
      me.markerAngle = null;
      me.markerSize = null;
      me.markerSymbolID = null;
    }

    /**
     * @function SuperMap.ServerStyle.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @return{Object } 对应的 JSON 格式对象
     */

  }, {
    key: 'toServerJSONObject',
    value: function toServerJSONObject() {
      var styleObj = {};
      styleObj = _Util.Util.copyAttributes(styleObj, this);
      //暂时先忽略serverColor往Json的转换
      return styleObj;
    }

    /**
     * @function SuperMap.ServerStyle.fromJson
     * @description 将JSON对象转换为 SuperMap.ServerStyle 对象。
     * @param jsonObject - {Object} 要转换的 JSON 对象。
     * @return{SuperMap.ServerStyle} 转化后的 SuperMap.ServerStyle 对象。
     */

  }], [{
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      if (!jsonObject) {
        return;
      }
      return new ServerStyle({
        fillBackColor: _ServerColor.ServerColor.fromJson(jsonObject.fillBackColor),
        fillBackOpaque: jsonObject.fillBackOpaque,
        fillForeColor: _ServerColor.ServerColor.fromJson(jsonObject.fillForeColor),
        fillGradientMode: jsonObject.fillGradientMode,
        fillGradientAngle: jsonObject.fillGradientAngle,
        fillGradientOffsetRatioX: jsonObject.fillGradientOffsetRatioX,
        fillGradientOffsetRatioY: jsonObject.fillGradientOffsetRatioY,
        fillOpaqueRate: jsonObject.fillOpaqueRate,
        fillSymbolID: jsonObject.fillSymbolID,
        lineColor: _ServerColor.ServerColor.fromJson(jsonObject.lineColor),
        lineSymbolID: jsonObject.lineSymbolID,
        lineWidth: jsonObject.lineWidth,
        markerAngle: jsonObject.markerAngle,
        markerSize: jsonObject.markerSize,
        markerSymbolID: jsonObject.markerSymbolID
      });
    }
  }]);

  return ServerStyle;
}();

_SuperMap.SuperMap.ServerStyle = ServerStyle;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SUtil = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Area = __webpack_require__(264);

var _Color = __webpack_require__(105);

var _ComputeBoundingBox = __webpack_require__(266);

var _Curve = __webpack_require__(79);

var _Env = __webpack_require__(268);

var _Event = __webpack_require__(269);

var _Http = __webpack_require__(272);

var _Log = __webpack_require__(273);

var _Math = __webpack_require__(274);

var _Matrix = __webpack_require__(275);

var _Util = __webpack_require__(29);

var _Vector = __webpack_require__(82);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SUtil = exports.SUtil = function () {
    function SUtil() {
        _classCallCheck(this, SUtil);
    }

    _createClass(SUtil, null, [{
        key: 'SUtil_smoothBezier',

        /**
         * APIFunction: SuperMap.LevelRenderer.SUtil_smoothBezier
         * 贝塞尔平滑曲线。
         *
         * Parameters:
         * points - {Array} 线段顶点数组。
         * smooth - {Number} 平滑等级, 0-1。
         * isLoop - {Boolean} isLoop。
         * constraint - {Array} 将计算出来的控制点约束在一个包围盒内，比如 [[0, 0], [100, 100]], 这个包围盒会与整个折线的包围盒做一个并集用来约束控制点。
         * originalPosition - {Array} 参考原点。默认值：[0, 0]。
         *
         * Returns:
         * {Array} 生成的平滑节点数组。
         */
        value: function SUtil_smoothBezier(points, smooth, isLoop, constraint, originalPosition) {
            if (!originalPosition || originalPosition !== 2) {
                originalPosition = [0, 0];
            }
            var __OP = originalPosition;

            var cps = [];

            var v = [];
            var v1 = [];
            var v2 = [];

            var hasConstraint = !!constraint;
            var min, max;
            if (hasConstraint) {
                min = [Infinity, Infinity];
                max = [-Infinity, -Infinity];
                var _len = points.length;
                for (var i = 0; i < _len; i++) {
                    SUtil.Util_vector.min(min, min, [points[i][0] + __OP[0], points[i][1] + __OP[1]]);
                    SUtil.Util_vector.max(max, max, [points[i][0] + __OP[0], points[i][1] + __OP[1]]);
                }
                // 与指定的包围盒做并集
                SUtil.Util_vector.min(min, min, constraint[0]);
                SUtil.Util_vector.max(max, max, constraint[1]);
            }

            var len = points.length;
            for (var _i = 0; _i < len; _i++) {
                var point = [points[_i][0] + __OP[0], points[_i][1] + __OP[1]];
                var prevPoint = void 0;
                var nextPoint = void 0;

                if (isLoop) {
                    prevPoint = [points[_i ? _i - 1 : len - 1][0] + __OP[0], points[_i ? _i - 1 : len - 1][1] + __OP[1]];
                    nextPoint = [points[(_i + 1) % len][0] + __OP[0], points[(_i + 1) % len][1] + __OP[1]];
                } else {
                    if (_i === 0 || _i === len - 1) {
                        cps.push([points[_i][0] + __OP[0], points[_i][1] + __OP[1]]);
                        continue;
                    } else {
                        prevPoint = [points[_i - 1][0] + __OP[0], points[_i - 1][1] + __OP[1]];
                        nextPoint = [points[_i + 1][0] + __OP[0], points[_i + 1][1] + __OP[1]];
                    }
                }

                SUtil.Util_vector.sub(v, nextPoint, prevPoint);

                // use degree to scale the handle length
                SUtil.Util_vector.scale(v, v, smooth);

                var d0 = SUtil.Util_vector.distance(point, prevPoint);
                var d1 = SUtil.Util_vector.distance(point, nextPoint);
                var sum = d0 + d1;
                if (sum !== 0) {
                    d0 /= sum;
                    d1 /= sum;
                }

                SUtil.Util_vector.scale(v1, v, -d0);
                SUtil.Util_vector.scale(v2, v, d1);
                var cp0 = SUtil.Util_vector.add([], point, v1);
                var cp1 = SUtil.Util_vector.add([], point, v2);
                if (hasConstraint) {
                    SUtil.Util_vector.max(cp0, cp0, min);
                    SUtil.Util_vector.min(cp0, cp0, max);
                    SUtil.Util_vector.max(cp1, cp1, min);
                    SUtil.Util_vector.min(cp1, cp1, max);
                }
                cps.push(cp0);
                cps.push(cp1);
            }

            if (isLoop) {
                cps.push(cps.shift());
            }

            return cps;
        }

        /**
         * APIFunction: SuperMap.LevelRenderer.SUtil_smoothSpline
         * 插值折线。
         *
         * Parameters:
         * points - {Array} 线段顶点数组。
         * isLoop - {Boolean} isLoop。
         * constraint - {Array} 将计算出来的控制点约束在一个包围盒内，比如 [[0 0] [100 100]] 这个包围盒会与整个折线的包围盒做一个并集用来约束控制点。
         * originalPosition - {Array} 参考原点。默认值：[0 0]。
         *
         * Returns:
         * {Array} 生成的平滑节点数组。
         */

    }, {
        key: 'SUtil_smoothSpline',
        value: function SUtil_smoothSpline(points, isLoop, constraint, originalPosition) {
            if (!originalPosition || originalPosition !== 2) {
                originalPosition = [0, 0];
            }
            var __OP = originalPosition;

            var len = points.length;
            var ret = [];

            var distance = 0;
            for (var i = 1; i < len; i++) {
                distance += SUtil.Util_vector.distance([points[i - 1][0] + __OP[0], points[i - 1][1] + __OP[1]], [points[i][0] + __OP[0], points[i][1] + __OP[1]]);
            }

            var segs = distance / 5;
            segs = segs < len ? len : segs;
            for (var _i2 = 0; _i2 < segs; _i2++) {
                var pos = _i2 / (segs - 1) * (isLoop ? len : len - 1);
                var idx = Math.floor(pos);

                var w = pos - idx;

                var p0 = void 0;
                var p1 = [points[idx % len][0] + __OP[0], points[idx % len][1] + __OP[1]];
                var p2 = void 0;
                var p3 = void 0;
                if (!isLoop) {
                    p0 = [points[idx === 0 ? idx : idx - 1][0] + __OP[0], points[idx === 0 ? idx : idx - 1][1] + __OP[1]];
                    p2 = [points[idx > len - 2 ? len - 1 : idx + 1][0] + __OP[0], points[idx > len - 2 ? len - 1 : idx + 1][1] + __OP[1]];
                    p3 = [points[idx > len - 3 ? len - 1 : idx + 2][0] + __OP[0], points[idx > len - 3 ? len - 1 : idx + 2][1] + __OP[1]];
                } else {

                    p0 = [points[(idx - 1 + len) % len][0] + __OP[0], points[(idx - 1 + len) % len][1] + __OP[1]];
                    p2 = [points[(idx + 1) % len][0] + __OP[0], points[(idx + 1) % len][1] + __OP[1]];
                    p3 = [points[(idx + 2) % len][0] + __OP[0], points[(idx + 2) % len][1] + __OP[1]];
                }

                var w2 = w * w;
                var w3 = w * w2;

                ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
            }
            return ret;

            // inner Function
            function interpolate(p0, p1, p2, p3, t, t2, t3) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
        }

        /**
         * APIFunction: SuperMap.LevelRenderer.SUtil_dashedLineTo
         * 虚线 lineTo。
         */

    }, {
        key: 'SUtil_dashedLineTo',
        value: function SUtil_dashedLineTo(ctx, x1, y1, x2, y2, dashLength, customDashPattern) {
            // http://msdn.microsoft.com/en-us/library/ie/dn265063(v=vs.85).aspx
            var dashPattern = [5, 5];
            dashLength = typeof dashLength != 'number' ? 5 : dashLength;

            if (ctx.setLineDash) {
                dashPattern[0] = dashLength;
                dashPattern[1] = dashLength;

                if (customDashPattern && customDashPattern instanceof Array) {
                    ctx.setLineDash(customDashPattern);
                } else {
                    ctx.setLineDash(dashPattern);
                }
                // ctx.setLineDash(dashPattern);

                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                return;
            }

            var dx = x2 - x1;
            var dy = y2 - y1;
            var numDashes = Math.floor(Math.sqrt(dx * dx + dy * dy) / dashLength);
            dx = dx / numDashes;
            dy = dy / numDashes;
            var flag = true;
            for (var i = 0; i < numDashes; ++i) {
                if (flag) {
                    ctx.moveTo(x1, y1);
                } else {
                    ctx.lineTo(x1, y1);
                }
                flag = !flag;
                x1 += dx;
                y1 += dy;
            }
            ctx.lineTo(x2, y2);
        }
    }]);

    return SUtil;
}();
// 把所有工具对象放到全局静态变量上，以便直接调用工具方法，
// 避免使用工具时频繁的创建工具对象带来的性能消耗。


SUtil.Util_area = new _Area.Area();
SUtil.Util_color = new _Color.Color();
SUtil.Util_computeBoundingBox = new _ComputeBoundingBox.ComputeBoundingBox();
SUtil.Util_curve = new _Curve.Curve();
SUtil.Util_env = new _Env.Env();
SUtil.Util_event = new _Event.Event();
SUtil.Util_http = new _Http.Http();
SUtil.Util_log = new _Log.Log();
SUtil.Util_math = new _Math.Math();
SUtil.Util_matrix = new _Matrix.Matrix();
SUtil.Util = new _Util.Util();
SUtil.Util_vector = new _Vector.Vector();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Shape = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Eventful = __webpack_require__(53);

var _Transformable = __webpack_require__(81);

var _Util = __webpack_require__(1);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape
 * 图形（shape）基类。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Eventful>
 *  - <SuperMap.LevelRenderer.Transformable>
 */
var Shape = exports.Shape = function (_SuperMap$mixin) {
    _inherits(Shape, _SuperMap$mixin);

    /**
     * Constructor: SuperMap.LevelRenderer.Shape
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function Shape(options) {
        _classCallCheck(this, Shape);

        var _this = _possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).call(this, options));

        options = options || {};
        /**
         * APIProperty: id
         * {String} 唯一标识。
         */
        _this.id = null;

        /**
         * APIProperty: style
         * {Object} 基础绘制样式。
         *
         * Symbolizer properties:
         * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
         * color - {String} 填充颜色。默认值："#000000'"。
         * strokeColor - {String} 描边颜色。默认值："#000000'"。
         * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
         * lineWidth - {Number} 描边宽度。默认值：1。
         * opacity - {Number} 绘制透明度。默认值：1。
         * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
         * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
         * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
         * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
         * text - {String} 图形中的附加文本。默认值：""。
         * textColor - {String} 文本颜色。默认值："#000000'"。
         * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
         * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
         * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
         * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
         *
         */
        _this.style = {};

        /**
         * APIProperty: style.__rect
         * {Object} 包围图形的最小矩形盒子。该对象包含以下属性：
         *
         * Symbolizer properties:
         * x - {Number} 左上角顶点x轴坐标。
         * y - {Number} 左上角顶点y轴坐标。
         * width - {Number} 包围盒矩形宽度。
         * height - {Number} 包围盒矩形高度。
         */

        /**
         * Property: highlightStyle
         * {Object} 高亮样式。
         *
         * Symbolizer properties:
         * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
         * color - {String} 填充颜色。默认值："#000000'"。
         * strokeColor - {String} 描边颜色。默认值："#000000'"。
         * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
         * lineWidth - {Number} 描边宽度。默认值：1。
         * opacity - {Number} 绘制透明度。默认值：1。
         * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
         * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
         * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
         * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
         * text - {String} 图形中的附加文本。默认值：""。
         * textColor - {String} 文本颜色。默认值："#000000'"。
         * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
         * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
         * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
         * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
         */
        _this.highlightStyle = null;

        /**
         * APIProperty: parent
         * {Object} 父节点，只读属性。<SuperMap.LevelRenderer.Group>
         */
        _this.parent = null;

        /**
         * Property: __dirty
         * {Boolean}
         */
        _this.__dirty = true;

        /**
         * Property: __clipShapes
         * {Array}
         */
        _this.__clipShapes = [];

        /**
         * APIProperty: invisible
         * {Boolean} 图形是否可见，为 true 时不绘制图形，但是仍能触发鼠标事件。默认值：false。
         */
        _this.invisible = false;

        /**
         * APIProperty: ignore
         * {Boolean} 图形是否忽略，为 true 时忽略图形的绘制以及事件触发。默认值：false。
         */
        _this.ignore = false;

        /**
         * APIProperty: zlevel
         * {Number} z 层 level，决定绘画在哪层 canvas 中。默认值：0。
         */
        _this.zlevel = 0;

        /**
         * APIProperty: draggable
         * {Boolean} 是否可拖拽。默认值：false。
         */
        _this.draggable = false;

        /**
         * APIProperty: clickable
         * {Boolean} 是否可点击。默认值：false。
         */
        _this.clickable = false;

        /**
         * APIProperty: hoverable
         * {Boolean} 是否可以 hover。默认值：true。
         */
        _this.hoverable = true;

        /**
         * APIProperty: z
         * {Number} z值，跟zlevel一样影响shape绘制的前后顺序，z值大的shape会覆盖在z值小的上面，
         * 但是并不会创建新的canvas，所以优先级低于zlevel，而且频繁改动的开销比zlevel小很多。
         * 默认值：0。
         */
        _this.z = 0;

        //地理扩展
        /**
         * APIProperty: refOriginalPosition
         * {Array} 图形参考原点位置，图形的参考中心位置。
         * refOriginalPosition 是长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         *
         * refOriginalPosition 表示图形的参考中心，通常情况下，图形是使用 canvas 的原点位置作为位置参考，
         * 但 refOriginalPosition 可以改变图形的参考位置，例如： refOriginalPosition = [80, 80],
         * 图形圆的 style.x = 20, style.y = 20，那么圆在 canvas 中的实际位置是 [100, 100]。
         *
         * 图形（Shape） 的所有位置相关属性都是以 refOriginalPosition 为参考中心，
         * 也就是说图形的所有位置信息在 canvas 中都是以 refOriginalPosition 为参考的相对位置，只有
         * refOriginalPosition 的值为 [0, 0] 时，形的位置信息才是 canvas 绝对位置。
         *
         * 图形的位置信息通常有：style.pointList，style.x，style.y。
         *
         * refOriginalPosition。默认值是： [0, 0]。
         */
        _this.refOriginalPosition = [0, 0];

        /**
         * APIProperty: refDataID
         * {String} 图形所关联数据的 ID。
         *
         */
        _this.refDataID = null;

        /**
         * APIProperty: isHoverByRefDataID
         * {Boolean} 是否根据 refDataID 进行高亮。用于同时高亮所有 refDataID 相同的图形。
         *
         */
        _this.isHoverByRefDataID = false;

        /**
         * APIProperty: refDataHoverGroup
         * {String} 高亮图形组的组名。此属性在 refDataID 有效且 isHoverByRefDataID 为 true 时生效。
         * 一旦设置此属性，且属性值有效，只有关联同一个数据的图形且此属性相同的图形才会高亮。
         *
         */
        _this.refDataHoverGroup = null;

        /**
         * APIProperty: dataInfo
         * {Object} 图形的数据信息。
         *
         */
        _this.dataInfo = null;
        _Util.Util.extend(_this, options);
        _this.id = _this.id || _Util.Util.createUniqueID("smShape_");
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape";
        /**
         * APIMethod: getTansform
         * 变换鼠标位置到 shape 的局部坐标空间
         *
         */
        _this.getTansform = function () {
            var invTransform = [];

            return function (x, y) {
                var originPos = [x, y];
                // 对鼠标的坐标也做相同的变换
                if (this.needTransform && this.transform) {
                    _SUtil.SUtil.Util_matrix.invert(invTransform, this.transform);

                    _SUtil.SUtil.Util_matrix.mulVector(originPos, invTransform, [x, y, 1]);

                    if (x == originPos[0] && y == originPos[1]) {
                        // 避免外部修改导致的 needTransform 不准确
                        this.updateNeedTransform();
                    }
                }
                return originPos;
            };
        }();

        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Shape, [{
        key: 'destroy',
        value: function destroy() {
            this.id = null;
            this.style = null;
            this.highlightStyle = null;
            this.parent = null;
            this.__dirty = null;
            this.__clipShapes = null;
            this.invisible = null;
            this.ignore = null;
            this.zlevel = null;
            this.draggable = null;
            this.clickable = null;
            this.hoverable = null;
            this.z = null;

            this.refOriginalPosition = null;
            this.refDataID = null;
            this.refDataHoverGroup = null;
            this.isHoverByRefDataID = null;
            this.dataInfo = null;
            _get(Shape.prototype.__proto__ || Object.getPrototypeOf(Shape.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: brush
         * 绘制图形。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * isHighlight - {Boolean} 是否使用高亮属性。
         * updateCallback - {Function} 需要异步加载资源的 shape 可以通过这个 callback(e)
         * 让painter更新视图，base.brush 没用，需要的话重载 brush。
         *
         */

    }, {
        key: 'brush',
        value: function brush(ctx, isHighlight) {

            var style = this.beforeBrush(ctx, isHighlight);

            ctx.beginPath();
            this.buildPath(ctx, style);

            switch (style.brushType) {
                /* jshint ignore:start */
                case 'both':
                    this.setCtxGlobalAlpha(ctx, "fill", style);
                    ctx.fill();
                    if (style.lineWidth > 0) {
                        this.setCtxGlobalAlpha(ctx, "stroke", style);
                        ctx.stroke();
                    }
                    this.setCtxGlobalAlpha(ctx, "reset", style);
                    break;
                case 'stroke':
                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                    style.lineWidth > 0 && ctx.stroke();
                    this.setCtxGlobalAlpha(ctx, "reset", style);
                    break;
                /* jshint ignore:end */
                default:
                    this.setCtxGlobalAlpha(ctx, "fill", style);
                    ctx.fill();
                    this.setCtxGlobalAlpha(ctx, "reset", style);
                    break;
            }

            this.drawText(ctx, style, this.style);

            this.afterBrush(ctx);
        }

        /**
         * APIMethod: beforeBrush
         * 具体绘制操作前的一些公共操作。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * isHighlight - {Boolean} 是否使用高亮属性。
         *
         * Returns:
         * {Object} 处理后的样式。
         */

    }, {
        key: 'beforeBrush',
        value: function beforeBrush(ctx, isHighlight) {
            var style = this.style;

            if (this.brushTypeOnly) {
                style.brushType = this.brushTypeOnly;
            }

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(style, this.highlightStyle || {}, this.brushTypeOnly);
            }

            if (this.brushTypeOnly == 'stroke') {
                style.strokeColor = style.strokeColor || style.color;
            }

            ctx.save();

            this.doClip(ctx);

            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            return style;
        }

        /**
         * APIMethod: afterBrush
         * 绘制后的处理。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         *
         */

    }, {
        key: 'afterBrush',
        value: function afterBrush(ctx) {
            ctx.restore();
        }

        /**
         * APIMethod: setContext
         * 设置 fillStyle strokeStyle shadow 等通用绘制样式。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} 样式。
         *
         */

    }, {
        key: 'setContext',
        value: function setContext(ctx, style) {
            var STYLE_CTX_MAP = [['color', 'fillStyle'], ['strokeColor', 'strokeStyle'], ['opacity', 'globalAlpha'], ['lineCap', 'lineCap'], ['lineJoin', 'lineJoin'], ['miterLimit', 'miterLimit'], ['lineWidth', 'lineWidth'], ['shadowBlur', 'shadowBlur'], ['shadowColor', 'shadowColor'], ['shadowOffsetX', 'shadowOffsetX'], ['shadowOffsetY', 'shadowOffsetY']];

            for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {
                var styleProp = STYLE_CTX_MAP[i][0];
                var styleValue = style[styleProp];
                var ctxProp = STYLE_CTX_MAP[i][1];

                if (typeof styleValue != 'undefined') {
                    ctx[ctxProp] = styleValue;
                }
            }
        }

        /**
         * Method: doClip
         *
         */

    }, {
        key: 'doClip',
        value: function doClip(ctx) {
            var clipShapeInvTransform = _SUtil.SUtil.Util_matrix.create();

            if (this.__clipShapes) {
                for (var i = 0; i < this.__clipShapes.length; i++) {
                    var clipShape = this.__clipShapes[i];
                    if (clipShape.needTransform) {
                        var m = clipShape.transform;
                        _SUtil.SUtil.Util_matrix.invert(clipShapeInvTransform, m);
                        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }
                    ctx.beginPath();
                    clipShape.buildPath(ctx, clipShape.style);
                    ctx.clip();
                    // Transform back
                    if (clipShape.needTransform) {
                        var _m = clipShapeInvTransform;
                        ctx.transform(_m[0], _m[1], _m[2], _m[3], _m[4], _m[5]);
                    }
                }
            }
        }

        /**
         * APIMethod: getHighlightStyle
         * 根据默认样式扩展高亮样式
         *
         * Parameters:
         * style - {Object} 样式。
         * highlightStyle - {Object} 高亮样式。
         * brushTypeOnly - {String} brushTypeOnly。
         *
         */

    }, {
        key: 'getHighlightStyle',
        value: function getHighlightStyle(style, highlightStyle, brushTypeOnly) {
            var newStyle = {};
            for (var k in style) {
                newStyle[k] = style[k];
            }

            var highlightColor = _SUtil.SUtil.Util_color.getHighlightColor();
            // 根据highlightStyle扩展
            if (style.brushType != 'stroke') {
                // 带填充则用高亮色加粗边线
                newStyle.strokeColor = highlightColor;
                // SMIC-方法修改 - start
                newStyle.lineWidth = style.lineWidth || 1;
                // 原始代码
                //      newStyle.lineWidth = (style.lineWidth || 1)
                //          + this.getHighlightZoom();
                // 修改代码1
                // if(!style.lineType || style.lineType === "solid"){
                //     newStyle.lineWidth = (style.lineWidth || 1)
                //         + this.getHighlightZoom();
                // }
                // else{
                //     newStyle.lineWidth = (style.lineWidth || 1);
                // }
                // SMIC-方法修改 - end
                newStyle.brushType = 'both';
            } else {
                if (brushTypeOnly != 'stroke') {
                    // 描边型的则用原色加工高亮
                    newStyle.strokeColor = highlightColor;
                    // SMIC-方法修改 - start
                    newStyle.lineWidth = style.lineWidth || 1;
                    // 原始代码
                    //      newStyle.lineWidth = (style.lineWidth || 1)
                    //          + this.getHighlightZoom();
                    // 修改代码1
                    // if(!style.lineType || style.lineType === "solid"){
                    //     newStyle.lineWidth = (style.lineWidth || 1)
                    //         + this.getHighlightZoom();
                    // }
                    // else{
                    //     newStyle.lineWidth = (style.lineWidth || 1);
                    // }
                    // SMIC-方法修改 - end
                } else {
                    // 线型的则用原色加工高亮
                    newStyle.strokeColor = highlightStyle.strokeColor || _SUtil.SUtil.Util_color.mix(style.strokeColor, _SUtil.SUtil.Util_color.toRGB(highlightColor));
                }
            }

            // 可自定义覆盖默认值
            for (var _k in highlightStyle) {
                if (typeof highlightStyle[_k] != 'undefined') {
                    newStyle[_k] = highlightStyle[_k];
                }
            }

            return newStyle;
        }

        /**
         * Method: getHighlightZoom
         * 高亮放大效果参数，当前统一设置为6，如有需要差异设置，通过 this.type 判断实例类型
         *
         */

    }, {
        key: 'getHighlightZoom',
        value: function getHighlightZoom() {
            return this.type != 'text' ? 6 : 2;
        }

        /**
         * APIMethod: drift
         * 移动位置
         *
         * Parameters:
         * dx - {Object} 横坐标变化。
         * dy - {Object} 纵坐标变化。
         *
         */

    }, {
        key: 'drift',
        value: function drift(dx, dy) {
            this.position[0] += dx;
            this.position[1] += dy;
        }

        /**
         * APIMethod: buildPath
         * 构建绘制的Path。子类必须重新实现此方法。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} 样式。
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            // eslint-disable-line no-unused-vars
            _SUtil.SUtil.Util_log('buildPath not implemented in ' + this.type);
        }

        /**
         * APIMethod: getRect
         * 计算返回包围盒矩形。子类必须重新实现此方法。
         *
         * Parameters:
         * style - {Object} 样式。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            // eslint-disable-line no-unused-vars
            _SUtil.SUtil.Util_log('getRect not implemented in ' + this.type);
        }

        /**
         * APIMethod: isCover
         * 判断鼠标位置是否在图形内。
         *
         * Parameters:
         * x - {Number} x。
         * y - {Number} y。
         */

    }, {
        key: 'isCover',
        value: function isCover(x, y) {
            var originPos = this.getTansform(x, y);
            x = originPos[0];
            y = originPos[1];

            // 快速预判并保留判断矩形
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }

            if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
                // 矩形内
                return _SUtil.SUtil.Util_area.isInside(this, this.style, x, y);
            }

            return false;
        }

        /**
         * APIMethod: drawText
         * 绘制附加文本。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {String} 样式。
         * normalStyle - {String} normalStyle 默认样式，用于定位文字显示。
         */

    }, {
        key: 'drawText',
        value: function drawText(ctx, style, normalStyle) {
            if (typeof style.text == 'undefined' || style.text === false) {
                return;
            }
            // 字体颜色策略
            var textColor = style.textColor || style.color || style.strokeColor;
            ctx.fillStyle = textColor;

            // 文本与图形间空白间隙
            var dd = 10;
            var al; // 文本水平对齐
            var bl; // 文本垂直对齐
            var tx; // 文本横坐标
            var ty; // 文本纵坐标

            var textPosition = style.textPosition // 用户定义
            || this.textPosition // shape默认
            || 'top'; // 全局默认

            // Smic 方法修改 -start
            var __OP = [];
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                __OP = [0, 0];
            } else {
                __OP = this.refOriginalPosition;
            }
            //原代码：
            // Smic 方法修改 -end

            switch (textPosition) {
                case 'inside':
                case 'top':
                case 'bottom':
                case 'left':
                case 'right':
                    if (this.getRect) {
                        var rect = (normalStyle || style).__rect || this.getRect(normalStyle || style);

                        switch (textPosition) {
                            case 'inside':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y + rect.height / 2;
                                al = 'center';
                                bl = 'middle';
                                if (style.brushType != 'stroke' && textColor == style.color) {
                                    ctx.fillStyle = '#fff';
                                }
                                break;
                            case 'left':
                                tx = rect.x - dd;
                                ty = rect.y + rect.height / 2;
                                al = 'end';
                                bl = 'middle';
                                break;
                            case 'right':
                                tx = rect.x + rect.width + dd;
                                ty = rect.y + rect.height / 2;
                                al = 'start';
                                bl = 'middle';
                                break;
                            case 'top':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y - dd;
                                al = 'center';
                                bl = 'bottom';
                                break;
                            case 'bottom':
                                tx = rect.x + rect.width / 2;
                                ty = rect.y + rect.height + dd;
                                al = 'center';
                                bl = 'top';
                                break;
                        }
                    }
                    break;
                case 'start':
                case 'end':
                    var xStart = 0;
                    var xEnd = 0;
                    var yStart = 0;
                    var yEnd = 0;
                    if (typeof style.pointList != 'undefined') {
                        var pointList = style.pointList;
                        if (pointList.length < 2) {
                            // 少于2个点就不画了~
                            return;
                        }
                        var length = pointList.length;
                        switch (textPosition) {
                            // Smic 方法修改 -start
                            case 'start':
                                xStart = pointList[0][0] + __OP[0];
                                xEnd = pointList[1][0] + __OP[0];
                                yStart = pointList[0][1] + __OP[1];
                                yEnd = pointList[1][1] + __OP[1];
                                break;
                            case 'end':
                                xStart = pointList[length - 2][0] + __OP[0];
                                xEnd = pointList[length - 1][0] + __OP[0];
                                yStart = pointList[length - 2][1] + __OP[1];
                                yEnd = pointList[length - 1][1] + __OP[1];
                                break;
                            //原代码：
                            /*
                             case 'start':
                             xStart = pointList[0][0];
                             xEnd = pointList[1][0];
                             yStart = pointList[0][1];
                             yEnd = pointList[1][1];
                             break;
                             case 'end':
                             xStart = pointList[length - 2][0];
                             xEnd = pointList[length - 1][0];
                             yStart = pointList[length - 2][1];
                             yEnd = pointList[length - 1][1];
                             break;
                             */
                            // Smic 方法修改 -end
                        }
                    } else {
                        // Smic 方法修改 -start
                        xStart = style.xStart + __OP[0] || 0;
                        xEnd = style.xEnd + __OP[0] || 0;
                        yStart = style.yStart + __OP[1] || 0;
                        yEnd = style.yEnd + __OP[1] || 0;
                        //原代码：
                        /*
                         xStart = style.xStart || 0;
                         xEnd = style.xEnd || 0;
                         yStart = style.yStart || 0;
                         yEnd = style.yEnd || 0;
                         */
                        // Smic 方法修改 -end
                    }

                    switch (textPosition) {
                        case 'start':
                            al = xStart < xEnd ? 'end' : 'start';
                            bl = yStart < yEnd ? 'bottom' : 'top';
                            tx = xStart;
                            ty = yStart;
                            break;
                        case 'end':
                            al = xStart < xEnd ? 'start' : 'end';
                            bl = yStart < yEnd ? 'top' : 'bottom';
                            tx = xEnd;
                            ty = yEnd;
                            break;
                    }
                    dd -= 4;
                    if (xStart && xEnd && xStart != xEnd) {
                        tx -= al == 'end' ? dd : -dd;
                    } else {
                        al = 'center';
                    }

                    if (yStart != yEnd) {
                        ty -= bl == 'bottom' ? dd : -dd;
                    } else {
                        bl = 'middle';
                    }
                    break;
                case 'specific':
                    tx = style.textX || 0;
                    ty = style.textY || 0;
                    al = 'start';
                    bl = 'middle';
                    break;
            }

            // Smic 方法修改 -start
            if (style.labelXOffset && !isNaN(style.labelXOffset)) {
                tx += style.labelXOffset;
            }
            if (style.labelYOffset && !isNaN(style.labelYOffset)) {
                ty += style.labelYOffset;
            }
            //原代码：
            // Smic 方法修改 -end

            if (tx != null && ty != null) {
                Shape._fillText(ctx, style.text, tx, ty, style.textFont, style.textAlign || al, style.textBaseline || bl);
            }
        }

        /**
         * Method: modSelf
         * 图形发生改变
         */

    }, {
        key: 'modSelf',
        value: function modSelf() {
            this.__dirty = true;
            if (this.style) {
                this.style.__rect = null;
            }
            if (this.highlightStyle) {
                this.highlightStyle.__rect = null;
            }
        }

        /**
         * APIMethod: isSilent
         * 图形是否会触发事件，通过 bind 绑定的事件
         */

    }, {
        key: 'isSilent',
        value: function isSilent() {
            return !(this.hoverable || this.draggable || this.clickable || this.onmousemove || this.onmouseover || this.onmouseout || this.onmousedown || this.onmouseup || this.onclick || this.ondragenter || this.ondragover || this.ondragleave || this.ondrop);
        }

        /**
         * Method: setCtxGlobalAlpha
         * 设置 Cavans 上下文全局透明度
         *
         * Parameters:
         * _ctx - {Object} Cavans 上下文
         * type - {String} one of 'stroke' 'fill' or 'reset'
         * style - {Object} Symbolizer hash
         */

    }, {
        key: 'setCtxGlobalAlpha',
        value: function setCtxGlobalAlpha(_ctx, type, style) {
            if (type === "fill") {
                _ctx.globalAlpha = typeof style["fillOpacity"] === "undefined" ? typeof style["opacity"] === "undefined" ? 1 : style['opacity'] : style['fillOpacity'];
            } else if (type === "stroke") {
                _ctx.globalAlpha = typeof style["strokeOpacity"] === "undefined" ? typeof style["opacity"] === "undefined" ? 1 : style['opacity'] : style['strokeOpacity'];
            } else {
                _ctx.globalAlpha = typeof style["opacity"] === "undefined" ? 1 : style['opacity'];
            }
        }

        /**
         * Method: SuperMap.LevelRenderer.Shape._fillText
         * 填充文本
         */

    }], [{
        key: '_fillText',
        value: function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
            if (textFont) {
                ctx.font = textFont;
            }
            ctx.textAlign = textAlign;
            ctx.textBaseline = textBaseline;
            var rect = Shape._getTextRect(text, x, y, textFont, textAlign, textBaseline);

            text = (text + '').split('\n');

            var lineHeight = _SUtil.SUtil.Util_area.getTextHeight('ZH', textFont);

            switch (textBaseline) {
                case 'top':
                    y = rect.y;
                    break;
                case 'bottom':
                    y = rect.y + lineHeight;
                    break;
                default:
                    y = rect.y + lineHeight / 2;
            }

            for (var i = 0, l = text.length; i < l; i++) {
                ctx.fillText(text[i], x, y);
                y += lineHeight;
            }
        }

        /**
         * Method: SuperMap.LevelRenderer.Shape._getTextRect
         * 返回矩形区域，用于局部刷新和文字定位
         *
         * Parameters:
         * text - {String} text。
         * x - {Number} x。
         * y - {Number} y。
         * textFont - {String} textFont。
         * textAlign - {String} textAlign。
         * textBaseline - {String} textBaseline。
         *
         * Returns:
         * {Object} 矩形区域。
         */

    }, {
        key: '_getTextRect',
        value: function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
            var width = _SUtil.SUtil.Util_area.getTextWidth(text, textFont);
            var lineHeight = _SUtil.SUtil.Util_area.getTextHeight('ZH', textFont);

            text = (text + '').split('\n');

            switch (textAlign) {
                case 'end':
                case 'right':
                    x -= width;
                    break;
                case 'center':
                    x -= width / 2;
                    break;
            }

            switch (textBaseline) {
                case 'top':
                    break;
                case 'bottom':
                    y -= lineHeight * text.length;
                    break;
                default:
                    y -= lineHeight * text.length / 2;
            }

            return {
                x: x,
                y: y,
                width: width,
                height: lineHeight * text.length
            };
        }
    }]);

    return Shape;
}(_SuperMap.SuperMap.mixin(_Eventful.Eventful, _Transformable.Transformable));

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeoJSON = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Vector = __webpack_require__(64);

var _Util = __webpack_require__(1);

var _Bounds = __webpack_require__(22);

var _Collection = __webpack_require__(27);

var _JSON = __webpack_require__(93);

var _Point = __webpack_require__(18);

var _MultiPoint = __webpack_require__(38);

var _LineString = __webpack_require__(17);

var _MultiLineString = __webpack_require__(47);

var _LinearRing = __webpack_require__(31);

var _Polygon = __webpack_require__(49);

var _MultiPolygon = __webpack_require__(48);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Format.GeoJSON
 * @classdesc  GeoJSON 的读和写。使用 <SuperMap.Format.GeoJSON> 构造器创建一个GeoJSON解析器。
 * @extends SuperMap.Format.JSON。
 */
var GeoJSON = exports.GeoJSON = function (_JSONFormat) {
    _inherits(GeoJSON, _JSONFormat);

    function GeoJSON(options) {
        _classCallCheck(this, GeoJSON);

        /**
         * @member SuperMap.Format.GeoJSON.prototype.ignoreExtraDims - {boolean}
         * @description 忽略维度超过2的几何要素。
         */
        var _this = _possibleConstructorReturn(this, (GeoJSON.__proto__ || Object.getPrototypeOf(GeoJSON)).call(this, options));

        _this.ignoreExtraDims = false;

        _this.CLASS_NAME = "SuperMap.Format.GeoJSON";
        /**
         * @member SuperMap.Format.GeoJSON.prototype.parseCoords - {Object}
         * @description 一个属性名对应着GeoJSON对象的几何类型的对象。每个属性其实都是一个实际上做解析用的方法。
         */
        _this.parseCoords = {
            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.point
             * @description 将一组坐标成一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的一组坐标。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "point": function point(array) {
                if (this.ignoreExtraDims == false && array.length != 2) {
                    throw "Only 2D points are supported: " + array;
                }
                return new _Point.Point(array[0], array[1]);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.multipoint
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "multipoint": function multipoint(array) {
                var points = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["point"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    points.push(p);
                }
                return new _MultiPoint.MultiPoint(points);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.linestring
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "linestring": function linestring(array) {
                var points = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["point"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    points.push(p);
                }
                return new _LineString.LineString(points);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.multilinestring
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "multilinestring": function multilinestring(array) {
                var lines = [];
                var l = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        l = this.parseCoords["linestring"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    lines.push(l);
                }
                return new _MultiLineString.MultiLineString(lines);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.polygon
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "polygon": function polygon(array) {
                var rings = [];
                var r, l;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        l = this.parseCoords["linestring"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    r = new _LinearRing.LinearRing(l.components);
                    rings.push(r);
                }
                return new _Polygon.Polygon(rings);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.multipolygon
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "multipolygon": function multipolygon(array) {
                var polys = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["polygon"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    polys.push(p);
                }
                return new _MultiPolygon.MultiPolygon(polys);
            },

            /**
             * @function SuperMap.Format.GeoJSON.parseCoords.box
             * @description 将坐标组数组转化成为一个<SuperMap.Geometry>对象。
             * @param array - {Object} GeoJSON片段中的坐标组数组。
             * @return {SuperMap.Geometry} 一个几何对象。
             */
            "box": function box(array) {
                if (array.length != 2) {
                    throw "GeoJSON box coordinates must have 2 elements";
                }
                return new _Polygon.Polygon([new _LinearRing.LinearRing([new _Point.Point(array[0][0], array[0][1]), new _Point.Point(array[1][0], array[0][1]), new _Point.Point(array[1][0], array[1][1]), new _Point.Point(array[0][0], array[1][1]), new _Point.Point(array[0][0], array[0][1])])]);
            }

        };
        /**
         * Property: extract
         * 一个属性名对应着GeoJSON类型的对象。其值为相应的实际的解析方法。
         */
        _this.extract = {
            /**
             * @function SuperMap.Format.GeoJSON.extract.feature
             * @description 返回一个表示单个要素对象的GeoJSON的一部分。
             * @param feature - iServer要素对象
             * @return {Object} 一个表示点的对象。
             */
            'feature': function feature(_feature) {
                var geom = this.extract.geometry.apply(this, [_feature.geometry]);
                var json = {
                    "type": "Feature",
                    "properties": this.createAttributes(_feature),
                    "geometry": geom
                };

                if (_feature.geometry && _feature.geometry.type === 'TEXT') {
                    json.properties.texts = _feature.geometry.texts;
                    json.properties.textStyle = _feature.geometry.textStyle;
                }
                if (_feature.fid !== null) {
                    json.id = _feature.fid;
                }
                if (_feature.ID !== null) {
                    json.id = _feature.ID;
                }
                return json;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.geometry
             * @description 返回一个表示单个几何对象的GeoJSON的一部分。
             * @param geometry -iServer 几何对象
             * @return {Object} 一个表示几何体的对象。
             */
            'geometry': function geometry(_geometry) {
                if (_geometry == null) {
                    return null;
                }
                var geo = this.toGeometry(_geometry);
                var geometryType = geo.type;
                var data = this.extract[geometryType.toLowerCase()].apply(this, [geo]);
                geometryType = geometryType === 'TEXT' ? 'Point' : geometryType;
                var json;
                if (geometryType === "Collection") {
                    json = {
                        "type": "GeometryCollection",
                        "geometries": data
                    };
                } else {
                    json = {
                        "type": geometryType,
                        "coordinates": data
                    };
                }
                return json;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.point
             * @description 从一个点对象中返回一个坐标组。
             * @param point - {SuperMap.Geometry.Point} 一个点对象。
             * @return {Array} 一个表示一个点的坐标组。
             */
            'point': function point(_point) {
                var p = [_point.x, _point.y];
                for (var name in _point) {
                    if (name !== "x" && name !== "y" && !isNaN(_point[name])) {
                        p.push(_point[name]);
                    }
                }
                return p;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.point
             * @description 从一个文本对象中返回一个坐标组。
             * @param geo 一个文本对象。
             * @return {Array} 一个表示一个点的坐标组。
             */
            'text': function text(geo) {
                return [geo.points[0].x, geo.points[0].y];
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.multipoint
             * @description 从一个多点对象中返一个坐标组数组。
             * @param multipoint - {SuperMap.Geometry.MultiPoint} 多点对象。
             * @return {Array} 一个表示多点的坐标组数组。
             */
            'multipoint': function multipoint(_multipoint) {
                var array = [];
                for (var i = 0, len = _multipoint.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [_multipoint.components[i]]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.linestring
             * @description 从一个线对象中返回一个坐标组数组。
             * @param linestring - {SuperMap.Geometry.Linestring} 线对象。
             * @return {Array} 一个表示线对象的坐标组数组。
             */
            'linestring': function linestring(_linestring) {
                var array = [];
                for (var i = 0, len = _linestring.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [_linestring.components[i]]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.multilinestring
             * @description 从一个多线对象中返回一个线数组。
             * @param multilinestring - {SuperMap.Geometry.MultiLinestring} 多线对象
             *
             * @return {Array} 一个表示多线的线数组。
             */
            'multilinestring': function multilinestring(_multilinestring) {
                var array = [];
                for (var i = 0, len = _multilinestring.components.length; i < len; ++i) {
                    array.push(this.extract.linestring.apply(this, [{ components: _multilinestring.components[i] }]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.polygon
             * @description 从一个面对象中返回一组线环。
             * @polygon - {SuperMap.Geometry.Polygon} 面对象。
             * @return {Array} 一组表示面的线环。
             */
            'polygon': function polygon(_polygon) {
                var array = [];
                for (var i = 0, len = _polygon.components.length; i < len; ++i) {
                    array.push(this.extract.linestring.apply(this, [{ components: _polygon.components[i] }]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.multipolygon
             * @description 从一个多面对象中返回一组面。
             * @param multipolygon - {SuperMap.Geometry.MultiPolygon} 多面对象。
             * @return {Array} 一组表示多面的面。
             */
            'multipolygon': function multipolygon(_multipolygon) {
                var array = [];
                for (var i = 0, len = _multipolygon.components.length; i < len; ++i) {
                    array.push(this.extract.polygon.apply(this, [{ components: _multipolygon.components[i] }]));
                }
                return array;
            },

            /**
             * @function SuperMap.Format.GeoJSON.extract.collection
             * @description 从一个几何要素集合中一组几何要素数组。
             * @param collection - {SuperMap.Geometry.Collection} 几何要素集合。
             * @return {Array} 一组表示几何要素集合的几何要素数组。
             */
            'collection': function collection(_collection) {
                var len = _collection.components.length;
                var array = new Array(len);
                for (var i = 0; i < len; ++i) {
                    array[i] = this.extract.geometry.apply(this, [{
                        type: "Collection",
                        components: _collection.components[i]
                    }]);
                }
                return array;
            }
        };
        return _this;
    }

    /**
     * @function SuperMap.Format.GeoJSON.prototype.read
     * @description 反序列化一个 GeoJSON 字符串。
     * @param json - {string}  GeoJSON 字符串
     * @param type - {string} 可选的字符串，它决定了输出的格式。
     *     支持的值有："Geometry","Feature",和"FeatureCollection",
     *     如果此值为null，则会使用默认值"FeaureCollection"。
     * @param filter - {function} 对象中每个层次每个键值对都会调用此函数得出一个结果。
     *     每个值都会被filter函数的结果所替换掉。这个函数可被用来将某些对象转化成
     *     某个类相应的对象，或者将日期字符串转化成Date对象。
     *
     * @return {Object}    返回值依赖于type参数的值。<br>
     *     如果type等于"FeatureCollection"（默认值），返回值将会是 <SuperMap.Feature.Vector> 数组。<br>
     *     如果type为"Geometry",输入的json对象必须表示一个唯一的几何体，然后返回值就会是 <SuperMap.Feature.Geometry>。 <br>
     *     如果type为"Feature"，输入的json对象也必须表示的一个要素，这样返回值才会是<SuperMap.Feature.Vector> 。
     */


    _createClass(GeoJSON, [{
        key: 'read',
        value: function read(json, type, filter) {
            type = type ? type : "FeatureCollection";
            var results = null;
            var obj = null;
            if (typeof json == "string") {
                obj = _get(GeoJSON.prototype.__proto__ || Object.getPrototypeOf(GeoJSON.prototype), 'read', this).call(this, json, filter);
            } else {
                obj = json;
            }
            if (!obj) {
                //SuperMap.Console.error("Bad JSON: " + json);
            } else if (typeof obj.type != "string") {
                //SuperMap.Console.error("Bad GeoJSON - no type: " + json);
            } else if (this.isValidType(obj, type)) {
                switch (type) {
                    case "Geometry":
                        try {
                            results = this.parseGeometry(obj);
                        } catch (err) {
                            //SuperMap.Console.error(err);
                        }
                        break;
                    case "Feature":
                        try {
                            results = this.parseFeature(obj);
                            results.type = "Feature";
                        } catch (err) {
                            //SuperMap.Console.error(err);
                        }
                        break;
                    case "FeatureCollection":
                        // for type FeatureCollection, we allow input to be any type
                        results = [];
                        switch (obj.type) {
                            case "Feature":
                                try {
                                    results.push(this.parseFeature(obj));
                                } catch (err) {
                                    results = null;
                                    //SuperMap.Console.error(err);
                                }
                                break;
                            case "FeatureCollection":
                                for (var i = 0, len = obj.features.length; i < len; ++i) {
                                    try {
                                        results.push(this.parseFeature(obj.features[i]));
                                    } catch (err) {
                                        results = null;
                                        // SuperMap.Console.error(err);
                                    }
                                }
                                break;
                            default:
                                try {
                                    var geom = this.parseGeometry(obj);
                                    results.push(new _Vector.Vector(geom));
                                } catch (err) {
                                    results = null;
                                    //SuperMap.Console.error(err);
                                }
                        }
                        break;
                    default:
                        break;
                }
            }
            return results;
        }

        /**
         *  @function SuperMap.Format.GeoJSON.prototype.isValidType
         *  @description 检查一个GeoJSON对象是否和给定的类型相符的合法的对象。
         *  @return {boolean} GeoJSON是否是给定类型的合法对象。
         */

    }, {
        key: 'isValidType',
        value: function isValidType(obj, type) {
            var valid = false;
            switch (type) {
                case "Geometry":
                    if (_Util.Util.indexOf(["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "Box", "GeometryCollection"], obj.type) == -1) {
                        // unsupported geometry type
                        //SuperMap.Console.error("Unsupported geometry type: " +
                        // obj.type);
                    } else {
                        valid = true;
                    }
                    break;
                case "FeatureCollection":
                    // allow for any type to be converted to a feature collection
                    valid = true;
                    break;
                default:
                    // for Feature types must match
                    if (obj.type == type) {
                        valid = true;
                    } else {
                        //SuperMap.Console.error("Cannot convert types from " +
                        //obj.type + " to " + type);
                    }
            }
            return valid;
        }

        /**
         * @function SuperMap.Format.GeoJSON.prototype.parseFeature
         * @description 将一个GeoJSON中的feature转化成<SuperMap.Feature.Vector>对象。
         * @param obj - {Object} 从GeoJSON对象中创建一个对象。
         * @return {SuperMap.Feature.Vector} 一个要素。
         */

    }, {
        key: 'parseFeature',
        value: function parseFeature(obj) {
            var feature, geometry, attributes, bbox;
            attributes = obj.properties ? obj.properties : {};
            bbox = obj.geometry && obj.geometry.bbox || obj.bbox;
            try {
                geometry = this.parseGeometry(obj.geometry);
            } catch (err) {
                // deal with bad geometries
                throw err;
            }
            feature = new _Vector.Vector(geometry, attributes);
            if (bbox) {
                feature.bounds = _Bounds.Bounds.fromArray(bbox);
            }
            if (obj.id) {
                feature.fid = obj.id;
            }
            return feature;
        }

        /**
         * @function SuperMap.Format.GeoJSON.prototype.parseGeometry
         * @description 将一个GeoJSON中的几何要素转化成<SuperMap.Geometry>对象。
         * @param obj - {Object} 从GeoJSON对象中创建一个对象。
         * @return {SuperMap.Geometry} 一个几何要素。
         */

    }, {
        key: 'parseGeometry',
        value: function parseGeometry(obj) {
            if (obj == null) {
                return null;
            }
            var geometry;
            if (obj.type == "GeometryCollection") {
                if (!_Util.Util.isArray(obj.geometries)) {
                    throw "GeometryCollection must have geometries array: " + obj;
                }
                var numGeom = obj.geometries.length;
                var components = new Array(numGeom);
                for (var i = 0; i < numGeom; ++i) {
                    components[i] = this.parseGeometry.apply(this, [obj.geometries[i]]);
                }
                geometry = new _Collection.Collection(components);
            } else {
                if (!_Util.Util.isArray(obj.coordinates)) {
                    throw "Geometry must have coordinates array: " + obj;
                }
                if (!this.parseCoords[obj.type.toLowerCase()]) {
                    throw "Unsupported geometry type: " + obj.type;
                }
                try {
                    geometry = this.parseCoords[obj.type.toLowerCase()].apply(this, [obj.coordinates]);
                } catch (err) {
                    // deal with bad coordinates
                    throw err;
                }
            }
            return geometry;
        }

        /**
         * @function SuperMap.Format.GeoJSON.write
         * @description 序列化一个要素对象，几何对象，要素对象数组为一个GeoJSON字符串。
         * @param obj - {Object} 一个 <SuperMap.Feature.Vector> 对象，一个 <SuperMap.Geometry> 对象或者一个要素对象数组。
         * @param pretty - {boolean} 是否使用换行和缩进来控制输出。默认值为false。
         * @return {string} 一个GeoJSON字符串，它表示了输入的几何对象，要素对象，或者要素对象数组。
         */

    }, {
        key: 'write',
        value: function write(obj, pretty) {
            var geojson = {
                "type": null
            };
            if (_Util.Util.isArray(obj)) {
                geojson.type = "FeatureCollection";
                var numFeatures = obj.length;
                geojson.features = new Array(numFeatures);
                for (var i = 0; i < numFeatures; ++i) {
                    var element = obj[i];
                    if (isGeometry(element)) {
                        var feature = {};
                        feature.geometry = element;
                        geojson.features[i] = this.extract.feature.apply(this, [feature]);
                    } else {
                        geojson.features[i] = this.extract.feature.apply(this, [element]);
                    }
                }
            } else if (isGeometry(obj)) {
                var _feature2 = {};
                _feature2.geometry = obj;
                geojson = this.extract.feature.apply(this, [_feature2]);
            }

            function isGeometry(input) {
                return input.hasOwnProperty("parts") && input.hasOwnProperty("points");
            }

            return _get(GeoJSON.prototype.__proto__ || Object.getPrototypeOf(GeoJSON.prototype), 'write', this).call(this, geojson, pretty);
        }

        /**
         * @function SuperMap.Format.GeoJSON.createCRSObject
         * @description 从一个要素对象中创建一个坐标参考系对象。
         * @param object - {SuperMap.Feature.Vector} 要素对象
         * @return {Object} 一个可作为GeoJSON对象的crs属性使用的对象。
         */

    }, {
        key: 'createCRSObject',
        value: function createCRSObject(object) {
            var proj = object.layer.projection.toString();
            var crs = {};
            if (proj.match(/epsg:/i)) {
                var code = parseInt(proj.substring(proj.indexOf(":") + 1));
                if (code == 4326) {
                    crs = {
                        "type": "name",
                        "properties": {
                            "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                        }
                    };
                } else {
                    crs = {
                        "type": "name",
                        "properties": {
                            "name": "EPSG:" + code
                        }
                    };
                }
            }
            return crs;
        }
    }, {
        key: 'createAttributes',
        value: function createAttributes(feature) {
            if (!feature) {
                return null;
            }
            var attr = {};
            processFieldsAttributes(feature, attr);
            var exceptKeys = ["fieldNames", "fieldValues", "geometry"];
            for (var key in feature) {
                if (exceptKeys.indexOf(key) > -1) {
                    continue;
                }
                attr[key] = feature[key];
            }

            function processFieldsAttributes(feature, attributes) {
                if (!(feature.hasOwnProperty("fieldNames") && feature.hasOwnProperty("fieldValues"))) {
                    return;
                }
                var names = feature.fieldNames,
                    values = feature.fieldValues;
                for (var i in names) {
                    attributes[names[i]] = values[i];
                }
            }

            return attr;
        }
    }, {
        key: 'toGeometry',
        value: function toGeometry(geometry) {
            var me = this,
                geoType = geometry.type;
            if (geoType === 'polygon') {
                geoType = _REST.GeometryType.REGION;
            }
            switch (geoType.toUpperCase()) {
                case _REST.GeometryType.POINT:
                    return me.toGeoPoint(geometry);
                case _REST.GeometryType.LINE:
                    return me.toGeoLine(geometry);
                case _REST.GeometryType.LINEM:
                    return me.toGeoLinem(geometry);
                case _REST.GeometryType.REGION:
                    return me.toGeoRegion(geometry);
                case _REST.GeometryType.POINTEPS:
                    return me.toGeoPoint(geometry);
                // case GeometryType.LINEEPS:
                //     return me.toGeoLineEPS();
                // case GeometryType.REGIONEPS:
                //     return me.toGeoRegionEPS();
                default:
                    return geometry;
            }
        }

        /**
         * @function SuperMap.Format.GeoJSON.toGeoPoint
         * @description 将服务端的点几何对象转换为几何对象
         */

    }, {
        key: 'toGeoPoint',
        value: function toGeoPoint(geometry) {
            var geoPoints = geometry.points || [{ x: geometry.x, y: geometry.y }],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length;
            if (len < 1) {
                return null;
            }
            if (len === 1) {
                return { type: "Point", x: parseFloat(geoPoints[0].x), y: parseFloat(geoPoints[0].y) };
            } else {
                for (var i = 0, pointList = []; i < len; i++) {
                    pointList.push({ x: parseFloat(geoPoints[i].x), y: parseFloat(geoPoints[i].y) });
                }
                return { type: "MultiPoint", components: pointList };
            }
        }

        /**
         *
         * @function SuperMap.Format.GeoJSON.toGeoPoint
         * @description 将服务端的线几何对象转换为几何对象。
         */

    }, {
        key: 'toGeoLine',
        value: function toGeoLine(geometry) {
            var me = this,
                geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length;
            if (len < 1) {
                return null;
            }
            if (len === 1) {
                for (var i = 0, pointList = []; i < geoParts[0]; i++) {
                    pointList.push({ x: parseFloat(geoPoints[i].x), y: parseFloat(geoPoints[i].y) });
                }
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (me.isPointsEquals(pointList[0], pointList[geoParts[0] - 1])) {
                    pointList.pop();
                    pointList.push(pointList[0]);
                }
                return { type: "LineString", components: pointList };
            } else {
                for (var k = 0, lineList = []; k < len; k++) {
                    for (var j = 0, pointArr = []; j < geoParts[k]; j++) {
                        pointArr.push({ x: parseFloat(geoPoints[j].x), y: parseFloat(geoPoints[j].y) });
                    }
                    lineList.push(pointArr);
                    geoPoints.splice(0, geoParts[k]);
                }
                return { type: "MultiLineString", components: lineList };
            }
        }

        /**
         *
         * @function SuperMap.Format.GeoJSON.toGeoLinem
         * @description 将服务端的路由线几何对象转换为几何对象。
         */

    }, {
        key: 'toGeoLinem',
        value: function toGeoLinem(geometry) {
            var me = this,
                geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length,
                lineList = [];
            if (len < 1) {
                return null;
            }
            for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                for (var j = 0; j < geoParts[i]; j++) {
                    pointList.push({
                        x: parseFloat(geoPoints[pointIndex + j].x),
                        y: parseFloat(geoPoints[pointIndex + j].y),
                        measure: parseFloat(geoPoints[pointIndex + j].measure)
                    });
                }
                pointIndex += geoParts[i];
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (me.isPointsEquals(pointList[0], pointList[geoParts[0] - 1])) {
                    pointList.pop();
                    pointList.push(pointList[0]);
                }
                lineList.push(pointList);
                pointList = [];
            }
            return { type: "MultiLineString", components: lineList };
        }

        /**
         *
         * @function SuperMap.Format.GeoJSON.toGeoRegion
         * @description 将服务端的面几何对象转换为几何对象。
         */

    }, {
        key: 'toGeoRegion',
        value: function toGeoRegion(geometry) {
            var CCWArray = [],
                geoPoints = geometry.points || [],
                geoParts = geometry.parts || [geoPoints.length],
                len = geoParts.length;
            if (len < 1) {
                return null;
            }
            var polygonArray = new Array();
            for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                for (var j = 0; j < geoParts[i]; j++) {
                    pointList.push({
                        x: parseFloat(geoPoints[pointIndex + j].x),
                        y: parseFloat(geoPoints[pointIndex + j].y)
                    });
                }

                pointIndex += geoParts[i];
                var linearRing = pointList.concat();
                linearRing.pop();
                linearRing.push(linearRing[0]);

                if (this.isClockWise(linearRing) > 0) {
                    CCWArray.push(linearRing);
                } else {
                    polygonArray.push([linearRing]);
                }

                if (i === len - 1) {
                    var polyLength = polygonArray.length;
                    if (polyLength) {
                        polygonArray[polyLength - 1] = polygonArray[polyLength - 1].concat(CCWArray);
                    } else {
                        for (var k = 0, length = CCWArray.length; k < length; k++) {
                            polygonArray.push([CCWArray[k]].concat());
                        }
                    }
                }
                pointList = [];
            }
            return { type: "MultiPolygon", components: polygonArray };
        }
    }, {
        key: 'isClockWise',
        value: function isClockWise(points) {
            var length = points.length;
            if (length < 3) {
                return 0.0;
            }
            var s = points[0].y * (points[length - 1].x - points[1].x);
            points.push(points[0]);
            for (var i = 1; i < length; i++) {
                s += points[i].y * (points[i - 1].x - points[i + 1].x);
            }
            return s * 0.5;
        }
    }, {
        key: 'isPointsEquals',
        value: function isPointsEquals(point1, point2) {
            return point1.x === point2.x && point1.y === point2.y;
        }
    }]);

    return GeoJSON;
}(_JSON.JSONFormat);

_SuperMap.SuperMap.Format.GeoJSON = GeoJSON;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NetworkAnalystServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _CommonServiceBase2 = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.NetworkAnalystServiceBase
 * @classdesc 网络分析服务基类。
 * @description 网络分析服务基类。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址
 * @param options - {Object} 网络分析可选参数。如：<br>
 *        format - {{@link SuperMap.DataFormat}} 查询结果返回格式
 *
 */
var NetworkAnalystServiceBase = exports.NetworkAnalystServiceBase = function (_CommonServiceBase) {
    _inherits(NetworkAnalystServiceBase, _CommonServiceBase);

    function NetworkAnalystServiceBase(url, options) {
        _classCallCheck(this, NetworkAnalystServiceBase);

        /**
         * @member SuperMap.NetworkAnalystServiceBase.prototype.format -{SuperMap.DataFormat}
         * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
         *              参数格式为"ISERVER","GEOJSON"
         * @default "GEOJSON"
         */
        var _this = _possibleConstructorReturn(this, (NetworkAnalystServiceBase.__proto__ || Object.getPrototypeOf(NetworkAnalystServiceBase)).call(this, url, options));

        _this.format = _REST.DataFormat.GEOJSON;

        _this.CLASS_NAME = "SuperMap.NetworkAnalystServiceBase";
        return _this;
    }

    /**
     * @function SuperMap.NetworkAnalystServiceBase.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */


    _createClass(NetworkAnalystServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(NetworkAnalystServiceBase.prototype.__proto__ || Object.getPrototypeOf(NetworkAnalystServiceBase.prototype), 'destroy', this).call(this);
            this.format = null;
        }

        /**
         * @function SuperMap.NetworkAnalystServiceBase.prototype.serviceProcessCompleted
         * @description 分析完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this,
                analystResult;
            result = _Util.Util.transformResult(result);
            if (result && me.format === _REST.DataFormat.GEOJSON && typeof me.toGeoJSONResult === 'function') {
                analystResult = me.toGeoJSONResult(result);
            }
            if (!analystResult) {
                analystResult = result;
            }
            me.events.triggerEvent("processCompleted", { result: analystResult });
        }

        /**
         * @function SuperMap.NetworkAnalystServiceBase.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。只处理结果中的路由，由子类实现
         * @param result - {Object} 服务器返回的结果对象。
         * @return{Object} geojson对象
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            // eslint-disable-line no-unused-vars
            return null;
        }
    }]);

    return NetworkAnalystServiceBase;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.NetworkAnalystServiceBase = NetworkAnalystServiceBase;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(66);

__webpack_require__(207);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FilterParameter
 * @classdesc 查询过滤条件参数类。该类用于设置查询数据集的查询过滤参数。
 * @param options - {Object} 可选参数。如:<br>
 *        attributeFilter - {string} 属性过滤条件。</br>
 *        name - {string} 查询数据集名称或者图层名称。</br>
 *        joinItems - {Array<{@link SuperMap.JoinItem}>} 与外部表的连接信息 SuperMap.JoinItem 数组。</br>
 *        linkItems - {Array<{@link SuperMap.LinkItem}>} 与外部表的关联信息 SuperMap.LinkItem 数组。</br>
 *        ids - {Array<string>} 查询 id 数组，即属性表中的 SmID 值。</br>
 *        orderBy - {string} 查询排序的字段, orderBy 的字段须为数值型的。</br>
 *        groupBy - {string} 查询分组条件的字段。</br>
 *        fields - {Array<string>} 查询字段数组。</br>
 */
var FilterParameter = exports.FilterParameter = function () {
  function FilterParameter(options) {
    _classCallCheck(this, FilterParameter);

    /**
     * @member SuperMap.FilterParameter.prototype.attributeFilter - {string}
     * @description 属性过滤条件。
     * 相当于 SQL 语句中的 WHERE 子句，其格式为：WHERE <条件表达式>，
     * attributeFilter 就是其中的“条件表达式”。
     * 该字段的用法为 attributeFilter = "过滤条件"。
     * 例如，要查询字段 fieldValue 小于100的记录，设置 attributeFilter = "fieldValue < 100"；
     * 要查询字段 name 的值为“酒店”的记录，设置 attributeFilter = "name like '%酒店%'"，等等。
     */
    this.attributeFilter = null;

    /**
     * @member SuperMap.FilterParameter.prototype.name - {string}
     * @description 查询数据集名称或者图层名称，根据实际的查询对象而定，必设属性。
     * 一般情况下该字段为数据集名称，但在进行与地图相关功能的操作时，
     * 需要设置为图层名称（图层名称格式：数据集名称@数据源别名）。
     * 因为一个地图的图层可能是来自于不同数据源的数据集，
     * 而不同的数据源中可能存在同名的数据集，
     * 使用数据集名称不能唯一的确定数据集，
     * 所以在进行与地图相关功能的操作时，该值需要设置为图层名称。
     */
    this.name = null;

    /**
     * @member SuperMap.FilterParameter.prototype.joinItems - {Array<SuperMap.JoinItem>}
     * @description 与外部表的连接信息 SuperMap.JoinItem 数组。
     */
    this.joinItems = null;

    /**
     * @member SuperMap.FilterParameter.prototype.linkItems - {Array<SuperMap.LinkItem>}
     * @description 与外部表的关联信息 LinkItem 数组。
     */
    this.linkItems = null;

    /**
     * @member SuperMap.FilterParameter.prototype.ids -{Array<string>}
     * @description 查询 id 数组，即属性表中的 SmID 值。
     */
    this.ids = null;

    /**
     * @member SuperMap.FilterParameter.prototype.orderBy - {string}
     * @description 查询排序的字段,orderBy的字段须为数值型的。
     * 相当于 SQL 语句中的 ORDER BY 子句，其格式为：ORDER BY <列名>，
     * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。
     * 对单个字段排序时，该字段的用法为 orderBy = "字段名"；
     * 对多个字段排序时，字段之间以英文逗号进行分割，用法为 orderBy = "字段名1, 字段名2"。
     * 例如，现有一个国家数据集，它有两个字段分别为“SmArea”和“pop_1994”，
     * 分别表示国家的面积和1994年的各国人口数量。
     * 如果要按照各国人口数量对记录进行排序，则 orderBy = "pop_1994"；
     * 如果要以面积和人口进行排序，则 orderBy = "SmArea, pop_1994"。
     */
    this.orderBy = null;

    /**
     * @member SuperMap.FilterParameter.prototype.groupBy - {string}
     * @description 查询分组条件的字段。
     * 相当于 SQL 语句中的 GROUP BY 子句，其格式为：GROUP BY <列名>，
     * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。
     * 对单个字段分组时，该字段的用法为 groupBy = "字段名"；
     * 对多个字段分组时，字段之间以英文逗号进行分割，用法为 groupBy = "字段名1, 字段名2"。
     * 例如，现有一个全球城市数据集，该数据集有两个字段分别为“Continent”和“Country”，
     * 分别表示某个城市所属的洲和国家。
     * 如果要按照国家对全球的城市进行分组， 可以设置 groupBy = "Country"；
     * 如果以洲和国家对城市进行分组，设置 groupBy = "Continent, Country"。
     */
    this.groupBy = null;

    /**
     * @member SuperMap.FilterParameter.prototype.fields - {Array<string>}
     * @description 查询字段数组，如果不设置则使用系统返回的所有字段。
     */
    this.fields = null;
    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.FilterParameter";
  }

  /**
   * @function SuperMap.FilterParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FilterParameter, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.attributeFilter = null;
      me.name = null;
      if (me.joinItems) {
        for (var i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
          joinItems[i].destroy();
        }
        me.joinItems = null;
      }
      if (me.linkItems) {
        for (var _i = 0, linkItems = me.linkItems, _len = linkItems.length; _i < _len; _i++) {
          linkItems[_i].destroy();
        }
        me.linkItems = null;
      }
      me.ids = null;
      me.orderBy = null;
      me.groupBy = null;
      me.fields = null;
    }
  }]);

  return FilterParameter;
}();

_SuperMap.SuperMap.FilterParameter = FilterParameter;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineString = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Point = __webpack_require__(18);

var _Curve2 = __webpack_require__(90);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.LineString
 * @classdesc 几何对象线串类。
 * @param points - {Array<SuperMap.Geometry.Point>} 用来生成线串的点数组。
 * @extends {SuperMap.Geometry.Curve}
 *
 * @example
 * var points = [new SuperMap.Geometry.Point(4933.319287022352, -3337.3849141502124),
 *     new SuperMap.Geometry.Point(4960.9674060199022, -3349.3316322355736),
 *     new SuperMap.Geometry.Point(5006.0235999418364, -3358.8890067038628),
 *     new SuperMap.Geometry.Point(5075.3145648369318, -3378.0037556404409),
 *     new SuperMap.Geometry.Point(5305.19551436013, -3376.9669111768926)],
 * var roadLine = new SuperMap.Geometry.LineString(points)；
 */
var LineString = exports.LineString = function (_Curve) {
    _inherits(LineString, _Curve);

    function LineString(points) {
        _classCallCheck(this, LineString);

        var _this = _possibleConstructorReturn(this, (LineString.__proto__ || Object.getPrototypeOf(LineString)).call(this, points));

        _this.CLASS_NAME = "SuperMap.Geometry.LineString";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.LineString.prototype.removeComponent
     * @description 只有在线串上有三个或更多的点的时候，才会允许移除点（否则结果将会是单一的点）。
     * @param point - {SuperMap.Geometry.Point} 将被删除的点。
     * @returns {Boolean} 删除的点。
     */


    _createClass(LineString, [{
        key: 'removeComponent',
        value: function removeComponent(point) {
            // eslint-disable-line no-unused-vars
            var removed = this.components && this.components.length > 2;
            if (removed) {
                _get(LineString.prototype.__proto__ || Object.getPrototypeOf(LineString.prototype), 'removeComponent', this).apply(this, arguments);
            }
            return removed;
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.getSortedSegments
         * @returns {Array} An array of segment objects.  Segment objects have properties
         *     x1 y1 x2 and y2.  The start point is represented by x1 and y1.
         *     The end point is represented by x2 and y2.  Start and end are
         *     ordered so that x1 < x2.
         */

    }, {
        key: 'getSortedSegments',
        value: function getSortedSegments() {
            var numSeg = this.components.length - 1;
            var segments = new Array(numSeg),
                point1,
                point2;
            for (var i = 0; i < numSeg; ++i) {
                point1 = this.components[i];
                point2 = this.components[i + 1];
                if (point1.x < point2.x) {
                    segments[i] = {
                        x1: point1.x,
                        y1: point1.y,
                        x2: point2.x,
                        y2: point2.y
                    };
                } else {
                    segments[i] = {
                        x1: point2.x,
                        y1: point2.y,
                        x2: point1.x,
                        y2: point1.y
                    };
                }
            }

            // more efficient to define this somewhere static
            function byX1(seg1, seg2) {
                return seg1.x1 - seg2.x1;
            }

            return segments.sort(byX1);
        }

        /**
         * @function SuperMap.Geometry.LineString.prototype.getVertices
         * @description 返回几何图形的所有顶点的列表。
         * @param nodes - {Boolean} 对于线来说，仅仅返回作为端点的顶点，如果设为false，则返回非端点的顶点
         * 如果没有设置此参数，则返回所有顶点。
         * @returns {Array} 几何图形的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            var vertices;
            if (nodes === true) {
                vertices = [this.components[0], this.components[this.components.length - 1]];
            } else if (nodes === false) {
                vertices = this.components.slice(1, this.components.length - 1);
            } else {
                vertices = this.components.slice();
            }
            return vertices;
        }

        /**
         * @function SuperMap.Geometry.LineString.calculateCircle
         * @description 三点画圆弧
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @returns {Array<SuperMap.Geometry.Point>} 计算出相应的圆弧控制点。
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-5030));
         * points.push(new SuperMap.Geometry.Point(-3050));
         * points.push(new SuperMap.Geometry.Point(260));
         *
         * var circle = SuperMap.Geometry.LineString.calculateCircle(points);
         */

    }], [{
        key: 'calculateCircle',
        value: function calculateCircle(points) {
            if (points.length < 3) {
                return points;
            }
            var centerPoint = {},
                p1 = points[0],
                p2 = points[1],
                p3 = points[2];
            var R = 0,
                dStep = 0,
                direc = true,
                dRotation = 0,
                dRotationBegin = 0,
                dRotationAngle = 0,
                nSegmentCount = 72,
                circlePoints = [];

            var KTan13 = (p3.y - p1.y) / (p3.x - p1.x);
            var B13 = p3.y - KTan13 * p3.x;
            if (p3.x != p1.x && p3.y != p1.y && p2.y == KTan13 * p2.x + B13 || p3.x == p1.x && p2.x == p1.x || p3.y == p1.y && p2.y == p1.y || p3.x == p1.x && p3.y == p1.y || p3.x == p2.x && p3.y == p2.y || p1.x == p2.x && p1.y == p2.y) {
                circlePoints.push(p1);
                circlePoints.push(p2);
                circlePoints.push(p3);
            } else {
                var D = (p2.x * p2.x + p2.y * p2.y - (p1.x * p1.x + p1.y * p1.y)) * (2 * (p3.y - p1.y)) - (p3.x * p3.x + p3.y * p3.y - (p1.x * p1.x + p1.y * p1.y)) * (2 * (p2.y - p1.y));
                var E = 2 * (p2.x - p1.x) * (p3.x * p3.x + p3.y * p3.y - (p1.x * p1.x + p1.y * p1.y)) - 2 * (p3.x - p1.x) * (p2.x * p2.x + p2.y * p2.y - (p1.x * p1.x + p1.y * p1.y));
                var F = 4 * ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));
                centerPoint.x = D / F;
                centerPoint.y = E / F;
                R = Math.sqrt((p1.x - centerPoint.x) * (p1.x - centerPoint.x) + (p1.y - centerPoint.y) * (p1.y - centerPoint.y));

                var dis = (p1.x - p3.x) * (p1.x - p3.x) + (p1.y - p3.y) * (p1.y - p3.y);
                var cons = (2 * R * R - dis) / (2 * R * R);
                cons = cons >= 1 ? 1 : cons;
                cons = cons <= -1 ? -1 : cons;
                dRotationAngle = Math.acos(cons) * 180 / Math.PI;

                if (p3.x == p1.x) {
                    dRotationAngle = centerPoint.x > p1.x && p2.x > p1.x || centerPoint.x < p1.x && p2.x < p1.x ? 360 - dRotationAngle : dRotationAngle;
                } else {
                    dRotationAngle = centerPoint.y > KTan13 * centerPoint.x + B13 && p2.y > KTan13 * p2.x + B13 || centerPoint.y < KTan13 * centerPoint.x + B13 && p2.y < KTan13 * p2.x + B13 ? 360 - dRotationAngle : dRotationAngle;
                }
                dStep = dRotationAngle / 72;

                if (p3.y != p1.y) {
                    if (p3.x == p1.x) {
                        if (p3.y > p1.y) {
                            if (p2.x < p1.x) {
                                direc = false;
                            }
                        } else {
                            if (p2.x > p1.x) {
                                direc = false;
                            }
                        }
                    } else if (p3.x < p1.x) {
                        if (p2.y < KTan13 * p2.x + B13) {
                            direc = false;
                        }
                    } else {
                        if (p2.y > KTan13 * p2.x + B13) {
                            direc = false;
                        }
                    }
                } else {
                    if (p3.x > p1.x) {
                        if (p2.y > p1.y) {
                            direc = false;
                        }
                    } else {
                        if (p2.y < p1.y) {
                            direc = false;
                        }
                    }
                }

                var K10 = (p1.y - centerPoint.y) / (p1.x - centerPoint.x);
                var atan10 = K10 >= 0 ? Math.atan(K10) * 180 / Math.PI : Math.abs(Math.atan(K10) * 180 / Math.PI) + 90;

                var CY = Math.abs(centerPoint.y);
                if (p1.y == CY && CY == p3.y) {
                    if (p1.x < p3.x) {
                        atan10 = atan10 + 180;
                    }
                }

                var newPY = p1.y - centerPoint.y;
                circlePoints.push(p1);
                for (var i = 1; i < nSegmentCount; i++) {
                    dRotation = dStep * i;
                    dRotationBegin = atan10;

                    if (direc) {
                        if (newPY >= 0) {
                            if (K10 >= 0) {
                                dRotationBegin = dRotationBegin + dRotation;
                            } else {
                                dRotationBegin = 180 - (dRotationBegin - 90) + dRotation;
                            }
                        } else {
                            if (K10 > 0) {
                                dRotationBegin = dRotationBegin - 180 + dRotation;
                            } else {
                                dRotationBegin = 90 - dRotationBegin + dRotation;
                            }
                        }
                    } else {
                        if (newPY >= 0) {
                            if (K10 >= 0) {
                                dRotationBegin = dRotationBegin - dRotation;
                            } else {
                                dRotationBegin = 180 - (dRotationBegin - 90) - dRotation;
                            }
                        } else {
                            if (K10 >= 0) {
                                dRotationBegin = dRotationBegin - 180 - dRotation;
                            } else {
                                dRotationBegin = 90 - dRotationBegin - dRotation;
                            }
                        }
                    }

                    dRotationBegin = dRotationBegin * Math.PI / 180;
                    var x = centerPoint.x + R * Math.cos(dRotationBegin);
                    var y = centerPoint.y + R * Math.sin(dRotationBegin);
                    circlePoints.push(new _Point.Point(x, y));
                }
                circlePoints.push(p3);
            }
            return circlePoints;
        }

        /**
         * @function SuperMap.Geometry.LineString.createLineEPS
         * @description 根据点的类型画出不同类型的曲线
         * 点的类型有三种 LTypeArc LTypeCurve NONE
         * @param points -{Array<SuperMap.Geometry.Point>} 传入的待计算的初始点串。
         * @returns {Array<SuperMap.Geometry.Point>} 计算出相应的lineEPS控制点。
         * @example
         * var points = [];
         * points.push(new SuperMap.Geometry.Point(-5030));
         * points.push(new SuperMap.Geometry.Point(-3050"LTypeArc"));
         * points.push(new SuperMap.Geometry.Point(260));
         * points.push(new SuperMap.Geometry.Point(820));
         *
         * var lineEPS = SuperMap.Geometry.LineString.createLineEPS(points);
         */

    }, {
        key: 'createLineEPS',
        value: function createLineEPS(points) {
            var list = [],
                len = points.length;
            if (points == null || len < 2) {
                return points;
            }
            for (var i = 0; i < len;) {
                var type = points[i].type;
                if (type == 'LTypeArc') {
                    var listObj = LineString.createLineArc(list, i, len, points);
                    list = listObj[0];
                    i = listObj[1];
                } else {
                    list.push(points[i]);
                    i++;
                }
            }
            return list;
        }
    }, {
        key: 'createLineArc',
        value: function createLineArc(list, i, len, points) {
            if (i == 0) {
                var bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeArc');
                Array.prototype.push.apply(list, bezierPtsObj[0]);
                i = bezierPtsObj[1] + 1;
            } else if (i == len - 1) {
                var bezierP = [points[i - 1], points[i]],
                    bezierPts = LineString.calculateCircle(bezierP);
                Array.prototype.push.apply(list, bezierPts);
                i++;
            } else {
                var _bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeArc');
                list.pop();
                Array.prototype.push.apply(list, _bezierPtsObj[0]);
                i = _bezierPtsObj[1] + 1;
            }
            return [list, i];
        }
    }, {
        key: 'addPointEPS',
        value: function addPointEPS(points, i, len, type) {
            var bezierP = [],
                j = i + 1;
            if (i == 0) {
                Array.prototype.push.apply(bezierP, [points[i], points[i + 1]]);
            } else if (i == len - 1) {
                Array.prototype.push.apply(bezierP, [points[i - 1], points[i]]);
            } else {
                Array.prototype.push.apply(bezierP, [points[i - 1], points[i], points[i + 1]]);
            }
            var bezierPts;
            if (type == 'LTypeCurve') {
                bezierPts = LineString.calculatePointsFBZN(bezierP);
            } else if (type == 'LTypeArc') {
                bezierPts = LineString.calculateCircle(bezierP);
            }
            return [bezierPts, j];
        }
    }]);

    return LineString;
}(_Curve2.Curve);

_SuperMap.SuperMap.Geometry.LineString = LineString;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Point = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Geometry2 = __webpack_require__(26);

var _Bounds = __webpack_require__(22);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Point
 * @classdesc 点几何对象类。
 * @extends {SuperMap.Geometry}
 * @param  x - {float} x-坐标
 * @param y - {float} y-坐标
 * @param type - {string} 用来存储点的类型
 * @param tag -  {float} 用来存储额外的属性，比如差值分析中的Z值。
 * @example
 * var point = new SuperMap.Geometry.Point(-111.04, 45.68);
 */
var Point = exports.Point = function (_Geometry) {
    _inherits(Point, _Geometry);

    function Point(x, y, type, tag) {
        _classCallCheck(this, Point);

        /**
         * @member SuperMap.Geometry.Point.prototype.x -{float}
         * @description 横坐标。
         */
        var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, x, y, type, tag));

        _this.x = parseFloat(x);

        /**
         * @member SuperMap.Geometry.Point.prototype.y -{float}
         * @description 纵坐标。
         */
        _this.y = parseFloat(y);

        /**
         * @member SuperMap.Geometry.Point.prototype.tag -{string}
         * @description  用来存储额外的属性，比如差值分析中的Z值。
         */
        _this.tag = tag || tag == 0 ? parseFloat(tag) : null;

        /**
         * @member SuperMap.Geometry.Point.prototype.tag -{string}
         * @description  用来存储点的类型
         */
        _this.type = type || "Point";
        _this.CLASS_NAME = "SuperMap.Geometry.Point";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Point.prototype.clone
     * @description 克隆点对象。
     * @returns {SuperMap.Geometry.Point} 克隆后的点对象。
     */


    _createClass(Point, [{
        key: 'clone',
        value: function clone(obj) {
            if (obj == null) {
                obj = new Point(this.x, this.y);
            }

            // catch any randomly tagged-on properties
            _Util.Util.applyDefaults(obj, this);

            return obj;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.calculateBounds
         * @description 计算点对象的范围。
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {
            this.bounds = new _Bounds.Bounds(this.x, this.y, this.x, this.y);
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.equals
         * @description 判断两个点对象是否相等。如果两个点对象具有相同的坐标，则认为是相等的。
         * @example
         * var point= new SuperMap.Geometry.Point(00);
         * var point1={x:0y:0};
         * var result= point.equals(point1);
         * @param geom - {SuperMap.Geometry.Point} 需要判断的点对象。
         *
         * @returns {Boolean} 两个点对象是否相等（true为相等，false为不等）。
         */

    }, {
        key: 'equals',
        value: function equals(geom) {
            var equals = false;
            if (geom != null) {
                equals = this.x === geom.x && this.y === geom.y || isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y);
            }
            return equals;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.move
         * @description 沿着x、y轴的正方向上按照给定的位移移动点对象，move 不仅改变了几何对象的位置并且清理了边界缓存。
         * @param x - {float} x轴正方向上的偏移量。
         * @param y - {float} y轴正方向上偏移量。
         */

    }, {
        key: 'move',
        value: function move(x, y) {
            this.x = this.x + x;
            this.y = this.y + y;
            this.clearBounds();
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.toShortString
         * @returns {string} 字符串代表点对象。(ex. <i>"5 42"</i>)
         */

    }, {
        key: 'toShortString',
        value: function toShortString() {
            return this.x + ", " + this.y;
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.destroy
         * @description 释放点对象的资源
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.x = null;
            this.y = null;
            this.tag = null;
            _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Geometry.Point.prototype.getVertices
         * @description 返回点对象的所有顶点的列表。
         * @param nodes - {Boolean} 对于点对象此参数不起作用，直接返回点。
         *
         * @returns {Array} 几何图形的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            // eslint-disable-line no-unused-vars
            return [this];
        }
    }]);

    return Point;
}(_Geometry2.Geometry);

_SuperMap.SuperMap.Geometry.Point = Point;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProcessingServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FetchRequest = __webpack_require__(21);

var _Util = __webpack_require__(1);

var _SecurityManager = __webpack_require__(35);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ProcessingServiceBase
 * @description 分布式分析服务基类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 分布式分析服务地址。
 * @param options - {Object} 参数。如：<br>
 *        events - {{@link SuperMap.Events}} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {{@link ServerType}} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。
 */
var ProcessingServiceBase = exports.ProcessingServiceBase = function (_CommonServiceBase) {
    _inherits(ProcessingServiceBase, _CommonServiceBase);

    function ProcessingServiceBase(url, options) {
        _classCallCheck(this, ProcessingServiceBase);

        options = options || {};
        /*
         * Constant: EVENT_TYPES
         * {Array<string>}
         * 此类支持的事件类型
         * - *processCompleted* 创建成功后触发的事件。
         * - *processFailed* 创建失败后触发的事件 。
         * - *processRunning* 创建过程的整个阶段都会触发的事件，用于获取创建过程的状态 。
         */
        options.EVENT_TYPES = ["processCompleted", "processFailed", "processRunning"];

        var _this = _possibleConstructorReturn(this, (ProcessingServiceBase.__proto__ || Object.getPrototypeOf(ProcessingServiceBase)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ProcessingServiceBase";
        return _this;
    }

    /**
     * @function SuperMap.ProcessingServiceBase.prototype.destroy
     * @override
     */


    _createClass(ProcessingServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(ProcessingServiceBase.prototype.__proto__ || Object.getPrototypeOf(ProcessingServiceBase.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.ProcessingServiceBase.prototype.getJobs
         * @description 获取分布式分析任务。
         * @param url - {string} 资源地址。
         */

    }, {
        key: 'getJobs',
        value: function getJobs(url) {
            var me = this;
            _FetchRequest.FetchRequest.get(url).then(function (response) {
                return response.json();
            }).then(function (result) {
                me.events.triggerEvent("processCompleted", { result: result });
            })["catch"](function (e) {
                me.eventListeners.processFailed({ error: e });
            });
        }

        /**
         * @function SuperMap.ProcessingServiceBase.prototype.addJob
         * @description 添加分布式分析任务。
         * @param url - {string} 资源根地址。
         * @param params - {Object} 创建一个空间分析的请求参数。
         * @param paramType - {string} - 请求参数类型。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addJob',
        value: function addJob(url, params, paramType, seconds) {
            var me = this,
                parameterObject = null;
            if (params && params instanceof paramType) {
                parameterObject = new Object();
                paramType.toObject(params, parameterObject);
            }
            var options = {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            };
            _FetchRequest.FetchRequest.post(me._processUrl(url), JSON.stringify(parameterObject), options).then(function (response) {
                return response.json();
            }).then(function (result) {
                if (result.succeed) {
                    me.serviceProcessCompleted(result, seconds);
                } else {
                    me.serviceProcessFailed(result);
                }
            })["catch"](function (e) {
                me.serviceProcessFailed({ error: e });
            });
        }
    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result, seconds) {
            result = _Util.Util.transformResult(result);
            seconds = seconds || 1000;
            var me = this;
            if (result) {
                var id = setInterval(function () {
                    _FetchRequest.FetchRequest.get(result.newResourceLocation).then(function (response) {
                        return response.json();
                    }).then(function (job) {
                        me.events.triggerEvent("processRunning", { id: job.id, state: job.state });
                        if (job.state.runState === 'LOST' || job.state.runState === 'KILLED' || job.state.runState === 'FAILED') {
                            clearInterval(id);
                            me.events.triggerEvent("processFailed", { error: job.state.errorMsg, state: job.state.runState });
                        }
                        if (job.state.runState === 'FINISHED' && job.setting.serviceInfo) {
                            clearInterval(id);
                            me.events.triggerEvent("processCompleted", { result: job });
                        }
                    })["catch"](function (e) {
                        clearInterval(id);
                        me.events.triggerEvent("processFailed", { error: e });
                    });
                }, seconds);
            }
        }
    }, {
        key: 'serviceProcessFailed',
        value: function serviceProcessFailed(result) {
            _get(ProcessingServiceBase.prototype.__proto__ || Object.getPrototypeOf(ProcessingServiceBase.prototype), 'serviceProcessFailed', this).call(this, result);
        }

        //为不是以.json结尾的url加上.json，并且如果有token的话，在.json后加上token参数。

    }, {
        key: '_processUrl',
        value: function _processUrl(url) {
            if (url.indexOf('.json') === -1) {
                url += '.json';
            }
            if (_SecurityManager.SecurityManager.getToken(url)) {
                url += '?token=' + _SecurityManager.SecurityManager.getToken(url);
            }
            return url;
        }
    }]);

    return ProcessingServiceBase;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.ProcessingServiceBase = ProcessingServiceBase;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerColor = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerColor
 * @classdesc 颜色类。该类使用三原色（ RGB ）来表达颜色。
 * @param options - {Object} 可选参数。如：<br>
 *        red - {number}获取或设置红色值,默认值为255。<br>
 *        green - {number}获取或设置绿色值,默认值为0。<br>
 *        blue - {number}获取或设置蓝色值,默认值为0。
 */
var ServerColor = exports.ServerColor = function () {
    function ServerColor(red, green, blue) {
        _classCallCheck(this, ServerColor);

        /**
         * @member SuperMap.ServerColor.prototype.red -{number}
         * @description 获取或设置红色值,默认值为255。
         * @default 255
         */
        this.red = !red && red != 0 ? 255 : red;

        /**
         * @member SuperMap.ServerColor.prototype.green -{number}
         * @description 获取或设置绿色值,默认值为0。
         * @default 0
         */
        this.green = green || 0;

        /**
         * @member SuperMap.ServerColor.prototype.blue -{number}
         * @description 获取或设置蓝色值,默认值为0。
         * @default 0
         */
        this.blue = blue || 0;

        this.CLASS_NAME = "SuperMap.ServerColor";
    }

    /**
     * @function SuperMap.ServerColor.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ServerColor, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.red = null;
            me.green = null;
            me.blue = null;
        }

        /**
         * @function SuperMap.ServerColor.formJson
         * @description 将JSON对象转化为ServerColor对象。
         * @param jsonObject - {Object} 要转换的JSON对象
         * @return{SuperMap.ServerColor} 转化后的ServerColor对象。
         */

    }], [{
        key: "fromJson",
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            var color = new ServerColor();
            var red = 255;
            if (jsonObject.red !== null) {
                red = Number(jsonObject.red);
            }
            color.red = red;

            var green = 0;
            if (jsonObject.green !== null) {
                green = Number(jsonObject.green);
            }
            color.green = green;

            var blue = 0;
            if (jsonObject.blue !== null) {
                blue = Number(jsonObject.blue);
            }
            color.blue = blue;
            return color;
        }
    }]);

    return ServerColor;
}();

_SuperMap.SuperMap.ServerColor = ServerColor;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FetchRequest = exports.RequestTimeout = exports.CORS = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(442);

var _whatwgFetchImportable = __webpack_require__(501);

var _whatwgFetchImportable2 = _interopRequireDefault(_whatwgFetchImportable);

var _fetchJsonp2 = __webpack_require__(456);

var _fetchJsonp3 = _interopRequireDefault(_fetchJsonp2);

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @member SuperMap.CORS
 * @description 是否支持跨域
 * @type {boolean}
 */
var CORS = exports.CORS = _SuperMap.SuperMap.CORS = _SuperMap.SuperMap.CORS || window.XMLHttpRequest && 'withCredentials' in new window.XMLHttpRequest();
/**
 * @member SuperMap.RequestTimeout
 * @description 请求超时时间，默认45s
 * @type {number}
 */
var RequestTimeout = exports.RequestTimeout = _SuperMap.SuperMap.RequestTimeout = _SuperMap.SuperMap.RequestTimeout || 45000;
var FetchRequest = exports.FetchRequest = _SuperMap.SuperMap.FetchRequest = {
    commit: function commit(method, url, params, options) {
        method = method ? method.toUpperCase() : method;
        switch (method) {
            case 'GET':
                return this.get(url, params, options);
            case 'POST':
                return this.post(url, params, options);
            case 'PUT':
                return this.put(url, params, options);
            case 'DELETE':
                return this["delete"](url, params, options);
            default:
                return this.get(url, params, options);
        }
    },

    get: function get(url, params, options) {
        options = options || {};
        var type = 'GET';
        url = this._processUrl(url, options);
        url = _Util.Util.urlAppend(url, this._getParameterString(params || {}));
        if (!this.urlIsLong(url)) {
            if (_Util.Util.isInTheSameDomain(url) || CORS || options.proxy) {
                return this._fetch(url, params, options, type);
            }
            if (!_Util.Util.isInTheSameDomain(url)) {
                url = url.replace('.json', '.jsonp');
                return this._fetchJsonp(url, options);
            }
        }
        return this._postSimulatie(type, url.substring(0, url.indexOf('?') - 1), params, options);
    },

    "delete": function _delete(url, params, options) {
        options = options || {};
        var type = 'DELETE';
        url = this._processUrl(url, options);
        url = _Util.Util.urlAppend(url, this._getParameterString(params || {}));
        if (!this.urlIsLong(url) && CORS) {
            return this._fetch(url, params, options, type);
        }
        return this._postSimulatie(type, url.substring(0, url.indexOf('?') - 1), params, options);
    },

    post: function post(url, params, options) {
        options = options || {};
        return this._fetch(this._processUrl(url, options), params, options, 'POST');
    },

    put: function put(url, params, options) {
        options = options || {};
        return this._fetch(this._processUrl(url, options), params, options, 'PUT');
    },
    urlIsLong: function urlIsLong(url) {
        //当前url的字节长度。
        var totalLength = 0,
            charCode = null;
        for (var i = 0, len = url.length; i < len; i++) {
            //转化为Unicode编码
            charCode = url.charCodeAt(i);
            if (charCode < 0x007f) {
                totalLength++;
            } else if (0x0080 <= charCode && charCode <= 0x07ff) {
                totalLength += 2;
            } else if (0x0800 <= charCode && charCode <= 0xffff) {
                totalLength += 3;
            }
        }
        return totalLength < 2000 ? false : true;
    },
    _postSimulatie: function _postSimulatie(type, url, params, options) {
        var separator = url.indexOf("?") > -1 ? "&" : "?";
        url += separator + '_method=' + type;
        if (typeof params !== 'string') {
            params = JSON.stringify(params);
        }
        return this.post(url, params, options);
    },

    _processUrl: function _processUrl(url, options) {
        if (this._isMVTRequest(url)) {
            return url;
        }

        if (url.indexOf('.json') === -1 && !options.withoutFormatSuffix) {
            if (url.indexOf("?") < 0) {
                url += '.json';
            } else {
                var urlArrays = url.split("?");
                if (urlArrays.length === 2) {
                    url = urlArrays[0] + ".json?" + urlArrays[1];
                }
            }
        }
        if (options && options.proxy) {
            if (typeof options.proxy === "function") {
                url = options.proxy(url);
            } else {
                url = decodeURIComponent(url);
                url = options.proxy + encodeURIComponent(url);
            }
        }
        return url;
    },

    _fetch: function _fetch(url, params, options, type) {
        options = options || {};
        options.headers = options.headers || {};
        if (!options.headers['Content-Type']) {
            options.headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        if (options.timeout) {
            return this._timeout(options.timeout, (0, _whatwgFetchImportable2["default"])(url, {
                method: type,
                headers: options.headers,
                body: type === 'PUT' || type === 'POST' ? params : undefined,
                credentials: options.withCredentials ? 'include' : 'omit',
                mode: 'cors',
                timeout: RequestTimeout
            }).then(function (response) {
                return response;
            }));
        }
        return (0, _whatwgFetchImportable2["default"])(url, {
            method: type,
            body: type === 'PUT' || type === 'POST' ? params : undefined,
            headers: options.headers,
            credentials: options.withCredentials ? 'include' : 'omit',
            mode: 'cors',
            timeout: RequestTimeout
        }).then(function (response) {
            return response;
        });
    },

    _fetchJsonp: function _fetchJsonp(url, options) {
        options = options || {};
        return (0, _fetchJsonp3["default"])(url, { method: 'GET', timeout: options.timeout }).then(function (response) {
            return response;
        });
    },

    _timeout: function _timeout(seconds, promise) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error("timeout"));
            }, seconds);
            promise.then(resolve, reject);
        });
    },

    _getParameterString: function _getParameterString(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if (value != null && typeof value !== 'function') {
                var encodedValue;
                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Array) {
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(item === null || item === undefined ? "" : item));
                    }
                    encodedValue = '[' + encodedItemArray.join(",") + ']';
                } else {
                    encodedValue = encodeURIComponent(value);
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }
        return paramsArray.join("&");
    },

    _isMVTRequest: function _isMVTRequest(url) {
        return url.indexOf('.mvt') > -1 || url.indexOf('.pbf') > -1;
    }
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Bounds = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Size = __webpack_require__(141);

var _Pixel = __webpack_require__(63);

var _LonLat = __webpack_require__(37);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Bounds
 * @classdesc 表示边界类实例。使用bounds之前需要设置left,bottom, right, top四个属性，这些属性的初始值为null。
 * @param  left - {number} 左边界，注意考虑宽度，理论上小于right值。
 * @param  bottom - {number} 下边界。考虑高度，理论上小于top值。
 * @param  right - {number} 右边界。
 * @param  top - {number} 上边界。
 * @param  array - {Array<number>} [left, bottom, right, top]  如果同时传多个参数，则使用左下右上组成的数组。
 * @example
 * var bounds = new SuperMap.Bounds();
 * bounds.extend(new SuperMap.LonLat(4,5));
 * bounds.extend(new SuperMap.LonLat(5,6));
 * bounds.toBBOX(); // returns 4,5,5,6
 */
var Bounds = exports.Bounds = function () {
    function Bounds(left, bottom, right, top) {
        _classCallCheck(this, Bounds);

        if (_Util.Util.isArray(left)) {
            top = left[3];
            right = left[2];
            bottom = left[1];
            left = left[0];
        }
        /**
         * @member SuperMap.Bounds.prototype.left - {number}
         * @description 最小的水平坐标系。
         */
        this.left = left != null ? _Util.Util.toFloat(left) : this.left;

        /**
         * @member SuperMap.Bounds.prototype.bottom - {number}
         * @description 最小的垂直坐标系。
         */
        this.bottom = bottom != null ? _Util.Util.toFloat(bottom) : this.bottom;

        /**
         * @member SuperMap.Bounds.prototype.right - {number}
         * @description 最大的水平坐标系。
         */
        this.right = right != null ? _Util.Util.toFloat(right) : this.right;

        /**
         * @member SuperMap.Bounds.prototype.top - {number}
         * @description 最大的垂直坐标系。
         */
        this.top = top != null ? _Util.Util.toFloat(top) : this.top;

        /**
         * @member SuperMap.Bounds.prototype.centerLonLat - {SuperMap.LonLat}
         * @description bounds的地图空间的中心点。用 getCenterLonLat() 获得。
         */
        this.centerLonLat = null;
        this.CLASS_NAME = "SuperMap.Bounds";
    }

    /**
     * @function SuperMap.Bounds.prototype.clone
     * @description 复制当前 bounds 对象。
     * @example
     * var bounds1 = new SuperMap.Bounds(-180,-90,180,90);
     * var bounds2 = bounds1.clone();
     * @returns {SuperMap.Bounds} 返回一个克隆的bounds。
     */


    _createClass(Bounds, [{
        key: 'clone',
        value: function clone() {
            return new Bounds(this.left, this.bottom, this.right, this.top);
        }

        /**
         * @function SuperMap.Bounds.prototype.equals
         * @description 判断两个 bounds 对象是否相等。
         * @example
         * var bounds1 = new SuperMap.Bounds(-180-9018090);
         * var bounds2 = new SuperMap.Bounds(-180-9018090);
         * var isEquals = bounds1.equals(bounds2);
         * @param bounds - {SuperMap.Bounds} 需要进行计较的 bounds。
         * @returns {boolean} 如果 bounds 对象的边和传入的 bounds 一致则返回true不一致或传入的 bounds 参数为NULL则返回false。
         */

    }, {
        key: 'equals',
        value: function equals(bounds) {
            var equals = false;
            if (bounds != null) {
                equals = this.left === bounds.left && this.right === bounds.right && this.top === bounds.top && this.bottom === bounds.bottom;
            }
            return equals;
        }

        /**
         * @function SuperMap.Bounds.prototype.toString
         * @description 返回此对象的字符串形式
         * @example
         * var bounds = new SuperMap.Bounds(-180-9018090);
         * var str = bounds.toString();
         * @returns {string} 边界对象的字符串表示形式（leftbottomrighttop），例如: "-180-9018090"
         */

    }, {
        key: 'toString',
        value: function toString() {
            return [this.left, this.bottom, this.right, this.top].join(",");
        }

        /**
         * @function SuperMap.Bounds.prototype.toArray
         * @description 边界对象的数组表示形式 。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * //array1 = [-180,-90,100,80];
         * var array1 = bounds.toArray();
         * //array1 = [-90,-180,80,100];
         * var array2 = bounds.toArray(true);
         * @param reverseAxisOrder - {boolean} 是否反转轴顺序，
         * 如果设为true，则倒转顺序（bottomlefttopright）否则按正常轴顺序（leftbottomrighttop）。
         * @returns {Array} left bottom right top数组。
         */

    }, {
        key: 'toArray',
        value: function toArray(reverseAxisOrder) {
            if (reverseAxisOrder === true) {
                return [this.bottom, this.left, this.top, this.right];
            } else {
                return [this.left, this.bottom, this.right, this.top];
            }
        }

        /**
         * @function SuperMap.Bounds.prototype.toBBOX
         * @description 取小数点后decimal位数字进行四舍五入再转换为BBOX字符串。
         * @example
         * var bounds = new SuperMap.Bounds(-1.1234567-1.76543211.44444441.5555555);
         * //str1 = "-1.123457,-1.765432,1.444444,1.555556";
         * var str1 = bounds.toBBOX();
         * //str2 = "-1.1,-1.8,1.4,1.6";
         * var str2 = bounds.toBBOX(1);
         * //str2 = "-1.8,-1.1,1.6,1.4";
         * var str2 = bounds.toBBOX(1true);
         * @param decimal - {integer} 边界方位坐标的有效数字个数，默认为6。
         * @param  reverseAxisOrder - {boolean} 是否是反转轴顺序。
         * 如果设为true，则倒转顺序（bottomlefttopright）否则按正常轴顺序（leftbottomrighttop）。
         * @returns {string} 边界对象的字符串表示形式，如："5421045"。
         */

    }, {
        key: 'toBBOX',
        value: function toBBOX(decimal, reverseAxisOrder) {
            if (decimal == null) {
                decimal = 6;
            }
            var mult = Math.pow(10, decimal);
            var xmin = Math.round(this.left * mult) / mult;
            var ymin = Math.round(this.bottom * mult) / mult;
            var xmax = Math.round(this.right * mult) / mult;
            var ymax = Math.round(this.top * mult) / mult;
            if (reverseAxisOrder === true) {
                return ymin + "," + xmin + "," + ymax + "," + xmax;
            } else {
                return xmin + "," + ymin + "," + xmax + "," + ymax;
            }
        }

        /**
         * @function SuperMap.Bounds.prototype.toGeometry
         * @description 基于当前边界范围创建一个新的多边形对象。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * //SuperMap.Geometry.Polygon对象
         * var geo = bounds.toGeometry();
         * @returns {SuperMap.Geometry.Polygon} 基于当前bounds坐标创建的新的多边形。
         */
        // toGeometry() {
        //     return new Polygon([
        //         new LinearRing([
        //             new Point(this.left, this.bottom),
        //             new Point(this.right, this.bottom),
        //             new Point(this.right, this.top),
        //             new Point(this.left, this.top)
        //         ])
        //     ]);
        // }

        /**
         * @function SuperMap.Bounds.prototype.getWidth
         * @description 获取bounds的宽度。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * //width = 280;
         * var width = bounds.getWidth();
         * @returns {float} 获取当前bounds的宽度（right减去left）。
         */

    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.right - this.left;
        }

        /**
         * @function SuperMap.Bounds.prototype.getHeight
         * @description 获取bounds的高度。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * //height = 170;
         * var height = bounds.getHeight();
         * @returns {float} 返回边界高度（top减去bottom）。
         */

    }, {
        key: 'getHeight',
        value: function getHeight() {
            return this.top - this.bottom;
        }

        /**
         * @function SuperMap.Bounds.prototype.getSize
         * @description 获取边框大小。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * var size = bounds.getSize();
         * @returns {SuperMap.Size} 返回边框大小。
         */

    }, {
        key: 'getSize',
        value: function getSize() {
            return new _Size.Size(this.getWidth(), this.getHeight());
        }

        /**
         * @function SuperMap.Bounds.prototype.getCenterPixel
         * @description 获取像素格式的范围中心点。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * var pixel = bounds.getCenterPixel();
         * @returns {SuperMap.Pixel} 返回像素格式的当前范围的中心点。
         */

    }, {
        key: 'getCenterPixel',
        value: function getCenterPixel() {
            return new _Pixel.Pixel((this.left + this.right) / 2, (this.bottom + this.top) / 2);
        }

        /**
         * @function SuperMap.Bounds.prototype.getCenterLonLat
         * @description 获取地理格式的范围中心点。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * var lonlat = bounds.getCenterLonLat();
         * @returns {SuperMap.LonLat} 返回当前地理范围的中心点。
         */

    }, {
        key: 'getCenterLonLat',
        value: function getCenterLonLat() {
            if (!this.centerLonLat) {
                this.centerLonLat = new _LonLat.LonLat((this.left + this.right) / 2, (this.bottom + this.top) / 2);
            }
            return this.centerLonLat;
        }

        /**
         * @function SuperMap.Bounds.prototype.scale
         * @description 按照比例扩大/缩小出一个新的bounds。
         * @example
         * var bounds = new SuperMap.Bounds(-50-504040);
         * var bounds2 = bounds.scale(2);
         * @param ratio - {float} 需要扩大的比例，默认为1。
         * @param origin - {SuperMap.Pixel|SuperMap.LonLat} 扩大时的基准点，默认为当前bounds的中心点。
         * @returns {SuperMap.Bounds} 返回通过ratio、origin计算得到的新的边界范围。
         */

    }, {
        key: 'scale',
        value: function scale(ratio, origin) {
            ratio = ratio ? ratio : 1;
            if (origin == null) {
                origin = this.getCenterLonLat();
            }

            var origx, origy;

            // get origin coordinates
            if (origin.CLASS_NAME === "SuperMap.LonLat") {
                origx = origin.lon;
                origy = origin.lat;
            } else {
                origx = origin.x;
                origy = origin.y;
            }

            var left = (this.left - origx) * ratio + origx;
            var bottom = (this.bottom - origy) * ratio + origy;
            var right = (this.right - origx) * ratio + origx;
            var top = (this.top - origy) * ratio + origy;

            return new Bounds(left, bottom, right, top);
        }

        /**
         * @function SuperMap.Bounds.prototype.add
         * @description 在当前的dounds上按照传入的坐标点进行平移，返回新的范围。
         * @example
         * var bounds1 = new SuperMap.Bounds(-50-504040);
         * //bounds2 是新的 bounds
         * var bounds2 = bounds.add(2010);
         * @param x - {float} 传入坐标点的x坐标。
         * @param y - {float} 传入坐标点的y坐标。
         * @returns {SuperMap.Bounds} 返回一个新的bounds，此bounds的坐标是由传入的x，y参数与当前bounds坐标计算所得。
         */

    }, {
        key: 'add',
        value: function add(x, y) {
            if (x == null || y == null) {
                throw new TypeError('Bounds.add cannot receive null values');
            }
            return new Bounds(this.left + x, this.bottom + y, this.right + x, this.top + y);
        }

        /**
         * @function SuperMap.Bounds.prototype.extend
         * @description 在当前bounds上扩展bounds，支持point，lanlat和bounds。扩展后的bounds的范围是两者的结合。
         * @example
         * var bounds1 = new SuperMap.Bounds(-50-504040);
         * //bounds改变
         * bounds.extend(new SuperMap.LonLat(5060));
         * @param object - {SuperMap.Geometry.Point|SuperMap.LonLat | SuperMap.Bounds} 可以是point，lanlat和bounds。
         */

    }, {
        key: 'extend',
        value: function extend(object) {
            var bounds = null;
            if (object) {
                // clear cached center location
                switch (object.CLASS_NAME) {
                    case "SuperMap.LonLat":
                        bounds = new Bounds(object.lon, object.lat, object.lon, object.lat);
                        break;
                    case "SuperMap.Geometry.Point":
                        bounds = new Bounds(object.x, object.y, object.x, object.y);
                        break;

                    case "SuperMap.Bounds":
                        bounds = object;
                        break;
                }

                if (bounds) {
                    this.centerLonLat = null;
                    if (this.left == null || bounds.left < this.left) {
                        this.left = bounds.left;
                    }
                    if (this.bottom == null || bounds.bottom < this.bottom) {
                        this.bottom = bounds.bottom;
                    }
                    if (this.right == null || bounds.right > this.right) {
                        this.right = bounds.right;
                    }
                    if (this.top == null || bounds.top > this.top) {
                        this.top = bounds.top;
                    }
                }
            }
        }

        /**
         * @function SuperMap.Bounds.prototype.containsLonLat
         * @description 判断传入的坐标是否在范围内。
         * @example
         * var bounds1 = new SuperMap.Bounds(-50-504040);
         * //isContains1 = true
         * //这里的第二个参数可以直接为 boolean 类型，也就是inclusive
         * var isContains1 = bounds.containsLonLat(new SuperMap.LonLat(4040)true);
         *
         * //(40,40)在范围内，同样(40+360,40)也在范围内
         * var bounds2 = new SuperMap.Bounds(-50-504040);
         * //isContains2 = true;
         * var isContains2 = bounds2.containsLonLat(
         *      new SuperMap.LonLat(40040)
         *      {
         *           inclusive:true
         *           //全球的范围
         *           worldBounds: new SuperMap.Bounds(-180-9018090)
         *      }
         *      );
         * @param ll - {SuperMap.LonLat|Object}  <SuperMap.LonLat> 对象或者是一个
         *     包含 'lon' 与 'lat' 属性的对象。
         * @param options - {Object} 可选参数<br>
         *         inclusive - {boolean} 是否包含边界，默认为 true 。<br>
         *         worldBounds - {@link SuperMap.Bounds} 如果提供 worldBounds 参数 如果 ll 参数提供的坐标超出了世界边界（worldBounds）
         *         但是通过日界线的转化可以被包含 它将被认为是包含在该范围内的。
         * @returns {boolean} 传入坐标是否包含在范围内.
         */

    }, {
        key: 'containsLonLat',
        value: function containsLonLat(ll, options) {
            if (typeof options === "boolean") {
                options = { inclusive: options };
            }
            options = options || {};
            var contains = this.contains(ll.lon, ll.lat, options.inclusive),
                worldBounds = options.worldBounds;
            //日界线以外的也有可能算包含，
            if (worldBounds && !contains) {
                var worldWidth = worldBounds.getWidth();
                var worldCenterX = (worldBounds.left + worldBounds.right) / 2;
                //这一步很关键
                var worldsAway = Math.round((ll.lon - worldCenterX) / worldWidth);
                contains = this.containsLonLat({
                    lon: ll.lon - worldsAway * worldWidth,
                    lat: ll.lat
                }, { inclusive: options.inclusive });
            }
            return contains;
        }

        /**
         * @function SuperMap.Bounds.prototype.containsPixel
         * @description 判断传入的像素是否在范围内。直接匹配大小，不涉及像素和地理转换。
         * @example
         * var bounds = new SuperMap.Bounds(-50-504040);
         * //isContains = true
         * var isContains = bounds.containsPixel(new SuperMap.Pixel(4040)true);
         * @param px - {SuperMap.Pixel} 提供的像素参数。
         * @param inclusive - {boolean} 是否包含边界，默认为true。
         * @returns {boolean} 传入的pixel在当前边界范围之内。
         */

    }, {
        key: 'containsPixel',
        value: function containsPixel(px, inclusive) {
            return this.contains(px.x, px.y, inclusive);
        }

        /**
         * @function SuperMap.Bounds.prototype.contains
         * @description 判断传入的x，y坐标值是否在范围内。
         * @example
         * var bounds = new SuperMap.Bounds(-50-504040);
         * //isContains = true
         * var isContains = bounds.contains(4040true);
         * @param x - {float} 传入的x坐标值。
         * @param y - {float} 传入的y坐标值。
         * @param inclusive - {boolean} 是否包含边界，默认为true。
         * @returns {boolean} 传入的xy坐标在当前范围内。
         */

    }, {
        key: 'contains',
        value: function contains(x, y, inclusive) {
            //set default
            if (inclusive == null) {
                inclusive = true;
            }

            if (x == null || y == null) {
                return false;
            }

            x = _Util.Util.toFloat(x);
            y = _Util.Util.toFloat(y);

            var contains = false;
            if (inclusive) {
                contains = x >= this.left && x <= this.right && y >= this.bottom && y <= this.top;
            } else {
                contains = x > this.left && x < this.right && y > this.bottom && y < this.top;
            }
            return contains;
        }

        /**
         * @function SuperMap.Bounds.prototype.intersectsBounds
         * @description 判断目标边界范围是否与当前边界范围相交。如果两个边界范围中的任意
         *                边缘相交或者一个边界包含了另外一个就认为这两个边界相交。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * var isIntersects = bounds.intersectsBounds(
         *      new SuperMap.Bounds(-170-9012080)
         *  );
         * @param bounds - {SuperMap.Bounds} 目标边界。
         * @param options - {Object} 可选参数。<br>
         *         inclusive - {boolean} 边缘重合也看成相交，默认为true。如果是false，
         *                               两个边界范围没有重叠部分仅仅是在边缘相接（重合），
         *                               这种情况被认为没有相交。<br>
         *         worldBounds - {@link SuperMap.Bounds} 提供了 worldBounds 参数 如果他们相交时
         *                               是在全球范围内 两个边界将被视为相交。这仅适用于交叉
         *                               或完全不在世界范围的边界。
         * @returns {boolean} 传入的bounds对象与当前bounds相交。
         */

    }, {
        key: 'intersectsBounds',
        value: function intersectsBounds(bounds, options) {
            if (typeof options === "boolean") {
                options = { inclusive: options };
            }
            options = options || {};
            if (options.worldBounds) {
                var self = this.wrapDateLine(options.worldBounds);
                bounds = bounds.wrapDateLine(options.worldBounds);
            } else {
                self = this;
            }
            if (options.inclusive == null) {
                options.inclusive = true;
            }
            var intersects = false;
            var mightTouch = self.left === bounds.right || self.right === bounds.left || self.top === bounds.bottom || self.bottom === bounds.top;

            // if the two bounds only touch at an edge, and inclusive is false,
            // then the bounds don't *really* intersect.
            if (options.inclusive || !mightTouch) {
                // otherwise, if one of the boundaries even partially contains another,
                // inclusive of the edges, then they do intersect.
                var inBottom = bounds.bottom >= self.bottom && bounds.bottom <= self.top || self.bottom >= bounds.bottom && self.bottom <= bounds.top;
                var inTop = bounds.top >= self.bottom && bounds.top <= self.top || self.top > bounds.bottom && self.top < bounds.top;
                var inLeft = bounds.left >= self.left && bounds.left <= self.right || self.left >= bounds.left && self.left <= bounds.right;
                var inRight = bounds.right >= self.left && bounds.right <= self.right || self.right >= bounds.left && self.right <= bounds.right;
                intersects = (inBottom || inTop) && (inLeft || inRight);
            }
            // document me
            if (options.worldBounds && !intersects) {
                var world = options.worldBounds;
                var width = world.getWidth();
                var selfCrosses = !world.containsBounds(self);
                var boundsCrosses = !world.containsBounds(bounds);
                if (selfCrosses && !boundsCrosses) {
                    bounds = bounds.add(-width, 0);
                    intersects = self.intersectsBounds(bounds, { inclusive: options.inclusive });
                } else if (boundsCrosses && !selfCrosses) {
                    self = self.add(-width, 0);
                    intersects = bounds.intersectsBounds(self, { inclusive: options.inclusive });
                }
            }
            return intersects;
        }

        /**
         * @function SuperMap.Bounds.prototype.containsBounds
         * @description 判断目标边界是否被当前边界包含在内。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * var isContains = bounds.containsBounds(
         *      new SuperMap.Bounds(-170-9010080)truetrue
         *  );
         * @param bounds - {SuperMap.Bounds} 目标边界。
         * @param partial - {boolean} 目标边界的任意部分都包含在当前边界中则被认为是包含关系。默认为false，
         *                             如果设为false，整个目标边界全部被包含在当前边界范围内。
         * @param inclusive - {boolean} 边缘共享被视为包含。默认为true。
         * @returns {boolean} 传入的边界被当前边界包含。
         */

    }, {
        key: 'containsBounds',
        value: function containsBounds(bounds, partial, inclusive) {
            if (partial == null) {
                partial = false;
            }
            if (inclusive == null) {
                inclusive = true;
            }
            var bottomLeft = this.contains(bounds.left, bounds.bottom, inclusive);
            var bottomRight = this.contains(bounds.right, bounds.bottom, inclusive);
            var topLeft = this.contains(bounds.left, bounds.top, inclusive);
            var topRight = this.contains(bounds.right, bounds.top, inclusive);

            return partial ? bottomLeft || bottomRight || topLeft || topRight : bottomLeft && bottomRight && topLeft && topRight;
        }

        /**
         * @function SuperMap.Bounds.prototype.determineQuadrant
         * @description 判断传入坐标在bounds范围内的象限。以bounds中心点为坐标原点。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * //str = "tr";
         * var str = bounds.determineQuadrant(
         *      new SuperMap.LonLat(2020)
         *  );
         * @param lonlat - {SuperMap.LonLat} 传入的坐标对象。
         * @returns {string} 传入坐标所在的象限("br" "tr" "tl" "bl" 分别对应"右下"，"右上"，"左上" "左下")。
         */

    }, {
        key: 'determineQuadrant',
        value: function determineQuadrant(lonlat) {

            var quadrant = "";
            var center = this.getCenterLonLat();

            quadrant += lonlat.lat < center.lat ? "b" : "t";
            quadrant += lonlat.lon < center.lon ? "l" : "r";

            return quadrant;
        }

        /**
         * @function SuperMap.Bounds.prototype.wrapDateLine
         * @description 将当前bounds移动到最大边界范围内部（所谓的内部是相交或者内部）。
         * @example
         * var bounds = new SuperMap.Bounds(380-40400-20);
         * var maxExtent = new SuperMap.Bounds(-180-9010080);
         * //新的bounds
         * var newBounds = bounds.wrapDateLine(maxExtent);
         * @param maxExtent - {SuperMap.Bounds} 最大的边界范围（一般是全球范围）。
         * @param options - {Object} 可选选项参数。<br>
         *         leftTolerance - {float} left允许的误差。默认为0。<br>
         *         rightTolerance - {float} right允许的误差。默认为0。
         * @returns {SuperMap.Bounds} 克隆当前边界。如果当前边界完全在最大范围之外此函数则返回一个不同值的边界，
         *                             若落在最大边界的左边，则给当前的bounds值加上最大范围的宽度，即向右移动，
         *                             若落在右边，则向左移动，即给当前的bounds值加上负的最大范围的宽度。
         */

    }, {
        key: 'wrapDateLine',
        value: function wrapDateLine(maxExtent, options) {
            options = options || {};

            var leftTolerance = options.leftTolerance || 0;
            var rightTolerance = options.rightTolerance || 0;

            var newBounds = this.clone();

            if (maxExtent) {
                var width = maxExtent.getWidth();
                //如果 newBounds 在 maxExtent 的左边，那么一直向右移动，直到相交或者包含为止，每次移动width
                //shift right?
                while (newBounds.left < maxExtent.left && newBounds.right - rightTolerance <= maxExtent.left) {
                    newBounds = newBounds.add(width, 0);
                }
                //如果 newBounds 在 maxExtent 的右边，那么一直向左移动，直到相交或者包含为止，每次移动width
                //shift left?
                while (newBounds.left + leftTolerance >= maxExtent.right && newBounds.right > maxExtent.right) {
                    newBounds = newBounds.add(-width, 0);
                }
                //如果和右边相交，左边又在内部，那么再次向左边移动一次
                // crosses right only? force left
                var newLeft = newBounds.left + leftTolerance;
                if (newLeft < maxExtent.right && newLeft > maxExtent.left && newBounds.right - rightTolerance > maxExtent.right) {
                    newBounds = newBounds.add(-width, 0);
                }
            }

            return newBounds;
        }

        /**
         * @function SuperMap.Bounds.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * var obj = bounds.toServerJSONObject();
         * @returns {Object} 返回json 格式的Object对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = {
                rightTop: { x: this.right, y: this.top },
                leftBottom: { x: this.left, y: this.bottom },
                left: this.left,
                right: this.right,
                top: this.top,
                bottom: this.bottom
            };
            return jsonObject;
        }

        /**
         *
         * @function SuperMap.Bounds.prototype.destroy
         * @description 销毁此对象。
         * 销毁后此对象的所有属性为null，而不是初始值。
         * @example
         * var bounds = new SuperMap.Bounds(-180-9010080);
         * bounds.destroy();
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.left = null;
            this.right = null;
            this.top = null;
            this.bottom = null;
            this.centerLonLat = null;
        }

        /**
         * @function SuperMap.Bounds.fromString
         * @description 通过字符串参数创建新的bounds的构造函数。
         * @example
         * var bounds = SuperMap.Bounds.fromString("-180-9010080");
         * @param str - {string} 边界字符串，用逗号隔开 (e.g. <i>"5421045"</i>)
         * @param reverseAxisOrder - {boolean} 是否反转轴顺序.
         * 如果设为true，则倒转顺序（bottomlefttopright）否则按正常轴顺序（leftbottomrighttop）。
         * @returns {SuperMap.Bounds} 返回给定的字符串创建的新的边界对象
         */

    }], [{
        key: 'fromString',
        value: function fromString(str, reverseAxisOrder) {
            var bounds = str.split(",");
            return Bounds.fromArray(bounds, reverseAxisOrder);
        }

        /**
         * @function SuperMap.Bounds.fromArray
         * @description 通过边界框数组创建Bounds。
         * @example
         * var bounds = SuperMap.Bounds.fromArray([-180-9010080]);
         * @param bbox - {Array(float)} 边界值数组。 (e.g. <i>[5421045]</i>)
         * @param reverseAxisOrder - {boolean} 是否是反转轴顺序。如果设为true，则倒转顺序（bottomlefttopright）否则按正常轴顺序（leftbottomrighttop）。
         * @returns {SuperMap.Bounds} 返回根据传入的数组创建的新的边界对象。
         */

    }, {
        key: 'fromArray',
        value: function fromArray(bbox, reverseAxisOrder) {
            return reverseAxisOrder === true ? new Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) : new Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
        }

        /**
         * @function SuperMap.Bounds.fromSize
         * @description 通过传入的边界大小来创建新的边界。
         * @example
         * var bounds = SuperMap.Bounds.fromSize(new SuperMap.Size(2010));
         * @param size - {SuperMap.Size} 传入的边界大小。
         * @returns {SuperMap.Bounds} 返回根据传入的边界大小的创建新的边界。
         */

    }, {
        key: 'fromSize',
        value: function fromSize(size) {
            return new Bounds(0, size.h, size.w, 0);
        }

        /**
         * @function SuperMap.Bounds.oppositeQuadrant
         * @description 反转象限。"t"和"b" 交换，"r"和"l"交换 如："tl"变为"br"。
         * @param quadrant - {string} 代表象限的字符串，如："tl"。
         * @returns {string} 反转后的象限。
         */

    }, {
        key: 'oppositeQuadrant',
        value: function oppositeQuadrant(quadrant) {
            var opp = "";

            opp += quadrant.charAt(0) === 't' ? 'b' : 't';
            opp += quadrant.charAt(1) === 'l' ? 'r' : 'l';

            return opp;
        }
    }]);

    return Bounds;
}();

_SuperMap.SuperMap.Bounds = Bounds;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Theme = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(243);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Theme
 * @classdesc 专题图基类。
 * @param  type - {string} 专题图类型。
 * @param options - {Object} 可选参数。如：<br>
 *        memoryData - {{@link SuperMap.ThemeMemoryData}} 专题图内存数据。
 */
var Theme = exports.Theme = function () {
    function Theme(type, options) {
        _classCallCheck(this, Theme);

        if (!type) {
            return this;
        }
        /**
         * @member SuperMap.Theme.prototype.memoryData -{SuperMap.ThemeMemoryData}
         * @description 专题图内存数据。<br>
         *              用内存数据制作专题图的方式与表达式制作专题图的方式互斥，前者优先级较高。
         *              第一个参数代表专题值，即数据集中用来做专题图的字段或表达式的值；第二个参数代表外部值。在制作专题图时，会用外部值代替专题值来制作相应的专题图。
         */
        this.memoryData = null;

        /**
         * @member SuperMap.Theme.prototype.type -{string}
         * @description 专题图类型。
         */
        this.type = type;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.Theme";
    }

    /**
     * @function SuperMap.Theme.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(Theme, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.memoryData) {
                me.memoryData.destroy();
                me.memoryData = null;
            }
            me.type = null;
        }

        /**
         * @function SuperMap.Theme.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            //return 子类实现
            return;
        }
    }]);

    return Theme;
}();

_SuperMap.SuperMap.Theme = Theme;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ShapeFactory = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Point = __webpack_require__(74);

var _Line = __webpack_require__(104);

var _Polygon = __webpack_require__(75);

var _Rectangle = __webpack_require__(262);

var _Sector = __webpack_require__(76);

var _Label = __webpack_require__(261);

var _Image = __webpack_require__(260);

var _Circle = __webpack_require__(103);

var _SmicPoint = __webpack_require__(108);

var _SmicText = __webpack_require__(110);

var _SmicCircle = __webpack_require__(278);

var _SmicBrokenLine = __webpack_require__(106);

var _SmicImage = __webpack_require__(107);

var _SmicPolygon = __webpack_require__(80);

var _SmicRectangle = __webpack_require__(109);

var _SmicSector = __webpack_require__(279);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.Feature.ShapeFactory
 * 图形工厂类。
 *
 * 目前支持创建的图形有：
 *
 * 用于统计专题图：
 * 点 - 参数对象： <SuperMap.Feature.ShapeParameters.Point>
 *
 * 线 - 参数对象： <SuperMap.Feature.ShapeParameters.Line>
 *
 * 面 - 参数对象： <SuperMap.Feature.ShapeParameters.Polygon>
 *
 * 矩形 - 参数对象： <SuperMap.Feature.ShapeParameters.Rectangle>
 *
 * 扇形 - 参数对象： <SuperMap.Feature.ShapeParameters.Sector>
 *
 * 标签 - 参数对象： <SuperMap.Feature.ShapeParameters.Label>
 *
 * 图片 - 参数对象： <SuperMap.Feature.ShapeParameters.Image>
 *
 *
 * 用于符号专题图：
 * 圆形 -  参数对象：<Supermap.Feature.ShapeParameters.Cilcle>
 */
var ShapeFactory = exports.ShapeFactory = function () {

    /**
     * Constructor: SuperMap.Feature.ShapeFactory
     * 构建图形工厂对象。
     *
     * Parameters:
     * shapeParameters - {Object}  图形参数对象，<SuperMap.Feature.ShapeParameters> 子类对象，可选参数。
     *
     * Returns:
     * {Object} 返回图形工厂类对象。
     */
    function ShapeFactory(shapeParameters) {
        _classCallCheck(this, ShapeFactory);

        /**
         * APIProperty: shapeParameters
         * {Object} 图形参数对象， <SuperMap.Feature.ShapeParameters> 子类对象。必设参数，默认值 null。
         */
        this.shapeParameters = shapeParameters;

        this.CLASS_NAME = "SuperMap.Feature.ShapeFactory";
    }

    /**
     * APIMethod: destroy
     * 销毁图形工厂类对象。
     */


    _createClass(ShapeFactory, [{
        key: 'destroy',
        value: function destroy() {
            this.shapeParameters = null;
        }

        /**
         * APIMethod: createShape
         * 创建一个图形。具体图形由 shapeParameters 决定。
         *
         * Parameters:
         * shapeParameters - {Object} 图形参数对象， <SuperMap.Feature.ShapeParameters> 子类对象。
         * 此参数可选，如果使用此参数（不为 null），shapeParameters 属性值将被修改为参数的值，然后再使用 shapeParameters 属性值创建图形；
         * 如果不使用此参数，createShape 方法将直接使用 shapeParameters 属性创建图形。
         *
         * Returns:
         * {Object} - 图形对象（或 null - 图形创建失败）。
         */

    }, {
        key: 'createShape',
        value: function createShape(shapeParameters) {
            if (shapeParameters) {
                this.shapeParameters = shapeParameters;
            }

            if (!this.shapeParameters) {
                return null;
            }

            var sps = this.shapeParameters;

            if (sps instanceof _Point.Point) {
                // 点
                //设置style
                var style = new Object();
                style["x"] = sps.x;
                style["y"] = sps.y;
                style["r"] = sps.r;

                style = _Util.Util.copyAttributesWithClip(style, sps.style, ['x', 'y']);

                //创建图形
                var shape = new _SmicPoint.SmicPoint();
                shape.style = ShapeFactory.transformStyle(style);
                shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'style', 'highlightStyle']);

                return shape;
            } else if (sps instanceof _Line.Line) {
                // 线
                //检查参数 pointList 是否存在
                if (!sps.pointList) {
                    return null;
                }

                // 设置style
                var _style = new Object();
                _style["pointList"] = sps.pointList;
                _style = _Util.Util.copyAttributesWithClip(_style, sps.style, ['pointList']);

                // 创建图形
                var _shape = new _SmicBrokenLine.SmicBrokenLine();
                _shape.style = ShapeFactory.transformStyle(_style);
                _shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape, sps, ['pointList', 'style', 'highlightStyle']);

                return _shape;
            } else if (sps instanceof _Polygon.Polygon) {
                // 面
                //检查参数 pointList 是否存在
                if (!sps.pointList) {
                    return null;
                }

                //设置style
                var _style2 = new Object();
                _style2["pointList"] = sps.pointList;
                _style2 = _Util.Util.copyAttributesWithClip(_style2, sps.style, ['pointList']);

                //创建图形
                var _shape2 = new _SmicPolygon.SmicPolygon();
                _shape2.style = ShapeFactory.transformStyle(_style2);
                _shape2.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape2, sps, ['pointList', 'style', "highlightStyle"]);

                return _shape2;
            } else if (sps instanceof _Rectangle.Rectangle) {
                // 矩形
                //检查参数 pointList 是否存在
                if (!sps.x && !sps.y & !sps.width & !sps.height) {
                    return null;
                }

                //设置style
                var _style3 = new Object();
                _style3["x"] = sps.x;
                _style3["y"] = sps.y;
                _style3["width"] = sps.width;
                _style3["height"] = sps.height;

                _style3 = _Util.Util.copyAttributesWithClip(_style3, sps.style, ['x', 'y', 'width', 'height']);

                //创建图形
                var _shape3 = new _SmicRectangle.SmicRectangle();
                _shape3.style = ShapeFactory.transformStyle(_style3);
                _shape3.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape3, sps, ['x', 'y', 'width', 'height', 'style', 'highlightStyle']);

                return _shape3;
            } else if (sps instanceof _Sector.Sector) {
                // 扇形
                //设置style
                var _style4 = new Object();
                _style4["x"] = sps.x;
                _style4["y"] = sps.y;
                _style4["r"] = sps.r;
                _style4["startAngle"] = sps.startAngle;
                _style4["endAngle"] = sps.endAngle;
                if (sps["r0"]) {
                    _style4["r0"] = sps.r0;
                }

                if (sps["clockWise"]) {
                    _style4["clockWise"] = sps.clockWise;
                }

                _style4 = _Util.Util.copyAttributesWithClip(_style4, sps.style, ['x', 'y', 'r', 'startAngle', 'endAngle', 'r0', 'endAngle']);

                //创建图形
                var _shape4 = new _SmicSector.SmicSector();
                _shape4.style = ShapeFactory.transformStyle(_style4);
                _shape4.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape4, sps, ['x', 'y', 'r', 'startAngle', 'endAngle', 'r0', 'endAngle', 'style', 'highlightStyle']);

                return _shape4;
            } else if (sps instanceof _Label.Label) {
                // 标签
                //设置style
                var _style5 = new Object();
                _style5["x"] = sps.x;
                _style5["y"] = sps.y;
                _style5["text"] = sps.text;

                _style5 = _Util.Util.copyAttributesWithClip(_style5, sps.style, ['x', 'y', 'text']);

                //创建图形
                var _shape5 = new _SmicText.SmicText();
                _shape5.style = ShapeFactory.transformStyle(_style5);
                _shape5.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape5, sps, ['x', 'y', 'text', 'style', 'highlightStyle']);

                return _shape5;
            } else if (sps instanceof _Image.Image) {
                // 图片
                //设置style
                var _style6 = new Object();
                _style6["x"] = sps.x;
                _style6["y"] = sps.y;
                if (sps["image"]) {
                    _style6["image"] = sps.image;
                }
                if (sps["width"]) {
                    _style6["width"] = sps.width;
                }
                if (sps["height"]) {
                    _style6["height"] = sps.height;
                }
                if (sps["sx"]) {
                    _style6["sx"] = sps.sx;
                }
                if (sps["sy"]) {
                    _style6["sy"] = sps.sy;
                }
                if (sps["sWidth"]) {
                    _style6["sWidth"] = sps.sWidth;
                }
                if (sps["sHeight"]) {
                    _style6["sHeight"] = sps.sHeight;
                }

                _style6 = _Util.Util.copyAttributesWithClip(_style6, sps.style, ['x', 'y', 'image', 'width', 'height', 'sx', 'sy', 'sWidth', 'sHeight']);

                //创建图形
                var _shape6 = new _SmicImage.SmicImage();
                _shape6.style = ShapeFactory.transformStyle(_style6);
                _shape6.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape6, sps, ['x', 'y', 'image', 'width', 'height', 'style', 'highlightStyle']);

                return _shape6;
            } else if (sps instanceof _Circle.Circle) {
                //圆形 用于符号专题图
                //设置stytle
                var _style7 = new Object();
                _style7["x"] = sps.x;
                _style7["r"] = sps.r;
                _style7["y"] = sps.y;

                _style7 = _Util.Util.copyAttributesWithClip(_style7, sps.style, ['x', 'y', 'r']);

                //创建图形
                var _shape7 = new _SmicCircle.SmicCircle();
                _shape7.style = new ShapeFactory.transformStyle(_style7);
                _shape7.highlightStyle = new ShapeFactory.transformStyle(sps.highlightStyle);
                _Util.Util.copyAttributesWithClip(_shape7, sps, ['x', 'y', 'r', 'style', 'highlightStyle', 'lineWidth', 'text', 'textPosition']);

                return _shape7;
            }

            return null;
        }

        /**
         * Function: ShapeFactory.transformStyle
         * 将用户 feature.style (类 Svg style 标准) 的样式，转换为 levelRenderer 的样式标准（类 CSS-Canvas 样式）
         *
         * Parameters:
         * style - {Object} 用户 style。
         *
         * Returns:
         * {Object} 符合 levelRenderer 的 tyle。
         */

    }], [{
        key: 'transformStyle',
        value: function transformStyle(style) {
            var newStyle = {};

            //字体 ["font-style", "font-variant", "font-weight", "font-size / line-height", "font-family"];
            var fontStr = ["normal", "normal", "normal", "12", "arial,sans-serif"];

            //画笔类型 ["fill", "stroke"];
            var brushType = [true, false];

            for (var ss in style) {
                switch (ss) {
                    case "fill":
                        brushType[0] = style[ss];
                        break;
                    case "fillColor":
                        newStyle["color"] = style[ss];
                        break;
                    case "stroke":
                        brushType[1] = style[ss];
                        break;
                    case "strokeWidth":
                        newStyle["lineWidth"] = style[ss];
                        break;
                    case "strokeLinecap":
                        newStyle["lineCap"] = style[ss];
                        break;
                    case "strokeLineJoin":
                        newStyle["lineJoin"] = style[ss];
                        break;
                    case "strokeDashstyle":
                        newStyle["lineType"] = style[ss];
                        break;
                    case "pointRadius":
                        newStyle["r"] = style[ss];
                        break;
                    case "label":
                        newStyle["text"] = style[ss];
                        break;
                    case "labelRect":
                        newStyle["labelRect"] = style[ss];
                        break;
                    case "fontColor":
                        newStyle["textColor"] = style[ss];
                        break;
                    case "fontStyle":
                        fontStr[0] = style[ss];
                        break;
                    case "fontVariant":
                        fontStr[1] = style[ss];
                        break;
                    case "fontWeight":
                        fontStr[2] = style[ss];
                        break;
                    case "fontSize":
                        var unit = "";
                        if (style[ss] && style[ss].toString().indexOf("px") < 0) {
                            unit = "px";
                        }
                        fontStr[3] = style[ss] + unit;
                        break;
                    case "fontFamily":
                        fontStr[4] = style[ss];
                        break;
                    case "fontOpacity":
                        newStyle["opacity"] = style[ss];
                        break;
                    case "labelPosition":
                        newStyle["textPosition"] = style[ss];
                        break;
                    case "labelAlign":
                        newStyle["textAlign"] = style[ss];
                        break;
                    case "labelBaseline":
                        newStyle["textBaseline"] = style[ss];
                        break;
                    case "labelRotation":
                        newStyle["textRotation"] = style[ss];
                        break;

                    default:
                        newStyle[ss] = style[ss];
                        break;
                }
            }

            //拼接字体字符串
            newStyle["textFont"] = fontStr.join(" ");

            //画笔类型
            if (brushType[0] === true && brushType[1] === false) {
                newStyle["brushType"] = "fill";
            } else if (brushType[0] === false && brushType[1] === true) {
                newStyle["brushType"] = "stroke";
            } else if (brushType[0] === true && brushType[1] === true) {
                newStyle["brushType"] = "both";
            } else {
                newStyle["brushType"] = "fill";
            }

            //默认线宽 1
            if (newStyle["lineWidth"] == null) {
                newStyle["lineWidth"] = 1;
            }

            return newStyle;
        }

        /**
         * APIFunction: ShapeFactory.Background
         * 创建一个矩形背景框图形对象。
         *
         * Parameters:
         * shapeFactory - {<SuperMap.Feature.ShapeFactory>} 图形工厂对象，必设参数。
         * box - {Array{Number}} 框区域，长度为 4 的一维数组，像素坐标，[left bottom right top]，必设参数。
         * setting - {Object} 图表配置参数，必设参数。
         *
         * 本函数中图形配置对象 setting 可设属性：
         *
         * Symbolizer properties:
         * backgroundStyle - {Object} 背景样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Rectangle::style>。
         * backgroundRadius - {Array} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 
         * 则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0 0 0 0]。
         *
         * Returns:
         * {Object} 背景框图形，一个可视化图形（矩形）对象。
         */

    }, {
        key: 'Background',
        value: function Background(shapeFactory, box, setting) {
            var sets = setting ? setting : {};

            // 背景框图形参数对象
            var bgSP = new _Rectangle.Rectangle(box[0], box[3], Math.abs(box[2] - box[0]), Math.abs(box[3] - box[1]));

            // 默认样式
            bgSP.style = {
                fillColor: "#f3f3f3"
            };

            // 设置用户 style
            if (sets.backgroundStyle) {
                _Util.Util.copyAttributesWithClip(bgSP.style, sets.backgroundStyle);
            }

            // 设置背景框圆角参数
            if (sets.backgroundRadius) {
                bgSP.style["radius"] = sets.backgroundRadius;
            }

            // 禁止背景框响应事件
            bgSP.clickable = false;
            bgSP.hoverable = false;

            return shapeFactory.createShape(bgSP);
        }

        /**
         * APIFunction: ShapeFactory.GraphAxis
         * 创建一个统计图表坐标轴图形对象组。
         *
         * Parameters:
         * shapeFactory - {<SuperMap.Feature.ShapeFactory>} 图形工厂对象，必设参数。
         * dataViewBox - {Array{Number}} 统计图表模型的数据视图框，长度为 4 的一维数组，像素坐标，[left bottom right top]，必设参数。
         * setting - {Object} 图表配置参数，必设参数。
         * xShapeInfo - {Object} X 方向上的图形信息对象，包含两个属性，
         * 属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
         * 如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         * width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         * xShapeInfo 包含两个属性
         *
         * Symbolizer properties:
         * xPositions - {Array{Number}} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         * width - {Number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         *
         * 本函数中图形配置对象 setting 可设属性：
         *
         * Symbolizer properties:
         * axisStyle - {Object} 坐标轴样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。
         * axisUseArrow - {Boolean} 坐标轴是否使用箭头，默认值：false，不使用箭头。
         * axisYTick - {Number} y 轴刻度数量，默认值：0 ，不使用刻度。
         * axisYLabels - {Array{String}} y 轴上的标签组内容，标签顺序沿着数据视图框左面条边自上而下，等距排布。例如：["1000" "750" "500" "250" "0"]。
         * axisYLabelsStyle - {Object} y 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。
         * axisYLabelsOffset - {Array{Number}} y 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 y 轴标签组横向上的偏移量，向左为正，默认值：0；
         * 数组第二项表示 y 轴标签组纵向上的偏移量，向下为正，默认值：0。
         * axisXLabels - {Array{String}} x 轴上的标签组内容，标签顺序沿着数据视图框下面条边自左向右排布，例如：["92年" "95年" "99年"]。
         * 标签排布规则：当标签数量与 xShapeInfo 中的属性 xPositions 数量相同（即标签个数与数据个数相等时） 按照 xPositions 提供的位置在水平方向上排布标签，
         * 否则沿数据视图框下面条边等距排布标签。
         * axisXLabelsStyle - {Object} x 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。
         * axisXLabelsOffset - {Array{Number}} x 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 x 轴标签组横向上的偏移量，向左为正，默认值：0；
         * 数组第二项表示 x 轴标签组纵向上的偏移量，向下为正，默认值：0。
         * useXReferenceLine - {Boolean) 是否使用水平参考线，如果为 true，在 axisYTick 大于 0 时有效，水平参考线是 y 轴刻度在数据视图框里的延伸。
        * xReferenceLineStyle - {Object) 水平参考线样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。
        * axis3DParameter - {Number} 3D 坐标轴参数，此属性值在大于等于 15 时有效，默认值：0。
        *
        * Returns:
        * {Array{Object}} 统计图表坐标轴图形对象数组。
        */

    }, {
        key: 'GraphAxis',
        value: function GraphAxis(shapeFactory, dataViewBox, setting, xShapeInfo) {
            var dvb = dataViewBox;
            var sets = setting ? setting : {};

            // 参考线图形对象组
            var refLines = [];
            //坐标轴箭头对象组
            var arrows = [];
            // 是否使用参水平考线，默认不使用
            var isAddRefLine = sets.useXReferenceLine ? sets.useXReferenceLine : false;
            // y 轴上的刻度
            var axisytick = sets.axisYTick && !isNaN(sets.axisYTick) ? sets.axisYTick : 0;
            // 坐标轴节点数组
            var pois = [];
            //z 轴箭头数组
            var zArrowPois = [];
            // x,y 轴主干节点数组
            var xMainPois = [];
            if (axisytick == 0) {
                xMainPois.push([dvb[0], dvb[3] - 5]);
                xMainPois.push([dvb[0], dvb[1]]);

                // 3D 坐标轴  第三象限平分线
                if (sets.axis3DParameter && !isNaN(sets.axis3DParameter) && sets.axis3DParameter >= 15) {
                    var axis3DParameter = parseInt(sets.axis3DParameter);
                    var axis3DPoi = [dvb[0] - axis3DParameter, dvb[1] + axis3DParameter];

                    // 添加 3D 轴节点
                    if (sets.axisUseArrow) {
                        // 添加 3D 轴箭头节点坐标
                        //箭头坐标
                        zArrowPois.push([axis3DPoi[0] + 1.5, axis3DPoi[1] - 7.5]);
                        zArrowPois.push([axis3DPoi[0] - 1, axis3DPoi[1] + 1]);
                        zArrowPois.push([axis3DPoi[0] + 7.5, axis3DPoi[1] - 1.5]);
                        //3D轴
                        xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                    } else {
                        xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                    }

                    xMainPois.push([dvb[0], dvb[1]]);
                }
                xMainPois.push([dvb[2] + 5, dvb[1]]);
            } else {
                // 单位刻度长度
                var unitTick = Math.abs(dvb[1] - dvb[3]) / axisytick;
                // 刻度 y 坐标
                var thckY = dvb[3];

                xMainPois.push([dvb[0], thckY - 5]);

                for (var i = 0; i < axisytick; i++) {
                    xMainPois.push([dvb[0], thckY]);
                    xMainPois.push([dvb[0] - 5, thckY]);
                    xMainPois.push([dvb[0], thckY]);

                    // 参考线
                    if (isAddRefLine) {
                        // 参考线参数对象
                        var refLineSP = new _Line.Line([[dvb[0], thckY], [dvb[2], thckY]]);
                        // 参考线默认样式对象
                        refLineSP.style = {
                            strokeColor: "#cfcfcf",
                            strokeLinecap: "butt",
                            strokeLineJoin: "round",
                            strokeWidth: 1
                        };
                        // 禁止事件
                        refLineSP.clickable = false;
                        refLineSP.hoverable = false;
                        // 用户style
                        if (sets.xReferenceLineStyle) {
                            _Util.Util.copyAttributesWithClip(refLineSP.style, sets.xReferenceLineStyle);
                        }
                        // 生成参考线图形对象
                        refLines.push(shapeFactory.createShape(refLineSP));
                    }

                    // y 刻度增量
                    thckY += unitTick;
                }

                xMainPois.push([dvb[0], dvb[1]]);

                // 3D 坐标轴  第三象限平分线
                if (sets.axis3DParameter && !isNaN(sets.axis3DParameter) && sets.axis3DParameter >= 15) {
                    var _axis3DParameter = parseInt(sets.axis3DParameter);
                    var _axis3DPoi = [dvb[0] - _axis3DParameter, dvb[1] + _axis3DParameter];

                    /*
                     // 箭头计算过程
                     var axis3DPoiRef = [axis3DPoi[0] + 7, axis3DPoi[1] - 7];  // 7 是 10 为斜边 cos（45度）时邻边的值
                     var axis3DPoiLT = [axis3DPoiRef[0] - 4, axis3DPoiRef[1] - 4];
                     var axis3DPoiRB = [axis3DPoiRef[0] + 4, axis3DPoiRef[1] + 4];
                     if(sets.axisUseArrow){
                     xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                     xMainPois.push([axis3DPoiLT[0], axis3DPoiLT[1]]);
                     xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                     xMainPois.push([axis3DPoiRB[0], axis3DPoiRB[1]]);
                     xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                     }
                     else{
                     xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                     }
                     */

                    // 添加 3D 轴节点
                    if (sets.axisUseArrow) {
                        // 添加 3D 轴和箭头坐标
                        //箭头坐标
                        zArrowPois.push([_axis3DPoi[0] + 1.5, _axis3DPoi[1] - 7.5]);
                        zArrowPois.push([_axis3DPoi[0] - 1, _axis3DPoi[1] + 1]);
                        zArrowPois.push([_axis3DPoi[0] + 7.5, _axis3DPoi[1] - 1.5]);
                        //3D轴
                        xMainPois.push([_axis3DPoi[0], _axis3DPoi[1]]);
                    } else {
                        xMainPois.push([_axis3DPoi[0], _axis3DPoi[1]]);
                    }

                    xMainPois.push([dvb[0], dvb[1]]);
                }

                xMainPois.push([dvb[2] + 5, dvb[1]]);
            }
            // 坐标轴箭头
            if (sets.axisUseArrow) {
                // x 轴箭头节点数组
                var xArrowPois = [[dvb[2] + 5, dvb[1] + 4], [dvb[2] + 13, dvb[1]], [dvb[2] + 5, dvb[1] - 4]];

                // y 轴箭头节点数组
                var yArrowPois = [[dvb[0] - 4, dvb[3] - 5], [dvb[0], dvb[3] - 13], [dvb[0] + 4, dvb[3] - 5]];

                //x轴箭头
                var xSP = new _Polygon.Polygon(xArrowPois);
                xSP.style = { fillColor: "#008acd" };
                _Util.Util.copyAttributesWithClip(xSP.style, sets.axisStyle);
                arrows.push(shapeFactory.createShape(xSP));

                //y轴箭头
                var ySP = new _Polygon.Polygon(yArrowPois);
                ySP.style = { fillColor: "#008acd" };
                _Util.Util.copyAttributesWithClip(ySP.style, sets.axisStyle);
                arrows.push(shapeFactory.createShape(ySP));

                // z轴箭头 坐标轴箭头是否要使用
                if (sets.axis3DParameter && !isNaN(sets.axis3DParameter) && sets.axis3DParameter >= 15) {
                    var zSP = new _Polygon.Polygon(zArrowPois);
                    zSP.style = { fillColor: "#008acd" };
                    _Util.Util.copyAttributesWithClip(zSP.style, sets.axisStyle);
                    arrows.push(shapeFactory.createShape(zSP));
                }
            }
            //不带箭头的坐标轴
            pois = xMainPois;

            // 坐标轴参数对象
            var axisSP = new _Line.Line(pois);
            // 坐标轴默认style
            axisSP.style = {
                strokeLinecap: "butt",
                strokeLineJoin: "round",
                strokeColor: "#008acd",
                strokeWidth: 1
            };
            // 用户 style
            if (sets.axisStyle) {
                _Util.Util.copyAttributesWithClip(axisSP.style, sets.axisStyle);
            }
            // 禁止事件
            axisSP.clickable = false;
            axisSP.hoverable = false;
            // 创建坐标轴图形对象
            var axisMain = [shapeFactory.createShape(axisSP)];

            // Y 轴标签
            var yLabels = [];
            if (sets.axisYLabels && sets.axisYLabels.length && sets.axisYLabels.length > 0) {
                var axisYLabels = sets.axisYLabels;
                var len = axisYLabels.length;

                // 标签偏移量
                var ylOffset = [0, 0];
                if (sets.axisYLabelsOffset && sets.axisYLabelsOffset.length) {
                    ylOffset = sets.axisYLabelsOffset;
                }

                if (len == 1) {
                    // 标签参数对象
                    var labelYSP = new _Label.Label(dvb[0] - 5 + ylOffset[0], dvb[3] + ylOffset[1], axisYLabels[0]);
                    labelYSP.style = {
                        labelAlign: "right"
                    };
                    // 用户 style
                    if (sets.axisYLabelsStyle) {
                        _Util.Util.copyAttributesWithClip(labelYSP.style, sets.axisYLabelsStyle);
                    }
                    // 禁止事件
                    labelYSP.clickable = false;
                    labelYSP.hoverable = false;
                    // 制作标签
                    yLabels.push(shapeFactory.createShape(labelYSP));
                } else {
                    var labelY = dvb[3];
                    // y 轴标签单位距离
                    var yUnit = Math.abs(dvb[1] - dvb[3]) / (len - 1);

                    for (var j = 0; j < len; j++) {
                        // 标签参数对象
                        var _labelYSP = new _Label.Label(dvb[0] - 5 + ylOffset[0], labelY + ylOffset[1], axisYLabels[j]);
                        _labelYSP.style = {
                            labelAlign: "right"
                        };
                        // 用户 style
                        if (sets.axisYLabelsStyle) {
                            _Util.Util.copyAttributesWithClip(_labelYSP.style, sets.axisYLabelsStyle);
                        }
                        // 禁止事件
                        _labelYSP.clickable = false;
                        _labelYSP.hoverable = false;
                        // 制作标签
                        yLabels.push(shapeFactory.createShape(_labelYSP));
                        // y 轴标签 y 方向增量
                        labelY += yUnit;
                    }
                }
            }

            // X 轴标签
            var xLabels = [];
            if (sets.axisXLabels && sets.axisXLabels.length && sets.axisXLabels.length > 0) {
                var axisXLabels = sets.axisXLabels;
                var _len = axisXLabels.length;

                // 标签偏移量
                var xlOffset = [0, 0];
                if (sets.axisXLabelsOffset && sets.axisXLabelsOffset.length) {
                    xlOffset = sets.axisXLabelsOffset;
                }

                // 标签个数与数据字段个数相等等时，标签在 x 轴均匀排列
                if (xShapeInfo && xShapeInfo.xPositions && xShapeInfo.xPositions.length && xShapeInfo.xPositions.length == _len) {
                    var xsCenter = xShapeInfo.xPositions;
                    for (var K = 0; K < _len; K++) {
                        // 标签参数对象
                        var labelXSP = new _Label.Label(xsCenter[K] + xlOffset[0], dvb[1] + xlOffset[1], axisXLabels[K]);
                        // 默认 style
                        labelXSP.style = {
                            labelAlign: "center",
                            labelBaseline: "top"
                        };
                        // 用户 style
                        if (sets.axisXLabelsStyle) {
                            _Util.Util.copyAttributesWithClip(labelXSP.style, sets.axisXLabelsStyle);
                        }
                        // 禁止事件
                        labelXSP.clickable = false;
                        labelXSP.hoverable = false;
                        // 创建标签对象
                        xLabels.push(shapeFactory.createShape(labelXSP));
                    }
                } else {
                    if (_len == 1) {
                        // 标签参数对象
                        var _labelXSP = new _Label.Label(dvb[0] - 5 + xlOffset[0], dvb[1] + xlOffset[0], axisXLabels[0]);
                        // 默认 style
                        _labelXSP.style = {
                            labelAlign: "center",
                            labelBaseline: "top"
                        };
                        // 用户 style
                        if (sets.axisXLabelsStyle) {
                            _Util.Util.copyAttributesWithClip(_labelXSP.style, sets.axisXLabelsStyle);
                        }
                        // 禁止事件
                        _labelXSP.clickable = false;
                        _labelXSP.hoverable = false;
                        // 创建标签对象
                        xLabels.push(shapeFactory.createShape(_labelXSP));
                    } else {
                        var labelX = dvb[0];
                        // x 轴标签单位距离
                        var xUnit = Math.abs(dvb[2] - dvb[0]) / (_len - 1);

                        for (var m = 0; m < _len; m++) {
                            // 标签参数对象
                            var _labelXSP2 = new _Label.Label(labelX + xlOffset[0], dvb[1] + xlOffset[1], axisXLabels[m]);
                            // 默认 style
                            _labelXSP2.style = {
                                labelAlign: "center",
                                labelBaseline: "top"
                            };
                            // 用户 style
                            if (sets.axisXLabelsStyle) {
                                _Util.Util.copyAttributesWithClip(_labelXSP2.style, sets.axisXLabelsStyle);
                            }
                            // 禁止事件
                            _labelXSP2.clickable = false;
                            _labelXSP2.hoverable = false;
                            // 创建标签对象
                            xLabels.push(shapeFactory.createShape(_labelXSP2));
                            // x 轴标签 x 方向增量
                            labelX += xUnit;
                        }
                    }
                }
            }

            // 组装并返回构成坐标轴的图形
            return refLines.concat(axisMain).concat(yLabels).concat(xLabels).concat(arrows);
        }

        /**
         * APIFunction: ShapeFactory.ShapeStyleTool
         * 一个图形 style 处理工具。此工具将指定的默认 style，通用 style，按 styleGroup 取得的 style 和按数据值 value 范围取得的 style 进行合并，得到图形最终的 style。
         *
         * Parameters:
         * defaultStyle - {Object} 默认 style，此样式对象可设属性根据图形类型参考 <SuperMap.Feature.ShapeParameters> 子类对象的 style 属性。
         * style - {Object} 图形对象基础 style，此参数控制图形的基础样式，
         * 可设属性根据图形类型参考 <SuperMap.Feature.ShapeParameters> 子类对象的 style 属性。
         * 优先级低于 styleGroup，styleByCodomain。
         * styleGroup - {Array{Object}} 一个 style 数组，优先级低于 styleByCodomain，高于 style。
         * 此数组每个元素是样式对象，其可设属性根据图形类型参考 <SuperMap.Feature.ShapeParameters> 子类对象的 style 属性。
         * 通过 index 参数从 styleGroup 中取 style。
         * styleByCodomain - {Array{Object}} 按数据（参数 value）所在值域范围控制数据的可视化对象样式。
         * (start code)
         * // styleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
         * // start: 值域值下限（包含）;
         * // end: 值域值上限（不包含）;
         * // style: 数据可视化图形的 style，其可设属性根据图形类型参考 <SuperMap.Feature.ShapeParameters> 子类对象的 style 属性。。
         * // dataStyleByCodomain 数组形如：
         * [
         *   {
        *     start:0
        *     end:250
        *     style:{
        *          fillColor:"#00CD00"
        *      }
        *  }
         *   {
        *     start:250
        *     end:500
        *     style:{
        *          fillColor:"#00EE00"
        *      }
        *  }
         *   {
        *     start:500
        *     end:750
        *     style:{
        *          fillColor:"#00FF7F"
        *      }
        *  }
         *   {
        *     start:750
        *     end:1500
        *     style:{
        *          fillColor:"#00FF00"
        *      }
        *  }
         * ]
         * (end)
         * index - {Number} styleGroup 的索引值，用于取出 styleGroup 指定的 style。
         * value - {Number} 数据值，用于取出 styleByCodomain 指定的 style。
         *
         * Returns:
         * {Object} 合并后的样式 （style） 对象。
         */

    }, {
        key: 'ShapeStyleTool',
        value: function ShapeStyleTool(defaultStyle, style, styleGroup, styleByCodomain, index, value) {
            // 用 defaultStyle 初始化 style 对象
            var finalStyle = defaultStyle ? defaultStyle : {};

            // 基础 style
            if (style) {
                _Util.Util.copyAttributesWithClip(finalStyle, style);
            }

            // 按索引赋 style
            if (styleGroup && styleGroup.length && typeof index !== "undefined" && !isNaN(index) && index >= 0) {
                if (styleGroup[index]) {
                    _Util.Util.copyAttributesWithClip(finalStyle, styleGroup[index]);
                }
            }

            // 按值域赋 style
            if (styleByCodomain && styleByCodomain.length && typeof value !== "undefined") {
                var dsc = styleByCodomain;
                var dscLen = dsc.length;
                var v = parseFloat(value);
                for (var i = 0; i < dscLen; i++) {
                    if (dsc[i].start <= v && v < dsc[i].end) {
                        _Util.Util.copyAttributesWithClip(finalStyle, dsc[i].style);
                        break;
                    }
                }
            }

            return finalStyle;
        }
    }]);

    return ShapeFactory;
}();

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeFactory = ShapeFactory;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShapeParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters
 * 图形参数基类，此类不可实例化
 */
var ShapeParameters = exports.ShapeParameters = function () {

  /**
   * Constructor: SuperMap.Feature.ShapeParameters
   * 图形参数对象。
   *
   * Returns:
   * {Object} 图形参数对象。
   */
  function ShapeParameters() {
    _classCallCheck(this, ShapeParameters);

    /**
     * APIProperty: refOriginalPosition
     * {Array} 图形参考原点位置，图形的参考中心位置。
     * refOriginalPosition 是长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
     *
     * refOriginalPosition 表示图形的参考中心，通常情况下，图形是使用 canvas 的原点位置作为位置参考，
     * 但 refOriginalPosition 可以改变图形的参考位置，例如： refOriginalPosition = [80, 80],
     * 图形圆的 style.x = 20, style.y = 20，那么圆在 canvas 中的实际位置是 [100, 100]。
     *
     * 图形（Shape） 的所有位置相关属性都是以 refOriginalPosition 为参考中心，
     * 也就是说图形的所有位置信息在 canvas 中都是以 refOriginalPosition 为参考的相对位置，只有
     * refOriginalPosition 的值为 [0, 0] 时，图形的位置信息才是 canvas 绝对位置。
     *
     * 图形的位置信息通常有：style.pointList，style.x，style.y。
     *
     * refOriginalPosition。默认值是： [0, 0]。
     */
    this.refOriginalPosition = [0, 0];

    /**
     * APIProperty: refDataID
     * {String} 图形所关联数据的 ID （ <SuperMap.Feature.Vector> 的 id ）。
     */
    this.refDataID = null;

    /**
     * APIProperty: isHoverByRefDataID
     * {Boolean} 是否根据 refDataID 进行高亮。用于同时高亮所有 refDataID 相同的图形。
     */
    this.isHoverByRefDataID = false;

    /**
     * APIProperty: refDataHoverGroup
     * {String} 高亮图形组的组名。此属性在 refDataID 有效且 isHoverByRefDataID 为 true 时生效。
     * 一旦设置此属性，且属性值有效，只有关联同一个数据的图形且此属性相同的图形才会高亮。
     */
    this.refDataHoverGroup = null;

    /**
     * APIProperty: dataInfo
     * {Object} 图形携带的附加数据。
     */
    this.dataInfo = null;

    /**
     * APIProperty: clickable
     * {Boolean} 是否可点击。
     */
    this.clickable = true;

    /**
     * APIProperty: hoverable
     * {Boolean} 是否可 hover。
     */
    this.hoverable = true;

    /**
     * Property: style。
     * {Object} 图形样式对象，可设样式属性在子类中确定。
     */
    this.style = null;

    /**
     * Property: highlightStyle
     * {Object} 高亮样式对象，可设样式属性与 style 的可设样式属性相同。
     */
    this.highlightStyle = {};

    this.CLASS_NAME = "SuperMap.Feature.ShapeParameters";
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(ShapeParameters, [{
    key: "destroy",
    value: function destroy() {
      this.refOriginalPosition = null;
      this.refDataID = null;
      this.isHoverByRefDataID = null;
      this.refDataHoverGroup = null;
      this.dataInfo = null;
      this.clickable = null;
      this.hoverable = null;
      this.style = null;
      this.highlightStyle = null;
    }
  }]);

  return ShapeParameters;
}();

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters = ShapeParameters;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Geometry = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// import {WKT} from '../format/WKT';
// import {Vector} from './Vector';


var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Geometry
 * @classdesc 几何对象类，描述地理对象的几何图形。
 */
var Geometry = exports.Geometry = function () {
    function Geometry() {
        _classCallCheck(this, Geometry);

        this.CLASS_NAME = "SuperMap.Geometry";
        /**
         * @member SuperMap.Geometry.prototype.id -{string}
         * @description  此几何对象的唯一标示符。
         *
         */
        this.id = _Util.Util.createUniqueID(this.CLASS_NAME + "_");

        /**
         * @member SuperMap.Geometry.prototype.parent -{SuperMap.Geometry}
         * @description This is set when a Geometry is added as component
         * of another geometry
         */
        this.parent = null;

        /**
         * @member SuperMap.Geometry.prototype.bounds -{SuperMap.Bounds}
         * @description 几何对象的范围
         *
         */
        this.bounds = null;

        /**
         * @member SuperMap.Geometry.prototype.SRID -{interger}
         * @description 投影坐标参数。通过该参数，服务器判断Geometry对象的坐标参考系是否与数据集相同，如果不同，则在数据入库前进行投影变换。
         * @example
         *   var geometry= new SuperMap.Geometry();
         *   geometry. SRID=4326;
         *
         */
        this.SRID = null;
    }

    /**
     * @function SuperMap.Geometry.prototype.destroy
     * @description 解构Geometry类，释放资源。
     */


    _createClass(Geometry, [{
        key: 'destroy',
        value: function destroy() {
            this.id = null;
            this.bounds = null;
            this.SRID = null;
        }

        /**
         * @function SuperMap.Geometry.prototype.clone
         * @description 创建克隆的几何图形。克隆的几何图形不设置非标准的属性。
         * @returns {SuperMap.Geometry} 克隆的几何图形。
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new Geometry();
        }

        /**
         * @function SuperMap.Geometry.prototype.setBounds
         * @description 设置此几何对象的bounds。
         * @param bounds - {SuperMap.Bounds}
         */

    }, {
        key: 'setBounds',
        value: function setBounds(bounds) {
            if (bounds) {
                this.bounds = bounds.clone();
            }
        }

        /**
         * @function SuperMap.Geometry.prototype.clearBounds
         * @description 清除几何对象的bounds。
         * 如果该对象有父类，也会清除父类几何对象的bounds。
         */

    }, {
        key: 'clearBounds',
        value: function clearBounds() {
            this.bounds = null;
            if (this.parent) {
                this.parent.clearBounds();
            }
        }

        /**
         * @function SuperMap.Geometry.prototype.extendBounds
         * @description Extend the existing bounds to include the new bounds.
         * If geometry's bounds is not yet set then set a new Bounds.
         *
         * @param newBounds - {SuperMap.Bounds}
         */

    }, {
        key: 'extendBounds',
        value: function extendBounds(newBounds) {
            var bounds = this.getBounds();
            if (!bounds) {
                this.setBounds(newBounds);
            } else {
                this.bounds.extend(newBounds);
            }
        }

        /**
         * @function SuperMap.Geometry.prototype.getBounds
         * @description 获得几何图形的边界。如果没有设置边界，可通过计算获得。
         * @returns {SuperMap.Bounds}返回的几何对象的边界。
         */

    }, {
        key: 'getBounds',
        value: function getBounds() {
            if (this.bounds == null) {
                this.calculateBounds();
            }
            return this.bounds;
        }

        /**
         * @function SuperMap.Geometry.prototype.calculateBounds
         * @description 重新计算几何图形的边界。（需要在子类中实现此方法）
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {}
        //
        // This should be overridden by subclasses.
        //


        /**
         * @function SuperMap.Geometry.prototype.getVertices
         * @description 返回几何图形的所有顶点的列表。（需要在子类中实现此方法）
         * @param nodes - {Boolean} 如果是true，线则只返回线的末端点，如果false，仅仅返回顶点，如果没有设置，则返回顶点。
         * @returns {Array} 几何图形的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {} // eslint-disable-line no-unused-vars


        /**
         * @function SuperMap.Geometry.prototype.getArea
         * @description 计算几何对象的面积 ，此方法需要在子类中定义  。
         * @returns {float} The area of the collection by summing its parts
         */

    }, {
        key: 'getArea',
        value: function getArea() {
            //to be overridden by geometries that actually have an area
            //
            return 0.0;
        }

        // /**
        //  * @function SuperMap.Geometry.prototype.toString
        //  * @description 返回geometry对象的字符串表述，需要引入{@link SuperMap.Format.WKT}。此方法只能在子类实现，在父类使用会报错。
        //  * @returns {string} geometry对象的字符串表述(Well-Known Text)
        //  */
        // toString() {
        // var string;
        // if (WKT) {
        //     var wkt = new WKT();
        //     string = wkt.write(new Vector(this));
        // } else {
        //     string = Object.prototype.toString.call(this);
        // }
        // return string;
        // }

    }]);

    return Geometry;
}();

_SuperMap.SuperMap.Geometry = Geometry;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Collection = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Bounds = __webpack_require__(22);

var _Geometry2 = __webpack_require__(26);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Collection
 * @classdesc 几何对象集合类，存储在本地的 components 属性中（可作为参数传递给构造函数）。<br>
 *            随着新的几何图形添加到集合中，将不能被克隆，当移动几何图形时，需要指定参照物。<br>
 *            getArea和getLength函数只能通过遍历存储几何对象的 components 数组，总计所有几何图形的面积和长度。
 *
 * @extends SuperMap.Geometry
 * @param components - {SuperMap.Geometry[]}几何对象数组。
 * @example
 * var point1 = new SuperMap.Geometry.Point(10,20);
 * var point2 = new SuperMap.Geometry.Point(30,40);
 * var col = new SuperMap.Geometry.Collection([point1,point2]);
 */
var Collection = exports.Collection = function (_Geometry) {
    _inherits(Collection, _Geometry);

    function Collection(components) {
        _classCallCheck(this, Collection);

        /**
         * @description 存储几何对象的数组。
         * @member SuperMap.Geometry.Collection.prototype.components -{Array<SuperMap.Geometry>}
         */
        var _this = _possibleConstructorReturn(this, (Collection.__proto__ || Object.getPrototypeOf(Collection)).call(this));

        _this.components = [];

        /**
         * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
         * @member SuperMap.Geometry.Collection.prototype.componentTypes -{Array<string>}
         */
        _this.componentTypes = null;
        if (components != null) {
            _this.addComponents(components);
        }
        _this.CLASS_NAME = "SuperMap.Geometry.Collection";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Collection.prototype.destroy
     * @description 销毁几何图形。
     */


    _createClass(Collection, [{
        key: 'destroy',
        value: function destroy() {
            this.components.length = 0;
            this.components = null;
            _get(Collection.prototype.__proto__ || Object.getPrototypeOf(Collection.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.clone
         * @description 克隆当前几何对象。
         * @returns {SuperMap.Geometry.Collection} 克隆的几何对象集合。
         */

    }, {
        key: 'clone',
        value: function clone() {
            var geometry = new Collection();
            for (var i = 0, len = this.components.length; i < len; i++) {
                geometry.addComponent(this.components[i].clone());
            }

            // catch any randomly tagged-on properties
            _Util.Util.applyDefaults(geometry, this);

            return geometry;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getComponentsString
         * @description 获取components字符串
         * @returns {string} components字符串
         */

    }, {
        key: 'getComponentsString',
        value: function getComponentsString() {
            var strings = [];
            for (var i = 0, len = this.components.length; i < len; i++) {
                strings.push(this.components[i].toShortString());
            }
            return strings.join(",");
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.calculateBounds
         * @description 通过遍历数组重新计算边界，在遍历每一子项中时调用 extend 方法。
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {
            this.bounds = null;
            var bounds = new _Bounds.Bounds();
            var components = this.components;
            if (components) {
                for (var i = 0, len = components.length; i < len; i++) {
                    bounds.extend(components[i].getBounds());
                }
            }
            // to preserve old behavior, we only set bounds if non-null
            // in the future, we could add bounds.isEmpty()
            if (bounds.left != null && bounds.bottom != null && bounds.right != null && bounds.top != null) {
                this.setBounds(bounds);
            }
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.addComponents
         * @description 给几何图形对象添加元素。
         * @param components -{Array<SuperMap.Geometry>} 几何对象组件。
         * @example
         * var collection = new SuperMap.Geometry.Collection();
         * collection.addComponents(new SuerpMap.Geometry.Point(1010));
         */

    }, {
        key: 'addComponents',
        value: function addComponents(components) {
            if (!_Util.Util.isArray(components)) {
                components = [components];
            }
            for (var i = 0, len = components.length; i < len; i++) {
                this.addComponent(components[i]);
            }
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.addComponent
         * @description 添加一个几何对象到集合中。如果设置了componentTypes类型，则添加的几何对象必须是componentTypes中的类型
         *
         * @param component - {SuperMap.Geometry} 待添加的几何对象
         * @param index - {int} 几何对象插入的位置
         *
         * @returns {Boolean} 是否添加成功
         */

    }, {
        key: 'addComponent',
        value: function addComponent(component, index) {
            var added = false;
            if (component) {
                if (this.componentTypes == null || _Util.Util.indexOf(this.componentTypes, component.CLASS_NAME) > -1) {

                    if (index != null && index < this.components.length) {
                        var components1 = this.components.slice(0, index);
                        var components2 = this.components.slice(index, this.components.length);
                        components1.push(component);
                        this.components = components1.concat(components2);
                    } else {
                        this.components.push(component);
                    }
                    component.parent = this;
                    this.clearBounds();
                    added = true;
                }
            }
            return added;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.removeComponents
         * @description 清除几何对象。
         *
         * @param components -{Array<SuperMap.Geometry>} 需要清除的几何对象。
         * @returns {Boolean} 元素是否被删除。
         */

    }, {
        key: 'removeComponents',
        value: function removeComponents(components) {
            var removed = false;

            if (!_Util.Util.isArray(components)) {
                components = [components];
            }
            for (var i = components.length - 1; i >= 0; --i) {
                removed = this.removeComponent(components[i]) || removed;
            }
            return removed;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.removeComponent
         * @description 从集合中移除一个几何对象
         * @param component -{SuperMap.Geometry} 要移除的几何对象
         * @returns {Boolean} 几何对象是否移除成功
         */

    }, {
        key: 'removeComponent',
        value: function removeComponent(component) {
            _Util.Util.removeItem(this.components, component);

            // clearBounds() so that it gets recalculated on the next call
            // to this.getBounds();
            this.clearBounds();
            return true;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getArea
         * @description 计算几何对象的面积。注意，这个方法在 <SuperMap.Geometry.Polygon> 类中需要重写。
         * @returns {number} 几何图形的面积，是几何对象中所有组成部分的面积之和。
         */

    }, {
        key: 'getArea',
        value: function getArea() {
            var area = 0.0;
            for (var i = 0, len = this.components.length; i < len; i++) {
                area += this.components[i].getArea();
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.equals
         * @description 判断两个几何图形是否相等。如果所有的 components 具有相同的坐标，则认为是相等的。
         * @param geometry - {SuperMap.Geometry} 需要判断的几何图形。
         * @returns {Boolean} 输入的几何图形与当前几何图形是否相等。
         */

    }, {
        key: 'equals',
        value: function equals(geometry) {
            var equivalent = true;
            if (!geometry || !geometry.CLASS_NAME || this.CLASS_NAME !== geometry.CLASS_NAME) {
                equivalent = false;
            } else if (!_Util.Util.isArray(geometry.components) || geometry.components.length !== this.components.length) {
                equivalent = false;
            } else {
                for (var i = 0, len = this.components.length; i < len; ++i) {
                    if (!this.components[i].equals(geometry.components[i])) {
                        equivalent = false;
                        break;
                    }
                }
            }
            return equivalent;
        }

        /**
         * @function SuperMap.Geometry.Collection.prototype.getVertices
         * @description 返回几何对象的所有结点的列表。
         * @param nodes - {Boolean} 对于线来说，仅仅返回作为端点的顶点，如果设为false，则返回非端点的顶点如果没有设置此参数，则返回所有顶点。
         * @returns {Array} 几何对象的顶点列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            var vertices = [];
            for (var i = 0, len = this.components.length; i < len; ++i) {
                Array.prototype.push.apply(vertices, this.components[i].getVertices(nodes));
            }
            return vertices;
        }
    }]);

    return Collection;
}(_Geometry2.Geometry);

_SuperMap.SuperMap.Geometry.Collection = Collection;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Graph = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Bounds = __webpack_require__(22);

var _Theme2 = __webpack_require__(77);

var _ShapeFactory = __webpack_require__(24);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Graph
 * @classdesc 统计专题要素基类。
 * @description 此类定义了统计专题要素基础模型，具体的图表模型通过继承此类，在子类中实现 assembleShapes 方法。
 *              统计专题要素模型采用了可视化图形大小自适应策略，用较少的参数控制着图表诸多图形，图表配置对象 <SuperMap.Feature.Theme.Graph::setting> 的基础属性只有 7 个，
 *              它们控制着图表结构、值域范围、数据小数位等基础图表形态。构成图表的图形必须在图表结构里自适应大小。
 *              此类不可实例化，此类的可实例化子类必须实现 assembleShapes() 方法。
 * @extends SuperMap.Feature.Theme
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.Theme} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @return {SuperMap.Feature.Theme.Graph} 返回一个统计专题要素。
 */
var Graph = exports.Graph = function (_Theme) {
    _inherits(Graph, _Theme);

    function Graph(data, layer, fields, setting, lonlat, options) {
        _classCallCheck(this, Graph);

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.shapeFactory -{SuperMap.Feature.ShapeFactory}
         * @description 内置的图形工厂对象，调用其 createShape 方法创建图形。
         */
        var _this = _possibleConstructorReturn(this, (Graph.__proto__ || Object.getPrototypeOf(Graph)).call(this, data, layer, fields, setting, lonlat, options));

        _this.shapeFactory = new _ShapeFactory.ShapeFactory();

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.shapeParameters -{Object}
         * @description 当前图形参数对象，<SuperMap.Feature.ShapeParameters> 的子类对象。
         */
        _this.shapeParameters = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.RelativeCoordinate -{bool}
         * @description 图形是否已经计算了相对坐标。
         */
        _this.RelativeCoordinate = false;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.setting -{Object}
         * @description 图表配置对象，该对象控制着图表的可视化显示。<br>
         *              下面是此配置对象的 7 个基础可设属性：<br>
         *              Symbolizer properties:<br>
         *              width - {number}专题要素（图表）宽度，必设参数。<br>
         *              height - {number}专题要素（图表）高度，必设参数。<br>
         *              codomain - {Array<number>} 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。<br>
         *              XOffset - {number}  专题要素（图表）在 X 方向上的偏移值，单位像素。<br>
         *              YOffset - {number}  专题要素（图表）在 Y 方向上的偏移值，单位像素。<br>
         *              dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，它是指图表框 chartBox
         *                                                    （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。<br>
         *              decimalNumber - {number}数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。
         *                                       如果不设置此参数，在取数据值时不对数据做小数位处理。<br>
         *              除了以上 7 个基础属性，此对象的可设属性在不同子类中有较大差异，不同子类中对同一属性的解释也可能不同。
         *              请在此类的子类中查看 setting 对象的可设属性和属性含义。
         */
        _this.setting = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.origonPoint - {Array<number>} {ReadOnly}
         * @description 专题要素（图表）原点，图表左上角点像素坐标，是长度为 2 的一维数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        _this.origonPoint = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.chartBox - {Array<number>} {ReadOnly}
         * @description 专题要素（图表）区域，即图表框，长度为 4 的一维数组，数组的 4 个元素依次表示图表框左端 x 坐标值、
         *              下端 y坐标值、 右端 x坐标值、 上端 y 坐标值；[left, bottom, right, top]。
         */
        _this.chartBox = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.chartBounds - {SuperMap.Bounds} {ReadOnly}
         * @description 图表 Bounds 随着 lonlat、XOffset、YOffset 更新，注意 chartBounds 是图表像素范围，不是地理范围。
         */
        _this.chartBounds = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.width - {number}{ReadOnly}
         * @description 专题要素（图表）宽度 ，必设属性。
         */
        _this.width = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.height - {number}{ReadOnly}
         * @description 专题要素（图表）高度 ，必设属性。
         */
        _this.height = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.XOffset - {number}{ReadOnly}
         * @description 专题要素（图表）在 X 方向上的偏移值，单位像素。
         */
        _this.XOffset = 0;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.YOffset - {number}{ReadOnly}
         * @description 专题要素（图表）在 Y 方向上的偏移值，单位像素。
         */
        _this.YOffset = 0;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBParameter - {Array<number>} {ReadOnly}
         * @description 数据视图框参数，长度为 4 的一维数组（数组元素值 >= 0），[leftOffset, bottomOffset, rightOffset, topOffset]，chartBox 内偏距值。
         *               此属性用于指定数据视图框 dataViewBox 的范围。
         */
        _this.DVBParameter = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.dataViewBox - {Array<number>} {ReadOnly}
         * @description 数据视图框，长度为 4 的一维数组，[left, bottom, right, top]。
         *              dataViewBox 是统计专题要素最核心的内容，它负责解释数据在一个像素区域里的数据可视化含义，
         *              这种含义用可视化图形表达出来，这些表示数据的图形和一些辅助图形组合在一起构成统计专题图表。
         */
        _this.dataViewBox = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBCodomain - {Array<number>} {ReadOnly}
         * @description 数据视图框的内允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
         *              dataViewBox 中允许的数据范围，对数据溢出值域范围情况的处理需要在 assembleShapes 中进行。
         */
        _this.DVBCodomain = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBCenterPoint - {Array<number>} {ReadOnly}
         * @description 数据视图框中心点，长度为 2 的一维数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        _this.DVBCenterPoint = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBUnitValue - {string} {ReadOnly}
         * @description 单位值。在 assembleShapes() 中初始化其具体意义，例如：饼图的 DVBUnitValue 可以定义为"360/数据总和"，
         *              折线图的 DVBUnitValue 可以定义为 "DVBCodomain/DVBHeight"。
         */
        _this.DVBUnitValue = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBOrigonPoint - {Array<number>} {ReadOnly}
         * @description 数据视图框原点，数据视图框左上角点，长度为 2 的一维数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        _this.DVBOrigonPoint = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBWidth - {number}{ReadOnly}
         * @description 数据视图框宽度。
         */
        _this.DVBWidth = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.DVBHeight - {number}{ReadOnly}
         * @description 数据视图框高度。
         */
        _this.DVBHeight = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.origonPointOffset - {Array<number>} {ReadOnly}
         * @description 数据视图框原点相对于图表框的原点偏移量，长度为 2 的一维数组，第一个元素表示 x 偏移量，第二个元素表示 y 偏移量。
         */
        _this.origonPointOffset = null;

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.fields - {Array<string>}
         * @description 数据{SuperMap.Feature.Vector}属性字段。
         */
        _this.fields = fields || [];

        /**
         * @member SuperMap.Feature.Theme.Graph.prototype.dataValues {Array<number>}
         * @description 图表展示的数据值，通过 fields 从数据feature属性中获得。
         */
        _this.dataValues = null;
        // 图表位置
        if (lonlat) {
            _this.lonlat = lonlat;
        } else {
            // 默认使用 bounds 中心
            _this.lonlat = _this.data.geometry.getBounds().getCenterLonLat();
        }

        // 配置项检测与赋值
        if (setting && setting.width && setting.height && setting.codomain) {
            _this.setting = setting;
        }
        _this.CLASS_NAME = "SuperMap.Feature.Theme.Graph";

        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Graph.prototype.destroy
     * @description 销毁专题要素。
     */


    _createClass(Graph, [{
        key: 'destroy',
        value: function destroy() {
            this.shapeFactory = null;
            this.shapeParameters = null;
            this.width = null;
            this.height = null;
            this.origonPoint = null;
            this.chartBox = null;
            this.dataViewBox = null;
            this.chartBounds = null;
            this.DVBParameter = null;
            this.DVBOrigonPoint = null;
            this.DVBCenterPoint = null;
            this.DVBWidth = null;
            this.DVBHeight = null;
            this.DVBCodomain = null;
            this.DVBUnitValue = null;
            this.origonPointOffset = null;
            this.XOffset = null;
            this.YOffset = null;
            this.fields = null;
            this.dataValues = null;
            this.setting = null;
            _get(Graph.prototype.__proto__ || Object.getPrototypeOf(Graph.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Graph.prototype.initBaseParameter
         * @description 初始化专题要素（图表）基础参数。在调用此方法前，此类的图表模型相关属性都是不可用的 ，此方法在 assembleShapes 函数中调用。<br>
         *              调用此函数关系到 setting 对象的以下属性。<br>
         *              width - {number} 专题要素（图表）宽度，必设参数。<br>
         *              height - {number} 专题要素（图表）高度，必设参数。<br>
         *              codomain - {Array<number>} 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。<br>
         *              XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。<br>
         *              YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。<br>
         *              dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，它是指图表框 chartBox。<br>
         *                                     （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。<br>
         *              decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。
         * @return {Boolean} 初始化参数是否成功。
         */

    }, {
        key: 'initBaseParameter',
        value: function initBaseParameter() {
            // 参数初始化是否成功
            var isSuccess = true;

            // setting 属性是否已成功赋值
            if (!this.setting) {
                return false;
            }
            var sets = this.setting;
            // 检测 setting 的必设参数
            if (!(sets.width && sets.height && sets.codomain)) {
                return false;
            }

            // 数据
            var decimalNumber = typeof sets.decimalNumber !== "undefined" && !isNaN(sets.decimalNumber) ? sets.decimalNumber : -1;
            var dataEffective = _Theme2.Theme.getDataValues(this.data, this.fields, decimalNumber);
            this.dataValues = dataEffective ? dataEffective : [];

            // 基础参数  width, height, codomain
            this.width = parseFloat(sets.width);
            this.height = parseFloat(sets.height);
            this.DVBCodomain = sets.codomain;

            // 图表偏移
            // if(sets.XOffset) {this.XOffset = sets.XOffset};
            // if(sets.YOffset) {this.YOffset = sets.YOffset};
            this.XOffset = sets.XOffset ? sets.XOffset : 0;
            this.YOffset = sets.YOffset ? sets.YOffset : 0;

            // 其他默认值
            this.origonPoint = [];
            this.chartBox = [];
            this.dataViewBox = [];

            this.DVBParameter = sets.dataViewBoxParameter ? sets.dataViewBoxParameter : [0, 0, 0, 0];

            this.DVBOrigonPoint = [];
            this.DVBCenterPoint = [];
            this.origonPointOffset = [];

            // 图表位置
            this.resetLocation();

            // 专题要素宽度 w
            var w = this.width;
            // 专题要素高度 h
            var h = this.height;
            // 专题要素像素位置 loc
            var loc = this.location;

            // 专题要素像素位置 loc
            this.origonPoint = [loc[0] - w / 2, loc[1] - h / 2];
            // 专题要素原点（左上角）
            var op = this.origonPoint;

            // 图表框（[left, bottom, right, top]）
            this.chartBox = [op[0], op[1] + h, op[0] + w, op[1]];
            // 图表框
            var cb = this.chartBox;

            // 数据视图框参数，它是图表框各方向对应的内偏距
            var dbbP = this.DVBParameter;
            // 数据视图框 （[left, bottom, right, top]）
            this.dataViewBox = [cb[0] + dbbP[0], cb[1] - dbbP[1], cb[2] - dbbP[2], cb[3] + dbbP[3]];
            // 数据视图框
            var dvb = this.dataViewBox;
            //检查数据视图框是否合法
            if (dvb[0] >= dvb[2] || dvb[1] <= dvb[3]) {
                return false;
            }

            // 数据视图框原点
            this.DVBOrigonPoint = [dvb[0], dvb[3]];
            // 数据视图框宽度
            this.DVBWidth = Math.abs(dvb[2] - dvb[0]);
            // 数据视图框高度
            this.DVBHeight = Math.abs(dvb[1] - dvb[3]);
            // 数据视图框中心点
            this.DVBCenterPoint = [this.DVBOrigonPoint[0] + this.DVBWidth / 2, this.DVBOrigonPoint[1] + this.DVBHeight / 2];

            // 数据视图框原点与图表框的原点偏移量
            this.origonPointOffset = [this.DVBOrigonPoint[0] - op[0], this.DVBOrigonPoint[1] - op[1]];

            return isSuccess;
        }

        /**
         * @function SuperMap.Feature.Theme.Graph.prototype.resetLocation
         * @description 根据地理位置 lonlat 重置专题要素（图表）位置。
         * @param lonlat - {SuperMap.LonLat} 专题要素新的像素中心位置。
         * @return {Array<number>} - 新专题要素像素参考位置。长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */

    }, {
        key: 'resetLocation',
        value: function resetLocation(lonlat) {
            if (lonlat) {
                this.lonlat = lonlat;
            }

            // 获取地理位置对应的像素坐标 newLocalLX
            var newLocalLX = this.getLocalXY(this.lonlat);
            // 处理偏移量 XOffset, YOffset
            newLocalLX[0] += this.XOffset;
            newLocalLX[1] += this.YOffset;
            // 将图形位置赋予  location 属性（注意 location 属性表示的是专题要素中心位置）
            this.location = newLocalLX;

            // 更新图表像素 Bounds
            var w = this.width;
            var h = this.height;
            var loc = this.location;
            this.chartBounds = new _Bounds.Bounds(loc[0] - w / 2, loc[1] + h / 2, loc[0] + w / 2, loc[1] - h / 2);

            //重新计算当前渐变色
            this.resetLinearGradient();

            return loc;
        }

        /**
         * @function SuperMap.Feature.Theme.Graph.prototype.resetLinearGradient
         * @description resetLocation中调用 图表的相对坐标存在的时候，重新计算渐变的颜色。(目前用于二维柱状图渐变色 所以子类实现此方法)
         */

    }, {
        key: 'resetLinearGradient',
        value: function resetLinearGradient() {}
        //子类实现此方法


        /**
         * @function SuperMap.Feature.Theme.Graph.prototype.shapesConvertToRelativeCoordinate
         * @description 将（构成图表）图形的节点转为相对坐标表示，此函数必须且只能在 assembleShapes() 结束时调用。
         */

    }, {
        key: 'shapesConvertToRelativeCoordinate',
        value: function shapesConvertToRelativeCoordinate() {
            var shapes = this.shapes;
            var shapeROP = this.location;
            for (var i = 0, len = shapes.length; i < len; i++) {
                shapes[i].refOriginalPosition = shapeROP;

                var style = shapes[i].style;

                for (var sty in style) {
                    switch (sty) {
                        case "pointList":
                            var pl = style[sty];
                            for (var j = 0, len2 = pl.length; j < len2; j++) {
                                pl[j][0] -= shapeROP[0];
                                pl[j][1] -= shapeROP[1];
                            }
                            break;
                        case "x":
                            style[sty] -= shapeROP[0];
                            break;
                        case "y":
                            style[sty] -= shapeROP[1];
                            break;
                        default:
                            break;
                    }
                }
            }
            this.RelativeCoordinate = true;
        }

        /**
         * @function SuperMap.Feature.Theme.Graph.prototype.assembleShapes
         * @description 图形装配函数。抽象方法，可视化子类必须实现此方法。<br>
         *              重写此方法的步骤：<br>
         *              1. 图表的某些特殊配置项（setting）处理，例如多数图表模型需要重新指定 dataViewBoxParameter 的默认值。<br>
         *              2. 调用 initBaseParameter() 方法初始化模型属性值，此步骤必须执行，只有当 initBaseParameter 返回 true 时才可以允许进行后续步骤。<br>
         *              3. 计算图形参数，制作图形，图形组合。在组装图表过程中，应该特别注意数据视图框单位值的定义、数据值溢出值域范围的处理和图形大小自适应。<br>
         *              4. 调用 shapesConvertToRelativeCoordinate() 方法，将图形的坐标值转为相对坐标，此步骤必须执行。
         * @example
         *  //子类实现 assembleShapes() 接口的步骤示例：
         *  assembleShapes: function(){
         *    // 第一步：图表的某些特殊配置项（setting）处理，例如多数图表模型需要重新指定 dataViewBoxParameter 的默认值。此步骤是非必须过程。
         *
         *    // 图表配置对象
         *    var sets = this.setting;
         *    // 默认数据视图框，这里展示在使用坐标轴和不使用坐标轴情况下对数据视图框参数赋予不同的默认值
         *    if(!sets.dataViewBoxParameter){
         *          if(typeof(sets.useAxis) === "undefined" || sets.useAxis){
         *              sets.dataViewBoxParameter = [45 15 15 15];
         *          }
         *          else{
         *                  sets.dataViewBoxParameter = [5 5 5 5];
         *          }
         *    }
         *
         *    // 第二步：初始化图表模型基本参数，只有在图表模型基本参数初始化成功时才可模型相关属性，如 this.dataViewBox、 this.DVBCodomain等。此步骤是必须过程。
         *    if(!this.initBaseParameter()) return;
         *
         *    // 第三步：用图形组装图表，在组装图表过程中，应该特别注意数据视图框单位值的定义、数据值溢出值域范围的处理和图形大小自适应。
         *    // 定义图表数据视图框中单位值的含义，下面行代码表示将数据视图框单位值定义为数据视图框高度上每像素代表的数据值
         *    this.DVBUnitValue =  (this.codomain[1] - this.codomain[0])/this.DVBHeight;
         *    var uv = this.DVBUnitValue;
         *
         *    // 图形参数计算代码......
         *
         *    // 关于图形装配，实际上就是利用图形工程对象 this.shapeFactory 的 createShape() 方法通过图形参数对象创建可视化的图形对象，并把这些图形对象按序添加到模型的图形库（his.shapes）中。下面的代码演示创建一个面图形参数对象，并允许通过图形配置对象设置图形的 style 和 highlightStyle，
         *    var barParams = new SuperMap.Feature.ShapeParameters.Polygon(poiLists);
         *    barParams.style = sets.barStyle? sets.barStyle:{fillColor: "lightblue"};
         *    barParams.highlightStyle = sets.barHoverStyle? sets.barHoverStyle:{fillColor: "blue"};
         *    // 图形携带数据ID信息
         *    barParams.refDataID = this.data.id;
         *    // 创建图形并添加到图表图形数组中
         *    this.shapes.push(this.shapeFactory.createShape(barParams));
         *
         *    // 第四步：调用 shapesConvertToRelativeCoordinate() 方法，将图形库（his.shapes）中的图形转为由相对坐标表示的图形，客户端统计专题图模块从结构上要求可视化图形使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数。此步骤是必须过程。
         *    this.shapesConvertToRelativeCoordinate();
         * }
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {}
        //子类必须实现此方法


        /**
         * @function SuperMap.Feature.Theme.Graph.prototype.getLocalXY
         * @description 地理坐标转为像素坐标。
         * @param lonlat - {SuperMap.Lonlat} 带转换的地理坐标。
         * @return 屏幕像素坐标。
         */

    }, {
        key: 'getLocalXY',
        value: function getLocalXY(lonlat) {
            return this.layer.getLocalXY(lonlat);
        }
    }]);

    return Graph;
}(_Theme2.Theme);

/**
 * @function SuperMap.Feature.Theme.getDataValues
 * @description 根据字段名数组获取指定数据（feature）的属性值数组。属性值类型必须为 Number。
 * @param data - {SuperMap.Feature.Vector} 数据。
 * @param fields - {Array<string>} 字段名数组。
 * @param decimalNumber - {number} 小数位处理参数，对获取到的属性数据值进行小数位处理。
 * @return {Array<string>} 字段名数组对应的属性数据值数组。
 */


_Theme2.Theme.getDataValues = function (data, fields, decimalNumber) {
    if (!data.attributes) {
        return false;
    }

    var fieldsValue = [];

    var attrs = data.attributes;
    for (var i = 0; i < fields.length; i++) {
        for (var field in attrs) {
            if (field !== fields[i]) {
                continue;
            }
            // 数字转换判断
            try {
                if (!isNaN(decimalNumber) && decimalNumber >= 0) {
                    fieldsValue.push(parseFloat(attrs[field].toString()).toFixed(decimalNumber));
                } else {
                    fieldsValue.push(parseFloat(attrs[field].toString()));
                }
            } catch (e) {
                throw new Error("not a number");
            }
        }
    }

    if (fieldsValue.length === fields.length) {
        return fieldsValue;
    } else {
        return false;
    }
};

_SuperMap.SuperMap.Feature.Theme.Graph = Graph;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Util
 * LevelRenderer 基础工具类
 *
 */
var Util = exports.Util = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Util
     * 构造函数。
     *
     */
    function Util() {
        _classCallCheck(this, Util);

        /**
         * Property: BUILTIN_OBJECT
         * {Object} 用于处理merge时无法遍历Date等对象的问题
         */
        this.BUILTIN_OBJECT = {
            '[object Function]': 1,
            '[object RegExp]': 1,
            '[object Date]': 1,
            '[object Error]': 1,
            '[object CanvasGradient]': 1
        };

        /**
         * Property: _ctx
         * {Object}
         */
        this._ctx = null;

        /**
         * Property: _canvas
         * {Object}
         */
        this._canvas = null;

        /**
         * Property: _pixelCtx
         * {Object}
         */
        this._pixelCtx = null;

        /**
         * Property: _width
         * {Object}
         */
        this._width = null;

        /**
         * Property: _height
         * {Object}
         */
        this._height = null;

        /**
         * Property: _offsetX
         * {Object}
         */
        this._offsetX = 0;

        /**
         * Property: _offsetY
         * {Object}
         */
        this._offsetY = 0;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Util";
    }

    /**
     * APIMethod: clone
     * 对一个object进行深度拷贝。
     *
     * Parameters:
     * source - {Object} 需要进行拷贝的对象。
     *
     * Returns:
     * {Object} 拷贝后的新对象。
     */


    _createClass(Util, [{
        key: 'clone',
        value: function clone(source) {
            var BUILTIN_OBJECT = this.BUILTIN_OBJECT;
            if ((typeof source === 'undefined' ? 'undefined' : _typeof(source)) == 'object' && source !== null) {
                var result = source;
                if (source instanceof Array) {
                    result = [];
                    for (var i = 0, len = source.length; i < len; i++) {
                        result[i] = this.clone(source[i]);
                    }
                } else if (!BUILTIN_OBJECT[Object.prototype.toString.call(source)]) {
                    result = {};
                    for (var key in source) {
                        if (source.hasOwnProperty(key)) {
                            result[key] = this.clone(source[key]);
                        }
                    }
                }

                return result;
            }

            return source;
        }

        /**
         * Method: mergeItem
         * 合并源对象的单个属性到目标对象。
         *
         * Parameters:
         * target - {Object} 目标对象。
         * source - {Object} 源对象。
         * key - {String} 键。
         * overwrite - {Boolean} 是否覆盖。
         *
         * Returns:
         * {Object} 目标对象。
         */

    }, {
        key: 'mergeItem',
        value: function mergeItem(target, source, key, overwrite) {
            var BUILTIN_OBJECT = this.BUILTIN_OBJECT;
            if (source.hasOwnProperty(key)) {
                if (_typeof(target[key]) == 'object' && !BUILTIN_OBJECT[Object.prototype.toString.call(target[key])]) {
                    // 如果需要递归覆盖，就递归调用merge
                    this.merge(target[key], source[key], overwrite);
                } else if (overwrite || !(key in target)) {
                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                    target[key] = source[key];
                }
            }
        }

        /**
         * APIMethod: merge
         * 合并源对象的属性到目标对象。
         *
         * Parameters:
         * target - {Object} 目标对象。
         * source - {Object} 源对象。
         * overwrite - {Boolean} 是否覆盖。
         *
         * Returns:
         * {Object} 目标对象。
         */

    }, {
        key: 'merge',
        value: function merge(target, source, overwrite) {
            for (var i in source) {
                this.mergeItem(target, source, i, overwrite);
            }

            return target;
        }

        /**
         * Method: getContext
         * 获取 Cavans 上下文
         *
         * Returns:
         * {Object} Cavans 上下文。
         */

    }, {
        key: 'getContext',
        value: function getContext() {
            if (!this._ctx) {
                this._ctx = document.createElement('canvas').getContext('2d');
            }
            return this._ctx;
        }

        /**
         * APIMethod: getPixelContext
         * 获取像素拾取专用的上下文
         *
         * Returns:
         * {Object}像素拾取专用的上下文。
         */

    }, {
        key: 'getPixelContext',
        value: function getPixelContext() {
            if (!this._pixelCtx) {
                this._canvas = document.createElement('canvas');
                this._width = this._canvas.width;
                this._height = this._canvas.height;
                this._pixelCtx = this._canvas.getContext('2d');
            }
            return this._pixelCtx;
        }

        /**
         * APIMethod: adjustCanvasSize
         * 如果坐标处在_canvas外部，改变_canvas的大小
         *
         * 注意 修改canvas的大小 需要重新设置translate
         *
         * Parameters:
         * x - {Number} 横坐标。
         * y - {Number} 纵坐标。
         *
         */

    }, {
        key: 'adjustCanvasSize',
        value: function adjustCanvasSize(x, y) {
            var _canvas = this._canvas;
            var _pixelCtx = this._pixelCtx;
            var _width = this._width;
            var _height = this._height;
            var _offsetX = this._offsetX;
            var _offsetY = this._offsetY;

            // 每次加的长度
            var _v = 100;
            var _flag;

            if (x + _offsetX > _width) {
                _width = x + _offsetX + _v;
                _canvas.width = _width;
                _flag = true;
            }

            if (y + _offsetY > _height) {
                _height = y + _offsetY + _v;
                _canvas.height = _height;
                _flag = true;
            }

            if (x < -_offsetX) {
                _offsetX = Math.ceil(-x / _v) * _v;
                _width += _offsetX;
                _canvas.width = _width;
                _flag = true;
            }

            if (y < -_offsetY) {
                _offsetY = Math.ceil(-y / _v) * _v;
                _height += _offsetY;
                _canvas.height = _height;
                _flag = true;
            }

            if (_flag) {
                _pixelCtx.translate(_offsetX, _offsetY);
            }
        }

        /**
         * APIMethod: getPixelOffset
         * 获取像素canvas的偏移量
         *
         * Returns:
         * {Object}偏移量。
         */

    }, {
        key: 'getPixelOffset',
        value: function getPixelOffset() {
            return {
                x: this._offsetX,
                y: this._offsetY
            };
        }

        /**
         * APIMethod: indexOf
         * 查询数组中元素的index
         *
         * Returns:
         * {Object}偏移量。
         */

    }, {
        key: 'indexOf',
        value: function indexOf(array, value) {
            if (array.indexOf) {
                return array.indexOf(value);
            }
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * APIMethod: inherits
         * 构造类继承关系
         *
         * Parameters:
         * clazz - {Function} 源类。
         * baseClazz - {Function} 基类。
         *
         * Returns:
         * {Object}偏移量。
         */

    }, {
        key: 'inherits',
        value: function inherits(clazz, baseClazz) {
            var clazzPrototype = clazz.prototype;

            function F() {}

            F.prototype = baseClazz.prototype;
            clazz.prototype = new F();

            for (var prop in clazzPrototype) {
                clazz.prototype[prop] = clazzPrototype[prop];
            }
            clazz.constructor = clazz;
        }
    }]);

    return Util;
}();

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(290);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LinearRing = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _LineString2 = __webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class  SuperMap.Geometry.LinearRing
 * @classdesc 几何对象线环类，是一个特殊的封闭的线串，在每次addPoint/removePoint之后会通过添加一个点（此点是复制的第一个点得到的）
 * 作为最后的一个点来自动关闭线环。
 * @extends {SuperMap.Geometry.LineString}
 * @param points {Array<SuperMap.Geometry.Point>} 组成线性环的点。
 * @example
 * var points = [new SuperMap.Geometry.Point(4933.319287022352, -3337.3849141502124),
 *      new SuperMap.Geometry.Point(4960.9674060199022, -3349.3316322355736),
 *      new SuperMap.Geometry.Point(5006.0235999418364, -3358.8890067038628),
 *      new SuperMap.Geometry.Point(5075.3145648369318, -3378.0037556404409),
 *      new SuperMap.Geometry.Point(5305.19551436013, -3376.9669111768926)],
 * var linearRing = new SuperMap.Geometry.LinearRing(points);
 */
var LinearRing = exports.LinearRing = function (_LineString) {
    _inherits(LinearRing, _LineString);

    function LinearRing(points) {
        _classCallCheck(this, LinearRing);

        /**
         * @member SuperMap.Geometry.LinearRing.prototype.componentTypes -{Array<string>}
         * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
         * @readonly
         * @default ["{@link SuperMap.Geometry.Point}"]
         */
        var _this = _possibleConstructorReturn(this, (LinearRing.__proto__ || Object.getPrototypeOf(LinearRing)).call(this, points));

        _this.componentTypes = ["SuperMap.Geometry.Point"];
        _this.CLASS_NAME = "SuperMap.Geometry.LinearRing";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.LinearRing.prototype.addComponent
     * @description 添加一个点到几何图形数组中，如果这个点将要被添加到组件数组的末端，并且与数组中已经存在的最后一个点相同，
     * 重复的点是不能被添加的。这将影响未关闭环的关闭。
     * 这个方法可以通过将非空索引（组件数组的下标）作为第二个参数重写。
     * @param point - {SuperMap.Geometry.Point} 点对象。
     * @param index - {Integer} 插入组件数组的下标。
     * @returns {Boolean} 点对象是否添加成功。
     */


    _createClass(LinearRing, [{
        key: 'addComponent',
        value: function addComponent(point, index) {
            var added = false;

            //remove last point
            var lastPoint = this.components.pop();

            // given an index, add the point
            // without an index only add non-duplicate points
            if (index != null || !point.equals(lastPoint)) {
                added = _get(LinearRing.prototype.__proto__ || Object.getPrototypeOf(LinearRing.prototype), 'addComponent', this).apply(this, arguments);
            }

            //append copy of first point
            var firstPoint = this.components[0];
            _get(LinearRing.prototype.__proto__ || Object.getPrototypeOf(LinearRing.prototype), 'addComponent', this).apply(this, [firstPoint]);

            return added;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.removeComponent
         * @description 从几何组件中删除一个点。
         * @param point - {SuperMap.Geometry.Point} 点对象。
         * @returns {Boolean} 点对象是否删除。
         */

    }, {
        key: 'removeComponent',
        value: function removeComponent(point) {
            // eslint-disable-line no-unused-vars
            var removed = this.components && this.components.length > 3;
            if (removed) {
                //remove last point
                this.components.pop();

                //remove our point
                _get(LinearRing.prototype.__proto__ || Object.getPrototypeOf(LinearRing.prototype), 'removeComponent', this).apply(this, arguments);
                //append copy of first point
                var firstPoint = this.components[0];
                _get(LinearRing.prototype.__proto__ || Object.getPrototypeOf(LinearRing.prototype), 'addComponent', this).apply(this, [firstPoint]);
            }
            return removed;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.getArea
         * @description 获得当前几何对象区域大小，如果是沿顺时针方向的环则是正值，否则为负值。
         * @returns {float} 环的面积。
         */

    }, {
        key: 'getArea',
        value: function getArea() {
            var area = 0.0;
            if (this.components && this.components.length > 2) {
                var sum = 0.0;
                for (var i = 0, len = this.components.length; i < len - 1; i++) {
                    var b = this.components[i];
                    var c = this.components[i + 1];
                    sum += (b.x + c.x) * (c.y - b.y);
                }
                area = -sum / 2.0;
            }
            return area;
        }

        /**
         * @function SuperMap.Geometry.LinearRing.prototype.getVertices
         * @description 返回几何图形的所有点的列表。
         * @param nodes - {Boolean} 对于线来说，仅仅返回作为端点的顶点，如果设为false，则返回非端点的顶点
         * 如果没有设置此参数，则返回所有顶点。
         * @returns {Array} 几何对象所有点的列表。
         */

    }, {
        key: 'getVertices',
        value: function getVertices(nodes) {
            return nodes === true ? [] : this.components.slice(0, this.components.length - 1);
        }
    }]);

    return LinearRing;
}(_LineString2.LineString);

_SuperMap.SuperMap.Geometry.LinearRing = LinearRing;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(16);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.QueryParameters
 * @classdesc 查询参数基类。距离查询、SQL 查询、几何地物查询等各自的参数均继承此类。
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys - {Object} 自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {{@link SuperMap.GeometryType}} 网络数据集对应的查询类型。<br>
 *         queryOption - {{@link SuperMap.QueryOption}} 查询结果类型枚举类。<br>
 *         queryParams - {Array<{@link SuperMap.FilterParameter}>}查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。
 */
var QueryParameters = exports.QueryParameters = function () {
  function QueryParameters(options) {
    _classCallCheck(this, QueryParameters);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.QueryParameters.prototype.customParams -{string}
     * @description 自定义参数，供扩展使用。
     */
    this.customParams = null;

    /**
     * @member SuperMap.QueryParameters.prototype.prjCoordSys -{Object}
     * @description 自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}
     */
    this.prjCoordSys = null;

    /**
     * @member SuperMap.QueryParameters.prototype.expectCount -{number}
     * @description 期望返回结果记录个数，默认返回100000条查询记录，
     *               如果实际不足100000条则返回实际记录条数。
     * @default 100000
     */
    this.expectCount = 100000;

    /**
     * @member SuperMap.QueryParameters.prototype.networkType -{SuperMap.GeometryType}
     * @description 网络数据集对应的查询类型，
     *               分为点和线两种类型，默认为线几何对象类型，即{@link GeometryType.LINE | SuperMap.GeometryType.LINE}。
     * @default  {@link SuperMap.GeometryType.LINE}
     */
    this.networkType = _REST.GeometryType.LINE;

    /**
     * @member SuperMap.QueryParameters.prototype.queryOption -{SuperMap.QueryOption}
     * @description 查询结果类型枚举类。
     *               该类描述查询结果返回类型，包括只返回属性、
     *               只返回几何实体以及返回属性和几何实体。
     * @default {@link SuperMap.QueryOption.ATTRIBUTEANDGEOMETRY}
     */
    this.queryOption = _REST.QueryOption.ATTRIBUTEANDGEOMETRY;

    /**
     * @member SuperMap.QueryParameters.prototype.queryParams -{Array<SuperMap.FilterParameter>}
     * @description 查询过滤条件参数数组。
     *               该类用于设置查询数据集的查询过滤参数。
     */
    this.queryParams = null;

    /**
     * @member SuperMap.QueryParameters.prototype.startRecord -{number}
     * @description 查询起始记录号，默认值为0。
     * @default 0
     */
    this.startRecord = 0;

    /**
     * @member SuperMap.QueryParameters.prototype.holdTime -{number}
     * @description 资源在服务端保存的时间。默认为10（分钟）。
     * @default 10
     */
    this.holdTime = 10;

    /**
     * @member SuperMap.QueryParameters.prototype.returnCustomResult -{boolean}
     * @description 仅供三维使用。
     * @default false
     */
    this.returnCustomResult = false;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.QueryParameters";
  }

  /**
   * @function SuperMap.QueryParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(QueryParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.customParams = null;
      me.expectCount = null;
      me.networkType = null;
      me.queryOption = null;
      if (me.queryParams) {
        for (var i = 0, qps = me.queryParams, len = qps.length; i < len; i++) {
          qps[i].destroy();
        }
        me.queryParams = null;
      }
      me.startRecord = null;
      me.holdTime = null;
      me.returnCustomResult = null;
      me.prjCoordSys = null;
    }
  }]);

  return QueryParameters;
}();

_SuperMap.SuperMap.QueryParameters = QueryParameters;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ServerTextStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _ServerColor = __webpack_require__(20);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerTextStyle
 * @classdesc 服务端文本风格类
 * @description 该类用于定义文本风格的相关属性。
 * @param options - {Object} 可选参数。如：<br>
 *        align - {{@link SuperMap.TextAlignment}} 文本的对齐方式。<br>
 *        backColor - {{@link SuperMap.ServerColor}} 文本的背景色。<br>
 *        foreColor - {{@link SuperMap.ServerColor}} 文本的前景色。<br>
 *        backOpaque - {boolean} 文本背景是否不透明。<br>
 *        sizeFixed - {boolean} 文本大小是否固定。<br>
 *        fontHeight - {number}文本字体的高度。<br>
 *        fontWidth - {number}文本字体的宽度。<br>
 *        fontWeight - {integer} 文本字体的磅数。<br>
 *        fontName - {string} 文本字体的名称。<br>
 *        bold - {boolean} 文本是否为粗体字。<br>
 *        italic - {boolean}文本是否采用斜体。<br>
 *        italicAngle - {number}字体倾斜角度。<br>
 *        shadow - {boolean} 文本是否有阴影。<br>
 *        strikeout - {boolean} 文本字体是否加删除线。<br>
 *        outline - {boolean} 是否以轮廓的方式来显示文本的背景。<br>
 *        opaqueRate - {number}注记文字的不透明度。<br>
 *        underline - {boolean} 文本字体是否加下划线。<br>
 *        rotation -  {number} 文本旋转的角度。
 */
var ServerTextStyle = exports.ServerTextStyle = function () {
  function ServerTextStyle(options) {
    _classCallCheck(this, ServerTextStyle);

    /**
     * @member SuperMap.ServerTextStyle.prototype.align -{SuperMap.TextAlignment}
     * @description 文本的对齐方式。默认为 SuperMap.TextAlignment.BASELINECENTER（基准线居中对齐）。
     */
    this.align = _REST.TextAlignment.BASELINECENTER;

    /**
     * @member SuperMap.ServerTextStyle.prototype.backColor -{SuperMap.ServerColor}
     * @description 文本的背景色。默认为白色。
     */
    this.backColor = new _ServerColor.ServerColor(255, 255, 255);

    /**
     * @member SuperMap.ServerTextStyle.prototype.foreColor -{SuperMap.ServerColor}
     * @description 文本的前景色。默认为黑色。
     */
    this.foreColor = new _ServerColor.ServerColor(0, 0, 0);

    /**
     * @member SuperMap.ServerTextStyle.prototype.backOpaque -{boolean}
     * @description 文本背景是否不透明。true 表示文本背景不透明。
     */
    this.backOpaque = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.sizeFixed -{boolean}
     * @description 文本大小是否固定。默认为 true，表示图片为固定像素大小，具体大小请参考 fontHeight。当设为 false 时，图片会随着地图缩放而缩放。
     */
    this.sizeFixed = true;

    /**
     * @member SuperMap.ServerTextStyle.prototype.fontHeight -{number}
     * @description 文本字体的高度，默认为6，单位与 sizeFixed 有关，当 sizeFixed 为 False 时，即非固定文本大小时使用地图坐标单位，
     *              如地理坐标系下的地图中单位为度；当 sizeFixed 为 True 时，单位为毫米（mm）。
     */
    this.fontHeight = 6;

    /**
     * @member SuperMap.ServerTextStyle.prototype.fontWidth -{number}
     * @description 文本字体的宽度。字体的宽度以英文字符为标准，由于一个中文字符相当于两个英文字符，默认为0地图坐标单位。
     */
    this.fontWidth = 0;

    /**
     * @member SuperMap.ServerTextStyle.prototype.fontWeight -{integer}
     * @description 文本字体的磅数。表示粗体的具体数值。取值范围为从0－900之间的整百数，默认值为400。
     */
    this.fontWeight = 400;

    /**
     * @member SuperMap.ServerTextStyle.prototype.fontName -{string}
     * @description 文本字体的名称。默认值为 Times New Roman。
     */
    this.fontName = "Times New Roman";

    /**
     * @member SuperMap.ServerTextStyle.prototype.bold -{boolean}
     * @description 文本是否为粗体字。true 表示为粗体。默认值为 false，即文本不是粗体字。
     */
    this.bold = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.italic -{boolean}
     * @description 文本是否采用斜体。true 表示采用斜体。默认为 false。
     */
    this.italic = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.italicAngle -{number}
     * @description 字体倾斜角度。正负度之间，以度为单位，精确到0.1度，默认为0度。当倾斜角度为0度，为系统默认的字体倾斜样式。
     *              正负度是指以纵轴为起始零度线，其纵轴左侧为正，右侧为负。允许的最大角度为60，最小-60。大于60按照60处理，小于-60按照-60处理。目前只对标签专题图有效。
     */
    this.italicAngle = 0;

    /**
     * @member SuperMap.ServerTextStyle.prototype.shadow -{boolean}
     * @description 文本是否有阴影。true 表示给文本增加阴影。默认值为 false，即文本没有阴影。
     */
    this.shadow = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.strikeout -{boolean}
     * @description 文本字体是否加删除线。true 表示加删除线。默认值为 false，即文本字体不加删除线。
     */
    this.strikeout = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.outline -{boolean}
     * @description 是否以轮廓的方式来显示文本的背景。true 表示以轮廓的方式来显示文本的背景。默认值为 false，表示不以轮廓的方式来显示文本的背景。
     */
    this.outline = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.opaqueRate -{number}
     * @description 注记文字的不透明度。不透明度的范围为0-100。默认为0，表示透明。
     */
    this.opaqueRate = 0;

    /**
     * @member SuperMap.ServerTextStyle.prototype.underline -{boolean}
     * @description 文本字体是否加下划线。true 表示加下划线。默认为 false。
     */
    this.underline = false;

    /**
     * @member SuperMap.ServerTextStyle.prototype.rotation -{number}
     * @description 文本旋转的角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
     */
    this.rotation = 0.0;

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.ServerTextStyle";
  }

  /**
   * @function SuperMap.ServerTextStyle.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ServerTextStyle, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.align = null;
      if (me.backColor) {
        me.backColor.destroy();
        me.backColor = null;
      }
      if (me.foreColor) {
        me.foreColor.destroy();
        me.foreColor = null;
      }
      me.backOpaque = null;
      me.sizeFixed = null;
      me.fontHeight = null;
      me.fontWidth = null;
      me.fontWeight = null;
      me.fontName = null;
      me.bold = null;
      me.italic = null;
      me.italicAngle = null;
      me.shadow = null;
      me.strikeout = null;
      me.outline = null;
      me.opaqueRate = null;
      me.underline = null;
      me.rotation = null;
    }

    /**
     * @function SuperMap.ServerTextStyle.fromObj
     * @description 从传入对象获服务端文本风格类。
     * @param obj - {Object} 传入对象
     * @return {SuperMap.ServerTextStyle} 返回服务端文本风格对象
     */

  }], [{
    key: 'fromObj',
    value: function fromObj(obj) {
      var res = new ServerTextStyle(obj);
      _Util.Util.copy(res, obj);
      res.backColor = _ServerColor.ServerColor.fromJson(obj.backColor);
      res.foreColor = _ServerColor.ServerColor.fromJson(obj.foreColor);
      return res;
    }
  }]);

  return ServerTextStyle;
}();

_SuperMap.SuperMap.ServerTextStyle = ServerTextStyle;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportationAnalystParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystResultSetting = __webpack_require__(250);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransportationAnalystParameter
 * @classdesc 交通网络分析通用参数类。
 * @description该类主要用来提供交通网络分析所需的通用参数。
 * 通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息，还可以对分析结果包含的内容进行一些设置。
 * @param options - {Object} 可选参数。如:</br>
 *        barrierEdgeIDs - {Array<number>} 网络分析中障碍弧段的 ID 数组。</br>
 *        barrierNodeIDs - {Array<number>} 网络分析中障碍点的 ID 数组。</br>
 *        barrierPoints - {Array<Point>} 网络分析中 Point2D 类型的障碍点数组。</br>
 *                         点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
 *        weightFieldName - {string} 阻力字段的名称。</br>
 *        turnWeightField - {string} 转向权重字段的名称。</br>
 *        resultSetting - {{@link SuperMap.TransportationAnalystResultSetting}} 分析结果返回内容。
 */
var TransportationAnalystParameter = exports.TransportationAnalystParameter = function () {
  function TransportationAnalystParameter(options) {
    _classCallCheck(this, TransportationAnalystParameter);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.TransportationAnalystParameter.prototype.barrierEdgeIDs -{Array<number>}
     * @description 网络分析中障碍弧段的 ID 数组。弧段设置为障碍边之后，表示双向都不通。
     */
    this.barrierEdgeIDs = null;

    /**
     * @member SuperMap.TransportationAnalystParameter.prototype.barrierNodeIDs -{Array<number>}
     * @description 网络分析中障碍点的 ID 数组。结点设置为障碍点之后，表示任何方向都不能通过此结点。
     */
    this.barrierNodeIDs = null;

    /**
     * @member SuperMap.TransportationAnalystParameter.prototype.barrierPoints -{Array<Point>}
     * @description 网络分析中 Point2D 类型的障碍点数组。障碍点表示任何方向都不能通过此点。</br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
     * 当各网络分析参数类中的 isAnalyzeById 属性设置为 false 时，该属性才生效。
     */
    this.barrierPoints = null;

    /**
     * @member SuperMap.TransportationAnalystParameter.prototype.weightFieldName -{string}
     * @description 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，例如表示时间、长度等的字段都可以用作阻力字段。
     * 该字段默值为服务器发布的所有耗费字段的第一个字段。
     */
    this.weightFieldName = null;

    /**
     * @member SuperMap.TransportationAnalystParameter.prototype.turnWeightField -{string}
     * @description 转向权重字段的名称。
     */
    this.turnWeightField = null;

    /**
     *  @member SuperMap.TransportationAnalystParameter.prototype.resultSetting -{SuperMap.TransportationAnalystResultSetting}
     *  @description 分析结果返回内容。
     */
    this.resultSetting = new _TransportationAnalystResultSetting.TransportationAnalystResultSetting();

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.TransportationAnalystParameter";
  }

  /**
   * @function SuperMap.TransportationAnalystParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(TransportationAnalystParameter, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.barrierEdgeIDs = null;
      me.barrierNodeIDs = null;
      me.weightFieldName = null;
      me.turnWeightField = null;
      if (me.resultSetting) {
        me.resultSetting.destroy();
        me.resultSetting = null;
      }
      if (me.barrierPoints && me.barrierPoints.length) {
        for (var i in me.barrierPoints) {
          me.barrierPoints[i].destroy();
        }
      }
      me.barrierPoints = null;
    }
  }]);

  return TransportationAnalystParameter;
}();

_SuperMap.SuperMap.TransportationAnalystParameter = TransportationAnalystParameter;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SecurityManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _FetchRequest = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @name SecurityManager
 * @memberOf SuperMap
 * @namespace
 * @description 安全管理中心，提供iServer,iPortal,Online统一权限认证管理
 *  > 使用说明：
 *  > 创建任何一个服务之前调用{@link SuperMap.SecurityManager.registerToken}或
 *  > {@link SuperMap.SecurityManager.registerKey}注册凭据。
 *  > 发送请求时根据url或者服务id获取相应的key或者token并自动添加到服务地址中
 */
var SecurityManager = exports.SecurityManager = function () {
    function SecurityManager() {
        _classCallCheck(this, SecurityManager);
    }

    _createClass(SecurityManager, null, [{
        key: 'generateToken',


        /**
         * @description 从服务器获取一个token,在此之前要注册服务器信息
         * @param url {string}-服务器域名+端口，如：http://localhost:8092
         * @param tokenParam -{SuperMap.TokenServiceParameter} token申请参数
         * @return {Promise} 返回包含token信息的Promise对象
         */

        value: function generateToken(url, tokenParam) {
            var serverInfo = this.servers[url];
            if (!serverInfo) {
                return;
            }
            return _FetchRequest.FetchRequest.post(serverInfo.tokenServiceUrl, JSON.stringify(tokenParam.toJSON())).then(function (response) {
                return response.text();
            });
        }

        /**
         * @description 注册安全服务器相关信息
         * @param serverInfos -{SuperMap.ServerInfo} 服务器信息
         */

    }, {
        key: 'registerServers',
        value: function registerServers(serverInfos) {
            this.servers = this.servers || {};
            if (!_Util.Util.isArray(serverInfos)) {
                serverInfos = [serverInfos];
            }
            for (var i = 0; i < serverInfos.length; i++) {
                var serverInfo = serverInfos[i];
                this.servers[serverInfo.server] = serverInfo;
            }
        }

        /**
         * @description 服务请求都会自动带上这个token
         * @param url {string} -服务器域名+端口：如http://localhost:8090
         * @param token -{string} token
         */

    }, {
        key: 'registerToken',
        value: function registerToken(url, token) {
            this.tokens = this.tokens || {};
            if (!url || !token) {
                return;
            }
            var domain = this._getTokenStorageKey(url);
            this.tokens[domain] = token;
        }

        /**
         * @description 注册keyids为数组(存在一个key对应多个服务)
         * @param ids -{Array} 可以是服务id数组或者url地址数组或者webAPI类型数组
         * @param key -{string} key
         */

    }, {
        key: 'registerKey',
        value: function registerKey(ids, key) {
            this.keys = this.keys || {};
            if (!ids || ids.length < 1 || !key) {
                return;
            }

            ids = _Util.Util.isArray(ids) ? ids : [ids];
            for (var i = 0; i < ids.length; i++) {
                var id = this._getUrlRestString(ids[0]) || ids[0];
                this.keys[id] = key;
            }
        }

        /**
         * @description 获取服务器信息
         * @param url {string}-服务器域名+端口，如：http://localhost:8092
         * @returns {SuperMap.ServerInfo} 服务器信息
         */

    }, {
        key: 'getServerInfo',
        value: function getServerInfo(url) {
            this.servers = this.servers || {};
            return this.servers[url];
        }

        /**
         * @description 根据Url获取token
         * @param url -{string} 服务器域名+端口，如：http://localhost:8092
         * @returns {string} token
         */

    }, {
        key: 'getToken',
        value: function getToken(url) {
            if (!url) {
                return;
            }
            this.tokens = this.tokens || {};
            var domain = this._getTokenStorageKey(url);
            return this.tokens[domain];
        }

        /**
         * @description 根据Url获取key
         * @param id -{string} id
         * @returns {string} key
         */

    }, {
        key: 'getKey',
        value: function getKey(id) {
            this.keys = this.keys || {};
            var key = this._getUrlRestString(id) || id;
            return this.keys[key];
        }

        /**
         * @description iServer登录验证
         * @param url -{string} iServer首页地址，如：http://localhost:8090/iserver
         * @param username -{string} 用户名
         * @param password -{string} 密码
         * @param rememberme -{boolean} 是否记住
         * @returns {Promise} 返回包含iServer登录请求结果的Promise对象
         */

    }, {
        key: 'loginiServer',
        value: function loginiServer(url, username, password, rememberme) {
            var end = url.substr(url.length - 1, 1);
            url += end === "/" ? "services/security/login.json" : "/services/security/login.json";
            var loginInfo = {
                username: username && username.toString(),
                password: password && password.toString(),
                rememberme: rememberme
            };
            loginInfo = JSON.stringify(loginInfo);
            var requestOptions = {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                }
            };
            return _FetchRequest.FetchRequest.post(url, loginInfo, requestOptions).then(function (response) {
                return response.json();
            });
        }

        /**
         * @description iServer登出
         * @param url -{string} iServer首页地址如：http://localhost:8090/iserver
         * @returns {Promise} 是否登出成功
         */

    }, {
        key: 'logoutiServer',
        value: function logoutiServer(url) {
            var end = url.substr(url.length - 1, 1);
            url += end === "/" ? "services/security/logout" : "/services/security/logout";

            var requestOptions = {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                },
                withoutFormatSuffix: true
            };
            return _FetchRequest.FetchRequest.get(url, "", requestOptions).then(function () {
                return true;
            })["catch"](function () {
                return false;
            });
        }

        /**
         * @description Online登录验证
         * @param callbackLocation -{string} 跳转位置
         * @param newTab -{boolean}是否新窗口打开
         */

    }, {
        key: 'loginOnline',
        value: function loginOnline(callbackLocation, newTab) {
            var loginUrl = SecurityManager.SSO + "/login?service=" + callbackLocation;
            this._open(loginUrl, newTab);
        }

        /**
         * @description iPortal登录验证
         * @param url -{string} iportal首页地址
         * @param username -{string} 用户名
         * @param password -{string} 密码
         * @returns {Promise} 返回包含iPortal登录请求结果的Promise对象
         */

    }, {
        key: 'loginiPortal',
        value: function loginiPortal(url, username, password) {
            var end = url.substr(url.length - 1, 1);
            url += end === "/" ? "web/login.json" : "/web/login.json";
            var loginInfo = {
                username: username && username.toString(),
                password: password && password.toString()
            };
            loginInfo = JSON.stringify(loginInfo);
            var requestOptions = {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                },
                withCredentials: true
            };
            return _FetchRequest.FetchRequest.post(url, loginInfo, requestOptions).then(function (response) {
                return response.json();
            });
        }

        /**
         * @description iPortal登出
         * @param url -{string} iportal首页地址
         * @returns {Promise} 如果登出成功，返回true;否则返回false
         */

    }, {
        key: 'logoutiPortal',
        value: function logoutiPortal(url) {
            var end = url.substr(url.length - 1, 1);
            url += end === "/" ? "services/security/logout" : "/services/security/logout";

            var requestOptions = {
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
                },
                withCredentials: true,
                withoutFormatSuffix: true
            };
            return _FetchRequest.FetchRequest.get(url, "", requestOptions).then(function () {
                return true;
            })["catch"](function () {
                return false;
            });
        }

        /**
         * @description iManager登录验证
         * @param url -{string} iManager地址。<br>
         *                      地址参数为iManager首页地址，如： http://localhost:8390/imanager<br>
         * @param loginInfoParams -{Object} iManager 登录参数<br>
         *        userName -{string} 用户名<br>
         *        password-{string} 密码
         * @param options -{Object} <br>
         *        isNewTab -{boolean} 不同域时是否在新窗口打开登录页面
         * @return {Promise} 返回包含iManager登录请求结果的Promise对象
         */

    }, {
        key: 'loginManager',
        value: function loginManager(url, loginInfoParams, options) {
            if (!_Util.Util.isInTheSameDomain(url)) {
                var isNewTab = options ? options.isNewTab : true;
                this._open(url, isNewTab);
                return;
            }
            var end = url.substr(url.length - 1, 1);
            var requestUrl = end === "/" ? url + "icloud/security/tokens.json" : url + "/icloud/security/tokens.json";
            var params = loginInfoParams || {};
            var loginInfo = {
                username: params.userName && params.userName.toString(),
                password: params.password && params.password.toString()
            };
            loginInfo = JSON.stringify(loginInfo);
            var requestOptions = {
                headers: {
                    'Accept': '*/*',
                    'Content-Type': 'application/json'
                }
            };
            var me = this;
            return _FetchRequest.FetchRequest.post(requestUrl, loginInfo, requestOptions).then(function (response) {
                response.text().then(function (result) {
                    me.imanagerToken = result;
                    return result;
                });
            });
        }

        /**
         * @description 清空全部验证信息
         */

    }, {
        key: 'destroyAllCredentials',
        value: function destroyAllCredentials() {
            this.keys = null;
            this.tokens = null;
            this.servers = null;
        }

        /**
         * @description 清空令牌信息
         */

    }, {
        key: 'destroyToken',
        value: function destroyToken(url) {
            if (!url) {
                return;
            }
            var domain = this._getTokenStorageKey(url);
            this.tokens = this.tokens || {};
            if (this.tokens[domain]) {
                delete this.tokens[domain];
            }
        }

        /**
         * @description 清空服务授权码
         */

    }, {
        key: 'destroyKey',
        value: function destroyKey(id) {
            if (!id) {
                return;
            }
            this.keys = this.keys || {};
            var key = this._getUrlRestString(id) || id;
            if (this.keys[key]) {
                delete this.keys[key];
            }
        }
    }, {
        key: '_open',
        value: function _open(url, newTab) {
            newTab = newTab != null ? newTab : true;
            var offsetX = window.screen.availWidth / 2 - this.INNER_WINDOW_WIDTH / 2;
            var offsetY = window.screen.availHeight / 2 - this.INNER_WINDOW_HEIGHT / 2;
            var options = "height=" + this.INNER_WINDOW_HEIGHT + ", width=" + this.INNER_WINDOW_WIDTH + ",top=" + offsetY + ", left=" + offsetX + ",toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no";
            if (newTab) {
                window.open(url, 'login');
            } else {
                window.open(url, 'login', options);
            }
        }
    }, {
        key: '_getTokenStorageKey',
        value: function _getTokenStorageKey(url) {
            var patten = /(.*?):\/\/([^\/]+)/i;
            var result = url.match(patten);
            if (!result) {
                return url;
            }
            return result[0];
        }
    }, {
        key: '_getUrlRestString',
        value: function _getUrlRestString(url) {
            if (!url) {
                return url;
            }
            var patten = /http:\/\/(.*\/rest)/i;
            var result = url.match(patten);
            if (!result) {
                return url;
            }
            return result[0];
        }
    }]);

    return SecurityManager;
}();

SecurityManager.INNER_WINDOW_WIDTH = 600;
SecurityManager.INNER_WINDOW_HEIGHT = 600;
SecurityManager.SSO = "https://sso.supermap.com";
SecurityManager.ONLINE = "http://www.supermapol.com";
_SuperMap.SuperMap.SecurityManager = SecurityManager;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CommontypesConversion = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class L.supermap.CommontypesConversion
 * @classdesc Leaflet对象和SuperMap对象转换工具
 */
var CommontypesConversion = exports.CommontypesConversion = function () {
    function CommontypesConversion() {
        _classCallCheck(this, CommontypesConversion);
    }

    _createClass(CommontypesConversion, null, [{
        key: 'toSuperMapBounds',

        /**
         * @function L.supermap.CommontypesConversion.toSuperMapBounds
         * @description 将Leaflet对象得bounds转成SuperMap 的bounds对象
         * @param bounds - {L.Bounds|L.LatLngBounds} 图层显示范围
         * @return {SuperMap.Bounds} SuperMap的bounds对象
         */
        value: function toSuperMapBounds(bounds) {
            if (bounds instanceof _leaflet2["default"].LatLngBounds) {
                return new _iclientCommon.Bounds(bounds.getSouthWest().lng, bounds.getSouthWest().lat, bounds.getNorthEast().lng, bounds.getNorthEast().lat);
            }
            if (bounds instanceof _leaflet2["default"].Bounds) {
                return new _iclientCommon.Bounds(bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y);
            }
            if (this.isArray(bounds)) {
                return new _iclientCommon.Bounds(bounds[0], bounds[1], bounds[2], bounds[3]);
            }
            return new _iclientCommon.Bounds();
        }

        /**
         * @function L.supermap.Util.isArray
         * @description 判断是否为数组格式
         * @param obj - {Object} 待判断对象
         * @return {boolean} 是否是数组
         */

    }, {
        key: 'isArray',
        value: function isArray(obj) {
            return Object.prototype.toString.call(obj) == '[object Array]';
        }

        /**
         * @function L.supermap.CommontypesConversion.toProcessingParam
         * @description 将Region节点数组转为Processing服务需要的分析参数
         * @param points - Region各个节点数组
         * @return processing服务裁剪、查询分析的分析参数
         */

    }, {
        key: 'toProcessingParam',
        value: function toProcessingParam(points) {
            var geometryParam = {};
            if (points.length < 1) {
                geometryParam = "";
            } else {
                var results = [];
                for (var i = 0; i < points.length; i++) {
                    var point = {};
                    point.x = points[i][0];
                    point.y = points[i][1];
                    results.push(point);
                }
                geometryParam.type = "REGION";
                geometryParam.points = results;
            }
            return geometryParam;
        }
    }]);

    return CommontypesConversion;
}();

_leaflet2["default"].supermap.CommontypesConversion = CommontypesConversion;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LonLat = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LonLat
 * @classdesc  这个类用来表示经度和纬度对。
 * @param lon - {number} 地图单位上的X轴坐标，如果地图是地理投影，则此值是经度，否则，此值是地图地理位置的x坐标。
 * @param lat - {number} 地图单位上的Y轴坐标，如果地图是地理投影，则此值是纬度，否则，此值是地图地理位置的y坐标。
 * @param location - {Array<float>} [lon, lat]  如果要同时设置，则使用传入横纵坐标组成的数组。
 * @example
 * var lonLat = new SuperMap.LonLat(30,45);
 */
var LonLat = exports.LonLat = function () {
    function LonLat(lon, lat) {
        _classCallCheck(this, LonLat);

        if (_Util.Util.isArray(lon)) {
            lat = lon[1];
            lon = lon[0];
        }
        /**
         * @member SuperMap.LonLat.prototype.lon  -{float}
         * @description 地图的单位的X轴（横轴）坐标，默认为0.0。
         */
        this.lon = lon ? _Util.Util.toFloat(lon) : 0.0;

        /**
         * @member SuperMap.LonLat.prototype.lat  -{float}
         * @description 地图的单位的Y轴（纵轴）坐标，默认为0.0。
         */
        this.lat = lat ? _Util.Util.toFloat(lat) : 0.0;
        this.CLASS_NAME = "SuperMap.LonLat";
    }

    /**
     * @function SuperMap.LonLat.prototype.toString
     * @description 返回此对象的字符串形式
     * @example
     * var lonLat = new SuperMap.LonLat(100,50);
     * var str = lonLat.toString();
     * @returns {string} 例如: "lon=100,lat=50"
     */


    _createClass(LonLat, [{
        key: "toString",
        value: function toString() {
            return "lon=" + this.lon + ",lat=" + this.lat;
        }

        /**
         * @function SuperMap.LonLat.prototype.toShortString
         * @description 将经度纬度转换成简单字符串。
         * @example
         * var lonLat = new SuperMap.LonLat(10050);
         * var str = lonLat.toShortString();
         * @returns {string} 返回处理后的经纬度字符串。例如："10050"
         */

    }, {
        key: "toShortString",
        value: function toShortString() {
            return this.lon + "," + this.lat;
        }

        /**
         * @function SuperMap.LonLat.prototype.clone
         * @description 复制坐标对象，并返回复制后的新对象。
         * @example
         * var lonLat1 = new SuperMap.LonLat(10050);
         * var lonLat2 = lonLat1.clone();
         * @returns {SuperMap.LonLat}  返回相同坐标值的新的坐标对象。
         */

    }, {
        key: "clone",
        value: function clone() {
            return new LonLat(this.lon, this.lat);
        }

        /**
         * @function SuperMap.LonLat.prototype.add
         * @description 在已有坐标对象的经纬度基础上加上新的坐标经纬度，并返回新的坐标对象。
         * @example
         * var lonLat1 = new SuperMap.LonLat(10050);
         * //lonLat2 是新的对象
         * var lonLat2 = lonLat1.add(10050);
         *
         * @param lon - {float} 传入的精度参数。
         * @param lat - {float} 传入的纬度参数。
         * @returns {SuperMap.LonLat} 返回一个新的LonLat对象，此对象的经纬度是由传
         *      入的经纬度与当前的经纬度相加所得。
         */

    }, {
        key: "add",
        value: function add(lon, lat) {
            if (lon == null || lat == null) {
                throw new TypeError('LonLat.add cannot receive null values');
            }
            return new LonLat(this.lon + _Util.Util.toFloat(lon), this.lat + _Util.Util.toFloat(lat));
        }

        /**
         * @function SuperMap.LonLat.prototype.equals
         * @description 判断两个坐标对象是否相等。
         * @example
         * var lonLat1 = new SuperMap.LonLat(10050);
         * var lonLat2 = new SuperMap.LonLat(10050);
         * var isEquals = lonLat1.equals(lonLat2);
         *
         * @param ll - {SuperMap.LonLat} 需要进行比较的坐标对象。
         * @returns {boolean} 如果LonLat对象的经纬度和传入的经纬度一致则返回true不一
         *      致或传入的ll参数为NULL则返回false。
         */

    }, {
        key: "equals",
        value: function equals(ll) {
            var equals = false;
            if (ll != null) {
                equals = this.lon === ll.lon && this.lat === ll.lat || isNaN(this.lon) && isNaN(this.lat) && isNaN(ll.lon) && isNaN(ll.lat);
            }
            return equals;
        }

        /**
         * @function SuperMap.LonLat.prototype.wrapDateLine
         * @description 通过传入的范围对象对坐标对象转换到该范围内。
         * 如果经度小于给定范围最小精度，则在原经度基础上加上范围宽度，
         * 直到精度在范围内为止，如果经度大于给定范围则在原经度基础上减去范围宽度。
         * 换句话说就是将不在经度范围内的坐标转换到范围以内。
         *  （只会转换lon，不会转换lat，主要用于转移到日界线以内）
         * @example
         * var lonLat1 = new SuperMap.LonLat(42050);
         * var lonLat2 = lonLat1.wrapDateLine(
         *      new SuperMap.Bounds(-180-9018090)
         *  );
         *
         * @param maxExtent - {SuperMap.Bounds} 最大边界的范围。
         * @returns {SuperMap.LonLat} 将坐标转换到范围对象以内，并返回新的坐标。
         */

    }, {
        key: "wrapDateLine",
        value: function wrapDateLine(maxExtent) {

            var newLonLat = this.clone();

            if (maxExtent) {
                //shift right?
                while (newLonLat.lon < maxExtent.left) {
                    newLonLat.lon += maxExtent.getWidth();
                }

                //shift left?
                while (newLonLat.lon > maxExtent.right) {
                    newLonLat.lon -= maxExtent.getWidth();
                }
            }

            return newLonLat;
        }

        /**
         *
         * @function SuperMap.LonLat.prototype.destroy
         * @description 销毁此对象。
         * 销毁后此对象的所有属性为null，而不是初始值。
         * @example
         * var lonLat = new SuperMap.LonLat(10050);
         * lonLat.destroy();
         */

    }, {
        key: "destroy",
        value: function destroy() {
            this.lon = null;
            this.lat = null;
        }

        /**
         * @function SuperMap.LonLat.fromString
         * @description 通过字符串生成一个<SuperMap.LonLat>对象
         * @example
         * var str = "10050";
         * var lonLat = SuperMap.LonLat.fromString(str);
         *
         * @param str - {string} 字符串的格式：Lon+""+Lat。如："10050"
         * @returns {SuperMap.LonLat} 返回一个 <SuperMap.LonLat> 对象
         */

    }], [{
        key: "fromString",
        value: function fromString(str) {
            var pair = str.split(",");
            return new LonLat(pair[0], pair[1]);
        }

        /**
         * @function SuperMap.LonLat.fromArray
         * @description 通过数组生成一个<SuperMap.LonLat>对象
         * @param arr - {Array<float>} 数组的格式，长度只能为2：[LonLat]。如： [5-42]
         * @returns {SuperMap.LonLat} 返回一个 <SuperMap.LonLat> 对象
         */

    }, {
        key: "fromArray",
        value: function fromArray(arr) {
            var gotArr = _Util.Util.isArray(arr),
                lon = gotArr && arr[0],
                lat = gotArr && arr[1];
            return new LonLat(lon, lat);
        }
    }]);

    return LonLat;
}();

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MultiPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Collection2 = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.MultiPoint
 * @classdesc 几何对象多点类。
 * @extends {SuperMap.Geometry.Collection}
 * @param components - {Array<SuperMap.Geometry.Point>} 点对象数组。
 * @example
 * var point1 = new SuperMap.Geometry.Point(5,6);
 * var poine2 = new SuperMap.Geometry.Point(7,8);
 * var multiPoint = new SuperMap.Geometry.MultiPoint([point1,point2]);
 */
var MultiPoint = exports.MultiPoint = function (_Collection) {
    _inherits(MultiPoint, _Collection);

    function MultiPoint(components) {
        _classCallCheck(this, MultiPoint);

        /**
         * @member SuperMap.Geometry.MultiPoint.prototype.componentTypes -{Array<string>}
         * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
         * @readonly
         * @default ["{@link SuperMap.Geometry.Point}"]
         */
        var _this = _possibleConstructorReturn(this, (MultiPoint.__proto__ || Object.getPrototypeOf(MultiPoint)).call(this, components));

        _this.componentTypes = ["SuperMap.Geometry.Point"];
        _this.CLASS_NAME = "SuperMap.Geometry.MultiPoint";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.MultiPoint.prototype.addPoint
     * @description 添加点，封装了 {@link SuperMap.Geometry.Collection|SuperMap.Geometry.Collection.addComponent}方法。
     * @param point - {SuperMap.Geometry.Point} 添加的点。
     * @param index - {integer} 可选的下标。
     */


    _createClass(MultiPoint, [{
        key: 'addPoint',
        value: function addPoint(point, index) {
            this.addComponent(point, index);
        }

        /**
         * @function SuperMap.Geometry.MultiPoint.prototype.removePoint
         * @description 移除点封装了 {@link SuperMap.Geometry.Collection|SuperMap.Geometry.Collection.removeComponent} 方法。
         * @param point - {SuperMap.Geometry.Point} 移除的点对象。
         */

    }, {
        key: 'removePoint',
        value: function removePoint(point) {
            this.removeComponent(point);
        }
    }]);

    return MultiPoint;
}(_Collection2.Collection);

_SuperMap.SuperMap.Geometry.MultiPoint = MultiPoint;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FacilityAnalyst3DParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FacilityAnalyst3DParameters
 * @classdesc 最近设施分析参数基类。最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *               设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，
 *               超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。最近设施查找实际上也是一种路径分析，因此对路径分析起
 *               作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @param options - {Object} 可选参数。如：<br>
 *         edgeID - {number} 指定的弧段ID。<br>
 *         nodeID - {integer} 指定的结点ID。<br>
 *         weightName -{string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                               指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 */
var FacilityAnalyst3DParameters = exports.FacilityAnalyst3DParameters = function () {
  function FacilityAnalyst3DParameters(options) {
    _classCallCheck(this, FacilityAnalyst3DParameters);

    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.edgeID - {number}
     * @description 指定的弧段ID。
     */
    this.edgeID = null;

    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.nodeID - {number}
     * @description 指定的结点ID。
     */
    this.nodeID = null;

    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.weightName - string}
     * @description 指定的权值字段信息对象的名称。
     */
    this.weightName = null;

    /**
     * @member SuperMap.FacilityAnalyst3DParameters.prototype.isUncertainDirectionValid - {boolean}
     * @description 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
     *                指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找
     */
    this.isUncertainDirectionValid = false;
    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.FacilityAnalyst3DParameters";
  }

  /**
   * @function SuperMap.FacilityAnalyst3DParameters.prototype.destroy
   * @override
   */


  _createClass(FacilityAnalyst3DParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.edgeID = null;
      me.nodeID = null;
      me.weightName = null;
      me.isUncertainDirectionValid = null;
    }
  }]);

  return FacilityAnalyst3DParameters;
}();

_SuperMap.SuperMap.FacilityAnalyst3DParameters = FacilityAnalyst3DParameters;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetFeaturesParametersBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GetFeaturesParametersBase
 * @classdesc 要素查询参数基类
 * @param options - {Object} 参数。如：<br>
 *        datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {integer} 查询结果的最小索引号。</br>
 *        toIndex - {integer} 查询结果的最大索引号。</br>
 */
var GetFeaturesParametersBase = exports.GetFeaturesParametersBase = function () {
  function GetFeaturesParametersBase(options) {
    _classCallCheck(this, GetFeaturesParametersBase);

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.datasetName - {Array<string>}
     * @description 数据集集合中的数据集名称列表。
     */
    this.datasetNames = null;

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.returnContent - {boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
     *              如果为 true，则直接返回新创建资源，即查询结果的表述。
     *              如果为 false，则返回的是查询结果资源的 URI。默认为 true。
     */
    this.returnContent = true;

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.fromIndex - {integer}
     * @description 查询结果的最小索引号。默认值是0，如果该值大于查询结果的最大索引号，则查询结果为空。
     */
    this.fromIndex = 0;

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.toIndex - {integer}
     * @description 查询结果的最大索引号。默认值是19，如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
     */
    this.toIndex = 19;

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.returnCountOnly - {boolean}
     * @description 只返回查询结果的总数，默认为false。
     */
    this.returnCountOnly = false;

    /**
     * @member SuperMap.GetFeaturesParametersBase.prototype.maxFeatures - {integer}
     * @description 进行SQL查询时，用于设置服务端返回查询结果条目数量，默认为1000。
     */
    this.maxFeatures = null;
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.GetFeaturesParametersBase";
  }

  /**
   *
   * @function SuperMap.GetFeaturesParametersBase.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(GetFeaturesParametersBase, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.datasetNames = null;
      me.returnContent = null;
      me.fromIndex = null;
      me.toIndex = null;
      me.maxFeatures = null;
    }
  }]);

  return GetFeaturesParametersBase;
}();

_SuperMap.SuperMap.GetFeaturesParametersBase = GetFeaturesParametersBase;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _CommonServiceBase2 = __webpack_require__(6);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesServiceBase
 * @classdesc 数据服务中数据集查询服务基类。获取结果数据类型为Object。包含 result属性，result的数据格式根据format参数决定为GeoJSON或者iServerJSON。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，URL
 * 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @example
 * var myService = new SuperMap.GetFeaturesServiceBase(url, {
 *     eventListeners: {
 *         "processCompleted": getFeatureCompleted,
 *         "processFailed": getFeatureError
 *     }
 * });
 */
var GetFeaturesServiceBase = exports.GetFeaturesServiceBase = function (_CommonServiceBase) {
    _inherits(GetFeaturesServiceBase, _CommonServiceBase);

    function GetFeaturesServiceBase(url, options) {
        _classCallCheck(this, GetFeaturesServiceBase);

        var _this = _possibleConstructorReturn(this, (GetFeaturesServiceBase.__proto__ || Object.getPrototypeOf(GetFeaturesServiceBase)).call(this, url, options));

        options = options || {};

        /**
         * @member SuperMap.GetFeaturesServiceBase.prototype.returnContent - {boolean}
         * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
         * 如果为 true，则直接返回新创建资源，即查询结果的表述。
         * 如果为 false，则返回的是查询结果资源的 URI。默认为 false。
         */
        _this.returnContent = true;

        /**
         * @member SuperMap.GetFeaturesServiceBase.prototype.fromIndex - {integer}
         * @description 查询结果的最小索引号。
         * 默认值是0，如果该值大于查询结果的最大索引号，则查询结果为空。
         */
        _this.fromIndex = 0;

        /**
         * @member SuperMap.GetFeaturesServiceBase.prototype.toIndex - {integer}
         * @description 查询结果的最大索引号。
         * 如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
         */
        _this.toIndex = 19;

        /**
         * @member SuperMap.GetFeaturesServiceBase.prototype.maxFeatures - {integer}
         * @description 进行SQL查询时，用于设置服务端返回查询结果条目数量，默认为1000。
         */
        _this.maxFeatures = null;

        /**
         * @member SuperMap.GetFeaturesServiceBase.prototype.format - {string}
         * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。
         *  参数格式为"ISERVER","GEOJSON",GEOJSON
         */
        _this.format = _REST.DataFormat.GEOJSON;

        if (options) {
            _Util.Util.extend(_this, options);
        }
        var me = _this,
            end;
        if (options && options.format) {
            me.format = options.format.toUpperCase();
        }

        end = me.url.substr(me.url.length - 1, 1);
        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
        // if (me.format==="geojson" ) {
        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
        // } else {
        //     me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
        // }
        me.url += end == "/" ? "featureResults.json?" : "/featureResults.json?";

        _this.CLASS_NAME = "SuperMap.GetFeaturesServiceBase";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesServiceBase.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(GetFeaturesServiceBase, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesServiceBase.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesServiceBase.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.fromIndex = null;
            me.toIndex = null;
            me.maxFeatures = null;
            me.format = null;
        }

        /**
         * @function SuperMap.GetFeaturesServiceBase.prototype.processAsync
         * @description  将客户端的查询参数传递到服务端。
         * @param params - {Object} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this,
                jsonParameters = null,
                firstPara = true;

            me.returnContent = params.returnContent;
            me.fromIndex = params.fromIndex;
            me.toIndex = params.toIndex;
            me.maxFeatures = params.maxFeatures;
            if (me.returnContent) {
                me.url += "returnContent=" + me.returnContent;
                firstPara = false;
            }
            var isValidNumber = me.fromIndex != null && me.toIndex != null && !isNaN(me.fromIndex) && !isNaN(me.toIndex);
            if (isValidNumber && me.fromIndex >= 0 && me.toIndex >= 0 && !firstPara) {
                me.url += "&fromIndex=" + me.fromIndex + "&toIndex=" + me.toIndex;
            }

            if (params.returnCountOnly) {
                me.url += "&returnCountOnly=" + params.returnContent;
            }
            jsonParameters = me.getJsonParameters(params);
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.GetFeaturesServiceBase.prototype.getFeatureComplete
         * @description 查询完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            if (me.format === _REST.DataFormat.GEOJSON && result.features) {
                var geoJSONFormat = new _GeoJSON.GeoJSON();
                result.features = JSON.parse(geoJSONFormat.write(result.features));
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }
    }]);

    return GetFeaturesServiceBase;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.GetFeaturesServiceBase = GetFeaturesServiceBase;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InterpolationAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(157);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.InterpolationAnalystParameters
 * @classdesc 插值分析参数类。
 * @param options - {Object} 可选参数。如：</br>
 *        bounds - {Object} 插值分析的范围，用于确定结果栅格数据集的范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchRadius - {number} 查找半径，即参与运算点的查找范围，与点数据集单位相同。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。</br>
 *        zValueScale - {number} 用于进行插值分析值的缩放比率，默认为1。</br>
 *        resolution - {number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {{@link SuperMap.FilterParameter}} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。</br>
 *        pixelFormat - {{@link SuperMap.PixelFormat}} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 用于做插值分析的数据源中数据集的名称。</br>
 *        inputPoints - {Array <Object>} 用于做插值分析的离散点集合。点类型可以是：SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *        InterpolationAnalystType - {string} 插值分析类型（dataset或geometry），默认为dataset 。</br>
 */
var InterpolationAnalystParameters = exports.InterpolationAnalystParameters = function () {
  function InterpolationAnalystParameters(options) {
    _classCallCheck(this, InterpolationAnalystParameters);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.bounds - {Object}
     * @description 插值分析的范围，用于确定结果栅格数据集的范围。
     * Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
     * 如果缺省，则默认为原数据集的范围。鉴于此插值方法为内插方法，原数据集的范围内的插值结果才相对有参考价值，
     * 因此建议此参数不大于原数据集范围。
     */
    this.bounds = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.searchRadius - {number}
     * @description 查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。
     * 计算某个位置的Z 值时，会以该位置为圆心，以查找范围的值为半径，落在这个范围内的采样点都将参与运算。
     * 该值需要根据待插值点数据的分布状况和点数据集范围进行设置。
     */
    this.searchRadius = 0;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.zValueFieldName - {string}
     * @description 数据集插值分析中，用于指定进行插值分析的目标字段名，插值分析不支持文本类型的字段。
     * 含义为每个插值点在插值过程中的权重，可以将所有点此字段值设置为1，即所有点在整体插值中权重相同。
     * 当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
     */
    this.zValueFieldName = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.zValueScale - {number}
     * @description 用于进行插值分析值的缩放比率，默认值为1。
     * 参加插值分析的值将乘以该参数值后再进行插值，也就是对进行插值分析的值进行统一的扩大或缩小。
     */
    this.zValueScale = 1;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.resolution - {number}
     * @description 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
     * 该值不能超过待分析数据集的范围边长。
     * 且该值设置时，应该考虑点数据集范围大小来取值，一般为结果栅格行列值（即结果栅格数据集范围除以分辨率），在500以内可以较好地体现密度走势。
     */
    this.resolution = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.filterQueryParameter - {SuperMap.FilterParameter}
     * @description 过滤条件，对分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
     */
    this.filterQueryParameter = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.outputDatasetName - {string}
     * @description 插值分析结果数据集的名称。必设参数。
     */
    this.outputDatasetName = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.outputDatasourceName - {string}
     * @description 插值分析结果数据源的名称。必设参数。
     */
    this.outputDatasourceName = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.pixelFormat - {SuperMap.PixelFormat}
     * @description 指定结果栅格数据集存储的像素格式。
     * 默认值为 SuperMap.PixelFormat.BIT16。
     * 支持存储的像素格式有 BIT16、BIT32、DOUBLE、SINGLE、UBIT1、UBIT4、UBIT8、UBIT24、UBIT32。
     */
    this.pixelFormat = _REST.PixelFormat.BIT16;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.dataset - {string}
     * @description 用来做插值分析的数据源中数据集的名称，该名称用形如"数据集名称@数据源别名"形式来表示。
     * 当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。
     */
    this.dataset = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.inputPoints - {Array<Object>}
     * @description 用于做插值分析的离散点（离散点包括Z值）集合。
     * 点类型可以是：SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     * 当插值分析类型（InterpolationAnalystType）为 geometry 时，此参数为必设参数。
     * 通过离散点直接进行插值分析不需要指定输入数据集inputDatasourceName，inputDatasetName以及zValueFieldName。
     */
    this.inputPoints = null;

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.InterpolationAnalystType - {string}
     * @description  插值分析类型。差值分析包括数据集插值分析和几何插值分析两类，
     * "dataset"表示对数据集进行插值分析，"geometry"表示对离散点数组进行插值分析，默认值为"dataset"。
     */
    this.InterpolationAnalystType = "dataset";

    /**
     * @member SuperMap.InterpolationAnalystParameters.prototype.clipParam - {Object}
     * @description 对插值分析结果进行裁剪的参数。
     */
    this.clipParam = null;

    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.InterpolationAnalystParameters";
  }

  /**
   * @function SuperMap.InterpolationAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(InterpolationAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.bounds = null;
      me.searchRadius = null;
      me.zValueFieldName = null;
      me.zValueScale = null;

      me.resolution = null;
      me.filterQueryParameter = null;
      me.outputDatasetName = null;
      me.pixelFormat = null;
    }

    /**
     * @function SuperMap.InterpolationAnalystParameters.toObject
     * @param interpolationAnalystParameters - {SuperMap.InterpolationAnalystParameters} 插值分析参数类。
     * @param tempObj - {SuperMap.InterpolationAnalystParameters} 插值分析参数对象。
     * @description 将插值分析参数对象转换成JSON对象。
     * @return JSON对象。
     */

  }], [{
    key: 'toObject',
    value: function toObject(interpolationAnalystParameters, tempObj) {
      for (var name in interpolationAnalystParameters) {
        if (name === "inputPoints" && interpolationAnalystParameters.InterpolationAnalystType === "geometry") {
          var objs = [];
          for (var i = 0; i < interpolationAnalystParameters.inputPoints.length; i++) {
            var item = interpolationAnalystParameters.inputPoints[i];
            var obj = {
              x: item.x,
              y: item.y,
              z: item.tag
            };
            objs.push(obj);
          }
          tempObj[name] = objs;
        } else {
          tempObj[name] = interpolationAnalystParameters[name];
        }
      }
    }
  }]);

  return InterpolationAnalystParameters;
}();

_SuperMap.SuperMap.InterpolationAnalystParameters = InterpolationAnalystParameters;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NormalizeScale = exports.GetResolutionFromScaleDpi = exports.scaleToResolution = exports.resolutionToScale = exports.getMeterPerMapUnit = exports.toSuperMapGeometry = exports.toGeoJSON = exports.supermap_callbacks = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var supermap_callbacks = exports.supermap_callbacks = {};
_leaflet2["default"].Util.supermap_callbacks = supermap_callbacks;
var toGeoJSON = exports.toGeoJSON = function toGeoJSON(feature) {
    if (!feature) {
        return feature;
    }
    return JSON.parse(new _iclientCommon.GeoJSON().write(feature));
};
var toSuperMapGeometry = exports.toSuperMapGeometry = function toSuperMapGeometry(geometry) {
    if (!geometry) {
        return geometry;
    }
    var result,
        format = new _iclientCommon.GeoJSON();
    if (["FeatureCollection", "Feature", "Geometry"].indexOf(geometry.type) != -1) {
        result = format.read(geometry, geometry.type);
    } else if (typeof geometry.toGeoJSON === "function") {
        var geojson = geometry.toGeoJSON();
        result = geojson ? format.read(geojson, geojson.type) : geometry;
    }

    var serverResult = result;
    if (_leaflet2["default"].Util.isArray(result)) {
        if (result.length === 1) {
            serverResult = result[0];
        } else if (result.length > 1) {
            serverResult = [];
            result.map(function (item) {
                serverResult.push(item.geometry);
                return item;
            });
        }
    }

    return serverResult && serverResult.geometry ? serverResult.geometry : serverResult;
};

var getMeterPerMapUnit = exports.getMeterPerMapUnit = function getMeterPerMapUnit(mapUnit) {
    var earchRadiusInMeters = 6378137;
    var meterPerMapUnit;
    if (mapUnit === _iclientCommon.Unit.METER) {
        meterPerMapUnit = 1;
    } else if (mapUnit === _iclientCommon.Unit.DEGREE) {
        // 每度表示多少米。
        meterPerMapUnit = Math.PI * 2 * earchRadiusInMeters / 360;
    } else if (mapUnit === _iclientCommon.Unit.KILOMETER) {
        meterPerMapUnit = 1.0E-3;
    } else if (mapUnit === _iclientCommon.Unit.INCH) {
        meterPerMapUnit = 1 / 2.5399999918E-2;
    } else if (mapUnit === _iclientCommon.Unit.FOOT) {
        meterPerMapUnit = 0.3048;
    } else {
        return meterPerMapUnit;
    }
    return meterPerMapUnit;
};

var resolutionToScale = exports.resolutionToScale = function resolutionToScale(resolution, dpi, mapUnit) {
    var inchPerMeter = 1 / 0.0254;
    // 地球半径。
    var meterPerMapUnit = getMeterPerMapUnit(mapUnit);
    var scale = resolution * dpi * inchPerMeter * meterPerMapUnit;
    scale = 1 / scale;
    return scale;
};
var scaleToResolution = exports.scaleToResolution = function scaleToResolution(scale, dpi, mapUnit) {
    var inchPerMeter = 1 / 0.0254;
    var meterPerMapUnitValue = getMeterPerMapUnit(mapUnit);
    var resolution = scale * dpi * inchPerMeter * meterPerMapUnitValue;
    resolution = 1 / resolution;
    return resolution;
};

var GetResolutionFromScaleDpi = exports.GetResolutionFromScaleDpi = function GetResolutionFromScaleDpi(scale, dpi, coordUnit, datumAxis) {
    var resolution = null,
        ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || "";
    if (scale > 0 && dpi > 0) {
        scale = _leaflet2["default"].Util.NormalizeScale(scale);
        if (coordUnit.toLowerCase() === "degree" || coordUnit.toLowerCase() === "degrees" || coordUnit.toLowerCase() === "dd") {
            //scale = SuperMap.Util.normalizeScale(scale);
            resolution = 0.0254 * ratio / dpi / scale / (Math.PI * 2 * datumAxis / 360) / ratio;
            return resolution;
        } else {
            resolution = 0.0254 * ratio / dpi / scale / ratio;
            return resolution;
        }
    }
    return -1;
};
var NormalizeScale = exports.NormalizeScale = function NormalizeScale(scale) {
    return scale > 1.0 ? 1.0 / scale : scale;
};

_leaflet2["default"].Util.toGeoJSON = toGeoJSON;
_leaflet2["default"].Util.toSuperMapGeometry = toSuperMapGeometry;
_leaflet2["default"].Util.resolutionToScale = resolutionToScale;
_leaflet2["default"].Util.scaleToResolution = scaleToResolution;
_leaflet2["default"].Util.getMeterPerMapUnit = getMeterPerMapUnit;
_leaflet2["default"].Util.GetResolutionFromScaleDpi = GetResolutionFromScaleDpi;
_leaflet2["default"].Util.NormalizeScale = NormalizeScale;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = function(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
};

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = function(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrayExt = exports.FunctionExt = exports.NumberExt = exports.StringExt = undefined;

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *@namespace SuperMap
 */

/**
 * @description In addition to the mandatory C and P parameters, an arbitrary number of
 * objects can be passed, which will extend C.
 * @memberOf SuperMap
 * @param C - {Object} the class that inherits
 * @param P - {Object} the superclass to inherit from
 */
_SuperMap.SuperMap.inherit = function (C, P) {
    var F = function F() {};
    F.prototype = P.prototype;
    C.prototype = new F();
    var i, l, o;
    for (i = 2, l = arguments.length; i < l; i++) {
        o = arguments[i];
        if (typeof o === "function") {
            o = o.prototype;
        }
        _SuperMap.SuperMap.Util.extend(C.prototype, o);
    }
};

/**
 * @description 实现多重继承
 * @memberOf SuperMap
 * @param ...mixins {Class|Object}继承的类
 */
_SuperMap.SuperMap.mixin = function () {
    for (var _len = arguments.length, mixins = Array(_len), _key = 0; _key < _len; _key++) {
        mixins[_key] = arguments[_key];
    }

    var Mix = function Mix(options) {
        _classCallCheck(this, Mix);

        for (var index = 0; index < mixins.length; index++) {
            copyProperties(this, new mixins[index](options));
        }
    };

    for (var index = 0; index < mixins.length; index++) {
        var mixin = mixins[index];
        copyProperties(Mix, mixin);
        copyProperties(Mix.prototype, mixin.prototype);
        copyProperties(Mix.prototype, new mixin());
    }
    return Mix;

    function copyProperties(target, source) {
        var ownKeys = Object.getOwnPropertyNames(source);
        if (Object.getOwnPropertySymbols) {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source));
        }
        for (var index = 0; index < ownKeys.length; index++) {
            var key = ownKeys[index];
            if (key !== "constructor" && key !== "prototype" && key !== "name" && key !== "length") {
                var desc = Object.getOwnPropertyDescriptor(source, key);
                Object.defineProperty(target, key, desc);
            }
        }
    }
};

/**
 * @name String
 * @memberOf SuperMap
 * @namespace
 * @description 字符串操作的一系列常用扩展函数.
 */
var StringExt = exports.StringExt = _SuperMap.SuperMap.String = {

    /**
     * @description 判断目标字符串是否以指定的子字符串开头.
     * @param str - {string} 目标字符串.
     * @param sub - {string} 查找的子字符串.
     * @returns {Boolean} 目标字符串以指定的子字符串开头,则返回true;否则返回false.
     */
    startsWith: function startsWith(str, sub) {
        return str.indexOf(sub) == 0;
    },

    /**
     * @description 判断目标字符串是否包含指定的子字符串.
     * @param str - {string} 目标字符串.
     * @param sub - {string} 查找的子字符串.
     * @returns {Boolean} 目标字符串中包含指定的子字符串,则返回true;否则返回false.
     */
    contains: function contains(str, sub) {
        return str.indexOf(sub) != -1;
    },

    /**
     * @description 删除一个字符串的开头和结尾处的所有空白字符.
     * @param str - {string} (可能)存在空白字符填塞的字符串.
     * @returns {string} 删除开头和结尾处空白字符后的字符串.
     */
    trim: function trim(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },

    /**
     * @description 骆驼式("-")连字符的字符串处理.
     * 例如: "chicken-head" becomes "chickenHead",
     *       "-chicken-head" becomes "ChickenHead".
     * @param str - {string} 要处理的字符串,原始内容不应被修改.
     * @returns {string}
     */
    camelize: function camelize(str) {
        var oStringList = str.split('-');
        var camelizedString = oStringList[0];
        for (var i = 1, len = oStringList.length; i < len; i++) {
            var s = oStringList[i];
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
        }
        return camelizedString;
    },

    /**
     * @description 提供带 ${token} 标记的字符串, 返回context对象属性中指定标记的属性值.
     * @example
     * 示例:
     * (code)
     * 1、template = "${value,getValue}";
     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};
     *         args = [2,23,12,36,21];
     *       返回值:36
     * (end)
     * 示例:
     * (code)
     * 2、template = "$${{value,getValue}}";
     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};
     *         args = [2,23,12,36,21];
     *       返回值:"${36}"
     * (end)
     * 示例:
     * (code)
     * 3、template = "${a,b}";
     *         context = {a: {b:"format"}};
     *         args = null;
     *       返回值:"format"
     * (end)
     * 示例:
     * (code)
     * 3、template = "${a,b}";
     *         context = null;
     *         args = null;
     *       返回值:"${a.b}"
     * (end)
     * @param template - {string} 带标记的字符串将要被替换.参数 template 格式为"${token}",此处的 token 标记会替换为 context["token"] 属性的值
     * @param context - {Object} 带有属性的可选对象的属性用于匹配格式化字符串中的标记.如果该参数为空,将使用 window 对象.
     * @param args - {Array} 可选参数传递给在context对象上找到的函数.
     * @returns {string} 从 context 对象属性中替换字符串标记位的字符串.
     */
    format: function format(template, context, args) {
        if (!context) {
            context = window;
        }

        // Example matching:
        // str   = ${foo.bar}
        // match = foo.bar
        var replacer = function replacer(str, match) {
            var replacement;

            // Loop through all subs. Example: ${a.b.c}
            // 0 -> replacement = context[a];
            // 1 -> replacement = context[a][b];
            // 2 -> replacement = context[a][b][c];
            var subs = match.split(/\.+/);
            for (var i = 0; i < subs.length; i++) {
                if (i == 0) {
                    replacement = context;
                }

                replacement = replacement[subs[i]];
            }

            if (typeof replacement === "function") {
                replacement = args ? replacement.apply(null, args) : replacement();
            }

            // If replacement is undefined, return the string 'undefined'.
            // This is a workaround for a bugs in browsers not properly
            // dealing with non-participating groups in regular expressions:
            // http://blog.stevenlevithan.com/archives/npcg-javascript
            if (typeof replacement == 'undefined') {
                return 'undefined';
            } else {
                return replacement;
            }
        };

        return template.replace(_SuperMap.SuperMap.String.tokenRegEx, replacer);
    },

    /**
     * @description Used to find tokens in a string.
     * @default  /\$\{([\w.]+?)\}/g
     * @example
     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}
     */
    tokenRegEx: /\$\{([\w.]+?)\}/g,

    /**
     * @description Used to test strings as numbers.
     * @default  /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/
     */
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,

    /**
     * @description 判断一个字符串是否只包含一个数值.
     * @example
     * (code)
     * SuperMap.String.isNumeric("6.02e23") // true
     * SuperMap.String.isNumeric("12 dozen") // false
     * SuperMap.String.isNumeric("4") // true
     * SuperMap.String.isNumeric(" 4 ") // false
     * (end)
     * @returns {Boolean} 字符串包含唯一的数值,返回true;否则返回false.
     */
    isNumeric: function isNumeric(value) {
        return _SuperMap.SuperMap.String.numberRegEx.test(value);
    },

    /**
     * @description 把一个看似数值型的字符串转化为一个数值.
     *
     * @returns {number|string} 如果能转换为数值则返回数值,否则返回字符串本身.
     */
    numericIf: function numericIf(value) {
        return _SuperMap.SuperMap.String.isNumeric(value) ? parseFloat(value) : value;
    }

};

/**
 * @name Number
 * @memberOf SuperMap
 * @namespace
 * @description 数值操作的一系列常用扩展函数.
 */
var NumberExt = exports.NumberExt = _SuperMap.SuperMap.Number = {

    /**
     *  @description 格式化数字时默认的小数点分隔符.
     *  @constant
     *  @default "."
     */
    decimalSeparator: ".",

    /**
     *  @description 格式化数字时默认的千位分隔符.
     *  @constant
     *  @default ","
     */
    thousandsSeparator: ",",

    /**
     * @description 限制浮点数的有效数字位数.
     * @param num - {number}
     * @param sig - {integer}
     * @returns {number} 将数字四舍五入到指定数量的有效位数.
     */
    limitSigDigs: function limitSigDigs(num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },

    /**
     * @description 数字格式化输出.
     * @param num  - {number}
     * @param dec  - {integer} 数字的小数部分四舍五入到指定的位数.默认为 0. 设置为null值时小数部分不变.
     * @param tsep - {string} 千位分隔符. 默认为",".
     * @param dsep - {string} 小数点分隔符. 默认为".".
     * @returns {string} 数字格式化后的字符串.
     */
    format: function format(num, dec, tsep, dsep) {
        dec = typeof dec != "undefined" ? dec : 0;
        tsep = typeof tsep != "undefined" ? tsep : _SuperMap.SuperMap.Number.thousandsSeparator;
        dsep = typeof dsep != "undefined" ? dsep : _SuperMap.SuperMap.Number.decimalSeparator;

        if (dec != null) {
            num = parseFloat(num.toFixed(dec));
        }

        var parts = num.toString().split(".");
        if (parts.length === 1 && dec == null) {
            // integer where we do not want to touch the decimals
            dec = 0;
        }

        var integer = parts[0];
        if (tsep) {
            var thousands = /(-?[0-9]+)([0-9]{3})/;
            while (thousands.test(integer)) {
                integer = integer.replace(thousands, "$1" + tsep + "$2");
            }
        }

        var str;
        if (dec == 0) {
            str = integer;
        } else {
            var rem = parts.length > 1 ? parts[1] : "0";
            if (dec != null) {
                rem = rem + new Array(dec - rem.length + 1).join("0");
            }
            str = integer + dsep + rem;
        }
        return str;
    }
};

if (!Number.prototype.limitSigDigs) {
    /**
     * APIMethod: Number.limitSigDigs
     * 限制浮点数的有效数字位数.
     * @param sig - {integer}
     * @returns {integer} 将数字四舍五入到指定数量的有效位数.
     *           如果传入值为 null、0、或者是负数, 返回值 0
     */
    Number.prototype.limitSigDigs = function (sig) {
        return NumberExt.limitSigDigs(this, sig);
    };
}

/**
 * @name Function
 * @memberOf SuperMap
 * @namespace
 * @description 函数操作的一系列常用扩展函数.
 */
var FunctionExt = exports.FunctionExt = _SuperMap.SuperMap.Function = {
    /**
     * @description 绑定函数到对象.方便创建this的作用域.
     * @param func - {function} 输入函数.
     * @param object - {Object} 对象绑定到输入函数(作为输入函数的this对象).
     * @returns {function} object参数作为func函数的this对象.
     */
    bind: function bind(func, object) {
        // create a reference to all arguments past the second one
        var args = Array.prototype.slice.apply(arguments, [2]);
        return function () {
            // Push on any additional arguments from the actual function call.
            // These will come after those sent to the bind call.
            var newArgs = args.concat(Array.prototype.slice.apply(arguments, [0]));
            return func.apply(object, newArgs);
        };
    },

    /**
     * @description 绑定函数到对象,在调用该函数时配置并使用事件对象作为第一个参数.
     * @param func - {function} 用于监听事件的函数.
     * @param object - {Object} this 对象的引用.
     * @returns {function}
     */
    bindAsEventListener: function bindAsEventListener(func, object) {
        return function (event) {
            return func.call(object, event || window.event);
        };
    },

    /**
     * @description 该函数仅仅返回false.该函数主要是避免在IE8以下浏览中DOM事件句柄的匿名函数问题.
     * @example
     * document.onclick = SuperMap.Function.False;
     * @returns {Boolean}
     */
    False: function False() {
        return false;
    },

    /**
     * @description 该函数仅仅返回true.该函数主要是避免在IE8以下浏览中DOM事件句柄的匿名函数问题.
     * @example
     * document.onclick = SuperMap.Function.True;
     * @returns {Boolean}
     */
    True: function True() {
        return true;
    },

    /**
     * @description 可重用函数,仅仅返回"undefined".
     * @returns {undefined}
     */
    Void: function Void() {}

};

/**
 * @name Array
 * @memberOf SuperMap
 * @namespace
 * @description 数组操作的一系列常用扩展函数.
 */
var ArrayExt = exports.ArrayExt = _SuperMap.SuperMap.Array = {

    /**
     * @description 过滤数组.提供了ECMA-262标准中Array.prototype.filter函数的扩展.
     * @see {@link http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter}
     * @param array - {Array} 要过滤的数组..
     * @param callback - {function} 数组中的每一个元素调用该函数.<br>
     *     如果函数的返回值为true,该元素将包含在返回的数组中.该函数有三个参数: 数组中的元素,元素的索引,数组自身.<br>
     *     如果设置了可选参数caller,在调用callback时,使用可选参数caller设置为callback的参数.<br>
     * @param caller - {Object} 在调用callback时,使用可选参数caller设置为callback的参数.
     * @returns {Array} callback函数返回true时的元素将作为返回数组中的元素.
     */
    filter: function filter(array, callback, caller) {
        var selected = [];
        if (Array.prototype.filter) {
            selected = array.filter(callback, caller);
        } else {
            var len = array.length;
            if (typeof callback != "function") {
                throw new TypeError();
            }
            for (var i = 0; i < len; i++) {
                if (i in array) {
                    var val = array[i];
                    if (callback.call(caller, val, i, array)) {
                        selected.push(val);
                    }
                }
            }
        }
        return selected;
    }

};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiLineString = undefined;

var _SuperMap = __webpack_require__(0);

var _Collection2 = __webpack_require__(27);

__webpack_require__(17);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.MultiLineString
 * @classdesc 几何对象多线类。
 * @extends {SuperMap.Geometry.Collection}
 * @param components - {Array<SuperMap.Geometry.LineString>} LineString数组。
 * @example
 * var multi = new SuperMap.Geometry.MultiLineString([
 *      new SuperMap.Geometry.LineString([
 *          new SuperMap.Geometry.Point(1, 0),
 *          new SuperMap.Geometry.Point(0, 1)
 *      ])
 *  ]);
 */
var MultiLineString = exports.MultiLineString = function (_Collection) {
  _inherits(MultiLineString, _Collection);

  function MultiLineString(components) {
    _classCallCheck(this, MultiLineString);

    /**
     * @member SuperMap.Geometry.MultiLineString.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.LineString}"]
     */
    var _this = _possibleConstructorReturn(this, (MultiLineString.__proto__ || Object.getPrototypeOf(MultiLineString)).call(this, components));

    _this.componentTypes = ["SuperMap.Geometry.LineString"];
    _this.CLASS_NAME = "SuperMap.Geometry.MultiLineString";
    return _this;
  }

  return MultiLineString;
}(_Collection2.Collection);

_SuperMap.SuperMap.Geometry.MultiLineString = MultiLineString;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiPolygon = undefined;

var _SuperMap = __webpack_require__(0);

var _Collection2 = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.MultiPolygon
 * @classdesc 几何对象多多边形类。
 * @extends {SuperMap.Geometry.Collection}
 * @param  components - {Array<SuperMap.Geometry.Polygon>} 形成 MultiPolygon 的多边形数组。
 * @example
 * var points1 = [new SuperMap.Geometry.Point(10,10),new SuperMap.Geometry.Point(0,0)];
 * var points2 = [new SuperMap.Geometry.Point(10,10),new SuperMap.Geometry.Point(0,0),new SuperMap.Geometry.Point(3,3),new SuperMap.Geometry.Point(10,10)];
 *
 * var linearRing1 = new SuperMap.Geometry.LinearRing(points1);
 * var linearRing2 = new SuperMap.Geometry.LinearRing(points2);
 *
 * var polygon1 = new SuperMap.Geometry.Polygon([linearRing1]);
 * var polygon2 = new SuperMap.Geometry.Polygon([linearRing2]);
 *
 * var multiPolygon1 = new SuperMap.Geometry.MultiPolygon([polygon1,polygon2]);
 */
var MultiPolygon = exports.MultiPolygon = function (_Collection) {
  _inherits(MultiPolygon, _Collection);

  function MultiPolygon(components) {
    _classCallCheck(this, MultiPolygon);

    /**
     * @member SuperMap.Geometry.MultiPolygon.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.Polygon}"]
     */
    var _this = _possibleConstructorReturn(this, (MultiPolygon.__proto__ || Object.getPrototypeOf(MultiPolygon)).call(this, components));

    _this.componentTypes = ["SuperMap.Geometry.Polygon"];
    _this.CLASS_NAME = "SuperMap.Geometry.MultiPolygon";
    return _this;
  }

  return MultiPolygon;
}(_Collection2.Collection);

_SuperMap.SuperMap.Geometry.MultiPolygon = MultiPolygon;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Polygon = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Collection2 = __webpack_require__(27);

__webpack_require__(18);

__webpack_require__(17);

__webpack_require__(31);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Polygon
 * @classdesc  多边形几何对象类。
 * @extends {SuperMap.Geometry.Collection}
 * @param components - {Array<SuperMap.Geometry.LinearRing>} 用来生成多边形的线环数组。
 * @example
 * var points =[new SuperMap.Geometry.Point(0,4010338),
 *      new SuperMap.Geometry.Point(1063524,4010338),
 *      new SuperMap.Geometry.Point(1063524,3150322),
 *      new SuperMap.Geometry.Point(0,3150322)
 *  ],
 *  var linearRings = new SuperMap.Geometry.LinearRing(points),
 *  var  region = new SuperMap.Geometry.Polygon([linearRings]);
 */
var Polygon = exports.Polygon = function (_Collection) {
    _inherits(Polygon, _Collection);

    function Polygon(components) {
        _classCallCheck(this, Polygon);

        /**
         * @member SuperMap.Geometry.Polygon.prototype.componentTypes -{Array<string>}
         * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
         * @readonly
         * @default ["{@link SuperMap.Geometry.LinearRing}"]
         */
        var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, components));

        _this.componentTypes = ["SuperMap.Geometry.LinearRing"];
        _this.CLASS_NAME = "SuperMap.Geometry.Polygon";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.Polygon.prototype.getArea
     * @description 获得区域面积，从区域的外部口径减去计此区域内部口径算所得的面积。
     * @returns {float} 几何对象的面积。
     */


    _createClass(Polygon, [{
        key: 'getArea',
        value: function getArea() {
            var area = 0.0;
            if (this.components && this.components.length > 0) {
                area += Math.abs(this.components[0].getArea());
                for (var i = 1, len = this.components.length; i < len; i++) {
                    area -= Math.abs(this.components[i].getArea());
                }
            }
            return area;
        }
    }]);

    return Polygon;
}(_Collection2.Collection);

_SuperMap.SuperMap.Geometry.Polygon = Polygon;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DataReturnOption = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DataReturnOption
 * @classdesc 数据返回设置类。
 * @param options - {Object} 可选参数。如：<br>
 *         expectCount - {number} 设置返回的最大记录数，小于或者等于0时表示返回所有记录数。<br>
 *         dataset - {string} 设置结果数据集标识，当dataReturnMode为 SuperMap.DataReturnMode.DATASET_ONLY或SuperMap.DataReturnMode.DATASET_AND_RECORDSET时有效，
 *                            作为返回数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。<br>
 *         dataReturnMode - {@link SuperMap.DataReturnMode} 数据返回模式，默认为SuperMap.DataReturnMode.RECORDSET_ONLY。<br>
 *         deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为true。<br>
 */
var DataReturnOption = exports.DataReturnOption = function () {
  function DataReturnOption(options) {
    _classCallCheck(this, DataReturnOption);

    /**
     * @member SuperMap.DataReturnOption.prototype.expectCount -{number}
     * @description 设置返回的最大记录数，小于或者等于0时表示返回所有记录数。
     */
    this.expectCount = 1000;

    /**
     * @member SuperMap.DataReturnOption.prototype.dataset -{string}
     * @description 设置结果数据集标识，当dataReturnMode为 SuperMap.DataReturnMode.DATASET_ONLY
     * 或SuperMap.DataReturnMode.DATASET_AND_RECORDSET时有效，
     * 作为返回数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
     */
    this.dataset = null;

    /**
     * @member SuperMap.DataReturnOption.prototype.dataReturnMode -{SuperMap.DataReturnMode}
     * @description 数据返回模式，默认为SuperMap.DataReturnMode.RECORDSET_ONLY。
     */
    this.dataReturnMode = _REST.DataReturnMode.RECORDSET_ONLY;

    /**
     * @member SuperMap.DataReturnOption.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
     */
    this.deleteExistResultDataset = true;

    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.DataReturnOption";
  }

  /**
   * @function SuperMap.DataReturnOption.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(DataReturnOption, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.expectCount = null;
      me.dataset = null;
      me.dataReturnMode = null;
      me.deleteExistResultDataset = null;
    }
  }]);

  return DataReturnOption;
}();

_SuperMap.SuperMap.DataReturnOption = DataReturnOption;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _QueryParameters = __webpack_require__(32);

var _GeoJSON = __webpack_require__(14);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryService
 * @classdesc 查询服务基类。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 服务地址。请求地图查询服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @example
 * var myService = new SuperMap.QueryService(url, {
 *     eventListeners: {
 *	       "processCompleted": queryCompleted,
 *		   "processFailed": queryError
 *		   }
 * };
 */
var QueryService = exports.QueryService = function (_CommonServiceBase) {
    _inherits(QueryService, _CommonServiceBase);

    /*
     * @function SuperMap.QueryService.prototype.constructor
     * @description 查询服务基类构造函数。
     * @param url - {string} 服务地址。请求地图查询服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
     * @param options - {Object} 可选参数。如：<br>
     *        eventListeners - {Object} 需要被注册的监听器对象。
     */
    function QueryService(url, options) {
        _classCallCheck(this, QueryService);

        /*
         * Property: returnContent
         * {Boolean} 是否立即返回新创建资源的表述还是返回新资源的URI。
         */
        var _this = _possibleConstructorReturn(this, (QueryService.__proto__ || Object.getPrototypeOf(QueryService)).call(this, url, options));

        _this.returnContent = false;

        /*
         *  Property: format
         *  {string} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
         *  参数格式为"ISERVER","GEOJSON",GEOJSON
         */
        _this.format = _REST.DataFormat.GEOJSON;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.QueryService";
        var me = _this,
            end;
        if (!me.url) {
            return _possibleConstructorReturn(_this);
        }
        if (options && options.format) {
            me.format = options.format.toUpperCase();
        }

        end = me.url.substr(me.url.length - 1, 1);

        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
        // if (this.format==="geojson") {
        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
        // } else {
        //     me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
        // }
        me.url += end === "/" ? "queryResults.json?" : "/queryResults.json?";
        return _this;
    }

    /**
     * @function SuperMap.QueryService.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(QueryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryService.prototype.__proto__ || Object.getPrototypeOf(QueryService.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.format = null;
        }

        /**
         * @function SuperMap.QueryService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.QueryParameters} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _QueryParameters.QueryParameters)) {
                return;
            }
            var me = this,
                returnCustomResult = null,
                jsonParameters = null;
            me.returnContent = params.returnContent;
            jsonParameters = me.getJsonParameters(params);
            if (me.returnContent) {
                me.url += "returnContent=" + me.returnContent;
            } else {
                //仅供三维使用 获取高亮图片的bounds
                returnCustomResult = params.returnCustomResult;
                if (returnCustomResult) {
                    me.url += "returnCustomResult=" + returnCustomResult;
                }
            }
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: queryComplete
         * 查询完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            if (result && result.recordsets && me.format === _REST.DataFormat.GEOJSON) {
                var geoJSONFormat = new _GeoJSON.GeoJSON();
                for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                    if (recordsets[i].features) {
                        recordsets[i].features = JSON.parse(geoJSONFormat.write(recordsets[i].features));
                    }
                }
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }

        /**
         * @function SuperMap.QueryService.prototype.getQueryParameters
         * @description 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
         * @param params - {Object} JSON 字符串表示的查询参数。
         * @return {QueryParameters} 返回转化后的 QueryParameters 对象。
         */

    }, {
        key: 'getQueryParameters',
        value: function getQueryParameters(params) {
            return new _QueryParameters.QueryParameters({
                customParams: params.customParams,
                expectCount: params.expectCount,
                networkType: params.networkType,
                queryOption: params.queryOption,
                queryParams: params.queryParams,
                startRecord: params.startRecord,
                prjCoordSys: params.prjCoordSys,
                holdTime: params.holdTime
            });
        }
    }]);

    return QueryService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.QueryService = QueryService;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UGCSubLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _UGCMapLayer2 = __webpack_require__(251);

var _JoinItem = __webpack_require__(66);

var _DatasetInfo = __webpack_require__(161);

__webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UGCSubLayer
 * @classdesc 地图服务图层属性信息类，影像图层(Image)、专题图层(ServerTheme)、栅格图层(Grid)、矢量图层(Vector)等图层均继承该类。
 * @extends SuperMap.UGCMapLayer
 * @param options - {Object} 可选参数。如：<br>
 *        datasetInfo - {{@link SuperMap.DatasetInfo}} 数据集信息。<br>
 *        displayFilter - {string} 图层显示过滤条件。<br>
 *        joinItems - {{@link SuperMap.JoinItem}} 连接信息类。<br>
 *        representationField - {string} 存储制图表达信息的字段。<br>
 *        ugcLayerType - {{@link SuperMap.LayerType}} 图层类型
 */
var UGCSubLayer = exports.UGCSubLayer = function (_UGCMapLayer) {
    _inherits(UGCSubLayer, _UGCMapLayer);

    /*
     * Constructor: SuperMap.UGCSubLayer
     * 地图服务图层属性信息类构造函数。
     。
     */
    function UGCSubLayer(options) {
        _classCallCheck(this, UGCSubLayer);

        options = options || {};

        /**
         * @member SuperMap.UGCSubLayer.prototype.datasetInfo -{SuperMap.DatasetInfo}
         * @description 数据集信息。
         */
        var _this = _possibleConstructorReturn(this, (UGCSubLayer.__proto__ || Object.getPrototypeOf(UGCSubLayer)).call(this, options));

        _this.datasetInfo = null;

        /**
         * @member SuperMap.UGCSubLayer.prototype.displayFilter -{string}
         * @description 图层显示过滤条件。
         */
        _this.displayFilter = null;

        /**
         * @member SuperMap.UGCSubLayer.prototype.joinItems -{SuperMap.JoinItem}
         * @description 连接信息类。
         */
        _this.joinItems = null;

        /**
         * @member SuperMap.UGCSubLayer.prototype.representationField -{string}
         * @description 存储制图表达信息的字段。
         */
        _this.representationField = null;

        /**
         * @member SuperMap.UGCSubLayer.prototype.ugcLayerType -{SuperMap.LayerType}
         * @description 图层类型。
         */
        _this.ugcLayerType = null;

        _this.CLASS_NAME = "SuperMap.UGCSubLayer";
        return _this;
    }

    /**
     * @function SuperMap.UGCSubLayer.prototype.fromJson
     * @description 将服务端JSON对象转换成当前客户端对象
     * @param jsonObject - {Object} 要转换的 JSON 对象。
     */


    _createClass(UGCSubLayer, [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(UGCSubLayer.prototype.__proto__ || Object.getPrototypeOf(UGCSubLayer.prototype), 'fromJson', this).call(this, jsonObject);
            if (this.datasetInfo) {
                this.datasetInfo = new _DatasetInfo.DatasetInfo(this.datasetInfo);
            }
            if (this.joinItems && this.joinItems.length) {
                var newJoinItems = [];
                for (var i = 0; i < this.joinItems.length; i++) {
                    newJoinItems[i] = new _JoinItem.JoinItem(this.joinItems[i]);
                }
                this.joinItems = newJoinItems;
            }
        }

        /**
         * @function SuperMap.UGCSubLayer.prototype.destroy
         * @override
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            _get(UGCSubLayer.prototype.__proto__ || Object.getPrototypeOf(UGCSubLayer.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.UGCSubLayer.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return{Object} 对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = _get(UGCSubLayer.prototype.__proto__ || Object.getPrototypeOf(UGCSubLayer.prototype), 'toServerJSONObject', this).call(this);
            if (jsonObject.joinItems) {
                var joinItems = [];
                for (var i = 0; i < jsonObject.joinItems.length; i++) {
                    if (jsonObject.joinItems[i].toServerJSONObject) {
                        joinItems[i] = jsonObject.joinItems[i].toServerJSONObject();
                    }
                }
                jsonObject.joinItems = joinItems;
            }
            if (jsonObject.datasetInfo) {
                if (jsonObject.datasetInfo.toServerJSONObject) {
                    jsonObject.datasetInfo = jsonObject.datasetInfo.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return UGCSubLayer;
}(_UGCMapLayer2.UGCMapLayer);

_SuperMap.SuperMap.UGCSubLayer = UGCSubLayer;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Eventful
 * 事件分发器超类，所有支持事件处理的类均是此类的子类。
 *
 * 此类不可实例化。
 *
 */
var Eventful = exports.Eventful = function () {

    /*
     * Constructor: SuperMap.LevelRenderer.Eventful
     * 构造函数。
     *
     * 对象可以通过 onxxxx 绑定事件。
     *
     * 支持的事件：
     * Symbolizer properties:
     * onclick - {Function} 默认值：null。
     * onmouseover - {Function} 默认值：null。
     * onmouseout - {Function} 默认值：null。
     * onmousemove - {Function} 默认值：null。
     * onmousewheel - {Function} 默认值：null。
     * onmousedown - {Function} 默认值：null。
     * onmouseup - {Function} 默认值：null。
     * ondragstart - {Function} 默认值：null。
     * ondragend - {Function} 默认值：null。
     * ondragenter - {Function} 默认值：null。
     * ondragleave - {Function} 默认值：null。
     * ondragover - {Function} 默认值：null。
     * ondrop - {Function} 默认值：null。
     */
    function Eventful() {
        _classCallCheck(this, Eventful);

        /**
         * Property: _handlers
         * {Object} 事件处理对象（事件分发器）。
         */
        this._handlers = {};

        this.CLASS_NAME = "SuperMap.LevelRenderer.Eventful";
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Eventful, [{
        key: 'destroy',
        value: function destroy() {
            this._handlers = null;
        }

        /**
         * APIMethod: one
         * 单次触发绑定，dispatch后销毁。
         *
         * Parameters:
         * event - {String} 事件名。
         * handler - {Boolean} 响应函数。
         * context - {Object} context。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Eventful>} this。
         */

    }, {
        key: 'one',
        value: function one(event, handler, context) {
            var _h = this._handlers;

            if (!handler || !event) {
                return this;
            }

            if (!_h[event]) {
                _h[event] = [];
            }

            _h[event].push({
                h: handler,
                one: true,
                ctx: context || this
            });

            return this;
        }

        /**
         * APIMethod: bind
         * 绑定事件。
         *
         * Parameters:
         * event - {String} 事件名。
         * handler - {Boolean} 事件处理函数。
         * context - {Object} context。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Eventful>} this。
         */

    }, {
        key: 'bind',
        value: function bind(event, handler, context) {
            var _h = this._handlers;

            if (!handler || !event) {
                return this;
            }

            if (!_h[event]) {
                _h[event] = [];
            }

            _h[event].push({
                h: handler,
                one: false,
                ctx: context || this
            });

            return this;
        }

        /**
         * APIMethod: unbind
         * 解绑事件。
         *
         * Parameters:
         * event - {String} 事件名。
         * handler - {Boolean} 事件处理函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Eventful>} this。
         */

    }, {
        key: 'unbind',
        value: function unbind(event, handler) {
            var _h = this._handlers;

            if (!event) {
                this._handlers = {};
                return this;
            }

            if (handler) {
                if (_h[event]) {
                    var newList = [];
                    for (var i = 0, l = _h[event].length; i < l; i++) {
                        if (_h[event][i]['h'] != handler) {
                            newList.push(_h[event][i]);
                        }
                    }
                    _h[event] = newList;
                }

                if (_h[event] && _h[event].length === 0) {
                    delete _h[event];
                }
            } else {
                delete _h[event];
            }

            return this;
        }

        /**
         * APIMethod: dispatch
         * 事件分发。
         *
         * Parameters:
         * type - {String} 事件类型。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Eventful>} this。
         */

    }, {
        key: 'dispatch',
        value: function dispatch(type) {
            if (this._handlers[type]) {
                var args = arguments;
                var argLen = args.length;

                if (argLen > 3) {
                    args = Array.prototype.slice.call(args, 1);
                }

                var _h = this._handlers[type];
                var len = _h.length;
                for (var i = 0; i < len;) {
                    // Optimize advise from backbone
                    switch (argLen) {
                        case 1:
                            _h[i]['h'].call(_h[i]['ctx']);
                            break;
                        case 2:
                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
                            break;
                        case 3:
                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                            break;
                        default:
                            // have more than 2 given arguments
                            _h[i]['h'].apply(_h[i]['ctx'], args);
                            break;
                    }

                    if (_h[i]['one']) {
                        _h.splice(i, 1);
                        len--;
                    } else {
                        i++;
                    }
                }
            }

            return this;
        }

        /**
         * APIMethod: dispatchWithContext
         * 带有context的事件分发 最后一个参数是事件回调的 context。
         *
         * Parameters:
         * type - {String} 事件类型。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Eventful>} this。
         */

    }, {
        key: 'dispatchWithContext',
        value: function dispatchWithContext(type) {
            if (this._handlers[type]) {
                var args = arguments;
                var argLen = args.length;

                if (argLen > 4) {
                    args = Array.prototype.slice.call(args, 1, args.length - 1);
                }
                var ctx = args[args.length - 1];

                var _h = this._handlers[type];
                var len = _h.length;
                for (var i = 0; i < len;) {
                    // Optimize advise from backbone
                    switch (argLen) {
                        case 1:
                            _h[i]['h'].call(ctx);
                            break;
                        case 2:
                            _h[i]['h'].call(ctx, args[1]);
                            break;
                        case 3:
                            _h[i]['h'].call(ctx, args[1], args[2]);
                            break;
                        default:
                            // have more than 2 given arguments
                            _h[i]['h'].apply(ctx, args);
                            break;
                    }

                    if (_h[i]['one']) {
                        _h.splice(i, 1);
                        len--;
                    } else {
                        i++;
                    }
                }
            }

            return this;
        }
    }]);

    return Eventful;
}();

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsNative = __webpack_require__(468),
    getValue = __webpack_require__(478);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var HALF_PI = Math.PI/2;
var sign = __webpack_require__(61);

module.exports = function(x) {
  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
};

/***/ }),
/* 56 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
};

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
};

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return (x * x * x * (35 / 3072));
};

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = function(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
};

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = function(x) {
  return x<0 ? -1 : 1;
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Events = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Pixel = __webpack_require__(63);

var _Event = __webpack_require__(139);

var _BaseTypes = __webpack_require__(46);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Events
 * @classdesc 事件类。
 * @param object - {Object} 当前事件对象被添加到的JS对象。
 * @param element - {HTMLElement} 响应浏览器事件的dom元素。
 * @param eventTypes - {Array<string>} 自定义应用事件的数组。
 * @param fallThrough - {boolean} 是否允许事件处理之后向上传递（冒泡），为false的时候阻止事件冒泡。
 * @param options - {Object} 事件对象选项。
 */
var Events = exports.Events = function () {
    function Events(object, element, eventTypes, fallThrough, options) {
        _classCallCheck(this, Events);

        /**
         * @member SuperMap.Events.prototype.BROWSER_EVENTS -{Array<string>}
         * @description 支持的事件。
         * @constant
         * @default [
         "mouseover", "mouseout","mousedown", "mouseup", "mousemove",
         "click", "dblclick", "rightclick", "dblrightclick","resize",
         "focus", "blur","touchstart", "touchmove", "touchend","keydown",
         "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup",
         "MSGestureStart", "MSGestureChange", "MSGestureEnd","contextmenu"
         ]
         */
        this.BROWSER_EVENTS = ["mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "click", "dblclick", "rightclick", "dblrightclick", "resize", "focus", "blur", "touchstart", "touchmove", "touchend", "keydown", "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup", "MSGestureStart", "MSGestureChange", "MSGestureEnd", "contextmenu"];

        /**
         * @member SuperMap.Events.prototype.listeners -{Object}
         * @description Hashtable of Array(function): events listener functions
         */
        this.listeners = {};

        /**
         * @member SuperMap.Events.prototype.object  -{Object}
         * @description  发布应用程序事件的对象。
         */
        this.object = object;

        /**
         * @member SuperMap.Events.prototype.element  -{HTMLElement}
         * @description 接受浏览器事件的DOM节点。
         */
        this.element = null;

        /**
         * @member SuperMap.Events.prototype.eventTypes  -{Array<string>}
         * @description 支持的事件类型列表。
         */
        this.eventTypes = [];

        /**
         * @member SuperMap.Events.prototype.eventHandler -{function}
         * @description 绑定在元素上的事件处理器对象。
         */
        this.eventHandler = null;

        /**
         * @member SuperMap.Events.prototype.fallThrough -{boolean}
         * @description 是否允许事件处理之后向上传递（冒泡），为false的时候阻止事件冒泡。
         */
        this.fallThrough = fallThrough;

        /**
         * @member SuperMap.Events.prototype.includeXY -{boolean}
         * @description 判断是否让xy属性自动创建到浏览器上的鼠标事件，一般设置为false，如果设置为true，鼠标事件将会在事件传递过程中自动产生xy属性。
         *                可根据事件对象的'evt.object'属性在相关的事件句柄上调用getMousePosition函数。这个选项习惯默认为false的原因在于，当创建一个
         *                事件对象，其主要目的是管理。在一个div的相对定位的鼠标事件,将其设为true也是有意义的。这个选项也可以用来控制是否抵消缓存。如果
         *                设为false不抵消，如果设为true，用this.clearMouseCache() 清除缓存偏移（边界元素偏移，元素在页面的位置偏移）。
         * @example
         *  function named(evt) {
         *        this.xy = this.object.events.getMousePosition(evt);
         *  }
         */
        this.includeXY = false;

        /**
         * @member SuperMap.Events.prototype.extensions - {Object}
         * @description 事件扩展。Keys代表事件类型，values代表事件对象。
         * @example
         * 以扩展"foostart" 和 "fooend" 事件为例。展示替换css属性为foo的元素的click事件。
         *
         *   SuperMap.Events.foostart = SuperMap.Class({
        *       initialize: function(target) {
        *           this.target = target;
        *           this.target.register("click", this, this.doStuff, {extension: true});
        *           // only required if extension provides more than one event type
        *           this.target.extensions["foostart"] = true;
        *           this.target.extensions["fooend"] = true;
        *       },
        *       destroy: function() {
        *           var target = this.target;
        *           target.unregister("click", this, this.doStuff);
        *           delete this.target;
        *           // only required if extension provides more than one event type
        *           delete target.extensions["foostart"];
        *           delete target.extensions["fooend"];
        *       },
        *       doStuff: function(evt) {
        *           var propagate = true;
        *           if (SuperMap.Event.element(evt).className === "foo") {
        *               propagate = false;
        *               var target = this.target;
        *               target.triggerEvent("foostart");
        *               window.setTimeout(function() {
        *                   target.triggerEvent("fooend");
        *               }, 1000);
        *           }
        *           return propagate;
        *       }
        *   });
         *   // only required if extension provides more than one event type
         *   SuperMap.Events.fooend = SuperMap.Events.foostart;
         */
        this.extensions = {};

        /**
         * @member SuperMap.Events.prototype.extensionCount - {Object}
         */
        this.extensionCount = {};
        /**
         * @member SuperMap.Events.prototype.clearMouseListener - {Object}
         */
        this.clearMouseListener = null;

        _Util.Util.extend(this, options);

        if (eventTypes != null) {
            for (var i = 0, len = eventTypes.length; i < len; i++) {
                this.addEventType(eventTypes[i]);
            }
        }

        if (element != null) {
            this.attachToElement(element);
        }

        this.CLASS_NAME = "SuperMap.Events";
    }

    /**
     * @function SuperMap.Events.prototype.destroy
     * @description 移除当前要素element上的所有事件监听和处理。
     */


    _createClass(Events, [{
        key: 'destroy',
        value: function destroy() {
            for (var e in this.extensions) {
                if (typeof this.extensions[e] !== "boolean") {
                    this.extensions[e].destroy();
                }
            }
            this.extensions = null;
            if (this.element) {
                _Event.Event.stopObservingElement(this.element);
                if (this.element.hasScrollEvent) {
                    _Event.Event.stopObserving(window, "scroll", this.clearMouseListener);
                }
            }
            this.element = null;

            this.listeners = null;
            this.object = null;
            this.eventTypes = null;
            this.fallThrough = null;
            this.eventHandler = null;
        }

        /**
         * @function SuperMap.Events.prototype.addEventType
         * @description 在此事件对象中添加新的事件类型，如果这个事件类型已经添加过了，则不做任何事情。
         * @param eventName - {string} 事件名。
         */

    }, {
        key: 'addEventType',
        value: function addEventType(eventName) {
            if (!this.listeners[eventName]) {
                this.eventTypes.push(eventName);
                this.listeners[eventName] = [];
            }
        }

        /**
         * @function SuperMap.Events.prototype.attachToElement
         * @description 给dom元素绑定浏览器事件。
         * @param element - {HTMLDOMElement} 绑定浏览器事件的dom元素。
         */

    }, {
        key: 'attachToElement',
        value: function attachToElement(element) {
            if (this.element) {
                _Event.Event.stopObservingElement(this.element);
            } else {
                // keep a bound copy of handleBrowserEvent() so that we can
                // pass the same function to both Event.observe() and .stopObserving()
                this.eventHandler = _BaseTypes.FunctionExt.bindAsEventListener(this.handleBrowserEvent, this);

                // to be used with observe and stopObserving
                this.clearMouseListener = _BaseTypes.FunctionExt.bind(this.clearMouseCache, this);
            }
            this.element = element;
            for (var i = 0, len = this.BROWSER_EVENTS.length; i < len; i++) {
                var eventType = this.BROWSER_EVENTS[i];

                // every browser event has a corresponding application event
                // (whether it's listened for or not).
                this.addEventType(eventType);

                // use Prototype to register the event cross-browser
                _Event.Event.observe(element, eventType, this.eventHandler);
            }
            // disable dragstart in IE so that mousedown/move/up works normally
            _Event.Event.observe(element, "dragstart", _Event.Event.stop);
        }

        /**
         * @function SuperMap.Events.prototype.on
         * @description 在一个相同的范围内注册监听器的方法，此方法调用register函数。
         * @example
         * // 注册一个"loadstart"监听事件
         * events.on({"loadstart": loadStartListener});
         *
         * // 同样注册一个"loadstart"监听事件
         * events.register("loadstart" undefined loadStartListener);
         *
         * // 同时为对象注册多个监听事件
         * events.on({
         *     "loadstart": loadStartListener
         *     "loadend": loadEndListener
         *     scope: object
         * });
         *
         * // 同时为对象注册多个监听事件，多次调用register方法
         * events.register("loadstart" object loadStartListener);
         * events.register("loadend" object loadEndListener);
         *
         *
         * @param  object - {Object} 添加监听的对象。
         */

    }, {
        key: 'on',
        value: function on(object) {
            for (var type in object) {
                if (type !== "scope" && object.hasOwnProperty(type)) {
                    this.register(type, object.scope, object[type]);
                }
            }
        }

        /**
         * @function SuperMap.Events.prototype.register
         * @description 在事件对象上注册一个事件。当事件被触发时，'func'函数被调用，假设我们触发一个事件，
         *                指定SuperMap.Bounds作为‘obj’当事件被触发时，回调函数的上下文作为Bounds对象。
         * @param type - {string} 事件注册者的名字。
         * @param obj - {Object} 对象绑定的回调。如果没有特定的对象，则默认是事件的object属性。
         * @param func - {function} 回调函数，如果没有特定的回调，则这个函数不做任何事情。
         * @param priority - {boolean|Object} 当为true时将新的监听加在事件队列的前面。
         */

    }, {
        key: 'register',
        value: function register(type, obj, func, priority) {
            if (type in Events && !this.extensions[type]) {
                this.extensions[type] = new Events[type](this);
            }
            if (func != null && _Util.Util.indexOf(this.eventTypes, type) !== -1) {

                if (obj == null) {
                    obj = this.object;
                }
                var listeners = this.listeners[type];
                if (!listeners) {
                    listeners = [];
                    this.listeners[type] = listeners;
                    this.extensionCount[type] = 0;
                }
                var listener = { obj: obj, func: func };
                if (priority) {
                    listeners.splice(this.extensionCount[type], 0, listener);
                    if ((typeof priority === 'undefined' ? 'undefined' : _typeof(priority)) === "object" && priority.extension) {
                        this.extensionCount[type]++;
                    }
                } else {
                    listeners.push(listener);
                }
            }
        }

        /**
         * @function SuperMap.Events.prototype.registerPriority
         * @description 相同的注册方法，但是在前面增加新的监听者事件查询而代替到方法的结束。
         * @param type - {string} 事件注册者的名字。
         * @param obj - {Object} 对象绑定方面的回调。如果没有特定的对象，则默认是事件的object属性。
         * @param func - {function} 回调函数，如果没有特定的回调，则这个函数不做任何事情。
         */

    }, {
        key: 'registerPriority',
        value: function registerPriority(type, obj, func) {
            this.register(type, obj, func, true);
        }

        /**
         * @function SuperMap.Events.prototype.un
         * @description 在一个相同的范围内取消注册监听器的方法，此方法调用unregister函数。
         * @example
         * // 移除"loadstart" 事件监听
         * events.un({"loadstart": loadStartListener});
         *
         * // 使用unregister方法移除"loadstart" 事件监听
         * events.unregister("loadstart" undefined loadStartListener);
         *
         * // 取消对象多个事件监听
         * events.un({
         *     "loadstart": loadStartListener
         *     "loadend": loadEndListener
         *     scope: object
         * });
         *
         * // 取消对象多个事件监听，多次调用unregister方法。
         * events.unregister("loadstart" object loadStartListener);
         * events.unregister("loadend" object loadEndListener);
         *
         * @param object - {Object} 移除监听的对象。
         */

    }, {
        key: 'un',
        value: function un(object) {
            for (var type in object) {
                if (type !== "scope" && object.hasOwnProperty(type)) {
                    this.unregister(type, object.scope, object[type]);
                }
            }
        }

        /**
         * @function SuperMap.Events.prototype.unregister
         * @description 取消注册。
         * @param type - {string} 事件类型。
         * @param obj - {Object} 默认为 this.object。
         * @param func - {function} 事件监听。
         */

    }, {
        key: 'unregister',
        value: function unregister(type, obj, func) {
            if (obj == null) {
                obj = this.object;
            }
            var listeners = this.listeners[type];
            if (listeners != null) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i].obj === obj && listeners[i].func === func) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        }

        /**
         * @function SuperMap.Events.prototype.remove
         * @description 删除某个事件类型的所有监听，如果该事件类型没有注册，则不做任何操作。
         * @param type - {string} 事件类型。
         */

    }, {
        key: 'remove',
        value: function remove(type) {
            if (this.listeners[type] != null) {
                this.listeners[type] = [];
            }
        }

        /**
         * @function SuperMap.Events.prototype.triggerEvent
         * @description 触发一个特定的注册事件。
         * @param type - {string} 触发事件类型。
         * @param evt - {Event} 事件对象。
         * @returns {boolean} 返回监听对象，如果返回是falee，则停止监听。
         */

    }, {
        key: 'triggerEvent',
        value: function triggerEvent(type, evt) {
            var listeners = this.listeners[type];

            // fast path
            if (!listeners || listeners.length == 0) {
                return undefined;
            }

            // prep evt object with object & div references
            if (evt == null) {
                evt = {};
            }
            evt.object = this.object;
            evt.element = this.element;
            if (!evt.type) {
                evt.type = type;
            }

            // execute all callbacks registered for specified type
            // get a clone of the listeners array to
            // allow for splicing during callbacks
            listeners = listeners.slice();
            var continueChain;
            for (var i = 0, len = listeners.length; i < len; i++) {
                var callback = listeners[i];
                // bind the context to callback.obj
                continueChain = callback.func.apply(callback.obj, [evt]);

                if (continueChain != undefined && continueChain == false) {
                    // if callback returns false, execute no more callbacks.
                    break;
                }
            }
            // don't fall through to other DOM elements
            if (!this.fallThrough) {
                _Event.Event.stop(evt, true);
            }
            return continueChain;
        }

        /**
         * @function SuperMap.Events.prototype.handleBrowserEvent
         * @description 对triggerEvent函数的包装，给事件对象设置了xy属性(即当前鼠标点的xy坐标)。
         * @param evt - {Event} 事件对象。
         */

    }, {
        key: 'handleBrowserEvent',
        value: function handleBrowserEvent(evt) {
            var type = evt.type,
                listeners = this.listeners[type];
            if (!listeners || listeners.length == 0) {
                // noone's listening, bail out
                return;
            }
            // add clientX & clientY to all events - corresponds to average x, y
            var touches = evt.touches;
            if (touches && touches[0]) {
                var x = 0;
                var y = 0;
                var num = touches.length;
                var touch;
                for (var i = 0; i < num; ++i) {
                    touch = touches[i];
                    x += touch.clientX;
                    y += touch.clientY;
                }
                evt.clientX = x / num;
                evt.clientY = y / num;
            }
            if (this.includeXY) {
                evt.xy = this.getMousePosition(evt);
            }
            this.triggerEvent(type, evt);
        }

        /**
         * @function SuperMap.Events.prototype.clearMouseCache
         * @description 清除鼠标缓存。
         */

    }, {
        key: 'clearMouseCache',
        value: function clearMouseCache() {
            this.element.scrolls = null;
            this.element.lefttop = null;
            var body = document.body;
            if (body && !((body.scrollTop != 0 || body.scrollLeft != 0) && navigator.userAgent.match(/iPhone/i))) {
                this.element.offsets = null;
            }
        }

        /**
         * @function SuperMap.Events.prototype.getMousePosition
         * @param evt - {Event} 事件对象。
         * @returns {SuperMap.Pixel} 当前的鼠标的xy坐标点。
         */

    }, {
        key: 'getMousePosition',
        value: function getMousePosition(evt) {
            if (!this.includeXY) {
                this.clearMouseCache();
            } else if (!this.element.hasScrollEvent) {
                _Event.Event.observe(window, "scroll", this.clearMouseListener);
                this.element.hasScrollEvent = true;
            }

            if (!this.element.scrolls) {
                var viewportElement = _Util.Util.getViewportElement();
                this.element.scrolls = [viewportElement.scrollLeft, viewportElement.scrollTop];
            }

            if (!this.element.lefttop) {
                this.element.lefttop = [document.documentElement.clientLeft || 0, document.documentElement.clientTop || 0];
            }

            if (!this.element.offsets) {
                this.element.offsets = _Util.Util.pagePosition(this.element);
            }

            return new _Pixel.Pixel(evt.clientX + this.element.scrolls[0] - this.element.offsets[0] - this.element.lefttop[0], evt.clientY + this.element.scrolls[1] - this.element.offsets[1] - this.element.lefttop[1]);
        }
    }]);

    return Events;
}();

_SuperMap.SuperMap.Events = Events;
_SuperMap.SuperMap.Events.prototype.BROWSER_EVENTS = ["mouseover", "mouseout", "mousedown", "mouseup", "mousemove", "click", "dblclick", "rightclick", "dblrightclick", "resize", "focus", "blur", "touchstart", "touchmove", "touchend", "keydown", "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup", "MSGestureStart", "MSGestureChange", "MSGestureEnd", "contextmenu"];

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pixel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Pixel
 * @classdesc 此类用x,y坐标描绘屏幕坐标（像素点）。
 * @param x - {number} x坐标，默认为0.0
 * @param y - {number} y坐标，默认为0.0
 * @param mode - {string} 坐标模式，默认为{@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.LeftTop}
 *
 * @example
 * //单独创建一个对象
 * var pixcel = new SuperMap.Pixel(100,50);
 *
 * //依据size创建
 *  var size = new SuperMap.Size(21,25);
 *  var offset = new SuperMap.Pixel(-(size.w/2), -size.h);
 */
var Pixel = exports.Pixel = function () {
    function Pixel(x, y, mode) {
        _classCallCheck(this, Pixel);

        /**
         * @member SuperMap.Pixel.prototype.x -{number}
         * @description x坐标，默认为0.0
         */
        this.x = x ? parseFloat(x) : 0.0;

        /**
         * @member SuperMap.Pixel.prototype.y -{number}
         * @description y坐标，默认为0.0
         */
        this.y = y ? parseFloat(y) : 0.0;

        /**
         * @member SuperMap.Pixel.prototype.mode -{SuperMap.Pixel.Mode}
         * @description 坐标模式，有左上、右上、右下、左下这几种模式，分别表示相对于左上角、右上角、右下角、左下角的坐标。<br>
         * 值有<br>
         * * {@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.LeftTop}
         * * {@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.RightTop}
         * * {@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.RightBottom}
         * * {@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.LeftBottom}
         *
         * 这四种 默认值为：{@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.LeftTop}
         *
         * @default {@link SuperMap.Pixel.Mode|SuperMap.Pixel.Mode.LeftTop}
         */
        this.mode = mode;
        this.CLASS_NAME = "SuperMap.Pixel";
        /**
         * @member SuperMap.Pixel.Mode
         * @enum {string}
         * @readonly
         * @description 模式
         *
         * * SuperMap.Pixel.Mode.LeftTop 左上模式
         * * SuperMap.Pixel.Mode.RightTop 右上模式
         * * SuperMap.Pixel.Mode.RightBottom 右下模式
         * * SuperMap.Pixel.Mode.LeftBottom 左下模式
         */

        Pixel.Mode = {
            LeftTop: "lefttop",
            RightTop: "righttop",
            RightBottom: "rightbottom",
            LeftBottom: "leftbottom"
        };
    }

    /**
     * @function SuperMap.Pixel.prototype.toString
     * @description 返回此对象的字符串形式
     * @example
     *
     * var pixcel = new SuperMap.Pixel(100,50);
     * var str = pixcel.toString();
     *
     * @returns {string} 例如: "x=200.4,y=242.2"
     */


    _createClass(Pixel, [{
        key: "toString",
        value: function toString() {
            return "x=" + this.x + ",y=" + this.y;
        }

        /**
         * @function SuperMap.Pixel.prototype.clone
         * @description 克隆当前的 pixel 对象。
         * @example
         * var pixcel = new SuperMap.Pixel(10050);
         * var pixcel2 = pixcel.clone();
         * @returns {SuperMap.Pixel} 返回一个新的与当前 pixel 对象有相同x、y坐标的 pixel 对象。
         */

    }, {
        key: "clone",
        value: function clone() {
            return new Pixel(this.x, this.y, this.mode);
        }

        /**
         * @function SuperMap.Pixel.prototype.equals
         * @description 比较两 pixel 是否相等
         * @example
         * var pixcel = new SuperMap.Pixel(10050);
         * var pixcel2 = new SuperMap.Pixel(10050);
         * var isEquals = pixcel.equals(pixcel2);
         *
         * @param px - {SuperMap.Pixel} 用于比较相等的 pixel 对象。
         * @returns {Boolean} 如果传入的像素点和当前像素点相同返回true如果不同或传入参数为NULL则返回false
         */

    }, {
        key: "equals",
        value: function equals(px) {
            var equals = false;
            if (px != null) {
                equals = this.x == px.x && this.y == px.y || isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y);
            }
            return equals;
        }

        /**
         * @function SuperMap.Pixel.prototype.distanceTo
         * @description 返回两个 pixel 的距离。
         * @example
         * var pixcel = new SuperMap.Pixel(10050);
         * var pixcel2 = new SuperMap.Pixel(11030);
         * var distance = pixcel.distanceTo(pixcel2);
         *
         * @param px - {SuperMap.Pixel} 用于计算的一个 pixel
         * @returns {float} 作为参数传入的像素与当前像素点的距离。
         */

    }, {
        key: "distanceTo",
        value: function distanceTo(px) {
            return Math.sqrt(Math.pow(this.x - px.x, 2) + Math.pow(this.y - px.y, 2));
        }

        /**
         * @function SuperMap.Pixel.prototype.add
         * @description 在原来像素坐标基础上，x值加上传入的x参数，y值加上传入的y参数。
         * @example
         * var pixcel = new SuperMap.Pixel(10050);
         * //pixcel2是新的对象
         * var pixcel2 = pixcel.add(2030);
         *
         * @param x - {number} 传入的x值。
         * @param y - {number} 传入的y值。
         * @returns {SuperMap.Pixel} 返回一个新的pixel对象，该pixel是由当前的pixel与传
         *      入的xy相加得到。
         */

    }, {
        key: "add",
        value: function add(x, y) {
            if (x == null || y == null) {
                throw new TypeError('Pixel.add cannot receive null values');
            }
            return new Pixel(this.x + x, this.y + y);
        }

        /**
         * @function SuperMap.Pixel.prototype.offset
         * @description 通过传入的 {@link SuperMap.Pixel} 参数对原屏幕坐标进行偏移。
         * @example
         * var pixcel = new SuperMap.Pixel(10050);
         * var pixcel2 = new SuperMap.Pixel(13020);
         * //pixcel3 是新的对象
         * var pixcel3 = pixcel.offset(pixcel2);
         *
         * @param px - {SuperMap.Pixel}  传入的 <SuperMap.Pixel> 对象。
         * @returns {SuperMap.Pixel} 返回一个新的pixel，该pixel是由当前的pixel对象的x，y
         *      值与传入的Pixel对象的x，y值相加得到。
         */

    }, {
        key: "offset",
        value: function offset(px) {
            var newPx = this.clone();
            if (px) {
                newPx = this.add(px.x, px.y);
            }
            return newPx;
        }

        /**
         *
         * @function SuperMap.Pixel.prototype.destroy
         * @description 销毁此对象。
         * 销毁后此对象的所有属性为null，而不是初始值。
         * @example
         * var pixcel = new SuperMap.Pixel(10050);
         * pixcel.destroy();
         */

    }, {
        key: "destroy",
        value: function destroy() {
            this.x = null;
            this.y = null;
            this.mode = null;
        }
    }]);

    return Pixel;
}();

_SuperMap.SuperMap.Pixel = Pixel;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Vector = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Feature2 = __webpack_require__(140);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Vector
 * @classdesc 矢量要素类。该类具有 Geometry 属性存放几何信息，
 * attributes 属性存放非几何信息，另外还包含了 style 属性，用来定义矢量要素的样式，
 * 其中，默认的样式在 <SuperMap.Feature.Vector.style> 类中定义，如果没有特别的指定将使用默认的样式，
 * @extends SuperMap.Feature
 * @param geometry - {SuperMap.Geometry} 代表要素的几何形状。
 * @param attributes - {Object} 描述要素的任意的可序列化属性，将要映射到 attributes 属性中的可选对象。
 * @param style - {Object} 一个可选的样式对象。
 * @example
 * var geometry = new SuperMap.Geometry.Point(-115,10);
 *  var style = {
     *      strokeColor:"#339933",
     *      strokeOpacity:1,
     *      strokeWidth:3,
     *      pointRadius:6
     *  }
 *  var pointFeature = new SuperMap.Feature.Vector(geometry,null,style);
 *  vectorLayer.addFeatures(pointFeature);
 */
var Vector = exports.Vector = function (_Feature) {
    _inherits(Vector, _Feature);

    function Vector(geometry, attributes, style) {
        _classCallCheck(this, Vector);

        /**
         * @member SuperMap.Feature.Vector.prototype.fid -{string}
         * @description fid
         */
        var _this = _possibleConstructorReturn(this, (Vector.__proto__ || Object.getPrototypeOf(Vector)).call(this, null, null, attributes));

        _this.fid = null;

        /**
         * @member SuperMap.Feature.Vector.prototype.geometry -{SuperMap.Geometry}
         * @description 该属性用于存放几何信息。
         */
        _this.geometry = geometry ? geometry : null;

        /**
         * @member SuperMap.Feature.Vector.prototype.attributes -{Object}
         * @description 描述要素的任意的可序列化属性。
         */
        _this.attributes = {};

        if (attributes) {
            _this.attributes = _Util.Util.extend(_this.attributes, attributes);
        }

        /**
         * @member SuperMap.Feature.Vector.prototype.bounds -{SuperMap.Bounds}
         * @description The box bounding that feature's geometry, that
         *     property can be set by an <SuperMap.Format> object when
         *     deserializing the feature, so in most cases it represents an
         *     information set by the server.
         */
        _this.bounds = null;

        /**
         * @member SuperMap.Feature.Vector.prototype.state -{string}
         * @description state
         */
        _this.state = null;

        /**
         * @member SuperMap.Feature.Vector.prototype.style -{Object}
         * @description 要素的样式属性，地图查询返回的feature的style，8C变为null。
         */
        _this.style = style ? style : null;

        /**
         * @member SuperMap.Feature.Vector.prototype.url -{string}
         * @description 如果设置了这个属性，在更新或者删除要素时需要考虑 <SuperMap.HTTP> 。
         */
        _this.url = null;

        _this.lonlat = null;

        _this.CLASS_NAME = "SuperMap.Feature.Vector";
        // TRASH THIS
        _SuperMap.SuperMap.State = {
            /** states */
            UNKNOWN: 'Unknown',
            INSERT: 'Insert',
            UPDATE: 'Update',
            DELETE: 'Delete'
        };

        /**
         *
         * @member SuperMap.Feature.Vector.style
         * @description SuperMap.features有大量的样式属性，如果没有特别的指定将使用默认的样式，
         * 大部分样式通过SVG标准定义属性。
         *
         * - fill properties资料介绍: {@link http://www.w3.org/TR/SVG/painting.html#FillProperties}
         * - stroke properties资料介绍: {@link http://www.w3.org/TR/SVG/painting.html#StrokeProperties}
         *
         * #### Symbolizer properties:
         * * fill - {Boolean} 不需要填充则设置为false。
         * * fillColor - {string} 十六进制填充颜色，默认为"#ee9900"。
         * * fillOpacity - {number} 填充不透明度。默认为0.4。
         * * stroke - {Boolean} 不需要描边则设为false。
         * * strokeColor - {string} 十六进制描边颜色。
         * * strokeOpacity - {number} 描边的不透明度(0-1),默认为0.4。
         * * strokeWidth - {number} 像素描边宽度，默认为1。
         * * strokeLinecap - {string} strokeLinecap有三种类型butt，round，square，默认为"round"。
         * * strokeDashstyle - {string} 有dot,dash,dashot,longdash,longdashdot,solid几种样式，默认为"solid"。
         * * graphic - {Boolean} 不需要则设置为false。
         * * pointRadius - {number} 像素点半径，默认为6
         * * pointerEvents - {string}  默认为"visiblePainted"。
         * * cursor - {string} 默认为""。
         * * allowRotate -{string} 是否允许图标随着运行方向旋转，默认为false。用于时空数据图层
         * * externalGraphic - {string} 连接到用来渲染点的外部的图形。
         * * graphicWidth - {number} 外部图表的像素宽度。
         * * graphicHeight - {number} 外部图表的高宽度。
         * * graphicOpacity - {number} 外部图表的不透明度(0-1)。
         * * graphicXOffset - {number} 外部图表沿着x方向的偏移量。
         * * graphicYOffset - {number} 外部图表沿着y方向的偏移量Pixel。
         * * rotation - {number} 一个图表沿着其中心点（或者偏移中心指定点）在顺时针方向旋转。
         * * graphicZIndex - {number} 渲染时使用的索引值。The integer z-index value to use in rendering。
         * * graphicName - {string} 渲染点时图标使用的名字。支持"circle" , "square", "star", "x", "cross", "triangle"，
         * 默认为"circle"。
         * * graphicTitle - {string} 外部图表的提示框。
         * * backgroundGraphic - {string} 外部图表的背景。
         * * backgroundGraphicZIndex - {number} 背景图渲染时使用的索引值。
         * * backgroundXOffset - {number} 背景图在x轴的偏移量。
         * * backgroundYOffset - {number} 背景图在x轴的偏移量。
         * * backgroundHeight - {number} 背景图的高度。如果没有设置，将用graphicHeight。
         * * backgroundWidth - {number} 背景图的宽度。如果没有设置，将用graphicWidth。
         * * isUnicode - {Boolean} 这个属性要配合label属性来用，当为true时，label就可以使用unicode编码，
         * 比如"a"的unicode十六进制编码为61，则label属性可以为"&#x61;",其中"&#"为前缀，标志这个为unicode编码，
         * "x"是指16进制,这时页面显示的是"a"；当此值为false的时候，label的内容会被直接输出，
         * 比如，label为"&#x61;"，这时页面显示的也是"&#x61;"。默认为false。
         * * label - {string} 可选的标签文本。
         * * labelAlign - {string} 标签对齐，是由两个字符组成的字符串，如："lt", "cm", "rb"，
         * 其中第一个字符代表水平方向上的对齐，"l"=left, "c"=center, "r"=right；
         * 第二个字符代表垂直方向上的对齐，"t"=top, "m"=middle, "b"=bottom。
         * * labelXOffset - {number} 标签在x轴方向的偏移量。
         * * labelYOffset - {number} 标签在y轴方向的偏移量。
         * * labelSelect - {Boolean} 如果设为true，标签可以选用SelectFeature或者similar控件，默认为false。
         * * fontColor - {string} 标签字体颜色。
         * * fontOpacity - {number} 标签透明度 (0-1)。
         * * fontFamily - {string} 标签的字体类型。
         * * fontSize - {string} 标签的字体大小。
         * * fontStyle - {string} 标签的字体样式。
         * * fontWeight - {string} 标签的字体粗细。
         * * display - {string} 如果display属性设置为“none”，符号将没有任何效果。
         * @example
         *  // label的用法如下：
         *  function addGeoTest(){
        *  var geometry = new SuperMap.Geometry.Point(105, 35);
        *  var pointFeature = new SuperMap.Feature.Vector(geometry);
        *  var styleTest = {
        *        label:"supermap",
        *        fontColor:"#0000ff",
        *        fontOpacity:"0.5",
        *        fontFamily:"隶书",
        *        fontSize:"8em",
        *        fontWeight:"bold",
        *        fontStyle:"italic",
        *        labelSelect:"true",
        *     }
        *           pointFeature.style = styleTest;
        *          vectorLayer.addFeatures([pointFeature]);
        * }
         */
        Vector.style = {
            'default': {
                fillColor: "#ee9900",
                fillOpacity: 0.4,
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "#ee9900",
                strokeOpacity: 1,
                strokeWidth: 1,
                strokeLinecap: "round",
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                cursor: "inherit",
                fontColor: "#000000",
                labelAlign: "cm",
                labelOutlineColor: "white",
                labelOutlineWidth: 3
            },
            'select': {
                fillColor: "blue",
                fillOpacity: 0.4,
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "blue",
                strokeOpacity: 1,
                strokeWidth: 2,
                strokeLinecap: "round",
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                cursor: "pointer",
                fontColor: "#000000",
                labelAlign: "cm",
                labelOutlineColor: "white",
                labelOutlineWidth: 3

            },
            'temporary': {
                fillColor: "#66cccc",
                fillOpacity: 0.2,
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "#66cccc",
                strokeOpacity: 1,
                strokeLinecap: "round",
                strokeWidth: 2,
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                //cursor:"inherit",
                cursor: "default",
                fontColor: "#000000",
                labelAlign: "cm",
                labelOutlineColor: "white",
                labelOutlineWidth: 3

            },
            'delete': {
                display: "none"
            }
        };
        return _this;
    }

    /**
     * @function SuperMap.Feature.Vector.prototype.destroy
     * @description nullify references to prevent circular references and memory leaks
     */


    _createClass(Vector, [{
        key: 'destroy',
        value: function destroy() {
            if (this.layer) {
                this.layer.removeFeatures(this);
                this.layer = null;
            }

            this.geometry = null;
            _get(Vector.prototype.__proto__ || Object.getPrototypeOf(Vector.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Vector.prototype.clone
         * @description Create a clone of this vector feature.  Does not set any non-standard
         *     properties.
         * @returns {SuperMap.Feature.Vector} An exact clone of this vector feature.
         */

    }, {
        key: 'clone',
        value: function clone() {
            return new Vector(this.geometry ? this.geometry.clone() : null, this.attributes, this.style);
        }

        /**
         * @function SuperMap.Feature.Vector.prototype.toState
         * @description Sets the new state
         * @param state - {string}
         */

    }, {
        key: 'toState',
        value: function toState(state) {
            if (state === _SuperMap.SuperMap.State.UPDATE) {
                switch (this.state) {
                    case _SuperMap.SuperMap.State.UNKNOWN:
                    case _SuperMap.SuperMap.State.DELETE:
                        this.state = state;
                        break;
                    case _SuperMap.SuperMap.State.UPDATE:
                    case _SuperMap.SuperMap.State.INSERT:
                        break;
                }
            } else if (state === _SuperMap.SuperMap.State.INSERT) {
                switch (this.state) {
                    case _SuperMap.SuperMap.State.UNKNOWN:
                        break;
                    default:
                        this.state = state;
                        break;
                }
            } else if (state === _SuperMap.SuperMap.State.DELETE) {
                switch (this.state) {
                    case _SuperMap.SuperMap.State.INSERT:
                        // the feature should be destroyed
                        break;
                    case _SuperMap.SuperMap.State.DELETE:
                        break;
                    case _SuperMap.SuperMap.State.UNKNOWN:
                    case _SuperMap.SuperMap.State.UPDATE:
                        this.state = state;
                        break;
                }
            } else if (state === _SuperMap.SuperMap.State.UNKNOWN) {
                this.state = state;
            }
        }
    }]);

    return Vector;
}(_Feature2.Feature);

_SuperMap.SuperMap.Feature.Vector = Vector;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPortalServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _REST = __webpack_require__(3);

var _SecurityManager = __webpack_require__(35);

var _Credential = __webpack_require__(89);

var _FetchRequest = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.iPortalServiceBase
 * @classdesc iPortal服务基类(有权限限制的类需要实现此类)
 * @param url - {string} iPortal服务地址
 */
var IPortalServiceBase = exports.IPortalServiceBase = function () {
    function IPortalServiceBase(url) {
        _classCallCheck(this, IPortalServiceBase);

        this.serviceUrl = url;
        this.serverType = _REST.ServerType.iPortal;
        this.CLASS_NAME = "SuperMap.iPortalServiceBase";
    }

    /**
     * @function SuperMap.iPortalServiceBase.prototype.request
     * @description 子类统一通过该方法发送请求
     * @param method -{string} 请求类型
     * @param url -{string} 服务地址
     * @param param -{Object} 请求参数
     * @param requestOptions -{Object} fetch请求配置项
     * @returns {Promise} 返回包含请求结果的Promise对象
     */

    _createClass(IPortalServiceBase, [{
        key: 'request',
        value: function request(method, url, param, requestOptions) {
            url = this.createCredentialUrl(url);
            return _FetchRequest.FetchRequest.commit(method, url, param, requestOptions).then(function (response) {
                return response.json();
            });
        }

        /*
         * @function SuperMap.iPortalServiceBase.prototype.createCredentialUrl
         * @description 追加授权信息
         * @param url -{string} 创建证书url地址
         * @return {string} 携带token或key的新地址
         */

    }, {
        key: 'createCredentialUrl',
        value: function createCredentialUrl(url) {
            var newUrl = url,
                credential = this.getCredential();

            if (credential) {
                var endStr = newUrl.substring(newUrl.length - 1, newUrl.length);

                if (newUrl.indexOf("?") > -1 && endStr === "?") {
                    newUrl += credential.getUrlParameters();
                } else if (newUrl.indexOf("?") > -1 && endStr !== "?") {
                    newUrl += "&" + credential.getUrlParameters();
                } else {
                    newUrl += "?" + credential.getUrlParameters();
                }
            }
            return newUrl;
        }

        /*
         * @function SuperMap.iPortalServiceBase.prototype.getCredential
         * @description 获取token
         * @return {string } 返回获取的token
         *
         */

    }, {
        key: 'getCredential',
        value: function getCredential() {
            var credential,
                value = _SecurityManager.SecurityManager.getToken(this.serviceUrl);
            credential = value ? new _Credential.Credential(value, "token") : null;
            if (!credential) {
                value = this.getKey();
                credential = value ? new _Credential.Credential(value, "key") : null;
            }
            return credential;
        }

        /**
         * @function SuperMap.iPortalServiceBase.prototype.getKey
         * @description 其子类需要重写该方法，修改其中获取key的字段，存储key可能是服务id字段，可能是url
         */

    }, {
        key: 'getKey',
        value: function getKey() {
            //return SuperMap.SecurityManager.getKey(this.id);
            //或
            //return SuperMap.SecurityManager.getKey(this.serviceUrl);
        }
    }]);

    return IPortalServiceBase;
}();

_SuperMap.SuperMap.iPortalServiceBase = IPortalServiceBase;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JoinItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.JoinItem
 * @classdesc 连接信息类。
 * 该类用于矢量数据集与外部表的连接。外部表可以为另一个矢量数据集（其中纯属性数据集中没有空间几何信息）所对应的 DBMS 表，也可以是用户自建的业务表。需要注意的是，矢量数据集与外部表必须属于同一数据源。表之间的联系的建立有两种方式，一种是连接（join），一种是关联（link）。连接，实际上是依据相同的字段将一个外部表追加到指定的表；而关联是基于一个相同的字段定义了两个表格之间的联系，但不是实际的追加。用于连接两个表的字段的名称不一定相同，但类型必须一致。当两个表格之间建立了连接，通过对主表进行操作，可以对外部表进行查询，制作专题图以及分析等。当两个表格之间是一对一或多对一的关系时，可以使用 join 连接。当为多对一的关系时，允许指定多个字段之间的关联。(注意：SuperMap.JoinItem 目前支持左连接和内连接，不支持全连接和右连接，UDB 引擎不支持内连接。并且用于建立连接的两个表必须在同一个数据源下。)
 * @param options - {Object} 可選参数。如:</br>
 *        foreignTableName - {string} 外部表的名称。</br>
 *        joinFilter - {string} 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。</br>
 *        joinType - {SuperMap.JoinType} 两个表之间连接类型。</br>
 * @example 下面以SQL查询说明joinItem的使用方法：
 *(start code)
 *   function queryBySQL() {
     *       // 设置与外部表的连接信息
     *       var joinItem = new SuperMap.JoinItem({
     *           foreignTableName: "foreignTable",
     *           joinFilter: "foreignTable.CONTINENT = Countries.CONTINENT",
     *           joinType: "LEFTJOIN"
     *       })
     *       var queryParam, queryBySQLParams, queryBySQLService;
     *       // 设置查询参数，在查询参数中添加joinItem关联条件信息
     *       queryParam = new SuperMap.FilterParameter({
     *            name: "Countries@World",
     *            joinItems: [joinItem]
     *         }),
     *       queryBySQLParams = new SuperMap.QueryBySQLParameters({
     *             queryParams: [queryParam]
     *         }),
     *       queryBySQLService = new SuperMap.QueryBySQLService(url, {
     *             eventListeners: { "processCompleted": processCompleted, "processFailed": processFailed}
     *         });
     *       queryBySQLService.processAsync(queryBySQLParams);
     *  }
 *  function processCompleted(queryEventArgs) {//todo}
 *  function processFailed(e) {//todo}
 * (end)
 */
var JoinItem = exports.JoinItem = function () {
    function JoinItem(options) {
        _classCallCheck(this, JoinItem);

        /**
         * @member SuperMap.JoinItem.prototype.foreignTableName -{string}
         * @description 外部表的名称。
         * 如果外部表的名称是以“表名@数据源名”命名方式，则该属性只需赋值表名。
         * 例如：外部表 Name@changchun，Name 为表名，changchun 为数据源名称，则该属性的赋值应为：Name。
         */
        this.foreignTableName = null;

        /**
         * @member SuperMap.JoinItem.prototype.joinFilter -{string}
         * @description 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。
         * 例如，将房屋面数据集（Building）的 district 字段与房屋拥有者的纯属性数据集（Owner）的 region 字段相连接，
         * 两个数据集对应的表名称分别为 Table_Building 和 Table_Owner，
         * 则连接表达式为 Table_Building.district = Table_Owner.region。
         * 当有多个字段相连接时，用 AND 将多个表达式相连。
         */
        this.joinFilter = null;

        /**
         * @member SuperMap.JoinItem.prototype.joinType -{JoinType}
         * @description 两个表之间连接类型。
         * 连接类型决定了对两个表进行连接查询后返回的记录的情况。
         */
        this.joinType = null;

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.JoinItem";
    }

    /**
     * @function SuperMap.JoinItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(JoinItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.foreignTableName = null;
            me.joinFilter = null;
            me.joinType = null;
        }

        /**
         * @function SuperMap.JoinItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var dataObj = {};
            dataObj = _Util.Util.copyAttributes(dataObj, this);
            //joinFilter基本是个纯属性对象，这里不再做转换
            return dataObj;
        }
    }]);

    return JoinItem;
}();

_SuperMap.SuperMap.JoinItem = JoinItem;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LabelMatrixCell = undefined;

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LabelMatrixCell
 * @classdesc 矩阵标签元素抽象类。
 * @description 该类可以包含 n*n 个矩阵标签元素，矩阵标签元素的类型可以是图片，符号，标签专题图等。
 *              符号类型的矩阵标签元素类、图片类型的矩阵标签元素类和专题图类型的矩阵标签元素类均继承自该类。
 */
var LabelMatrixCell = exports.LabelMatrixCell = function LabelMatrixCell() {
    _classCallCheck(this, LabelMatrixCell);

    this.CLASS_NAME = "LabelMatrixCell";
};

_SuperMap.SuperMap.LabelMatrixCell = LabelMatrixCell;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Route = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _LinearRing = __webpack_require__(31);

var _LineString = __webpack_require__(17);

var _PointWithMeasure = __webpack_require__(212);

var _Collection2 = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Route
 * @classdesc
 * 路由对象类。路由对象为一系列有序的带有属性值 M 的 x，y 坐标对，其中 M 值为该结点的距离属性（到已知点的距离）。
 * @param points - {{Array<SuperMap.Geometry>}} 形成路由对象的线数组。
 * @param  options - {Object} 可选参数。如:</br>
 *         id - {number}路由对象在数据库中的id。</br>
 *         length - {number}路由对象的长度。</br>
 *         maxM - {number}最大线性度量值，即所有结点到起始点的量算距离中最大值。</br>
 *         minM - {number}最小线性度量值，即所有结点到起始点的量算距离中最小值。</br>
 *         type - {string} 数据类型，如："LINEM"</br>
 * @extends SuperMap.Geometry.Collection
 */
var Route = exports.Route = function (_Collection) {
    _inherits(Route, _Collection);

    function Route(points, options) {
        _classCallCheck(this, Route);

        /**
         * @member SuperMap.Route.prototype.id -{number}
         * @description 路由对象在数据库中的id。
         */
        var _this = _possibleConstructorReturn(this, (Route.__proto__ || Object.getPrototypeOf(Route)).call(this, points, options));

        _this.id = null;

        /**
         * @member SuperMap.Route.prototype.center -{number}
         * @description 路由对象的中心点
         */
        _this.center = null;

        /**
         * @member SuperMap.Route.prototype.style -{string}
         * @description 路由对象的样式
         */
        _this.style = null;

        /**
         * @member SuperMap.Route.prototype.length -{number}
         * @description 路由对象的长度。单位与数据集的单位相同。
         */
        _this.length = null;

        /**
         *  @member SuperMap.Route.prototype.maxM -{number}
         *  @description 最大线性度量值，即所有结点到起始点的量算距离中最大值。
         */
        _this.maxM = null;

        /**
         * @member SuperMap.Route.prototype.minM -{number}
         * @description 最小线性度量值，即所有结点到起始点的量算距离中最小值。
         */
        _this.minM = null;

        /**
         * @member SuperMap.Route.prototype.parts -{Array<number>}
         * @description 服务端几何对象中各个子对象所包含的节点个数。
         */
        _this.parts = null;

        /**
         * @member SuperMap.Route.prototype.points -{Array<Object>}
         * @description 路由对象的所有路由点。
         * @example
         * (start code)
         * [
         *  {
        *      "measure": 0,
        *      "y": -4377.027184298267,
        *      "x": 4020.0045221720466
        *  },
         *  {
        *      "measure": 37.33288381391519,
        *      "y": -4381.569363260499,
        *      "x": 4057.0600591960642
        *  }
         * ]
         * (end)
         */
        _this.points = null;

        /**
         * @member SuperMap.Route.prototype.type -{string}
         * @description 服务端几何对象类型。
         */
        _this.type = null;

        /**
         * @member SuperMap.Route.prototype.componentTypes -{Array<string>}
         * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
         * @default ["{@link SuperMap.Geometry.LinearRing}", "{@link SuperMap.Geometry.LineString}"];
         */
        _this.componentTypes = ["SuperMap.Geometry.LinearRing", "SuperMap.Geometry.LineString"];

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.Route";
        return _this;
    }

    /**
     *
     * @function SuperMap.Route.prototype.toJson
     * @description 转换为json对象。
     * @return{Object} json对象
     */


    _createClass(Route, [{
        key: 'toJson',
        value: function toJson() {
            var result = "{";
            if (this.id != null && this.id != undefined) {
                result += "\"id\":" + this.id + ",";
            }
            if (this.center != null && this.center != undefined) {
                result += "\"center\":" + this.center + ",";
            }
            if (this.style != null && this.style != undefined) {
                result += "\"style\":" + this.style + ",";
            }
            if (this.length != null && this.length != undefined) {
                result += "\"length\":" + this.length + ",";
            }
            if (this.maxM != null && this.maxM != undefined) {
                result += "\"maxM\":" + this.maxM + ",";
            }
            if (this.minM != null && this.minM != undefined) {
                result += "\"minM\":" + this.minM + ",";
            }
            if (this.type != null && this.type != undefined) {
                result += "\"type\":\"" + this.type + "\",";
            }
            if (this.parts != null && this.parts != undefined) {
                result += "\"parts\":[" + this.parts[0];

                for (var i = 1; i < this.parts.length; i++) {
                    result += "," + this.parts[i];
                }
                result += "],";
            }
            if (this.components != null && this.components.length > 0) {
                result += "\"points\":[";
                for (var j = 0, len = this.components.length; j < len; j++) {
                    for (var k = 0, len2 = this.components[j].components.length; k < len2; k++) {
                        result += this.components[j].components[k].toJson() + ",";
                    }
                }
                result = result.replace(/,$/g, '');
                result += "]";
            }
            result = result.replace(/,$/g, '');
            result += "}";
            return result;
        }

        /**
         * @function SuperMap.Route.prototype.destroy
         * @override
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.id = null;
            me.center = null;
            me.style = null;
            me.length = null;
            me.maxM = null;
            me.minM = null;
            me.type = null;
            me.parts = null;
            me.components.length = 0;
            me.components = null;
            me.componentTypes = null;
        }

        /**
         * @function SuperMap.Route.fromJson
         * @description  将 JSON 对象转换为 SuperMap.Route 对象。
         * @param jsonObject - {Object} JSON 对象表示的路由对象。
         * @return{SuperMap.Route} 转化后的 Route 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }

            var geoParts = jsonObject.parts || [],
                geoPoints = jsonObject.points || [],
                len = geoParts.length,
                lineList = [];
            if (len > 0) {
                for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                    for (var j = 0; j < geoParts[i]; j++) {
                        pointList.push(_PointWithMeasure.PointWithMeasure.fromJson(geoPoints[pointIndex + j]));
                    }
                    pointIndex += geoParts[i];
                    //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                    if (pointList[0].equals(pointList[geoParts[i] - 1])) {
                        lineList.push(new _LinearRing.LinearRing(pointList));
                    } else {
                        lineList.push(new _LineString.LineString(pointList));
                    }
                    pointList = [];
                }
            } else {
                return null;
            }

            return new Route(lineList, {
                id: jsonObject.id,
                center: jsonObject.center,
                style: jsonObject.style,
                length: jsonObject.length,
                maxM: jsonObject.maxM,
                minM: jsonObject.minM,
                type: jsonObject.type,
                parts: jsonObject.parts
            });
        }
    }]);

    return Route;
}(_Collection2.Collection);

_SuperMap.SuperMap.Route = Route;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SurfaceAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _DataReturnOption = __webpack_require__(50);

var _REST = __webpack_require__(3);

var _SurfaceAnalystParametersSetting = __webpack_require__(228);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SurfaceAnalystParameters
 * @classdesc 表面分析提取操作参数类。
 * @description 通过该类可以为进行表面分析提供参数信息，包括表面分析的方法提取等值线、提取等值面和中间结果的分辨率，
 * {@link SuperMap.DatasetSurfaceAnalystParameters} 和 {@link SuperMap.GeometrySurfaceAnalystParameters} 继承自该类。
 * @param options - {Object} 可选参数。如:</br>
 *        extractParameter - {{@link SuperMap.SurfaceAnalystParametersSetting}} 获取或设置表面分析参数。</br>
 *        resolution - {number}指定中间结果（栅格数据集）的分辨率。</br>
 *        resultSetting - {{@link SuperMap.DataReturnOption}} 结果返回设置类。</br>
 *        surfaceAnalystMethod - {{@link SuperMap.SurfaceAnalystMethod}} 获取或设置表面分析的提取方法，提取等值线和提取等值面。</br>
 */
var SurfaceAnalystParameters = exports.SurfaceAnalystParameters = function () {
    function SurfaceAnalystParameters(options) {
        _classCallCheck(this, SurfaceAnalystParameters);

        /**
         * @member SuperMap.SurfaceAnalystParameters.prototype.resolution -{number}
         * @description 获取或设置指定中间结果（栅格数据集）的分辨率。
         */
        this.resolution = 0;

        /**
         * @member SuperMap.SurfaceAnalystParameters.prototype.extractParameter -{SuperMap.SurfaceAnalystParametersSetting}
         * @description 获取或设置表面分析参数。
         * 在进行点数据集进行提取等值面分析时，暂时不支持 SurfaceAnalystParametersSetting 类中的 expectedZValues 字段。
         */
        this.extractParameter = new _SurfaceAnalystParametersSetting.SurfaceAnalystParametersSetting();

        /**
         * @member SuperMap.SurfaceAnalystParameters.prototype.resultSetting -{SuperMap.DataReturnOption}
         * @description 结果返回设置类。
         */
        this.resultSetting = new _DataReturnOption.DataReturnOption();

        /**
         * @member SuperMap.SurfaceAnalystParameters.prototype.surfaceAnalystMethod -{SuperMap.SurfaceAnalystMethod}
         * @description 获取或设置表面分析的提取方法，提取等值线和提取等值面，默认为等值线分析。
         */
        this.surfaceAnalystMethod = _REST.SurfaceAnalystMethod.ISOLINE;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.SurfaceAnalystParameters";
    }

    /**
     * @function SuperMap.SurfaceAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(SurfaceAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.resolution = null;
            if (me.extractParameter) {
                me.extractParameter.destroy();
                me.extractParameter = null;
            }
            if (me.resultSetting) {
                me.resultSetting.destroy();
                me.resultSetting = null;
            }
            me.surfaceAnalystMethod = null;
        }
    }]);

    return SurfaceAnalystParameters;
}();

_SuperMap.SuperMap.SurfaceAnalystParameters = SurfaceAnalystParameters;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeFlow = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerStyle = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeFlow
 * @classdesc 标签或符号流动显示和牵引线风格设置类。
 *              通过该类可以设置专题图中符号是否流动显示、是否使用牵引线以及牵引线风格。
 * @param options - {Object} 可选参数。如：<br>
 *        flowEnabled - {boolean} 是否流动显示标签或符号。<br>
 *        leaderLineDisplayed - {boolean} 是否显示标签或符号和它标注的对象之间的牵引线。<br>
 *        leaderLineStyle - {{@link SuperMap.ServerStyle}} 标签或符号与其标注对象之间牵引线的风格。
 */
var ThemeFlow = exports.ThemeFlow = function () {
    function ThemeFlow(options) {
        _classCallCheck(this, ThemeFlow);

        /**
         * @member SuperMap.ThemeFlow.prototype.flowEnabled -{boolean}
         * @description 是否流动显示标签或符号。<br>
         *              对于标签专题图而言，对于跨越比较大的区域和线条状的几何对象，在一个地图窗口中不能完全显示的情况下，如果其标签位置比较固定，<br>
         *              在当前地图窗口中该对象的标签不可见，则需要通过平移地图来查看对象的标签信息。如果采用了流动显示的效果，在当前地图窗口中，对象即使是部分显示，<br>
         *              其标签也会显示在当前地图窗口中。当平移地图时，对象的标签会随之移动，以保证在当前地图窗口中部分或全部显示的对象其标签都可见，从而可以方便地查看各要素的标签信息。
         */
        this.flowEnabled = false;

        /**
         * @member SuperMap.ThemeFlow.prototype.leaderLineDisplayed -{boolean}
         * @description 是否显示标签或符号和它标注的对象之间的牵引线。默认值为 false，即不显示标签或符号和它标注的对象之间的牵引线。<br>
         *              只有当 flowEnabled 为 true 时，牵引线才起作用。在当标签流动显示时，其位置不固定，由于牵引线始终指向要素的内点，<br>
         *              因而通过牵引线显示功能可以找到流动的标签或符号实际对应的要素。或者渲染符号偏移它所指向的对象时，图与对象之间可以采用牵引线进行连接。
         */
        this.leaderLineDisplayed = false;

        /**
         * @member SuperMap.ThemeFlow.prototype.leaderLineStyle -{SuperMap.ServerStyle}
         * @description 标签或符号与其标注对象之间牵引线的风格。
         */
        this.leaderLineStyle = new _ServerStyle.ServerStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeFlow";
    }

    /**
     * @function SuperMap.ThemeFlow.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeFlow, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.flowEnabled = null;
            me.leaderLineDisplayed = null;
            if (me.leaderLineStyle) {
                me.leaderLineStyle.destroy();
                me.leaderLineStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeFlow.fromObj
         * @description 从传入对象获取标签或符号流动显示和牵引线风格设置类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeFlow} ThemeFlow对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeFlow();
            _Util.Util.copy(res, obj);
            res.leaderLineStyle = _ServerStyle.ServerStyle.fromJson(obj.leaderLineStyle);
            return res;
        }
    }]);

    return ThemeFlow;
}();

_SuperMap.SuperMap.ThemeFlow = ThemeFlow;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeLabel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ThemeLabelItem = __webpack_require__(241);

var _ThemeUniqueItem = __webpack_require__(101);

var _ThemeFlow = __webpack_require__(70);

var _ThemeOffset = __webpack_require__(72);

var _ThemeLabelText = __webpack_require__(242);

var _ThemeLabelAlongLine = __webpack_require__(239);

var _ThemeLabelBackground = __webpack_require__(240);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeLabel
 * @classdesc 标签专题图类。
 * @extends SuperMap.Theme
 * @param  options - {Object} 可选参数。如：<br>
 *         alongLine - {{@link SuperMap.ThemeLabelAlongLine}} 标签沿线标注方向样式类。<br>
 *         background - {{@link SuperMap.ThemeLabelBackground}} 标签专题图中标签的背景风格类。<br>
 *         flow - {{@link SuperMap.ThemeFlow}} 标签专题图标签流动显示与牵引线设置类。<br>
 *         items - {Array<{@link SuperMap.ThemeUniqueItem}>} 分段标签专题图的子项数组。<br>
 *         labelExpression - {string} 标注字段表达式。<br>
 *         labelOverLengthMode - {{@link SuperMap.LabelOverLengthMode}} 标签专题图中超长标签的处理模式枚举类。<br>
 *         matrixCells - {Array<{@link SuperMap.LabelMatrixCell}>} 矩阵标签元素数组。<br>
 *         maxLabelLength - {number}标签在每一行显示的最大长度。<br>
 *         numericPrecision - {number}通过该字段设置其显示的精度。<br>
 *         offset - {{@link SuperMap.ThemeOffset}} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。<br>
 *         overlapAvoided - {boolean} 是否允许以文本避让方式显示文本。<br>
 *         rangeExpression - {string} 制作分段标签专题的分段字段或字段表达式。<br>
 *         smallGeometryLabeled - {boolean} 是否显示长度大于被标注对象本身长度的标签。<br>
 *         text - {{@link SuperMap.ThemeLabelText}} 标签中文本风格。<br>
 *         textSpace - {number} 沿线标注，相邻两个文字之间的间距，单位当前设置的字高。<br>
 *         memoryData - {{@link SuperMap.ThemeMemoryData}} 专题图内存数据。
 */
var ThemeLabel = exports.ThemeLabel = function (_Theme) {
    _inherits(ThemeLabel, _Theme);

    function ThemeLabel(options) {
        _classCallCheck(this, ThemeLabel);

        /**
         * @member SuperMap.ThemeLabel.prototype.alongLine -{SuperMap.ThemeLabelAlongLine}
         * @description 标签沿线标注方向样式类。<br>
         *              在该类中可以设置标签是否沿线标注以及沿线标注的多种方式。沿线标注属性只适用于线数据集专题图。
         */
        var _this = _possibleConstructorReturn(this, (ThemeLabel.__proto__ || Object.getPrototypeOf(ThemeLabel)).call(this, "LABEL", options));

        _this.alongLine = new _ThemeLabelAlongLine.ThemeLabelAlongLine();

        /**
         * @member SuperMap.ThemeLabel.prototype.background -{SuperMap.ThemeLabelBackground}
         * @description 标签专题图中标签的背景风格类。通过该字段可以设置标签的背景形状和风格。
         */
        _this.background = new _ThemeLabelBackground.ThemeLabelBackground();

        /**
         * @member SuperMap.ThemeLabel.prototype.flow -{SuperMap.ThemeFlow}
         * @description 标签专题图标签流动显示与牵引线设置类。通过该字段可以设置标签是否流动显示和牵引线风格。
         */
        _this.flow = new _ThemeFlow.ThemeFlow();

        /**
         * @member SuperMap.ThemeLabel.prototype.items - {Array<SuperMap.ThemeUniqueItem>}
         * @description 分段标签专题图的子项数组。分段标签专题图使用 rangeExpression <br>
         *              指定数字型的字段作为分段数据，items 中的每个子对象的 [start，end) 分段值必须来源于属性 rangeExpression 的字段值。每个子项拥有自己的风格。
         */
        _this.items = null;

        /**
         * @member SuperMap.ThemeLabel.prototype.uniqueItems -{Array<SuperMap.ThemeLabelUniqueItem>}
         * @description 单值标签专题图子项数组。单值标签专题图使用 uniqueExpression单值标签专题图子项集合
         */
        _this.uniqueItems = null;

        /**
         * @member SuperMap.ThemeLabel.prototype.labelExpression -{string}
         * @description 标注字段表达式。系统将 labelExpression 对应的字段或字段表达式的值以标签的形式显示在图层中。必设字段。
         */
        _this.labelExpression = null;

        /**
         * @member SuperMap.ThemeLabel.prototype.labelOverLengthMode -{SuperMap.LabelOverLengthMode} 标签专题图中超长标签的处理模式枚举类。
         * 对于标签的长度超过设置的标签最大长度 maxLabelLength 时称为超长标签。默认为 SuperMap.LabelOverLengthMode.NONE。
         */
        _this.labelOverLengthMode = _REST.LabelOverLengthMode.NONE;

        /**
         * @member SuperMap.ThemeLabel.prototype.matrixCells -{Array<SuperMap.LabelMatrixCell>}
         * @description 矩阵标签元素数组，用于制作矩阵标签专题图。
         *              数组中可以放置符号类型的矩阵标签元素和图片类型的矩阵标签元素。
         */
        _this.matrixCells = null;

        /**
         * @member SuperMap.ThemeLabel.prototype.maxLabelLength -{number}
         * @description 标签在每一行显示的最大长度，一个中文为两个字符。
         *              如果超过最大长度，可以采用两种方式来处理，一种是换行的模式进行显示，另一种是以省略号方式显示。默认最大长度为256个字符。
         */
        _this.maxLabelLength = 256;

        /**
         * @member SuperMap.ThemeLabel.prototype.numericPrecision -{number}
         * @description 如果显示的标签内容为数字，通过该字段设置其显示的精度。例如标签对应的数字是8071.64529347，
         *              如果该属性为0时，显示8071；为1时，显示8071.6；为3时，则是8071.645。
         */
        _this.numericPrecision = 0;

        /**
         * @member SuperMap.ThemeLabel.prototype.offset -{SuperMap.ThemeOffset}
         * @description 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。
         */
        _this.offset = new _ThemeOffset.ThemeOffset();

        /**
         * @member SuperMap.ThemeLabel.prototype.overlapAvoided -{boolean}
         * @description 是否允许以文本避让方式显示文本。默认值为 true， 即自动避免文本叠盖。只针对该标签专题图层中的文本数据。
         *               在标签重叠度很大的情况下，即使使用自动避让功能，可能也无法完全避免标签重叠现象。
         */
        _this.overlapAvoided = true;

        /**
         * @member SuperMap.ThemeLabel.prototype.rangeExpression -{string}
         * @description 制作分段标签专题的分段字段或字段表达式。该表达式对应的字段（或者字段表达式）的值应该为数值型。
         *              该字段与 items 分段子项联合使用，每个子项的起始值 [start，end)来源于 rangeExpression 字段值。
         *              最后 labelExpression 指定的标签字段（标签专题图要显示的具体内容）会根据分段子项的风格进行分段显示。
         */
        _this.rangeExpression = null;

        /**
         * @member SuperMap.ThemeLabel.prototype.uniqueExpression -{string}
         * @description 用于制作单值专题图的字段或字段表达式。
         *              该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必设字段,必须与labelExpression一起使用
         */
        _this.uniqueExpression = null;

        /**
         * @member SuperMap.ThemeLabel.prototype.smallGeometryLabeled -{boolean}
         * @description 是否显示长度大于被标注对象本身长度的标签，默认为 false。在标签的长度大于线或者面对象本身的长度时，
         *              如果该值为 true，则标签文字会叠加在一起显示，为了清楚完整的显示该标签，
         *              可以采用换行模式来显示标签，但必须保证每行的长度小于对象本身的长度。
         */
        _this.smallGeometryLabeled = false;

        /**
         * @member SuperMap.ThemeLabel.prototype.text -{SuperMap.ThemeLabelText}
         * @description 标签中文本风格。
         */
        _this.text = new _ThemeLabelText.ThemeLabelText();

        /**
         * @member SuperMap.ThemeLabel.prototype.textSpace -{number}
         * @description 沿线标注，相邻两个文字之间的间距，单位当前设置的字高
         */
        _this.textSpace = 0;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeLabel";
        return _this;
    }

    /**
     * @function SuperMap.ThemeLabel.prototype.destroy
     * @override
     */


    _createClass(ThemeLabel, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeLabel.prototype.__proto__ || Object.getPrototypeOf(ThemeLabel.prototype), 'destroy', this).call(this);
            var me = this;
            me.alongLine = null;
            if (me.background) {
                me.background.destroy();
                me.background = null;
            }
            me.flow = null;
            if (me.items) {
                for (var i = 0, items = me.items, len = items.length; i < len; i++) {
                    items[i].destroy();
                }
                me.items = null;
            }
            if (me.uniqueItems) {
                for (var j = 0, uniqueItems = me.uniqueItems, uniqueLen = uniqueItems.length; j < uniqueLen; j++) {
                    uniqueItems[j].destory();
                }
                me.uniqueItems = null;
            }
            me.labelExpression = null;
            me.labelOverLengthMode = null;
            me.matrixCells = null;
            me.maxLabelLength = null;
            me.numericPrecision = null;
            me.overlapAvoided = null;
            me.rangeExpression = null;
            me.uniqueExpression = null;
            if (me.offset) {
                me.offset.destroy();
                me.offset = null;
            }
            me.overlapAvoided = null;
            me.smallGeometryLabeled = null;
            if (me.text) {
                me.text.destroy();
                me.text = null;
            }
            me.textSpace = null;
        }

        /**
         * @function SuperMap.ThemeLabel.prototype.toJSON
         * @description 将themeLabel对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return _Util.Util.toJSON(this.toServerJSONObject());
        }

        /**
         * @function SuperMap.ThemeLabel.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj.type = this.type;
            obj.memoryData = this.memoryData;
            if (this.alongLine) {
                obj.alongLine = this.alongLine.isAlongLine;
                obj.alongLineDirection = this.alongLine.alongLineDirection;
                obj.angleFixed = this.alongLine.angleFixed;
                obj.isLabelRepeated = this.alongLine.isLabelRepeated;
                obj.labelRepeatInterval = this.alongLine.labelRepeatInterval;
                obj.repeatedLabelAvoided = this.alongLine.repeatedLabelAvoided;
                obj.repeatIntervalFixed = this.alongLine.repeatIntervalFixed;
            }
            if (this.offset) {
                obj.offsetFixed = this.offset.offsetFixed;
                obj.offsetX = this.offset.offsetX;
                obj.offsetY = this.offset.offsetY;
            }

            if (this.flow) {
                obj.flowEnabled = this.flow.flowEnabled;
                obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
                obj.leaderLineStyle = this.flow.leaderLineStyle;
            }
            if (this.text) {
                obj.maxTextHeight = this.text.maxTextHeight;
                obj.maxTextWidth = this.text.maxTextWidth;
                obj.minTextHeight = this.text.minTextHeight;
                obj.minTextWidth = this.text.minTextWidth;
                obj.uniformStyle = this.text.uniformStyle;
                obj.uniformMixedStyle = this.text.uniformMixedStyle;
            }
            if (this.background) {
                obj.labelBackShape = this.background.labelBackShape;
                obj.backStyle = this.background.backStyle;
            }
            obj.labelOverLengthMode = this.labelOverLengthMode;
            obj.maxLabelLength = this.maxLabelLength;
            obj.smallGeometryLabeled = this.smallGeometryLabeled;
            obj.rangeExpression = this.rangeExpression;
            obj.uniqueExpression = this.uniqueExpression;
            obj.numericPrecision = this.numericPrecision;
            obj.items = this.items;
            obj.uniqueItems = this.uniqueItems;
            obj.labelExpression = this.labelExpression;
            obj.overlapAvoided = this.overlapAvoided;
            obj.matrixCells = this.matrixCells;
            obj.textSpace = this.textSpace;
            return obj;
        }

        /**
         * @function SuperMap.ThemeLabel.fromObj
         * @description 从传入对象获取标签专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabel} ThemeLabel对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var lab = new ThemeLabel();
            var itemsL = obj.items,
                itemsU = obj.uniqueItems,
                cells = obj.matrixCells;
            obj.matrixCells = null;
            _Util.Util.copy(lab, obj);
            lab.alongLine = _ThemeLabelAlongLine.ThemeLabelAlongLine.fromObj(obj);
            lab.background = _ThemeLabelBackground.ThemeLabelBackground.fromObj(obj);
            lab.flow = new _ThemeFlow.ThemeFlow({
                flowEnabled: obj.flowEnabled,
                leaderLineDisplayed: obj.leaderLineDisplayed,
                leaderLineStyle: obj.leaderLineStyle
            });
            if (itemsL) {
                lab.items = [];
                for (var i = 0, len = itemsL.length; i < len; i++) {
                    lab.items.push(_ThemeLabelItem.ThemeLabelItem.fromObj(itemsL[i]));
                }
            }
            if (itemsU) {
                lab.uniqueItems = [];
                for (var j = 0, uniqueLen = itemsU.length; j < uniqueLen; j++) {
                    lab.uniqueItems.push(_ThemeUniqueItem.ThemeUniqueItem.fromObj(itemsU[j]));
                }
            }
            if (cells) {
                lab.matrixCells = [];
                for (var _i = 0, _len = cells.length; _i < _len; _i++) {
                    //TODO
                    //lab.matrixCells.push(SuperMap.LabelMatrixCell.fromObj(cells[i]));
                }
            }
            lab.offset = _ThemeOffset.ThemeOffset.fromObj(obj);
            lab.text = _ThemeLabelText.ThemeLabelText.fromObj(obj);
            return lab;
        }
    }]);

    return ThemeLabel;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeLabel = ThemeLabel;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeOffset = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeOffset
 * @classdesc 专题图中文本或符号相对于要素内点的偏移量设置类。
 *              通过该类可以设置专题图中标记文本或符号的偏移量以及偏移量是否随地图缩放而改变。
 * @param options - {Object} 可选参数。如：<br>
 *        offsetFixed - {boolean} 当前专题图是否固定标记文本或符号的偏移量。<br>
 *        offsetX - {string} 专题图中文本或符号相对于要素内点的水平偏移量。<br>
 *        offsetY - {string} 专题图中文本或符号相对于要素内点的垂直偏移量。
 */
var ThemeOffset = exports.ThemeOffset = function () {
    function ThemeOffset(options) {
        _classCallCheck(this, ThemeOffset);

        /**
         * @member SuperMap.ThemeOffset.prototype.offsetFixed -{boolean}
         * @description 当前专题图是否固定标记文本或符号的偏移量。所谓固定偏移量，则文本或符号的偏移量不随地图的缩放而变化。默认为 false，表示偏移量随地图的缩放而变化。
         */
        this.offsetFixed = false;

        /**
         * @member SuperMap.ThemeOffset.prototype.offsetX -{string}
         * @description 专题图中文本或符号相对于要素内点的水平偏移量。偏移量的单位为地图单位。
         *              该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么水平偏移量为2。
         */
        this.offsetX = "0.0";

        /**
         * @member SuperMap.ThemeOffset.prototype.offsetY -{string}
         * @description 专题图中文本或符号相对于要素内点的垂直偏移量。偏移量的单位为地图单位。
         *              该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么垂直偏移量为2。
         */
        this.offsetY = "0.0";

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeOffset";
    }

    /**
     * @function SuperMap.ThemeOffset.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeOffset, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.offsetFixed = null;
            me.offsetX = null;
            me.offsetY = null;
        }

        /**
         * @function SuperMap.ThemeOffset.fromObj
         * @description 从传入对象获取专题图中文本或符号相对于要素内点的偏移量设置类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeOffset} ThemeOffset对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeOffset();
            _Util.Util.copy(res, obj);
            return res;
        }
    }]);

    return ThemeOffset;
}();

_SuperMap.SuperMap.ThemeOffset = ThemeOffset;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThiessenAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThiessenAnalystParameters
 * @classdesc 泰森多边形分析参数基类。
 * @param options - {Object} 可选参数。如:</br>
 *        clipRegion - {Object} 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *        createResultDataset - {boolean} 是否返回结果数据集，默认不返回。</br>
 *        resultDatasetName - {boolean} 指定结果数据集名称。</br>
 *        resultDatasourceName - {boolean} 指定结果数据集所在数据源，默认为当前数据源。</br>
 *        returnResultRegion - {boolean} 是否返回分析得到的多边形面数组，默认返回。</br>
 */
var ThiessenAnalystParameters = exports.ThiessenAnalystParameters = function () {
  function ThiessenAnalystParameters(options) {
    _classCallCheck(this, ThiessenAnalystParameters);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.clipRegion  -{Object}
     * @description 结果数据裁剪区域，可以为null，表示不对结果进行裁剪。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。
     */
    this.clipRegion = null;

    /**
     *  @member SuperMap.ThiessenAnalystParameters.prototype.createResultDataset -{boolean}
     *  @description 是否返回结果数据集，默认值 false。如果为true，则必须设置属性resultDatasetName和resultDatasourceName。
     */
    this.createResultDataset = false;

    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.resultDatasetName -{string}
     * @description 指定结果数据集名称。
     */
    this.resultDatasetName = null;

    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.resultDatasourceName -{string}
     * @description 指定结果数据集所在数据源。
     */
    this.resultDatasourceName = null;

    /**
     * @member SuperMap.ThiessenAnalystParameters.prototype.returnResultRegion -{boolean}
     * @description 是否返回分析得到的多边形面数组，默认 true，返回。
     */
    this.returnResultRegion = true;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.ThiessenAnalystParameters";
  }

  /**
   * @function SuperMap.ThiessenAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ThiessenAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.clipRegion) {
        me.clipRegion.destroy();
        me.clipRegion = null;
      }
      me.createResultDataset = null;
      me.resultDatasetName = null;
      me.resultDatasourceName = null;
      me.returnResultRegion = null;
    }
  }]);

  return ThiessenAnalystParameters;
}();

_SuperMap.SuperMap.ThiessenAnalystParameters = ThiessenAnalystParameters;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Point = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Point
 * 点参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Point = exports.Point = function (_ShapeParameters) {
  _inherits(Point, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Point
   * 创建一个图形点参数对象。
   *
   * Parameters:
   * x - {Number} 点 x 坐标，必设参数
   * y - {Number} 点 y 坐标，必设参数。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Point>} 图形点参数对象。
   */
  function Point(x, y) {
    _classCallCheck(this, Point);

    /**
     * APIProperty: x
     * {Number} 点 x 坐标。
     */
    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, x, y));

    _this.x = !isNaN(x) ? x : 0;

    /**
     * APIProperty: y
     * {Number} 点 y 坐标。
     */
    _this.y = !isNaN(y) ? y : 0;

    /**
     * Property: y
     * {Number} 点的半径。style.pointRadius 默认值。
     */
    _this.r = 6;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Point";
    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Point, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.r = null;

      _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), 'destroy', this).call(this);
    }
  }]);

  return Point;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Point = Point;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Polygon = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Polygon
 * 面参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Polygon = exports.Polygon = function (_ShapeParameters) {
  _inherits(Polygon, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Polygon
   * 创建一个图形面参数对象。
   *
   * Parameters:
   * pointList - {Array} 面要素节点数组，二维数组，必设参数。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Polygon>} 图形面参数对象。
   */
  function Polygon(pointList) {
    _classCallCheck(this, Polygon);

    /**
     * APIProperty: pointList
     * {Array} 面要素节点数组，二维数组。
     *
     * 数组形如：
     * (start code)
     *  [
     *  [10, 20],         //节点
     *  [30, 40],
     *  [25, 30]         //最后一个节点和第一个节点不必相同，绘制时自动封闭
     *   ]
     * (end)
     */
    var _this = _possibleConstructorReturn(this, (Polygon.__proto__ || Object.getPrototypeOf(Polygon)).call(this, pointList));

    _this.pointList = pointList;

    /**
     * Property: holePolygonPointLists
     * {Array} 岛洞面多边形顶点数组（三维数组）
     */
    _this.holePolygonPointLists = null;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Polygon";
    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Polygon, [{
    key: 'destroy',
    value: function destroy() {
      this.pointList = null;
      this.holePolygonPointLists = null;
      _get(Polygon.prototype.__proto__ || Object.getPrototypeOf(Polygon.prototype), 'destroy', this).call(this);
    }
  }]);

  return Polygon;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Polygon = Polygon;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sector = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Sector
 * 扇形参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Sector = exports.Sector = function (_ShapeParameters) {
  _inherits(Sector, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Sector
   * 创建一个扇形参数对象。
   *
   * Parameters:
   * x - {Number} 圆心 x 坐标，必设参数。
   * y - {Number} 圆心 y 坐标，必设参数。
   * r - {Number} 外圆半径，必设参数。
   * startAngle - {Number} 起始角度，必设参数。取值范围[0, 360)。
   * endAngle - {Number} 结束角度，必设参数。取值范围(0, 360]。
   * r0 - {Number} 内圆半径，指定后将出现内弧，同时扇边长度为`r - r0`。取值范围[0, r)，默认值：0。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Sector>} 扇形参数对象。
   */
  function Sector(x, y, r, startAngle, endAngle, r0, clockWise) {
    _classCallCheck(this, Sector);

    /**
     * APIProperty: x
     * {Number} 圆心 x 坐标。
     */
    var _this = _possibleConstructorReturn(this, (Sector.__proto__ || Object.getPrototypeOf(Sector)).call(this, x, y, r, startAngle, endAngle, r0, clockWise));

    _this.x = !isNaN(x) ? x : 0;

    /**
     * APIProperty: y
     * {Number} 圆心 y 坐标。
     */
    _this.y = !isNaN(y) ? y : 0;

    /**
     * APIProperty: r
     * {Number} 外圆半径。
     */
    _this.r = !isNaN(r) ? r : 0;

    /**
     * APIProperty: startAngle
     * {Number} 起始角度。取值范围[0, 360)，默认值：null。
     */
    _this.startAngle = !isNaN(startAngle) ? startAngle : 0;

    /**
     * APIProperty: endAngle
     * {Number} 结束角度。取值范围(0, 360]，默认值：null。
     */
    _this.endAngle = !isNaN(endAngle) ? endAngle : 0;

    /**
     * APIProperty: r0
     * {Number} 内圆半径，指定后将出现内弧，同时扇边长度为 r 减 r0。取值范围[0, r)，默认值：0。
     */
    _this.r0 = !isNaN(r0) ? r0 : 0;

    /**
     * Property: clockWise
     * {Boolean} 是否是顺时针。默认值：false。
     */
    _this.clockWise = clockWise;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Sector";
    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Sector, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.r = null;
      this.startAngle = null;
      this.endAngle = null;
      this.r0 = null;
      this.clockWise = null;

      _get(Sector.prototype.__proto__ || Object.getPrototypeOf(Sector.prototype), 'destroy', this).call(this);
    }
  }]);

  return Sector;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Sector = Sector;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Theme = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Point = __webpack_require__(18);

var _GeoText = __webpack_require__(91);

var _LonLat = __webpack_require__(37);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.Feature.Theme
 * 专题要素基类，此类不可实例化。
 */
var Theme = exports.Theme = function () {

    /**
     * Constructor: SuperMap.Feature.Theme
     * 构造函数。
     *
     * Parameters:
     * data - {Object}  用户数据，用于生成可视化 shape，必设参数。
     * layer - {<SuperMap.Layer.Theme>} 此专题要素所在图层，必设参数。
     *
     * Returns:
     * {<SuperMap.Feature.Theme>} 返回一个专题要素。
     */
    function Theme(data, layer) {
        _classCallCheck(this, Theme);

        if (!data) {
            return;
        }
        // layer 必须已经添加到地图, 且已初始化渲染器
        if (!layer || !layer.map || !layer.renderer) {
            return;
        }

        /**
         * Property: id
         * {String} 专题要素唯一标识。
         */
        this.id = _Util.Util.createUniqueID(this.CLASS_NAME + "_");

        /**
         * APIProperty: lonlat
         * {<SuperMap.LonLat>} 专题要素地理参考位置。子类中必须根据用户数据（或地理位置参数）对其赋值。
         */
        this.lonlat = null;

        /**
         * APIProperty: location
         * {Array} 专题要素像素参考位置。通常由地理参考位置决定。长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        this.location = [];

        /**
         * APIProperty: data
         * {Object} {ReadOnly} 用户数据，用于生成可视化 shape，可在子类中规定数据格式或类型，如： <SuperMap.Feature.Vector> 。
         */
        this.data = data;

        /**
         * APIProperty: shapes
         * {Array} {ReadOnly} 构成此专题要素的可视化图形对象数组，数组顺序控制渲染。
         */
        this.shapes = [];

        /**
         * APIProperty: layer
         * {<SuperMap.Layer.Theme>} {ReadOnly} 此专题要素所在专题图层。
         */
        this.layer = layer;

        this.CLASS_NAME = "SuperMap.Feature.Theme";
    }

    /**
     * APIMethod: destroy
     * 销毁专题要素。
     */


    _createClass(Theme, [{
        key: 'destroy',
        value: function destroy() {
            this.data = null;
            this.id = null;
            this.lonlat = null;
            this.location = null;
            this.shapes = null;
            this.layer = null;
        }

        /**
         * Method: getLocalXY
         * 地理坐标转为像素坐标。
         *
         * Parameters:
         * coordinate - {<SuperMap.Geometry.Point>/<SuperMap.Geometry.GeoText>/<SuperMap.LonLat>} 地理坐标点。
         *
         * Returns:
         * {Array} 长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */

    }, {
        key: 'getLocalXY',
        value: function getLocalXY(coordinate) {
            var resolution = this.layer.map.getResolution();
            var extent = this.layer.map.getExtent();

            if (coordinate instanceof _Point.Point || coordinate instanceof _GeoText.GeoText) {
                var x = coordinate.x / resolution + -extent.left / resolution;
                var y = extent.top / resolution - coordinate.y / resolution;
                return [x, y];
            } else if (coordinate instanceof _LonLat.LonLat) {
                var _x = coordinate.lon / resolution + -extent.left / resolution;
                var _y = extent.top / resolution - coordinate.lat / resolution;
                return [_x, _y];
            } else {
                return null;
            }
        }
    }]);

    return Theme;
}();

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.Theme = Theme;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Config = exports.Config = function Config() {
    _classCallCheck(this, Config);
};
/**
 * APIProperty: EVENT
 * {Object} 事件
 */


Config.EVENT = {
    //窗口大小变化
    RESIZE: 'resize',

    //鼠标按钮被（手指）按下，事件对象是：目标图形元素或空
    CLICK: 'click',

    //双击事件
    DBLCLICK: 'dblclick',

    //鼠标滚轮变化，事件对象是：目标图形元素或空
    MOUSEWHEEL: 'mousewheel',

    //鼠标（手指）被移动，事件对象是：目标图形元素或空
    MOUSEMOVE: 'mousemove',

    //鼠标移到某图形元素之上，事件对象是：目标图形元素
    MOUSEOVER: 'mouseover',

    //鼠标从某图形元素移开，事件对象是：目标图形元素
    MOUSEOUT: 'mouseout',

    //鼠标按钮（手指）被按下，事件对象是：目标图形元素或空
    MOUSEDOWN: 'mousedown',

    //鼠标按键（手指）被松开，事件对象是：目标图形元素或空
    MOUSEUP: 'mouseup',

    //全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定
    GLOBALOUT: 'globalout',

    // 一次成功元素拖拽的行为事件过程是：
    // dragstart > dragenter > dragover [> dragleave] > drop > dragend

    //开始拖拽时触发，事件对象是：被拖拽图形元素
    DRAGSTART: 'dragstart',

    //拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素
    DRAGEND: 'dragend',

    //拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素
    DRAGENTER: 'dragenter',

    //拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素
    DRAGOVER: 'dragover',

    //拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素
    DRAGLEAVE: 'dragleave',

    //拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素
    DROP: 'drop',

    //touch end - start < delay is click
    touchClickDelay: 300
};

/**
 * APIProperty: catchBrushException
 * {Boolean} 是否异常捕获
 */
Config.catchBrushException = false;

/**
 * APIProperty: debugMode
 * {Boolean} debug 日志选项：catchBrushException 为 true 下有效
 *
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 */
Config.debugMode = 0;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Curve = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = __webpack_require__(82);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Curve
 * LevelRenderer 工具-曲线
 *
 */
var Curve = exports.Curve = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Curve
     * 构造函数。
     *
     */
    function Curve() {
        _classCallCheck(this, Curve);

        /**
         * Property: vector
         * {<SuperMap.LevelRenderer.Tool.Vector>} 矢量工具
         */
        this.vector = new _Vector.Vector();

        /**
         * Property: EPSILON
         * {Number} e
         */
        this.EPSILON = 1e-4;

        /**
         * Property: THREE_SQRT
         * {Number} 3 的平方根
         */
        this.THREE_SQRT = Math.sqrt(3);

        /**
         * Property: ONE_THIRD
         * {Number} 1/3
         */
        this.ONE_THIRD = 1 / 3;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Curve";
    }

    /**
     * Method: evalCubicCoeff
     *
     * Parameters:
     * a - {Number} 值。
     * b - {Number} 值。
     * c - {Number} 值。
     * d - {Number} 值。
     * t - {Number} 值。
     *
     * Returns:
     * {Number}
     */

    /*
     evalCubicCoeff: function(a, b, c, d, t){
     return ((a * t + b) * t + c) * t + d;
     },
     */

    /**
     * Method: isAroundZero
     * 判断一个值是否趋于0，判断参考值：1e-4。
     *
     * Parameters:
     * val - {Number} 值。
     *
     * Returns:
     * {Boolean} 值是否趋于0。
     */


    _createClass(Curve, [{
        key: "isAroundZero",
        value: function isAroundZero(val) {
            return val > -this.EPSILON && val < this.EPSILON;
        }

        /**
         * Method: isNotAroundZero
         * 判断一个值是否不趋于0，判断参考值：1e-4。
         *
         * Parameters:
         * val - {Number} 值。
         *
         * Returns:
         * {Boolean} 值是否不趋于0。
         */

    }, {
        key: "isNotAroundZero",
        value: function isNotAroundZero(val) {
            return val > this.EPSILON || val < -this.EPSILON;
        }

        /**
         * APIMethod: cubicAt
         * 计算三次贝塞尔值
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * p3 - {Number}
         * t - {Number}
         *
         * Returns:
         * {number} 三次贝塞尔值
         */

    }, {
        key: "cubicAt",
        value: function cubicAt(p0, p1, p2, p3, t) {
            var onet = 1 - t;
            return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
        }

        /**
         * APIMethod: cubicDerivativeAt
         * 计算三次贝塞尔导数值
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * p3 - {Number}
         * t - {Number}
         *
         * Returns:
         * {number} 三次贝塞尔导数值
         */

    }, {
        key: "cubicDerivativeAt",
        value: function cubicDerivativeAt(p0, p1, p2, p3, t) {
            var onet = 1 - t;
            return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
        }

        /**
         * APIMethod: cubicRootAt
         * 计算三次贝塞尔方程根，使用盛金公式
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * p3 - {Number}
         * val - {Number}
         * roots -{Array<number>} 有效根数目
         *
         * Returns:
         * {number} 有效根
         */

    }, {
        key: "cubicRootAt",
        value: function cubicRootAt(p0, p1, p2, p3, val, roots) {
            // Evaluate roots of cubic functions
            var a = p3 + 3 * (p1 - p2) - p0;
            var b = 3 * (p2 - p1 * 2 + p0);
            var c = 3 * (p1 - p0);
            var d = p0 - val;

            var A = b * b - 3 * a * c;
            var B = b * c - 9 * a * d;
            var C = c * c - 3 * b * d;

            var n = 0;

            if (this.isAroundZero(A) && this.isAroundZero(B)) {
                if (this.isAroundZero(b)) {
                    roots[0] = 0;
                } else {
                    var t1 = -c / b; //t1, t2, t3, b is not zero
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                }
            } else {
                var disc = B * B - 4 * A * C;

                if (this.isAroundZero(disc)) {
                    var K = B / A;
                    var _t2 = -b / a + K; // t1, a is not zero
                    var t2 = -K / 2; // t2, t3
                    if (_t2 >= 0 && _t2 <= 1) {
                        roots[n++] = _t2;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        roots[n++] = t2;
                    }
                } else if (disc > 0) {
                    var discSqrt = Math.sqrt(disc);
                    var Y1 = A * b + 1.5 * a * (-B + discSqrt);
                    var Y2 = A * b + 1.5 * a * (-B - discSqrt);
                    if (Y1 < 0) {
                        Y1 = -Math.pow(-Y1, this.ONE_THIRD);
                    } else {
                        Y1 = Math.pow(Y1, this.ONE_THIRD);
                    }
                    if (Y2 < 0) {
                        Y2 = -Math.pow(-Y2, this.ONE_THIRD);
                    } else {
                        Y2 = Math.pow(Y2, this.ONE_THIRD);
                    }
                    var _t3 = (-b - (Y1 + Y2)) / (3 * a);
                    if (_t3 >= 0 && _t3 <= 1) {
                        roots[n++] = _t3;
                    }
                } else {
                    var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
                    var theta = Math.acos(T) / 3;
                    var ASqrt = Math.sqrt(A);
                    var tmp = Math.cos(theta);

                    var _t4 = (-b - 2 * ASqrt * tmp) / (3 * a);
                    var _t5 = (-b + ASqrt * (tmp + this.THREE_SQRT * Math.sin(theta))) / (3 * a);
                    var t3 = (-b + ASqrt * (tmp - this.THREE_SQRT * Math.sin(theta))) / (3 * a);
                    if (_t4 >= 0 && _t4 <= 1) {
                        roots[n++] = _t4;
                    }
                    if (_t5 >= 0 && _t5 <= 1) {
                        roots[n++] = _t5;
                    }
                    if (t3 >= 0 && t3 <= 1) {
                        roots[n++] = t3;
                    }
                }
            }
            return n;
        }

        /**
         * APIMethod: cubicExtrema
         * 计算三次贝塞尔方程极限值的位置
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * p3 - {Number}
         * extrema - {Array<number>}
         *
         * Returns:
         * {number} 有效数目
         */

    }, {
        key: "cubicExtrema",
        value: function cubicExtrema(p0, p1, p2, p3, extrema) {
            var b = 6 * p2 - 12 * p1 + 6 * p0;
            var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
            var c = 3 * p1 - 3 * p0;

            var n = 0;
            if (this.isAroundZero(a)) {
                if (this.isNotAroundZero(b)) {
                    var t1 = -c / b;
                    if (t1 >= 0 && t1 <= 1) {
                        extrema[n++] = t1;
                    }
                }
            } else {
                var disc = b * b - 4 * a * c;
                if (this.isAroundZero(disc)) {
                    extrema[0] = -b / (2 * a);
                } else if (disc > 0) {
                    var discSqrt = Math.sqrt(disc);
                    var _t6 = (-b + discSqrt) / (2 * a);
                    var t2 = (-b - discSqrt) / (2 * a);
                    if (_t6 >= 0 && _t6 <= 1) {
                        extrema[n++] = _t6;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        extrema[n++] = t2;
                    }
                }
            }
            return n;
        }

        /**
         * APIMethod cubicSubdivide
         * 细分三次贝塞尔曲线
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * p3 - {Number}
         * t - {Number}
         * out - {Array{Number}}
         *
         * Returns:
         * {number} out
         */

    }, {
        key: "cubicSubdivide",
        value: function cubicSubdivide(p0, p1, p2, p3, t, out) {
            var p01 = (p1 - p0) * t + p0;
            var p12 = (p2 - p1) * t + p1;
            var p23 = (p3 - p2) * t + p2;

            var p012 = (p12 - p01) * t + p01;
            var p123 = (p23 - p12) * t + p12;

            var p0123 = (p123 - p012) * t + p012;
            // Seg0
            out[0] = p0;
            out[1] = p01;
            out[2] = p012;
            out[3] = p0123;
            // Seg1
            out[4] = p0123;
            out[5] = p123;
            out[6] = p23;
            out[7] = p3;
        }

        /**
         * APIMethod: cubicProjectPoint
         * 投射点到三次贝塞尔曲线上，返回投射距离。投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
         *
         * Parameters:
         * x0 - {Number}
         * y0 - {Number}
         * x1 - {Number}
         * y1 - {Number}
         * x2 - {Number}
         * y2 - {Number}
         * x3 - {Number}
         * y3 - {Number}
         * x - {Number}
         * y - {Number}
         * out - {Array{Number}}  投射点
         *
         * Returns:
         * {number} out
         */

    }, {
        key: "cubicProjectPoint",
        value: function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
            // 临时变量
            var _v0 = this.vector.create();
            var _v1 = this.vector.create();
            var _v2 = this.vector.create();
            // var _v3 = vector.create();

            // http://pomax.github.io/bezierinfo/#projections
            var t;
            var interval = 0.005;
            var d = Infinity;

            _v0[0] = x;
            _v0[1] = y;

            // 先粗略估计一下可能的最小距离的 t 值
            // PENDING
            for (var _t = 0; _t < 1; _t += 0.05) {
                _v1[0] = this.cubicAt(x0, x1, x2, x3, _t);
                _v1[1] = this.cubicAt(y0, y1, y2, y3, _t);
                var d1 = this.vector.distSquare(_v0, _v1);
                if (d1 < d) {
                    t = _t;
                    d = d1;
                }
            }
            d = Infinity;

            // At most 32 iteration
            for (var i = 0; i < 32; i++) {
                if (interval < this.EPSILON) {
                    break;
                }
                var prev = t - interval;
                var next = t + interval;
                // t - interval
                _v1[0] = this.cubicAt(x0, x1, x2, x3, prev);
                _v1[1] = this.cubicAt(y0, y1, y2, y3, prev);

                var _d = this.vector.distSquare(_v1, _v0);

                if (prev >= 0 && _d < d) {
                    t = prev;
                    d = _d;
                } else {
                    // t + interval
                    _v2[0] = this.cubicAt(x0, x1, x2, x3, next);
                    _v2[1] = this.cubicAt(y0, y1, y2, y3, next);
                    var d2 = this.vector.distSquare(_v2, _v0);

                    if (next <= 1 && d2 < d) {
                        t = next;
                        d = d2;
                    } else {
                        interval *= 0.5;
                    }
                }
            }
            // t
            if (out) {
                out[0] = this.cubicAt(x0, x1, x2, x3, t);
                out[1] = this.cubicAt(y0, y1, y2, y3, t);
            }
            // console.log(interval, i);
            return Math.sqrt(d);
        }

        /**
         * APIMethod: quadraticAt
         * 计算二次方贝塞尔值
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * t - {Number}
         *
         * Returns:
         * {number} 二次方贝塞尔值
         */

    }, {
        key: "quadraticAt",
        value: function quadraticAt(p0, p1, p2, t) {
            var onet = 1 - t;
            return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
        }

        /**
         * APIMethod: quadraticDerivativeAt
         * 计算二次方贝塞尔导数值
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * t - {Number}
         *
         * Returns:
         * {number} 二次方贝塞尔导数值
         */

    }, {
        key: "quadraticDerivativeAt",
        value: function quadraticDerivativeAt(p0, p1, p2, t) {
            return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
        }

        /**
         * APIMethod: quadraticRootAt
         * 计算二次方贝塞尔方程根
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         * val - {Number}
         * roots - {Array{Number}}
         *
         * Returns:
         * {number} 有效根数目
         */

    }, {
        key: "quadraticRootAt",
        value: function quadraticRootAt(p0, p1, p2, val, roots) {
            var a = p0 - 2 * p1 + p2;
            var b = 2 * (p1 - p0);
            var c = p0 - val;

            var n = 0;
            if (this.isAroundZero(a)) {
                if (this.isNotAroundZero(b)) {
                    var t1 = -c / b;
                    if (t1 >= 0 && t1 <= 1) {
                        roots[n++] = t1;
                    }
                }
            } else {
                var disc = b * b - 4 * a * c;
                if (this.isAroundZero(disc)) {
                    var _t7 = -b / (2 * a);
                    if (_t7 >= 0 && _t7 <= 1) {
                        roots[n++] = _t7;
                    }
                } else if (disc > 0) {
                    var discSqrt = Math.sqrt(disc);
                    var _t8 = (-b + discSqrt) / (2 * a);
                    var t2 = (-b - discSqrt) / (2 * a);
                    if (_t8 >= 0 && _t8 <= 1) {
                        roots[n++] = _t8;
                    }
                    if (t2 >= 0 && t2 <= 1) {
                        roots[n++] = t2;
                    }
                }
            }
            return n;
        }

        /**
         * APIMethod: quadraticExtremum
         * 计算二次贝塞尔方程极限值
         *
         * Parameters:
         * p0 - {Number}
         * p1 - {Number}
         * p2 - {Number}
         *
         * Returns:
         * {number}  二次贝塞尔方程极限值
         */

    }, {
        key: "quadraticExtremum",
        value: function quadraticExtremum(p0, p1, p2) {
            var divider = p0 + p2 - 2 * p1;
            if (divider === 0) {
                // p1 is center of p0 and p2
                return 0.5;
            } else {
                return (p0 - p1) / divider;
            }
        }

        /**
         * APIMethod: quadraticProjectPoint
         * 投射点到二次贝塞尔曲线上，返回投射距离。投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
         *
         * Parameters:
         * x0 - {Number}
         * y0 - {Number}
         * x1 - {Number}
         * y1 - {Number}
         * x2 - {Number}
         * y2 - {Number}
         * x - {Number}
         * y - {Number}
         * out - {Array{Number}}  投射点
         *
         * Returns:
         * {number} 投射距离
         */

    }, {
        key: "quadraticProjectPoint",
        value: function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
            // 临时变量
            var _v0 = this.vector.create();
            var _v1 = this.vector.create();
            var _v2 = this.vector.create();

            // http://pomax.github.io/bezierinfo/#projections
            var t;
            var interval = 0.005;
            var d = Infinity;

            _v0[0] = x;
            _v0[1] = y;

            // 先粗略估计一下可能的最小距离的 t 值
            // PENDING
            for (var _t = 0; _t < 1; _t += 0.05) {
                _v1[0] = this.quadraticAt(x0, x1, x2, _t);
                _v1[1] = this.quadraticAt(y0, y1, y2, _t);
                var d1 = this.vector.distSquare(_v0, _v1);
                if (d1 < d) {
                    t = _t;
                    d = d1;
                }
            }
            d = Infinity;

            // At most 32 iteration
            for (var i = 0; i < 32; i++) {
                if (interval < this.EPSILON) {
                    break;
                }
                var prev = t - interval;
                var next = t + interval;
                // t - interval
                _v1[0] = this.quadraticAt(x0, x1, x2, prev);
                _v1[1] = this.quadraticAt(y0, y1, y2, prev);

                var _d2 = this.vector.distSquare(_v1, _v0);

                if (prev >= 0 && _d2 < d) {
                    t = prev;
                    d = _d2;
                } else {
                    // t + interval
                    _v2[0] = this.quadraticAt(x0, x1, x2, next);
                    _v2[1] = this.quadraticAt(y0, y1, y2, next);
                    var d2 = this.vector.distSquare(_v2, _v0);
                    if (next <= 1 && d2 < d) {
                        t = next;
                        d = d2;
                    } else {
                        interval *= 0.5;
                    }
                }
            }
            // t
            if (out) {
                out[0] = this.quadraticAt(x0, x1, x2, t);
                out[1] = this.quadraticAt(y0, y1, y2, t);
            }
            // console.log(interval, i);
            return Math.sqrt(d);
        }
    }]);

    return Curve;
}();

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicPolygon = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

var _Util = __webpack_require__(1);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicPolygon
 * 多边形。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicPolygon({
 *         style: {
 *             // 100x100 的正方形
 *             pointList: [[0, 0], [100, 0], [100, 100], [0, 100]],
 *             color: 'blue'
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 */
var SmicPolygon = exports.SmicPolygon = function (_Shape) {
    _inherits(SmicPolygon, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * pointList - {Array} 节点数组，二维数组。默认值：null，必设参数。其形式如下：
     * (code)
     * (start code)
     *  [
     *  [10, 20],         //单个节点
     *  [30, 40],
     *  [25, 30]
     *   ]
     * (end)
     * smooth - {string} 是否做平滑插值, 平滑算法可以选择 "bezier", "spline"。默认值："";
     * smoothConstraint - {Number} 平滑约束。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style

    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicPolygon
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicPolygon(options) {
        _classCallCheck(this, SmicPolygon);

        /**
         * Property: type
         * {String} 图形类型.
         */
        var _this = _possibleConstructorReturn(this, (SmicPolygon.__proto__ || Object.getPrototypeOf(SmicPolygon)).call(this, options));

        _this.type = 'smicpolygon';

        /**
         * APIProperty: _holePolygonPointList
         * {Array} 岛洞面多边形顶点数组（三维数组）
         *
         */
        _this.holePolygonPointLists = null;

        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicPolygon";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicPolygon, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            this.holePolygonPointLists = null;
            _get(SmicPolygon.prototype.__proto__ || Object.getPrototypeOf(SmicPolygon.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: brush
         * 笔触。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * isHighlight - {Boolean} 是否使用高亮属性。
         *
         */

    }, {
        key: 'brush',
        value: function brush(ctx, isHighlight) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }

            var style = this.style;
            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }

            ctx.save();
            this.setContext(ctx, style);

            // 设置 transform
            this.setTransform(ctx);

            // 先 fill 再stroke
            var hasPath = false;
            if (style.brushType == 'fill' || style.brushType == 'both' || typeof style.brushType == 'undefined') {
                // 默认为fill
                ctx.beginPath();
                if (style.lineType == 'dashed' || style.lineType == 'dotted' || style.lineType == 'dot' || style.lineType == 'dash' || style.lineType == 'dashot' || style.lineType == 'longdash' || style.lineType == 'longdashdot') {
                    // 特殊处理，虚线围不成path，实线再build一次
                    this.buildPath(ctx, {
                        lineType: 'solid',
                        lineWidth: style.lineWidth,
                        pointList: style.pointList
                    });
                } else {
                    this.buildPath(ctx, style);
                    hasPath = true; // 这个path能用
                }
                ctx.closePath();
                this.setCtxGlobalAlpha(ctx, "fill", style);
                ctx.fill();
                this.setCtxGlobalAlpha(ctx, "reset", style);
            }

            if (style.lineWidth > 0 && (style.brushType == 'stroke' || style.brushType == 'both')) {
                if (!hasPath) {
                    ctx.beginPath();
                    this.buildPath(ctx, style);
                }
                this.setCtxGlobalAlpha(ctx, "stroke", style);
                ctx.stroke();
                this.setCtxGlobalAlpha(ctx, "reset", style);
            }

            this.drawText(ctx, style, this.style);

            //岛洞
            var hpStyle = _Util.Util.cloneObject(style);

            if (hpStyle.pointList) {
                if (this.holePolygonPointLists && this.holePolygonPointLists.length > 0) {
                    var holePLS = this.holePolygonPointLists;
                    var holePLSen = holePLS.length;
                    for (var i = 0; i < holePLSen; i++) {
                        var holePL = holePLS[i];
                        //岛洞面
                        hpStyle.pointList = holePL;

                        ctx.globalCompositeOperation = "destination-out";
                        // 先 fill 再stroke
                        hasPath = false;
                        if (hpStyle.brushType == 'fill' || hpStyle.brushType == 'both' || typeof hpStyle.brushType == 'undefined') {
                            // 默认为fill
                            ctx.beginPath();
                            if (hpStyle.lineType == 'dashed' || hpStyle.lineType == 'dotted' || hpStyle.lineType == 'dot' || hpStyle.lineType == 'dash' || hpStyle.lineType == 'dashot' || hpStyle.lineType == 'longdash' || hpStyle.lineType == 'longdashdot') {
                                // 特殊处理，虚线围不成path，实线再build一次
                                this.buildPath(ctx, {
                                    lineType: 'solid',
                                    lineWidth: hpStyle.lineWidth,
                                    pointList: hpStyle.pointList
                                });
                            } else {
                                this.buildPath(ctx, hpStyle);
                                hasPath = true; // 这个path能用
                            }
                            ctx.closePath();
                            this.setCtxGlobalAlpha(ctx, "fill", hpStyle);
                            ctx.fill();
                            this.setCtxGlobalAlpha(ctx, "reset", hpStyle);
                        }

                        if (hpStyle.lineWidth > 0 && (hpStyle.brushType == 'stroke' || hpStyle.brushType == 'both')) {
                            if (!hasPath) {
                                ctx.beginPath();
                                this.buildPath(ctx, hpStyle);
                            }
                            //如果描边，先回复 globalCompositeOperation 默认值再描边。
                            ctx.globalCompositeOperation = "source-over";
                            this.setCtxGlobalAlpha(ctx, "stroke", hpStyle);
                            ctx.stroke();
                            this.setCtxGlobalAlpha(ctx, "reset", hpStyle);
                        } else {
                            ctx.globalCompositeOperation = "source-over";
                        }
                    }
                }
            }
            ctx.restore();
            return;
        }

        /**
         * APIMethod: buildPath
         * 创建多边形路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (style.showShadow) {
                ctx.shadowBlur = style.shadowBlur;
                ctx.shadowColor = style.shadowColor;
                ctx.shadowOffsetX = style.shadowOffsetX;
                ctx.shadowOffsetY = style.shadowOffsetY;
            }
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            // 虽然能重用 brokenLine，但底层图形基于性能考虑，重复代码减少调用吧
            var pointList = style.pointList;

            if (pointList.length < 2) {
                // 少于2个点就不画了~
                return;
            }

            if (style.smooth && style.smooth !== 'spline') {
                var controlPoints = _SUtil.SUtil.SUtil_smoothBezier(pointList, style.smooth, true, style.smoothConstraint, __OP);

                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                var cp1;
                var cp2;
                var p;
                var len = pointList.length;
                for (var i = 0; i < len; i++) {
                    cp1 = controlPoints[i * 2];
                    cp2 = controlPoints[i * 2 + 1];
                    p = [pointList[(i + 1) % len][0] + __OP[0], pointList[(i + 1) % len][1] + __OP[1]];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
            } else {
                if (style.smooth === 'spline') {
                    pointList = _SUtil.SUtil.SUtil_smoothSpline(pointList, true, null, __OP);
                }

                if (!style.lineType || style.lineType == 'solid') {
                    // 默认为实线
                    ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                    for (var _i = 1; _i < pointList.length; _i++) {
                        ctx.lineTo(pointList[_i][0] + __OP[0], pointList[_i][1] + __OP[1]);
                    }
                    ctx.lineTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                } else if (style.lineType === 'dashed' || style.lineType === 'dotted' || style.lineType === 'dot' || style.lineType === 'dash' || style.lineType === 'longdash') {
                    // SMIC-方法修改 - start
                    var dashLengthForStyle = style._dashLength || (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    style._dashLength = dashLengthForStyle;

                    var dashLength = style.lineWidth || 1;
                    var pattern1 = dashLength;
                    var pattern2 = dashLength;

                    //dashed
                    if (style.lineType === 'dashed') {
                        pattern1 *= 5;
                        pattern2 *= 5;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 -= dashLength;
                            pattern2 += dashLength;
                        }
                    }

                    //dotted
                    if (style.lineType === 'dotted') {
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 = 1;
                            pattern2 += dashLength;
                        }
                    }

                    //dot
                    if (style.lineType === 'dot') {
                        pattern2 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 = 1;
                            pattern2 += dashLength;
                        }
                    }

                    //dash
                    if (style.lineType === 'dash') {
                        pattern1 *= 4;
                        pattern2 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 -= dashLength;
                            pattern2 += dashLength;
                        }
                    }

                    //longdash
                    if (style.lineType === 'longdash') {
                        pattern1 *= 8;
                        pattern2 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 -= dashLength;
                            pattern2 += dashLength;
                        }
                    }

                    ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                    for (var _i2 = 1; _i2 < pointList.length; _i2++) {
                        _SUtil.SUtil.SUtil_dashedLineTo(ctx, pointList[_i2 - 1][0] + __OP[0], pointList[_i2 - 1][1] + __OP[1], pointList[_i2][0] + __OP[0], pointList[_i2][1] + __OP[1], dashLength, [pattern1, pattern2]);
                    }
                    _SUtil.SUtil.SUtil_dashedLineTo(ctx, pointList[pointList.length - 1][0] + __OP[0], pointList[pointList.length - 1][1] + __OP[1], pointList[0][0] + __OP[0], pointList[0][1] + __OP[1], dashLength, [pattern1, pattern2]);
                } else if (style.lineType === 'dashot' || style.lineType === 'longdashdot') {
                    var _dashLengthForStyle = style._dashLength || (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    style._dashLength = _dashLengthForStyle;

                    var _dashLength = style.lineWidth || 1;
                    var _pattern = _dashLength;
                    var _pattern2 = _dashLength;
                    var pattern3 = _dashLength;
                    var pattern4 = _dashLength;

                    //dashot
                    if (style.lineType === 'dashot') {
                        _pattern *= 4;
                        _pattern2 *= 4;
                        pattern4 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            _pattern -= _dashLength;
                            _pattern2 += _dashLength;
                            pattern3 = 1;
                            pattern4 += _dashLength;
                        }
                    }

                    //longdashdot
                    if (style.lineType === 'longdashdot') {
                        _pattern *= 8;
                        _pattern2 *= 4;
                        pattern4 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            _pattern -= _dashLength;
                            _pattern2 += _dashLength;
                            pattern3 = 1;
                            pattern4 += _dashLength;
                        }
                    }

                    ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                    for (var _i3 = 1; _i3 < pointList.length; _i3++) {
                        _SUtil.SUtil.SUtil_dashedLineTo(ctx, pointList[_i3 - 1][0] + __OP[0], pointList[_i3 - 1][1] + __OP[1], pointList[_i3][0] + __OP[0], pointList[_i3][1] + __OP[1], _dashLength, [_pattern, _pattern2, pattern3, pattern4]);
                    }
                    _SUtil.SUtil.SUtil_dashedLineTo(ctx, pointList[pointList.length - 1][0] + __OP[0], pointList[pointList.length - 1][1] + __OP[1], pointList[0][0] + __OP[0], pointList[0][1] + __OP[1], _dashLength, [_pattern, _pattern2, pattern3, pattern4]);
                }
            }
            return;
        }

        /**
         * APIMethod: getRect
         * 计算返回多边形包围盒矩阵。
         * 该包围盒是直接从四个控制点计算，并非最小包围盒。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style, refOriginalPosition) {
            var __OP;
            if (!refOriginalPosition) {
                if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                    this.refOriginalPosition = [0, 0];
                }
                __OP = this.refOriginalPosition;
            } else {
                __OP = refOriginalPosition;
            }

            if (style.__rect) {
                return style.__rect;
            }

            var minX = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var minY = Number.MAX_VALUE;
            var maxY = Number.MIN_VALUE;

            var pointList = style.pointList;
            for (var i = 0, l = pointList.length; i < l; i++) {
                if (pointList[i][0] + __OP[0] < minX) {
                    minX = pointList[i][0] + __OP[0];
                }
                if (pointList[i][0] + __OP[0] > maxX) {
                    maxX = pointList[i][0] + __OP[0];
                }
                if (pointList[i][1] + __OP[1] < minY) {
                    minY = pointList[i][1] + __OP[1];
                }
                if (pointList[i][1] + __OP[1] > maxY) {
                    maxY = pointList[i][1] + __OP[1];
                }
            }

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }

            style.__rect = {
                x: Math.round(minX - lineWidth / 2),
                y: Math.round(minY - lineWidth / 2),
                width: maxX - minX + lineWidth,
                height: maxY - minY + lineWidth
            };
            return style.__rect;
        }
    }]);

    return SmicPolygon;
}(_Shape2.Shape);

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transformable = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Transformable
 * 可变换超类，所有支持 Canvas Transform 变换操作的类均是此类的子类。
 *
 * 此类不可实例化。
 *
 */
var Transformable = exports.Transformable = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Transformable
     * 构造函数。
     */
    function Transformable() {
        _classCallCheck(this, Transformable);

        /**
         * APIProperty: position
         * {Array{Number}} 平移， 默认值：[0, 0]。
         */
        this.position = [0, 0];

        /**
         * APIProperty: rotation
         * {Array{Number}} 旋转，可以通过数组二三项指定旋转的原点， 默认值：[0, 0, 0]。
         */
        this.rotation = [0, 0, 0];

        /**
         * APIProperty: scale
         * {Array{Number}} 缩放，可以通过数组三四项指定缩放的原点， 默认值：[1, 1, 0, 0]。
         */
        this.scale = [1, 1, 0, 0];

        /**
         * Property: needLocalTransform
         * {Boolean} 是否变换。默认值：false。
         */
        this.needLocalTransform = false;

        /**
         * APIProperty: needTransform
         * {Boolean} 是否有坐标变换。默认值：false。
         */
        this.needTransform = false;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Transformable";
        /**
         * APIMethod: lookAt
         * 设置图形的朝向。
         *
         */
        this.lookAt = function () {
            var v = _SUtil.SUtil.Util_vector.create();
            // {Array{Number}|Float32Array} target
            return function (target) {
                if (!this.transform) {
                    this.transform = _SUtil.SUtil.Util_matrix.create();
                }
                var m = this.transform;
                _SUtil.SUtil.Util_vector.sub(v, target, this.position);
                if (isAroundZero(v[0]) && isAroundZero(v[1])) {
                    return;
                }
                _SUtil.SUtil.Util_vector.normalize(v, v);
                // Y Axis
                // TODO Scale origin ?
                m[2] = v[0] * this.scale[1];
                m[3] = v[1] * this.scale[1];
                // X Axis
                m[0] = v[1] * this.scale[0];
                m[1] = -v[0] * this.scale[0];
                // Position
                m[4] = this.position[0];
                m[5] = this.position[1];

                this.decomposeTransform();

                function isAroundZero(val) {
                    var EPSILON = 5e-5;
                    return val > -EPSILON && val < EPSILON;
                }
            };
        }();
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Transformable, [{
        key: "destroy",
        value: function destroy() {
            this.position = null;
            this.rotation = null;
            this.scale = null;
            this.needLocalTransform = null;
            this.needTransform = null;
        }

        /**
         * Method: updateNeedTransform
         * 更新  needLocalTransform
         *
         */

    }, {
        key: "updateNeedTransform",
        value: function updateNeedTransform() {
            this.needLocalTransform = isNotAroundZero(this.rotation[0]) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);

            function isNotAroundZero(val) {
                var EPSILON = 5e-5;
                return val > EPSILON || val < -EPSILON;
            }
        }

        /**
         * APIMethod: updateTransform
         * 判断是否需要有坐标变换，更新 needTransform 属性。
         * 如果有坐标变换 则从 position rotation scale 以及父节点的 transform 计算出自身的 transform 矩阵
         *
         */

    }, {
        key: "updateTransform",
        value: function updateTransform() {
            this.updateNeedTransform();

            if (this.parent) {
                this.needTransform = this.needLocalTransform || this.parent.needTransform;
            } else {
                this.needTransform = this.needLocalTransform;
            }

            if (!this.needTransform) {
                return;
            }

            var origin = [0, 0];

            var m = this.transform || _SUtil.SUtil.Util_matrix.create();
            _SUtil.SUtil.Util_matrix.identity(m);

            if (this.needLocalTransform) {
                if (isNotAroundZero(this.scale[0]) || isNotAroundZero(this.scale[1])) {
                    origin[0] = -this.scale[2] || 0;
                    origin[1] = -this.scale[3] || 0;
                    var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                    if (haveOrigin) {
                        _SUtil.SUtil.Util_matrix.translate(m, m, origin);
                    }
                    _SUtil.SUtil.Util_matrix.scale(m, m, this.scale);
                    if (haveOrigin) {
                        origin[0] = -origin[0];
                        origin[1] = -origin[1];
                        _SUtil.SUtil.Util_matrix.translate(m, m, origin);
                    }
                }

                if (this.rotation instanceof Array) {
                    if (this.rotation[0] !== 0) {
                        origin[0] = -this.rotation[1] || 0;
                        origin[1] = -this.rotation[2] || 0;
                        var _haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                        if (_haveOrigin) {
                            _SUtil.SUtil.Util_matrix.translate(m, m, origin);
                        }
                        _SUtil.SUtil.Util_matrix.rotate(m, m, this.rotation[0]);
                        if (_haveOrigin) {
                            origin[0] = -origin[0];
                            origin[1] = -origin[1];
                            _SUtil.SUtil.Util_matrix.translate(m, m, origin);
                        }
                    }
                } else {
                    if (this.rotation !== 0) {
                        _SUtil.SUtil.Util_matrix.rotate(m, m, this.rotation);
                    }
                }

                if (isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])) {
                    _SUtil.SUtil.Util_matrix.translate(m, m, this.position);
                }
            }

            // 保存这个变换矩阵
            this.transform = m;

            // 应用父节点变换
            if (this.parent && this.parent.needTransform) {
                if (this.needLocalTransform) {
                    _SUtil.SUtil.Util_matrix.mul(this.transform, this.parent.transform, this.transform);
                } else {
                    _SUtil.SUtil.Util_matrix.copy(this.transform, this.parent.transform);
                }
            }

            function isNotAroundZero(val) {
                var EPSILON = 5e-5;
                return val > EPSILON || val < -EPSILON;
            }
        }

        /**
         * APIMethod: setTransform
         * 将自己的 transform 应用到 context 上。
         *
         * Parameters:
         * ctx - {Context2D} Context2D 上下文。
         */

    }, {
        key: "setTransform",
        value: function setTransform(ctx) {
            if (this.needTransform) {
                var m = this.transform;
                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            }
        }

        /**
         * APIMethod: decomposeTransform
         * 分解`transform`矩阵到`position` `rotation` `scale` 。
         *
         */

    }, {
        key: "decomposeTransform",
        value: function decomposeTransform() {
            if (!this.transform) {
                return;
            }
            var m = this.transform;
            var sx = m[0] * m[0] + m[1] * m[1];
            var position = this.position;
            var scale = this.scale;
            var rotation = this.rotation;
            if (isNotAroundZero(sx - 1)) {
                sx = Math.sqrt(sx);
            }
            var sy = m[2] * m[2] + m[3] * m[3];
            if (isNotAroundZero(sy - 1)) {
                sy = Math.sqrt(sy);
            }
            position[0] = m[4];
            position[1] = m[5];
            scale[0] = sx;
            scale[1] = sy;
            scale[2] = scale[3] = 0;
            rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);
            rotation[1] = rotation[2] = 0;

            function isNotAroundZero(val) {
                var EPSILON = 5e-5;
                return val > EPSILON || val < -EPSILON;
            }
        }
    }]);

    return Transformable;
}();

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Vector
 * LevelRenderer 二维向量类
 *
 */
var Vector = exports.Vector = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Vector
     * 构造函数。
     *
     */
    function Vector() {
        _classCallCheck(this, Vector);

        this.ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Vector";
    }

    /**
     * APIMethod: create
     * 创建一个向量。
     *
     * Parameters:
     * x - {Number} x 坐标。
     * y - {Number} y 坐标。
     *
     * Returns:
     * {Vector2} 向量。
     */


    _createClass(Vector, [{
        key: "create",
        value: function create(x, y) {
            var ArrayCtor = this.ArrayCtor;

            var out = new ArrayCtor(2);
            out[0] = x || 0;
            out[1] = y || 0;

            return out;
        }

        /**
         * APIMethod: copy
         * 复制一个向量。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v - {Vector2} 向量。
         *
         * Returns:
         * {Vector2} 克隆向量。
         */

    }, {
        key: "copy",
        value: function copy(out, v) {
            out[0] = v[0];
            out[1] = v[1];
            return out;
        }

        /**
         * APIMethod: set
         * 设置向量的两个项。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * a - {Number} 项 a。
         * b - {Number} 项 b。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "set",
        value: function set(out, a, b) {
            out[0] = a;
            out[1] = b;
            return out;
        }

        /**
         * APIMethod: add
         * 向量相加。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "add",
        value: function add(out, v1, v2) {
            out[0] = v1[0] + v2[0];
            out[1] = v1[1] + v2[1];
            return out;
        }

        /**
         * APIMethod: scaleAndAdd
         * 向量缩放后相加。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2（缩放向量）。
         * a - {Number} 缩放参数。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "scaleAndAdd",
        value: function scaleAndAdd(out, v1, v2, a) {
            out[0] = v1[0] + v2[0] * a;
            out[1] = v1[1] + v2[1] * a;
            return out;
        }

        /**
         * APIMethod: sub
         * 向量相减。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "sub",
        value: function sub(out, v1, v2) {
            out[0] = v1[0] - v2[0];
            out[1] = v1[1] - v2[1];
            return out;
        }

        /**
         * APIMethod: len
         * 向量长度。
         *
         * Parameters:
         * v - {Vector2} 向量。
         *
         * Returns:
         * {Number} 向量长度。
         */

    }, {
        key: "len",
        value: function len(v) {
            return Math.sqrt(this.lenSquare(v));
        }

        /**
         * APIMethod: lenSquare
         * 向量长度平方。
         *
         * Parameters:
         * v - {Vector2} 向量。
         *
         * Returns:
         * {Number} 向量长度平方。
         */

    }, {
        key: "lenSquare",
        value: function lenSquare(v) {
            return v[0] * v[0] + v[1] * v[1];
        }

        /**
         * APIMethod: mul
         * 向量乘法。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "mul",
        value: function mul(out, v1, v2) {
            out[0] = v1[0] * v2[0];
            out[1] = v1[1] * v2[1];
            return out;
        }

        /**
         * APIMethod: div
         * 向量除法。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "div",
        value: function div(out, v1, v2) {
            out[0] = v1[0] / v2[0];
            out[1] = v1[1] / v2[1];
            return out;
        }

        /**
         * APIMethod: dot
         * 向量点乘。
         *
         * Parameters:
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Number} 向量点乘。
         */

    }, {
        key: "dot",
        value: function dot(v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1];
        }

        /**
         * APIMethod: scale
         * 向量缩放。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v - {Vector2} 向量 v。
         * s - {Number} 缩放参数。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "scale",
        value: function scale(out, v, s) {
            out[0] = v[0] * s;
            out[1] = v[1] * s;
            return out;
        }

        /**
         * APIMethod: normalize
         * 向量归一化。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v - {Vector2} 向量 v。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "normalize",
        value: function normalize(out, v) {
            var d = this.len(v);
            if (d === 0) {
                out[0] = 0;
                out[1] = 0;
            } else {
                out[0] = v[0] / d;
                out[1] = v[1] / d;
            }
            return out;
        }

        /**
         * APIMethod: distance
         * 计算向量间距离。
         *
         * Parameters:
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Number} 向量间距离。
         */

    }, {
        key: "distance",
        value: function distance(v1, v2) {
            return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
        }

        /**
         * APIMethod: distanceSquare
         * 向量距离平方。
         *
         * Parameters:
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Number} 向量距离平方。
         */

    }, {
        key: "distanceSquare",
        value: function distanceSquare(v1, v2) {
            return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
        }

        /**
         * APIMethod: negate
         * 求负向量。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v - {Vector2} 向量 v。
         *
         * Returns:
         * {Vector2} 负向量。
         */

    }, {
        key: "negate",
        value: function negate(out, v) {
            out[0] = -v[0];
            out[1] = -v[1];
            return out;
        }

        /**
         * APIMethod: lerp
         * 插值两个点。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         * t - {Number} 。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "lerp",
        value: function lerp(out, v1, v2, t) {
            out[0] = v1[0] + t * (v2[0] - v1[0]);
            out[1] = v1[1] + t * (v2[1] - v1[1]);
            return out;
        }

        /**
         * APIMethod: applyTransform
         * 矩阵左乘向量。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v - {Vector2} 向量 v。
         * m - {Vector2} 向量 m。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "applyTransform",
        value: function applyTransform(out, v, m) {
            var x = v[0];
            var y = v[1];
            out[0] = m[0] * x + m[2] * y + m[4];
            out[1] = m[1] * x + m[3] * y + m[5];
            return out;
        }

        /**
         * APIMethod: min
         * 求两个向量最小值。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "min",
        value: function min(out, v1, v2) {
            out[0] = Math.min(v1[0], v2[0]);
            out[1] = Math.min(v1[1], v2[1]);
            return out;
        }

        /**
         * APIMethod: max
         * 求两个向量最大值。
         *
         * Parameters:
         * out - {Vector2} 基础向量。
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Vector2} 结果。
         */

    }, {
        key: "max",
        value: function max(out, v1, v2) {
            out[0] = Math.max(v1[0], v2[0]);
            out[1] = Math.max(v1[1], v2[1]);
            return out;
        }

        /**
         * APIMethod: length
         * 向量长度。
         *
         * Parameters:
         * v - {Vector2} 向量。
         *
         * Returns:
         * {Number} 向量长度。
         */

    }, {
        key: "length",
        value: function length(v) {
            return this.len(v);
        }

        /**
         * APIMethod: lengthSquare
         * 向量长度平方。
         *
         * Parameters:
         * v - {Vector2} 向量。
         *
         * Returns:
         * {Number} 向量长度平方。
         */

    }, {
        key: "lengthSquare",
        value: function lengthSquare(v) {
            return this.lenSquare(v);
        }

        /**
         * APIMethod: dist
         * 计算向量间距离。
         *
         * Parameters:
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Number} 向量间距离。
         */

    }, {
        key: "dist",
        value: function dist(v1, v2) {
            return this.distance(v1, v2);
        }

        /**
         * APIMethod: distSquare
         * 向量距离平方。
         *
         * Parameters:
         * v1 - {Vector2} 向量 v1。
         * v2 - {Vector2} 向量 v2。
         *
         * Returns:
         * {Number} 向量距离平方。
         */

    }, {
        key: "distSquare",
        value: function distSquare(v1, v2) {
            return this.distanceSquare(v1, v2);
        }
    }]);

    return Vector;
}();

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Symbolizer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.Symbolizer
 * @description 符号类
 * @private
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param feature — {L.feature} 要素
 */
var Symbolizer = exports.Symbolizer = _leaflet2["default"].Class.extend({

    initialize: function initialize(feature) {
        this.properties = feature.properties;
        this.type = feature.type;
        this.layerName = feature.layerName;
    },

    /**
     * @function L.supermap.Symbolizer.prototype.render
     * @description 绘制线符号
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    render: function render(renderer, style) {
        this._renderer = renderer;
        this.options = style;
        renderer._initPath(this);
        renderer._updateStyle(this);
        var elem = this.getElement();
        if (elem && this.layerName) {
            _leaflet2["default"].DomUtil.addClass(elem, this.layerName);
        }
    },

    /**
     * @function L.supermap.Symbolizer.prototype.updateStyle
     * @description 更新替换符号样式
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    updateStyle: function updateStyle(renderer, style) {
        this.options = style;
        renderer._updateStyle(this);
    },

    /**
     * @function L.supermap.Symbolizer.prototype.getElement
     * @description 获取文本信息
     */
    getElement: function getElement() {
        return this._path || this._renderer._container;
    },

    _getPixelBounds: function _getPixelBounds() {
        var parts = this._parts;
        var bounds = _leaflet2["default"].bounds([]);
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            for (var j = 0; j < part.length; j++) {
                bounds.extend(part[j]);
            }
        }

        var w = this._clickTolerance(),
            p = new _leaflet2["default"].Point(w, w);

        bounds.min._subtract(p);
        bounds.max._add(p);

        return bounds;
    },
    _clickTolerance: _leaflet2["default"].Path.prototype._clickTolerance
});

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * @constant L.supermap.VectorFeatureType
 * @description 矢量图层要素类型,和SuperMap.CartoStyleMap中的类型相对应
 * @private
 */
var VectorFeatureType = exports.VectorFeatureType = {
    LABEL: "LABEL", //label实际处理成TEXT
    TEXT: "TEXT",
    POINT: "POINT",
    LINE: "LINE",
    REGION: "REGION"
};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(289),
    getRawTag = __webpack_require__(476),
    objectToString = __webpack_require__(485);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 86 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;
module.exports = function(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
};

/***/ }),
/* 87 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;

module.exports = function(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wmtsLayer = exports.WMTSLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.wmtsLayer
 * @classdesc wmts图层类
 * @extends L.TileLayer{@linkdoc-leaflet/#tilelayer}
 * @param url -{string} wmts图层地址
 * @param options -{Object} wmts图层可选参数。如：<br>
 *        layersID - {number}图层ID，如果有layersID，则是在使用专题图。<br>
 *        redirect - {boolean} 是否从定向，如果为 true，则将请求重定向到图片的真实地址；如果为 false，则响应体中是图片的字节流。<br>
 *        transparent - {number}设置透明度。<br>
 *        cacheEnabled - {string} 启用缓存。<br>
 *        clipRegionEnabled - {boolean} 是否启用地图裁剪。<br>
 *        prjCoordSys - {Object} 请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}。<br>
 *        overlapDisplayed - {boolean} 地图对象在同一范围内时，是否重叠显示。<br>
 *        overlapDisplayedOptions - {string} 避免地图对象压盖显示的过滤选项。<br>
 *        tileversion - {string} 切片版本名称，cacheEnabled 为 true 时有效。<br>
 *        crs - {{@link L.Proj.CRS}} 坐标系统类。<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        attribution - {string} 版权信息。
 */
var WMTSLayer = exports.WMTSLayer = _leaflet2["default"].TileLayer.extend({

    options: {
        version: '1.0.0',
        style: '',
        tilematrixSet: '',
        format: 'image/png',
        tileSize: 256,
        matrixIds: null,
        layer: '',
        attribution: "with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    //todo 自动获取Capabilities
    initialize: function initialize(url, options) {
        // (String, Object)
        this._url = url;
        _leaflet2["default"].setOptions(this, options);
    },

    /**
     * @function L.supermap.wmtsLayer.prototype.getTileUrl
     * @description 根据行列号获取切片地址
     * @param coords - {Object} 行列号
     * @return {string} 切片地址
     */
    getTileUrl: function getTileUrl(coords) {
        // (Point, Number) -> String
        var zoom = this._getZoomForUrl();
        var ident = this.options.matrixIds ? this.options.matrixIds[zoom].identifier : zoom;
        var url = _leaflet2["default"].Util.template(this._url, { s: this._getSubdomain(coords) });
        var obj = {
            service: 'WMTS',
            request: 'GetTile',
            version: this.options.version,
            style: this.options.style,
            tilematrixSet: this.options.tilematrixSet,
            format: this.options.format,
            width: this.options.tileSize,
            height: this.options.tileSize,
            layer: this.options.layer,
            tilematrix: ident,
            tilerow: coords.y,
            tilecol: coords.x
        };
        return url + _leaflet2["default"].Util.getParamString(obj, url);
    }
});

var wmtsLayer = exports.wmtsLayer = function wmtsLayer(url, options) {
    return new WMTSLayer(url, options);
};

_leaflet2["default"].supermap.wmtsLayer = wmtsLayer;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Credential = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Credential
 * @classdesc SuperMap的安全证书类，其中包括token等安全验证信息。<br>
 * 需要使用用户名和密码在："http://localhost:8090/iserver/services/security/tokens"下申请value <br>
 * 获得形如："2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ.."的value<br>
 * 目前支持的功能包括：地图服务、专题图、量算、查询、公交换乘、空间分析、网络分析，不支持轮询功能。
 * @param value - {string}  访问受安全限制的服务时用于通过安全认证的验证信息。
 * @param name - {string}  验证信息前缀，name=value部分的name部分，默认为“token”。
 * @example
 * var pixcel = new SuperMap.Credential("valueString","token");
 * pixcel.destroy();
 */
var Credential = exports.Credential = function () {
    function Credential(value, name) {
        _classCallCheck(this, Credential);

        /**
         * @member SuperMap.Bounds.prototype.value -{string}
         * @description 访问受安全限制的服务时用于通过安全认证的验证信息。
         */
        this.value = value ? value : "";

        /**
         * @member SuperMap.Bounds.prototype.name -{string}
         * @description 验证信息前缀，name=value部分的name部分，默认为“token”。
         */
        this.name = name ? name : "token";
        this.CLASS_NAME = "SuperMap.Credential";
    }

    /**
     * @function SuperMap.Credential.prototype.getUrlParameters
     * @example
     * var credential = new SuperMap.Credential("valueString","token");
     * //这里 str = "token=valueString";
     * var str = credential.getUrlParameters();
     * @returns {string} 返回安全信息组成的url片段。
     */


    _createClass(Credential, [{
        key: "getUrlParameters",
        value: function getUrlParameters() {
            //当需要其他安全信息的时候，则需要return this.name + "=" + this.value + "&" + "...";的形式添加。
            return this.name + "=" + this.value;
        }

        /**
         * @function SuperMap.Bounds.prototype.getValue
         * @description 获取value
         * @example
         * var credential = new SuperMap.Credential("2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..""token");
         * //这里 str = "2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..";
         * var str = credential.getValue();
         * @returns {string} 返回value字符串，在iServer服务下该value值即为token值。
         */

    }, {
        key: "getValue",
        value: function getValue() {
            return this.value;
        }

        /**
         *
         * @function SuperMap.Credential.prototype.destroy
         * @description 销毁此对象。销毁后此对象的所有属性为null，而不是初始值。
         * @example
         * var credential = new SuperMap.Credential("valueString""token");
         * credential.destroy();
         */

    }, {
        key: "destroy",
        value: function destroy() {
            this.value = null;
            this.name = null;
        }
    }]);

    return Credential;
}();

/**
 * @member SuperMap.Credential.CREDENTIAL -{SuperMap.Credential}
 * @description 这个对象保存一个安全类的实例，在服务端需要安全验证的时候必须进行设置。
 * @constant
 * @example
 * 代码实例:
 *  // 当iServer启用服务安全的时候，下边的代码是必须的。安全证书类能够接收一个value和一个name参数。
 *  var value = "(以iServer为例，这里是申请的token值)";
 *  var name = "token";
 *  // 默认name参数为token，所以当使用iServer服务的时候可以不进行设置。
 *  SuperMap.Credential.CREDENTIAL = new SuperMap.Credential(value, name);
 *
 */

Credential.CREDENTIAL = null;
_SuperMap.SuperMap.Credential = Credential;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Curve = undefined;

var _SuperMap = __webpack_require__(0);

var _MultiPoint2 = __webpack_require__(38);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.Curve
 * @classdesc 几何对象曲线类。
 * @extends SuperMap.Geometry.MultiPoint
 * @param components - {Array<SuperMap.Geometry.Point>}几何对象数组。
 * @example
 * var point1 = new SuperMap.Geometry.Point(10,20);
 * var point2 = new SuperMap.Geometry.Point(30,40);
 * var curve = new SuperMap.Geometry.Curve([point1,point2]);
 */
var Curve = exports.Curve = function (_MultiPoint) {
  _inherits(Curve, _MultiPoint);

  function Curve(points) {
    _classCallCheck(this, Curve);

    /**
     * @member SuperMap.Geometry.Curve.prototype.componentTypes -{Array<string>}
     * @description components存储的的几何对象所支持的几何类型数组,为空表示类型不受限制。
     * @readonly
     * @default ["{@link SuperMap.Geometry.Point}", "{@link SuperMap.PointWithMeasure}"]
     */
    var _this = _possibleConstructorReturn(this, (Curve.__proto__ || Object.getPrototypeOf(Curve)).call(this, points));

    _this.componentTypes = ["SuperMap.Geometry.Point", "SuperMap.PointWithMeasure"];
    _this.CLASS_NAME = "SuperMap.Geometry.Curve";
    return _this;
  }

  return Curve;
}(_MultiPoint2.MultiPoint);

_SuperMap.SuperMap.Geometry.Curve = Curve;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeoText = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Geometry2 = __webpack_require__(26);

var _Bounds = __webpack_require__(22);

var _Util = __webpack_require__(1);

var _Point = __webpack_require__(18);

__webpack_require__(17);

__webpack_require__(63);

__webpack_require__(37);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Geometry.GeoText
 * @classdesc 文本标签类。
 * @extends {SuperMap.Geometry}
 * @param x {float} x-坐标，必设参数。
 * @param y {float} y-坐标，必设参数。
 * @param text {string} 标签中的文本内容，必设参数。
 */
var GeoText = exports.GeoText = function (_Geometry) {
    _inherits(GeoText, _Geometry);

    function GeoText(x, y, text) {
        _classCallCheck(this, GeoText);

        /**
         * @member SuperMap.Geometry.GeoText.prototype.x -{float}
         * @description 横坐标。
         */
        var _this = _possibleConstructorReturn(this, (GeoText.__proto__ || Object.getPrototypeOf(GeoText)).call(this, x, y, text));

        _this.x = parseFloat(x);

        /**
         * @member SuperMap.Geometry.GeoText.prototype.y -{float}
         * @description 纵坐标。
         */
        _this.y = parseFloat(y);

        /**
         * @member SuperMap.Geometry.GeoText.prototype.text -{string}
         * @description 标签中的文本内容。
         */
        _this.text = text.toString();

        /**
         * @member SuperMap.Geometry.GeoText.prototype.bsInfo -{Object}
         * @description 标签范围的基础信息，包含下面2个属性。
         *  * w: bounds 的宽；
         *  * h: bounds 的高度；
           */
        _this.bsInfo = {
            "h": null,
            "w": null
        };
        _this.element = document.createElement('span');
        _this.CLASS_NAME = "SuperMap.Geometry.GeoText";
        return _this;
    }

    /**
     * @function SuperMap.Geometry.GeoText.prototype.destroy
     * @description 销毁文本标签类。
     */


    _createClass(GeoText, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeoText.prototype.__proto__ || Object.getPrototypeOf(GeoText.prototype), 'destroy', this).call(this);
            this.x = null;
            this.y = null;
            this.text = null;
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.getCentroid
         * @description 获取标签对象的质心。
         * @return {SuperMap.Geometry.Point} 标签对象的质心。
         */

    }, {
        key: 'getCentroid',
        value: function getCentroid() {
            return new _Point.Point(this.x, this.y);
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.clone
         * @description 克隆标签对象。
         * @returns {SuperMap.Geometry.GeoText} 克隆后的标签对象。
         */

    }, {
        key: 'clone',
        value: function clone(obj) {
            if (obj == null) {
                obj = new GeoText(this.x, this.y, this.text);
            }
            _Util.Util.applyDefaults(obj, this);
            return obj;
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.calculateBounds
         * @description 计算标签对象的范围。
         */

    }, {
        key: 'calculateBounds',
        value: function calculateBounds() {
            this.bounds = new _Bounds.Bounds(this.x, this.y, this.x, this.y);
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.getLabelPxBoundsByLabel
         * @description 根据绘制好的标签获取文字标签的像素范围，参数的单位是像素；此方法相对于 getLabelPxBoundsByText 效率较低，但支持所有格式的文本。
         * @param locationPixel - {Object} 标签的位置点，该对象含有属性x(横坐标)，属性y(纵坐标)。
         * @param labelWidth - {string} 标签的宽度，如：“90px”。
         * @param labelHeight - {string}  标签的高度。
         * @param style - {Object}  标签的style。
         * @return {SuperMap.Bounds}  标签的像素范围。
         */

    }, {
        key: 'getLabelPxBoundsByLabel',
        value: function getLabelPxBoundsByLabel(locationPixel, labelWidth, labelHeight, style) {
            var labelPxBounds, left, bottom, top, right;
            var locationPx = _Util.Util.cloneObject(locationPixel);

            //计算文本行数
            var theText = style.label || this.text;
            var textRows = theText.split('\n');
            var laberRows = textRows.length;

            //处理文字对齐
            labelWidth = parseFloat(labelWidth);
            labelHeight = parseFloat(labelHeight);
            if (laberRows > 1) {
                labelHeight = parseFloat(labelHeight) * laberRows;
            }
            if (style.labelAlign && style.labelAlign !== "cm") {
                switch (style.labelAlign) {
                    case "lt":
                        locationPx.x += labelWidth / 2;
                        locationPx.y += labelHeight / 2;
                        break;
                    case "lm":
                        locationPx.x += labelWidth / 2;
                        break;
                    case "lb":
                        locationPx.x += labelWidth / 2;
                        locationPx.y -= labelHeight / 2;
                        break;
                    case "ct":
                        locationPx.y += labelHeight / 2;
                        break;
                    case "cb":
                        locationPx.y -= labelHeight / 2;
                        break;
                    case "rt":
                        locationPx.x -= labelWidth / 2;
                        locationPx.y += labelHeight / 2;
                        break;
                    case "rm":
                        locationPx.x -= labelWidth / 2;
                        break;
                    case "rb":
                        locationPx.x -= labelWidth / 2;
                        locationPx.y -= labelHeight / 2;
                        break;
                    default:
                        break;
                }
            }

            this.bsInfo.h = labelHeight;
            this.bsInfo.w = labelWidth;

            //bounds的四边
            left = locationPx.x - parseFloat(labelWidth) / 2;
            bottom = locationPx.y + parseFloat(labelHeight) / 2;
            right = locationPx.x + parseFloat(labelWidth) / 2;
            top = locationPx.y - parseFloat(labelHeight) / 2;

            labelPxBounds = new _Bounds.Bounds(left, bottom, right, top);

            return labelPxBounds;
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.getLabelPxBoundsByText
         * @description 根据文本内容获取文字标签的像素范围
         * @param locationPixel - {Object} 标签的位置点，该对象含有属性x(横坐标)，属性y(纵坐标)。
         * @param style - {Object} 标签的样式
         * @return {SuperMap.Bounds}  标签的像素范围。
         */

    }, {
        key: 'getLabelPxBoundsByText',
        value: function getLabelPxBoundsByText(locationPixel, style) {
            var labelPxBounds, left, bottom, top, right;
            var labelSize = this.getLabelPxSize(style);
            var locationPx = _Util.Util.cloneObject(locationPixel);

            //处理文字对齐
            if (style.labelAlign && style.labelAlign !== "cm") {
                switch (style.labelAlign) {
                    case "lt":
                        locationPx.x += labelSize.w / 2;
                        locationPx.y += labelSize.h / 2;
                        break;
                    case "lm":
                        locationPx.x += labelSize.w / 2;
                        break;
                    case "lb":
                        locationPx.x += labelSize.w / 2;
                        locationPx.y -= labelSize.h / 2;
                        break;
                    case "ct":
                        locationPx.y += labelSize.h / 2;
                        break;
                    case "cb":
                        locationPx.y -= labelSize.h / 2;
                        break;
                    case "rt":
                        locationPx.x -= labelSize.w / 2;
                        locationPx.y += labelSize.h / 2;
                        break;
                    case "rm":
                        locationPx.x -= labelSize.w / 2;
                        break;
                    case "rb":
                        locationPx.x -= labelSize.w / 2;
                        locationPx.y -= labelSize.h / 2;
                        break;
                    default:
                        break;
                }
            }

            this.bsInfo.h = labelSize.h;
            this.bsInfo.w = labelSize.w;

            left = locationPx.x - labelSize.w / 2;
            bottom = locationPx.y + labelSize.h / 2;
            //处理斜体字
            if (style.fontStyle && style.fontStyle === "italic") {
                right = locationPx.x + labelSize.w / 2 + parseInt(parseFloat(style.fontSize) / 2);
            } else {
                right = locationPx.x + labelSize.w / 2;
            }
            top = locationPx.y - labelSize.h / 2;

            labelPxBounds = new _Bounds.Bounds(left, bottom, right, top);

            return labelPxBounds;
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.getLabelPxSize
         * @description 获取label的像素大小
         * @param style - {Object} 标签样式。
         * @return {Object} 标签大小对象，属性w表示标签的宽度，属性h表示标签的高度。
         */

    }, {
        key: 'getLabelPxSize',
        value: function getLabelPxSize(style) {
            var text,
                //文本内容
            fontSize,
                //字体大小
            spacing = 1,
                //两个字符间的间距（单位：px）
            lineSpacing = 0.2,
                bgstrokeWidth = parseFloat(style.strokeWidth); //标签背景框边框的宽度

            text = style.label || this.text;
            if (style.fontSize) {
                fontSize = parseFloat(style.fontSize);
            } else {
                fontSize = parseFloat("12px");
            }

            //标签宽高
            var labelW, labelH;

            var textRows = text.split('\n');
            var numRows = textRows.length;

            if (numRows > 1) {
                labelH = fontSize * numRows + numRows + bgstrokeWidth + lineSpacing * fontSize;
            } else {
                labelH = fontSize + bgstrokeWidth + lineSpacing * fontSize + 1;
            }

            //取最大宽度
            labelW = 0;
            if (this.labelWTmp && labelW < this.labelWTmp) {
                labelW = this.labelWTmp;
            }
            for (var i = 0; i < numRows; i++) {
                var textCharC = this.getTextCount(textRows[i]);
                var labelWTmp = this.labelWTmp = _Util.Util.getTextBounds(style, textRows[i], this.element).textWidth + textCharC.textC * spacing + bgstrokeWidth;
                if (labelW < labelWTmp) {
                    labelW = labelWTmp;
                }
            }

            var labelSize = new Object(); //标签大小
            labelSize.h = labelH;
            labelSize.w = labelW;

            return labelSize;
        }

        /**
         * @function SuperMap.Geometry.GeoText.prototype.getTextCount
         * @description 获取text中的字符个数。
         * @param text - {string} 字符串。
         * @return {Object} 字符个数统计结果，属性cnC表示中文字符个数，属性enC表示英文字符个数，属性textC表示字符总个数。
         */

    }, {
        key: 'getTextCount',
        value: function getTextCount(text) {
            var textCharCount = {};

            var cnCount = 0;
            var enCount = 0;

            for (var i = 0; i < text.length; i++) {
                if (text.charCodeAt(i) > 255) {
                    //遍历判断字符串中每个字符的Unicode码,大于255则为中文
                    cnCount++;
                } else {
                    enCount++;
                }
            }
            //中午字符个数
            textCharCount.cnC = cnCount;
            //英文字符个数
            textCharCount.enC = enCount;
            //字符总个数
            textCharCount.textC = text.length;

            return textCharCount;
        }
    }]);

    return GeoText;
}(_Geometry2.Geometry);

_SuperMap.SuperMap.Geometry.GeoText = GeoText;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Format = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Format
 * @classdesc 读写各种格式的格式类基类。其子类应该包含并实现read和write方法。
 * @param options - {Object} 可选参数。<br>
 *        keepData - {boolean} 如果设置为true， data属性会指向被解析的对象（例如json或xml数据对象）。
 */
var Format = exports.Format = function () {
    function Format(options) {
        _classCallCheck(this, Format);

        /**
         * @member SuperMap.Format.prototype.data - {Object}
         * @description 当 <keepData> 属性设置为true，这是传递给<read>操作的要被解析的字符串。
         */
        this.data = null;

        /**
         * APIProperty: keepData
         * @member SuperMap.Format.prototype.keepData - {Object}
         * @description 保持最近读到的数据的引用（通过 <data> 属性）。默认值是false。
         */
        this.keepData = false;

        _Util.Util.extend(this, options);
        /**
         * @member SuperMap.Format.prototype.options - {Object}
         * @description 可选参数。
         */
        this.options = options;

        this.CLASS_NAME = "SuperMap.Format";
    }

    /**
     * @function SuperMap.Format.prototype.destroy
     * @description 销毁该格式类，释放相关资源。
     */


    _createClass(Format, [{
        key: 'destroy',
        value: function destroy() {}
        //用来销毁该格式类，释放相关资源


        /**
         * @function SuperMap.Format.prototype.read
         * @description 来从字符串中读取数据。
         * @param data - {string} 读取的数据。
         */

    }, {
        key: 'read',
        value: function read(data) {} // eslint-disable-line no-unused-vars
        //用来从字符串中读取数据


        /**
         * @function SuperMap.Format.prototype.write
         * @description 将对象写成字符串。
         * @param object - {Object} 可序列化的对象。
         * @return {string} 对象被写成字符串。
         */

    }, {
        key: 'write',
        value: function write(object) {// eslint-disable-line no-unused-vars
            //用来写字符串
        }
    }]);

    return Format;
}();

_SuperMap.SuperMap.Format = Format;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JSONFormat = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Format2 = __webpack_require__(92);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Format.JSON
 * @classdesc 安全的读写JSON的解析类。使用<SuperMap.Format.JSON> 构造函数创建新实例。
 * @extends SuperMap.Format
 */
var JSONFormat = exports.JSONFormat = function (_Format) {
    _inherits(JSONFormat, _Format);

    function JSONFormat(options) {
        _classCallCheck(this, JSONFormat);

        /**
         * @member SuperMap.Format.JSON.prototype.indent - {string}
         * @description 用于格式化输出，indent字符串会在每次缩进的时候使用一次。
         */
        var _this = _possibleConstructorReturn(this, (JSONFormat.__proto__ || Object.getPrototypeOf(JSONFormat)).call(this, options));

        _this.indent = "    ";

        /**
         * @member SuperMap.Format.JSON.prototype.space -{string}
         * @description 用于格式化输出，space字符串会在名值对的":"后边添加。
         */
        _this.space = " ";

        /**
         * @member SuperMap.Format.JSON.prototype.newline - {string}
         * @description 用于格式化输出, newline字符串会用在每一个名值对或数组项末尾。
         */
        _this.newline = "\n";

        /**
         * @member SuperMap.Format.JSON.prototype.level - {integer}
         * @description 用于格式化输出, 表示的是缩进级别。
         */
        _this.level = 0;

        /**
         * @member SuperMap.Format.JSON.prototype.pretty - {boolean}
         * @description 是否在序列化的时候使用额外的空格控制结构。在write方法中使用，默认值为false。
         */
        _this.pretty = false;

        /**
         * @member SuperMap.Format.JSON.prototype.nativeJSON - {boolean}
         * @description 判断浏览器是否原生支持JSON格式数据。
         */
        _this.nativeJSON = function () {
            return !!(window.JSON && typeof JSON.parse === "function" && typeof JSON.stringify === "function");
        }();

        _this.CLASS_NAME = "SuperMap.Format.JSON";
        /**
         * @member SuperMap.Format.JSON.prototype.serialize
         * @description 提供一些类型对象转JSON字符串的方法。
         */
        _this.serialize = {
            /**
             * @function SuperMap.Format.JSON.serialize.object
             * @description 把对象转换为JSON字符串。
             * @param object - {Object} 可序列化的对象。
             * @return {string} JSON字符串。
             */
            'object': function object(_object) {
                // three special objects that we want to treat differently
                if (_object == null) {
                    return "null";
                }
                if (_object.constructor === Date) {
                    return this.serialize.date.apply(this, [_object]);
                }
                if (_object.constructor === Array) {
                    return this.serialize.array.apply(this, [_object]);
                }
                var pieces = ['{'];
                this.level += 1;
                var key, keyJSON, valueJSON;

                var addComma = false;
                for (key in _object) {
                    if (_object.hasOwnProperty(key)) {
                        // recursive calls need to allow for sub-classing
                        keyJSON = this.write.apply(this, [key, this.pretty]);
                        valueJSON = this.write.apply(this, [_object[key], this.pretty]);
                        if (keyJSON != null && valueJSON != null) {
                            if (addComma) {
                                pieces.push(',');
                            }
                            pieces.push(this.writeNewline(), this.writeIndent(), keyJSON, ':', this.writeSpace(), valueJSON);
                            addComma = true;
                        }
                    }
                }

                this.level -= 1;
                pieces.push(this.writeNewline(), this.writeIndent(), '}');
                return pieces.join('');
            },

            /**
             * @function SuperMap.Format.JSON.serialize.array
             * @description 把数组转换成JSON字符串。
             * @param array - {Array} 可序列化的数组。
             * @return {string} JSON字符串。
             */
            'array': function array(_array) {
                var json;
                var pieces = ['['];
                this.level += 1;

                for (var i = 0, len = _array.length; i < len; ++i) {
                    // recursive calls need to allow for sub-classing
                    json = this.write.apply(this, [_array[i], this.pretty]);
                    if (json != null) {
                        if (i > 0) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(), json);
                    }
                }

                this.level -= 1;
                pieces.push(this.writeNewline(), this.writeIndent(), ']');
                return pieces.join('');
            },

            /**
             * @function SuperMap.Format.JSON.serialize.string
             * @description 把字符串转换成JSON字符串。
             * @param string - {string} 可序列化的字符串。
             * @return {string} JSON字符串。
             */
            'string': function string(_string) {
                // If the string contains no control characters, no quote characters, and no
                // backslash characters, then we can simply slap some quotes around it.
                // Otherwise we must also replace the offending characters with safe
                // sequences.
                var m = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"': '\\"',
                    '\\': '\\\\'
                };
                /*eslint-disable no-control-regex*/
                if (/["\\\x00-\x1f]/.test(_string)) {
                    return '"' + _string.replace(/([\x00-\x1f\\"])/g, function (a, b) {
                        var c = m[b];
                        if (c) {
                            return c;
                        }
                        c = b.charCodeAt();
                        return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
                    }) + '"';
                }
                return '"' + _string + '"';
            },

            /**
             * @function SuperMap.Format.JSON.serialize.number
             * @description 把数字转换成JSON字符串。
             * @param number - {number} 可序列化的数字。
             * @return {string} JSON字符串。
             */
            'number': function number(_number) {
                return isFinite(_number) ? String(_number) : "null";
            },

            /**
             * @function SuperMap.Format.JSON.serialize.boolean
             * @description Transform a boolean into a JSON string.
             * @param bool - {boolean} The boolean to be serialized.
             * @return {string} A JSON string representing the boolean.
             */
            'boolean': function boolean(bool) {
                return String(bool);
            },

            /**
             * @function SuperMap.Format.JSON.serialize.object
             * @description 将日期对象转换成JSON字符串。
             * @param date - {Date} 可序列化的日期对象。
             * @return {string} JSON字符串。
             */
            'date': function date(_date) {
                function format(number) {
                    // Format integers to have at least two digits.
                    return number < 10 ? '0' + number : number;
                }

                return '"' + _date.getFullYear() + '-' + format(_date.getMonth() + 1) + '-' + format(_date.getDate()) + 'T' + format(_date.getHours()) + ':' + format(_date.getMinutes()) + ':' + format(_date.getSeconds()) + '"';
            }
        };
        return _this;
    }

    /**
     * @function SuperMap.Format.JSON.prototype.read
     * @description 将一个符合json结构的字符串进行解析。
     * @param json - {string} 符合json结构的字符串。
     * @param filter - {function} 过滤方法，最终结果的每一个键值对都会调用该过滤方法，并在对应的值的位置替换成该方法返回的值。
     * @return {Object} 对象，数组，字符串或数字。
     */


    _createClass(JSONFormat, [{
        key: 'read',
        value: function read(json, filter) {
            var object;
            if (this.nativeJSON) {
                try {
                    object = JSON.parse(json, filter);
                } catch (e) {
                    // Fall through if the regexp test fails.
                }
            }

            if (this.keepData) {
                this.data = object;
            }

            return object;
        }

        /**
         * @function SuperMap.Format.JSON.prototype.write
         * @description 序列化一个对象到一个符合JSON格式的字符串。
         * @param value - {object}|{string}|<Array>|{number}|{boolean} 需要被序列化的对象，数组，字符串，数字，布尔值。
         * @param pretty - {boolean}
         * @return {string} 符合JSON格式的字符串。
         *
         */

    }, {
        key: 'write',
        value: function write(value, pretty) {
            this.pretty = !!pretty;
            var json = null;
            var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
            if (this.serialize[type]) {
                try {
                    json = !this.pretty && this.nativeJSON ? JSON.stringify(value) : this.serialize[type].apply(this, [value]);
                } catch (err) {
                    //SuperMap.Console.error("Trouble serializing: " + err);
                }
            }
            return json;
        }

        /**
         * @function SuperMap.Format.JSON.prototype.writeIndent
         * @description 根据缩进级别输出一个缩进字符串。
         * @return {string} 一个适当的缩进字符串。
         */

    }, {
        key: 'writeIndent',
        value: function writeIndent() {
            var pieces = [];
            if (this.pretty) {
                for (var i = 0; i < this.level; ++i) {
                    pieces.push(this.indent);
                }
            }
            return pieces.join('');
        }

        /**
         * @function SuperMap.Format.JSON.prototype.writeNewline
         * @description 在格式化输出模式情况下输出代表新一行的字符串。
         * @return {string} 代表新的一行的字符串。
         */

    }, {
        key: 'writeNewline',
        value: function writeNewline() {
            return this.pretty ? this.newline : '';
        }

        /**
         * @function SuperMap.Format.JSON.prototype.writeSpace
         * @description 在格式化输出模式情况下输出一个代表空格的字符串。
         * @return {string} A space.
         */

    }, {
        key: 'writeSpace',
        value: function writeSpace() {
            return this.pretty ? this.space : '';
        }
    }]);

    return JSONFormat;
}(_Format2.Format);

_SuperMap.SuperMap.Format.JSON = JSONFormat;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BufferAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _BufferSetting = __webpack_require__(152);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BufferAnalystParameters
 * @classdesc 缓冲区分析参数基类。
 * @param options - {Object} 参数。如:</br>
 *        bufferSetting - {@link SuperMap.BufferSetting} 设置缓冲区通用参数。为缓冲区分析提供必要的参数信息，包括左缓冲距离、右缓冲距离、端点类型、圆头缓冲圆弧处线段的个数信息。
 */
var BufferAnalystParameters = exports.BufferAnalystParameters = function () {
    function BufferAnalystParameters(options) {
        _classCallCheck(this, BufferAnalystParameters);

        var me = this;
        /**
         * @member SuperMap.BufferAnalystParameters.prototype.bufferSetting - {SuperMap.BufferSetting}
         * @description 设置缓冲区通用参数。为缓冲区分析提供必要的参数信息，包括左缓冲距离、右缓冲距离、端点类型、圆头缓冲圆弧处线段的个数信息。
         */
        me.bufferSetting = new _BufferSetting.BufferSetting();
        _Util.Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.BufferAnalystParameters";
    }

    /**
     * @function SuperMap.BufferAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(BufferAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.bufferSetting) {
                me.bufferSetting.destroy();
                me.bufferSetting = null;
            }
        }
    }]);

    return BufferAnalystParameters;
}();

_SuperMap.SuperMap.BufferAnalystParameters = BufferAnalystParameters;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OverlayAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.OverlayAnalystParameters
 * @classdesc 叠加分析参数基类，数据集叠加分析参数和几何对象叠加分析参数均继承此基类
 * @param options - {Object} 叠加分析参数。
 */
var OverlayAnalystParameters = exports.OverlayAnalystParameters = function () {
    function OverlayAnalystParameters(options) {
        _classCallCheck(this, OverlayAnalystParameters);

        /**
         * @member SuperMap.OverlayAnalystParameters.prototype.operation -{SuperMap.OverlayOperationType}
         * @description 指定叠加分析操作类型。
         */
        this.operation = _REST.OverlayOperationType.UNION;

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.OverlayAnalystParameters";
    }

    /**
     * @function SuperMap.OverlayAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(OverlayAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.operation = null;
        }
    }]);

    return OverlayAnalystParameters;
}();

_SuperMap.SuperMap.OverlayAnalystParameters = OverlayAnalystParameters;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeDotDensity = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ServerStyle = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeDotDensity
 * @classdesc 点密度专题图。<br>
 * @description
 *              点密度专题图用一定大小、形状相同的点表示现象分布范围、数量特征和分布密度。点的多少和所代表的意义由地图的内容确定。<br>
 *              点密度专题图利用图层的某一数值属性信息（专题值）映射为不同等级，每一级别使用不同数量或表现为密度的点符号来表示。<br>
 *              该专题值在各个分区内的分布情况，体现不同区域的相对数量差异。多用于具有数量特征的地图上，<br>
 *              比如表示不同地区的粮食产量、GDP、人口等的分级，主要针对区域或面状的要素，因而，点密度专题图适用于面数据集。<br>
 *              注意：点密度专题图中点的分布是随机的，并不代表实际的分布位置。即使在相关设置完全相同的情况下，<br>
 *              每次制作出的专题图，点的数量相同，但点的位置都有差异。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        dotExpression - {string} 创建点密度专题图的字段或字段表达式。<br>
 *        style - {{@link SuperMap.ServerStyle}} 点密度专题图中点的风格。<br>
 *        value - {string} 专题图中每一个点所代表的数值。<br>
 *        memoryData - {{@link SuperMap.ThemeMemoryData}} 专题图内存数据。
 */
var ThemeDotDensity = exports.ThemeDotDensity = function (_Theme) {
    _inherits(ThemeDotDensity, _Theme);

    function ThemeDotDensity(options) {
        _classCallCheck(this, ThemeDotDensity);

        /**
         * @member SuperMap.ThemeDotDensity.prototype.dotExpression -{string}
         * @description 创建点密度专题图的字段或字段表达式。点的数目或密集程度的来源。
         */
        var _this = _possibleConstructorReturn(this, (ThemeDotDensity.__proto__ || Object.getPrototypeOf(ThemeDotDensity)).call(this, "DOTDENSITY", options));

        _this.dotExpression = null;

        /**
         * @member SuperMap.ThemeDotDensity.prototype.style -{SuperMap.ServerStyle}
         * @description 点密度专题图中点的风格。
         */
        _this.style = new _ServerStyle.ServerStyle();

        /**
         * @member SuperMap.ThemeDotDensity.prototype.value -{number}
         * @description 专题图中每一个点所代表的数值。<br>
         *              点值的确定与地图比例尺以及点的大小有关。地图比例尺越大，相应的图面范围也越大，<br>
         *              点相应就可以越多，此时点值就可以设置相对小一些。点形状越大，<br>
         *              点值相应就应该设置的小一些。点值过大或过小都是不合适的。
         */
        _this.value = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.ThemeDotDensity";
        return _this;
    }

    /**
     * @function SuperMap.ThemeDotDensity.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeDotDensity, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.dotExpression = null;
            me.value = null;

            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
        }

        /**
         * @function SuperMap.ThemeDotDensity.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return{Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.style) {
                if (obj.style.toServerJSONObject) {
                    obj.style = obj.style.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeDotDensity.fromObj
         * @description 从传入对象获取点密度专题图中点的风格。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeDotDensity} ThemeDotDensity对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeDotDensity();
            _Util.Util.copy(res, obj);
            res.style = _ServerStyle.ServerStyle.fromJson(obj.style);
            return res;
        }
    }]);

    return ThemeDotDensity;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeDotDensity = ThemeDotDensity;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGraduatedSymbol = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ThemeFlow = __webpack_require__(70);

var _ThemeOffset = __webpack_require__(72);

var _ThemeGraduatedSymbolStyle = __webpack_require__(230);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGraduatedSymbol
 * @classdesc 等级符号专题图。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        baseValue - {number}等级符号专题图的基准值，单位同专题变量的单位。<br>
 *        expression - {string} 等级符号专题图的字段或字段表达式。<br>
 *        flow - {{@link SuperMap.ThemeFlow}} 等级符号专题图符号流动显示与牵引线设置类。<br>
 *        graduatedMode - {{@link SuperMap.GraduatedMode}} 等级符号专题图分级模式。<br>
 *        offset - {{@link SuperMap.ThemeOffset}} 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。<br>
 *        style - {{@link SuperMap.ThemeGraduatedSymbolStyle}} 用于设置等级符号图正负和零值显示风格。<br>
 *        memoryData - {{@link SuperMap.ThemeMemoryData}} 专题图内存数据。
 */
var ThemeGraduatedSymbol = exports.ThemeGraduatedSymbol = function (_Theme) {
    _inherits(ThemeGraduatedSymbol, _Theme);

    function ThemeGraduatedSymbol(options) {
        _classCallCheck(this, ThemeGraduatedSymbol);

        /**
         * @member SuperMap.ThemeGraduatedSymbol.prototype.baseValue -{number}
         * @description 等级符号专题图的基准值，单位同专题变量的单位。<br>
         *              依据此值系统会自动根据分级方式计算其余值对应的符号大小，每个符号的显示大小等于<br>
         *              ThemeValueSection.positiveStyle（或 zeroStyle，negativeStyle）.markerSize * value / basevalue，<br>
         *              其中 value 是 expression 所指定字段对应的值经过分级计算之后的值。默认值为0，建议通过多次尝试设置该值才能达到较好的显示效果。
         */
        var _this = _possibleConstructorReturn(this, (ThemeGraduatedSymbol.__proto__ || Object.getPrototypeOf(ThemeGraduatedSymbol)).call(this, "GRADUATEDSYMBOL", options));

        _this.baseValue = 0;

        /**
         * @member SuperMap.ThemeGraduatedSymbol.prototype.expression -{string}
         * @description 用于创建等级符号专题图的字段或字段表达式，字段或字段表达式应为数值型。必设字段。
         */
        _this.expression = null;

        /**
         * @member SuperMap.ThemeGraduatedSymbol.prototype.flow -{SuperMap.ThemeFlow}
         * @description 等级符号专题图符号流动显示与牵引线设置类。<br>
         *              通过该字段可以设置等级符号是否流动显示和牵引线风格。
         */
        _this.flow = new _ThemeFlow.ThemeFlow();

        /**
         * @member SuperMap.ThemeGraduatedSymbol.prototype.graduatedMode -{SuperMap.GraduatedMode}
         * @description 等级符号专题图分级模式。<br>
         *              分级主要是为了减少制作等级符号专题图中数据大小之间的差异。如果数据之间差距较大，则可以采用对数或者平方根的分级方式来进行，<br>
         *              这样就减少了数据之间的绝对大小的差异，使得等级符号图的视觉效果比较好，同时不同类别之间的比较也是有意义的。<br>
         *              有三种分级模式：常数、对数和平方根，对于有值为负数的字段，在用对数或平方根方式分级时，默认对负数取正。<br>
         *              不同的分级模式用于确定符号大小的数值是不相同的：常数按照字段的原始数据进行；对数则是对每条记录对应的专题变量取自然对数；<br>
         *              平方根则是对其取平方根，然后用最终得到的结果来确定其等级符号的大小。<br>
         *              默认值为 SuperMap.GraduatedMode.CONSTANT。
         */
        _this.graduatedMode = _REST.GraduatedMode.CONSTANT;

        /**
         * @member SuperMap.ThemeGraduatedSymbol.prototype.offset -{SuperMap.ThemeOffset}
         * @description 用于设置等级符号图相对于要素内点的偏移量。
         */
        _this.offset = new _ThemeOffset.ThemeOffset();

        /**
         * @member SuperMap.ThemeGraduatedSymbol.prototype.style -{SuperMap.ThemeGraduatedSymbolStyle}
         * @description 用于设置等级符号图正负和零值显示风格。
         */
        _this.style = new _ThemeGraduatedSymbolStyle.ThemeGraduatedSymbolStyle();

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeGraduatedSymbol";
        return _this;
    }

    /**
     * @function SuperMap.ThemeGraduatedSymbol.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGraduatedSymbol, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGraduatedSymbol.prototype.__proto__ || Object.getPrototypeOf(ThemeGraduatedSymbol.prototype), 'destroy', this).call(this);
            var me = this;
            me.expression = null;
            if (me.flow) {
                me.flow.destroy();
                me.flow = null;
            }
            me.graduatedMode = _REST.GraduatedMode.CONSTANT;
            if (me.offset) {
                me.offset.destroy();
                me.offset = null;
            }
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbol.prototype.toJSON
         * @description 将themeLabel对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return _Util.Util.toJSON(this.toServerJSONObject());
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbol.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return{Object} 对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj.type = this.type;
            obj.memoryData = this.memoryData;
            obj.baseValue = this.baseValue;
            obj.expression = this.expression;
            obj.graduatedMode = this.graduatedMode;
            if (this.flow) {
                obj.flowEnabled = this.flow.flowEnabled;
                obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
                obj.leaderLineStyle = this.flow.leaderLineStyle;
            }
            if (this.offset) {
                obj.offsetFixed = this.offset.offsetFixed;
                obj.offsetX = this.offset.offsetX;
                obj.offsetY = this.offset.offsetY;
            }
            if (this.style) {
                obj.negativeStyle = this.style.negativeStyle;
                obj.negativeDisplayed = this.style.negativeDisplayed;
                obj.positiveStyle = this.style.positiveStyle;
                obj.zeroDisplayed = this.style.zeroDisplayed;
                obj.zeroStyle = this.style.zeroStyle;
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGraduatedSymbol.fromObj
         * @description 从传入对象获取等级符号专题图。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraduatedSymbol} 等级符号专题图对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new _SuperMap.SuperMap.ThemeGraduatedSymbol();
            _Util.Util.copy(res, obj);
            res.flow = _ThemeFlow.ThemeFlow.fromObj(obj);
            res.offset = _ThemeOffset.ThemeOffset.fromObj(obj);
            res.style = _ThemeGraduatedSymbolStyle.ThemeGraduatedSymbolStyle.fromObj(obj);
            return res;
        }
    }]);

    return ThemeGraduatedSymbol;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeGraduatedSymbol = ThemeGraduatedSymbol;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGraph = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ThemeFlow = __webpack_require__(70);

var _ThemeOffset = __webpack_require__(72);

var _ThemeGraphAxes = __webpack_require__(231);

var _ThemeGraphSize = __webpack_require__(233);

var _ThemeGraphText = __webpack_require__(234);

var _ThemeGraphItem = __webpack_require__(232);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGraph
 * @classdesc 统计专题图类。
 * @extends SuperMap.Theme
 * @param options - {Object} 参数。<br>
 *        barWidth - {number}柱状专题图中每一个柱的宽度。<br>
 *        flow - {SuperMap.ThemeFlow} 统计专题图流动显示与牵引线设置。<br>
 *        graduatedMode - {{@link SuperMap.GraduatedMode}} 统计图中地理要素的值与图表尺寸间的映射关系。<br>
 *        graphAxes - {{@link SuperMap.ThemeGraphAxes}} 统计图中坐标轴样式相关信息。<br>
 *        graphSize - {{@link SuperMap.ThemeGraphSize}} 统计符号的最大最小尺寸。<br>
 *        graphSizeFixed - {boolean} 缩放地图时统计图符号是否固定大小。<br>
 *        graphText - {{@link SuperMap.ThemeGraphText}} 统计图上的文字是否可以见以及文字标注风格。<br>
 *        graphAxesTextDisplayMode -{{@link SuperMap.GraphAxesTextDisplayMode}} 统计专题图坐标轴文本显示模式 。默认值 SuperMap.GraphAxesTextDisplayMode.NONE。
 *        graphType - {{@link SuperMap.ThemeGraphType}} 统计专题图类型。<br>
 *        items - {Array<{@link SuperMap.ThemeGraphItem}>} 统计专题图子项集合。<br>
 *        memoryKeys - {Array<integer>} 以内存数组方式制作专题图时的键数组。<br>
 *        negativeDisplayed - {boolean} 专题图中是否显示属性为负值的数据。<br>
 *        offset - {{@link SuperMap.ThemeOffset}} 统计图相对于要素内点的偏移量。<br>
 *        overlapAvoided - {boolean} 统计图是否采用避让方式显示。<br>
 *        roseAngle - {number}统计图中玫瑰图或三维玫瑰图用于等分的角度。<br>
 *        startAngle - {number}饼状统计图扇形的起始角度。
 */
var ThemeGraph = exports.ThemeGraph = function (_Theme) {
    _inherits(ThemeGraph, _Theme);

    function ThemeGraph(options) {
        _classCallCheck(this, ThemeGraph);

        /**
         * @member SuperMap.ThemeGraph.prototype.barWidth -{number}
         * @description 柱状专题图中每一个柱的宽度。使用地图坐标单位，默认值为0。<br>
         *              只有选择的统计图类型为柱状图（柱状图、三维柱状图、堆叠柱状图、三维堆叠柱状图）时，此项才可设置。
         */
        var _this = _possibleConstructorReturn(this, (ThemeGraph.__proto__ || Object.getPrototypeOf(ThemeGraph)).call(this, "GRAPH", options));

        _this.barWidth = 0;

        /**
         * @member SuperMap.ThemeGraph.prototype.flow -{SuperMap.ThemeFlow}
         * @description 统计专题图流动显示与牵引线设置。
         *              通过该字段可以设置统计符号是否流动显示和牵引线风格。
         */
        _this.flow = new _ThemeFlow.ThemeFlow();

        /**
         * @member SuperMap.ThemeGraph.prototype.graduatedMode -{SuperMap.GraduatedMode}
         * @description 统计图中地理要素的值与图表尺寸间的映射关系（常数、对数、平方根），即分级方式。
         *              默认值为 SuperMap.GraduatedMode.CONSTANT。
         *              分级主要是为了减少制作统计专题图中数据大小之间的差异，使得统计图的视觉效果比较好，同时不同类别之间的比较也还是有意义的。
         *              提供三种分级模式：常数、对数和平方根，对于有值为负数的字段，不可以采用对数和平方根的分级方式。不同的等级方式用于确定符号大小的数值是不相同的。
         */
        _this.graduatedMode = _REST.GraduatedMode.CONSTANT;

        /**
         * @member SuperMap.ThemeGraph.prototype.graphAxes -{SuperMap.ThemeGraphAxes}
         * @description 用于设置统计图中坐标轴样式相关信息，如坐标轴颜色、是否显示、坐标文本样式等。
         */
        _this.graphAxes = new _ThemeGraphAxes.ThemeGraphAxes();

        /**
         * @member SuperMap.ThemeGraph.prototype.graphSize -{SuperMap.ThemeGraphSize}
         * @description 用于设置统计符号的最大最小尺寸。
         */
        _this.graphSize = new _ThemeGraphSize.ThemeGraphSize();

        /**
         * @member SuperMap.ThemeGraph.prototype.graphSizeFixed -{boolean}
         * @description 缩放地图时统计图符号是否固定大小。默认值为 false，即统计图符号将随地图缩放。
         */
        _this.graphSizeFixed = false;

        /**
         * @member SuperMap.ThemeGraph.prototype.graphText -{SuperMap.ThemeGraphText}
         * @description 统计图上的文字是否可以见以及文字标注风格。
         */
        _this.graphText = new _ThemeGraphText.ThemeGraphText();

        /**
         * @member SuperMap.ThemeGraph.prototype.graphType -{SuperMap.ThemeGraphType}
         * @description 统计专题图类型。SuperMap 提供了多种类型的统计图，<br>
         *              分别为面积图、阶梯图、折线图、点状图、柱状图、三维柱状图、饼图、三维饼图、玫瑰图、三维玫瑰图、堆叠柱状图、三维堆叠柱状图、环状图。默认为面积图。
         */
        _this.graphType = _REST.ThemeGraphType.AREA;

        /**
         * @member SuperMap.ThemeGraph.prototype.graphAxesTextDisplayMode -{SuperMap.GraphAxesTextDisplayMode}
         * @description 统计专题图坐标轴文本显示模式 。默认值 SuperMap.GraphAxesTextDisplayMode.NONE。
         */
        _this.graphAxesTextDisplayMode = _REST.GraphAxesTextDisplayMode.NONE;

        /**
         * @member SuperMap.ThemeGraph.prototype.items -{Array<SuperMap.ThemeGraphItem>}
         * @description 统计专题图子项集合。必设字段。
         *              统计专题图可以基于多个变量，反映多种属性，即可以将多个专题变量的值绘制在一个统计图上。每一个专题变量对应的统计图即为一个专题图子项。
         *              对于每个专题图子项可以为其设置标题、风格，甚至可以将该子项再制作成范围分段专题图。
         */
        _this.items = null;

        /**
         * @member SuperMap.ThemeGraph.prototype.memoryKeys -{Array<integer>}
         * @description 以内存数组方式制作专题图时的键数组。<br>
         *              键数组内的数值代表 SmID 值，它与 SuperMap.ThemeGraphItem 类中的值数组（SuperMap.ThemeGraphItem.memoryDoubleValues）要关联起来应用。<br>
         *              键数组中数值的个数必须要与值数组的数值个数一致。值数组中的值将代替原来的专题值来制作统计专题图。<br>
         *              目前所有的专题图都支持以内存数组的方式制作专题图，但统计专题图与其他专题图指定内存数组的方式不同，<br>
         *              统计专题图使用 memoryKeys 指定内存数组，而其他专题图则使用 memoryData 来指定内存数组。
         * @example
         *  memoryKeys的使用方法如：
         *   function addThemeGraph() {
        *      removeTheme();
        *        //创建统计专题图对象，SuperMap.ThemeGraph 必设 items。
        *       //专题图参数 ThemeParameters 必设 theme（即以设置好的分段专题图对象）、dataSourceName 和 datasetName
        *      var style1 = new SuperMap.ServerStyle({
        *                   fillForeColor: new SuperMap.ServerColor(92,73,234),
        *                   lineWidth: 0.1
        *               }),
        *               style2 = new SuperMap.ServerStyle({
        *                   fillForeColor: new SuperMap.ServerColor(211,111,240),
        *                   lineWidth: 0.1
        *               }),
        *               item1 = new SuperMap.ThemeGraphItem({
        *                   memoryDoubleValues:[1.18,0.95,0.37,1.31,0.8,1.5],
        *                  caption: "1992-1995人口增长率",
        *                  graphExpression: "Pop_Rate95",
        *                   uniformStyle: style1
        *               }),
        *               item2 = new SuperMap.ThemeGraphItem({
        *               //以内存数组方式制作专题图时的值数组
        *                   memoryDoubleValues:[2.71,0,0.74,3.1,2.2,3.5],
        *                   caption: "1995-1999人口增长率",  //专题图子项的名称
        *                   graphExpression: "Pop_Rate99",  //统计专题图的专题变量
        *                   uniformStyle: style2      //统计专题图子项的显示风格
        *               }),
        *               themeGraph  = new SuperMap.ThemeGraph({
        *               //以内存数组方式制作专题图时的键数组，键数组内的数值代表 SmID 值
        *                    memoryKeys:[1,2,4,8,10,12],
        *                   items: new Array(item1,item2),
        *                   barWidth: 0.03,
        *                    //统计图中地理要素的值与图表尺寸间的映射关系为平方根
        *                   graduatedMode: SuperMap.GraduatedMode.SQUAREROOT,
        *                   //graphAxes用于设置统计图中坐标轴样式相关信息
        *                   graphAxes: new SuperMap.ThemeGraphAxes({
        *                       axesDisplayed: true
        *                   }),
        *                   graphSize: new SuperMap.ThemeGraphSize({
        *                       maxGraphSize: 1,
        *                       minGraphSize: 0.35
        *                   }),
        *                   //统计图上的文字是否可以见以及文字标注风格
        *                   graphText: new SuperMap.ThemeGraphText({
        *                       graphTextDisplayed: true,
        *                       graphTextFormat: SuperMap.ThemeGraphTextFormat.VALUE,
        *                       graphTextStyle: new SuperMap.ServerTextStyle({
        *                           sizeFixed: true,
        *                           fontHeight: 9,
        *                           fontWidth: 5
        *                       })
        *                   }),
        *                   //统计专题图类型为三维柱状图
        *                   graphType: SuperMap.ThemeGraphType.BAR3D
        *               }),
        * //专题图参数对象
        *               themeParameters = new SuperMap.ThemeParameters({
        *                   themes: [themeGraph],
        *                   dataSourceNames: ["Jingjin"],
        *                   datasetNames: ["BaseMap_R"]
        *               }),
        *    //与服务端交互
        *               themeService=new SuperMap.ThemeService(url, {
        *                   eventListeners: {
        *                       "processCompleted": ThemeCompleted,
        *                        "processFailed": themeFailed
        *                  }
        *              });
        *       themeService.processAsync(themeParameters);
        *   }
         */
        _this.memoryKeys = null;

        /**
         * @member SuperMap.ThemeGraph.prototype.negativeDisplayed -{boolean}
         * @description 专题图中是否显示属性为负值的数据。true 表示显示；默认为 false 即不显示。
         */
        _this.negativeDisplayed = false;

        /**
         * @member SuperMap.ThemeGraph.prototype.offset -{SuperMap.ThemeOffset}
         * @description 用于设置统计图相对于要素内点的偏移量。
         */
        _this.offset = new _ThemeOffset.ThemeOffset();

        /**
         * @member SuperMap.ThemeGraph.prototype.overlapAvoided -{boolean}
         * @description 统计图是否采用避让方式显示。<br>
         *              1.对数据集制作统计专题图:当统计图采用避让方式显示时，如果 overlapAvoided 为 true，则在统计图重叠度很大的情况下，
         *              会出现无法完全避免统计图重叠的现象；如果 overlapAvoided 为 false，会过滤掉一些统计图，从而保证所有的统计图均不重叠。<br>
         *              2.对数据集同时制作统计专题图和标签专题图：当统计图不显示子项文本时，标签专题图的标签即使和统计图重叠，两者也都可正常显示；
         *              当统计图显示子项文本时，如果统计图中的子项文本和标签专题图中的标签不重叠，则两者均正常显示；如果重叠，则会过滤掉统计图的子项文本，只显示标签。
         */
        _this.overlapAvoided = true;

        /**
         * @member SuperMap.ThemeGraph.prototype.roseAngle -{number}
         * @description 统计图中玫瑰图或三维玫瑰图用于等分的角度，默认为0度，精确到0.1度。在角度为0或者大于360度的情况下均使用360度来等分制作统计图的字段数。
         */
        _this.roseAngle = 0;

        /**
         * @member SuperMap.ThemeGraph.prototype.startAngle -{number}
         * @description 饼状统计图扇形的起始角度。默认为0度，精确到0.1度，以水平方向为正向。只有选择的统计图类型为饼状图（饼图、三维饼图、玫瑰图、三维玫瑰图）时，此项才可设置。
         */
        _this.startAngle = 0;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeGraph";
        return _this;
    }

    /**
     * @function SuperMap.ThemeGraph.prototype.destroy
     * @override
     */


    _createClass(ThemeGraph, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGraph.prototype.__proto__ || Object.getPrototypeOf(ThemeGraph.prototype), 'destroy', this).call(this);
            var me = this;
            me.barWidth = null;
            if (me.flow) {
                me.flow.destroy();
                me.flow = null;
            }
            me.graduatedMode = null;
            if (me.graphAxes) {
                me.graphAxes.destroy();
                me.graphAxes = null;
            }
            if (me.graphSize) {
                me.graphSize.destroy();
                me.graphSize = null;
            }
            me.graphSizeFixed = null;
            if (me.graphText) {
                me.graphText.destroy();
                me.graphText = null;
            }
            me.graphType = null;
            if (me.items) {
                for (var i = 0, items = me.items, len = items.length; i < len; i++) {
                    items[i].destroy();
                }
                me.items = null;
            }
            me.memoryKeys = null;
            me.negativeDisplayed = null;
            if (me.offset) {
                me.offset.destroy();
                me.offset = null;
            }
            me.overlapAvoided = null;
            me.roseAngle = null;
            me.startAngle = null;
            me.graphAxesTextDisplayMode = null;
        }

        /**
         * @function SuperMap.ThemeGraph.prototype.toJSON
         * @description 将SuperMap.ThemeGraph对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            return _Util.Util.toJSON(this.toServerJSONObject());
        }

        /**
         * @function SuperMap.ThemeGraph.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj.type = this.type;
            if (this.graphText) {
                obj.graphTextDisplayed = this.graphText.graphTextDisplayed;
                obj.graphTextFormat = this.graphText.graphTextFormat;
                obj.graphTextStyle = this.graphText.graphTextStyle;
            }
            if (this.flow) {
                obj.flowEnabled = this.flow.flowEnabled;
                obj.leaderLineDisplayed = this.flow.leaderLineDisplayed;
                obj.leaderLineStyle = this.flow.leaderLineStyle;
            }
            if (this.graphAxes) {
                obj.axesColor = this.graphAxes.axesColor;
                obj.axesDisplayed = this.graphAxes.axesDisplayed;
                obj.axesGridDisplayed = this.graphAxes.axesGridDisplayed;
                obj.axesTextDisplayed = this.graphAxes.axesTextDisplayed;
                obj.axesTextStyle = this.graphAxes.axesTextStyle;
            }
            if (this.graphSize) {
                obj.maxGraphSize = this.graphSize.maxGraphSize;
                obj.minGraphSize = this.graphSize.minGraphSize;
            }
            if (this.offset) {
                obj.offsetFixed = this.offset.offsetFixed;
                obj.offsetX = this.offset.offsetX;
                obj.offsetY = this.offset.offsetY;
            }
            obj.barWidth = this.barWidth;
            obj.graduatedMode = this.graduatedMode;
            obj.graphSizeFixed = this.graphSizeFixed;
            obj.graphType = this.graphType;
            obj.graphAxesTextDisplayMode = this.graphAxesTextDisplayMode;
            obj.items = this.items;
            obj.memoryKeys = this.memoryKeys;
            obj.negativeDisplayed = this.negativeDisplayed;
            obj.overlapAvoided = this.overlapAvoided;
            obj.roseAngle = this.roseAngle;
            obj.startAngle = this.startAngle;
            return obj;
        }

        /**
         * @function SuperMap.ThemeGraph.fromObj
         * @description 从传入对象获取统计专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraph} ThemeGraph对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGraph();
            var itemsG = obj.items;
            var len = itemsG ? itemsG.length : 0;
            _Util.Util.copy(res, obj);
            res.items = [];
            res.flow = _ThemeFlow.ThemeFlow.fromObj(obj);
            res.graphAxes = _ThemeGraphAxes.ThemeGraphAxes.fromObj(obj);
            res.graphSize = _ThemeGraphSize.ThemeGraphSize.fromObj(obj);
            res.graphText = _ThemeGraphText.ThemeGraphText.fromObj(obj);
            res.offset = _ThemeOffset.ThemeOffset.fromObj(obj);
            for (var i = 0; i < len; i++) {
                res.items.push(_ThemeGraphItem.ThemeGraphItem.fromObj(itemsG[i]));
            }
            return res;
        }
    }]);

    return ThemeGraph;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeGraph = ThemeGraph;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeRange = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ThemeRangeItem = __webpack_require__(245);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeRange
 * @classdesc 范围分段专题图。
 * @description 范围分段专题图是按照指定的分段方法（如：等距离分段法）对字段的属性值进行分段，使用不同的颜色或符号（线型、填充）表示不同范围段落的属性值在整体上的分布情况，体现区域的差异。
 *              在分段专题图中，专题值按照某种分段方式被分成多个范围段，要素根据各自的专题值被分配到其中一个范围段中，在同一个范围段中的要素使用相同的颜色，填充，符号等风格进行显示。
 *              分段专题图所基于的专题变量必须为数值型，分段专题图一般用来反映连续分布现象的数量或程度特征，如降水量的分布，土壤侵蚀强度的分布等。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        items - {Array<{@link SuperMap.ThemeRangeItem}>} 分段专题图子项数组。<br>
 *        rangeExpression - {string} 分段字段表达式。<br>
 *        rangeMode - {{@link SuperMap.RangeMode}} 分段专题图的分段模式。<br>
 *        rangeParameter - {number}分段参数。<br>
 *        colorGradientType - {{@link SuperMap.ColorGradientType}} 渐变颜色枚举类。<br>
 *        memoryData - {{@link SuperMap.ThemeMemoryData}} 专题图内存数据。
 */
var ThemeRange = exports.ThemeRange = function (_Theme) {
    _inherits(ThemeRange, _Theme);

    function ThemeRange(options) {
        _classCallCheck(this, ThemeRange);

        /**
         * @member SuperMap.ThemeRange.prototype.precision -{string}
         * @description 精准度
         */
        var _this = _possibleConstructorReturn(this, (ThemeRange.__proto__ || Object.getPrototypeOf(ThemeRange)).call(this, "RANGE", options));

        _this.precision = '1.0E-12';

        /**
         * @member SuperMap.ThemeRange.prototype.items -{Array<SuperMap.ThemeRangeItem>}
         * @description 分段专题图子项数组。<br>
         *              在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。<br>
         *              每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。<br>
         *              如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按照您设置的值对分段结果进行调整。
         */
        _this.items = null;

        /**
         * @member SuperMap.ThemeRange.prototype.rangeExpression -{string}
         * @description 分段字段表达式。<br>
         *              由于范围分段专题图基于各种分段方法根据一定的距离进行分段，因而范围分段专题图所基于的字段值的数据类型必须为数值型。对于字段表达式，只能为数值型的字段间的运算。必设字段。
         */
        _this.rangeExpression = null;

        /**
         * @member SuperMap.ThemeRange.prototype.rangeMode -{SuperMap.RangeMode}
         * @description 分段专题图的分段模式。<br>
         *              默认值为 {@link RangeMode|SuperMap.RangeMode.EQUALINTERVAL}（等距离分段）。
         *              在分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。
         *              目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，
         *              显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
         */
        _this.rangeMode = _REST.RangeMode.EQUALINTERVAL;

        /**
         * @member SuperMap.ThemeRange.prototype.rangeParameter -{number}
         * @description 分段参数。<br>
         *              当分段模式为等距离分段法，平方根分段，对数分段法，计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，
         *              该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。默认值为 -1。
         */
        _this.rangeParameter = 0;

        /**
         * @member SuperMap.ThemeRange.prototype.colorGradientType -{SuperMap.ColorGradientType}
         * @description 渐变颜色枚举类 <br>
         *              渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
         *              该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色
         *              方案完成填*充。但如果为某几个子项的风格进行单独设置后（设置了 {@link SuperMap.ThemeUniqueItem} 或 {@link SuperMap.ThemeRangeItem} 类中Style属性），
         *              该配色方案对于这几个子项将不起作用。
         */
        _this.colorGradientType = _REST.ColorGradientType.YELLOW_RED;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeRange";
        return _this;
    }

    /**
     * @function SuperMap.ThemeRange.prototype.destroy
     * @override
     */


    _createClass(ThemeRange, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeRange.prototype.__proto__ || Object.getPrototypeOf(ThemeRange.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }
            me.rangeExpression = null;
            me.rangeMode = null;
            me.rangeParameter = null;
            me.colorGradientType = null;
        }

        /**
         * @function SuperMap.ThemeRange.fromObj
         * @description 从传入对象获取范围分段专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeRange} ThemeRange对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeRange();
            _Util.Util.copy(res, obj);
            var itemsR = obj.items;
            var len = itemsR ? itemsR.length : 0;
            res.items = [];
            for (var i = 0; i < len; i++) {
                res.items.push(_ThemeRangeItem.ThemeRangeItem.fromObj(itemsR[i]));
            }
            return res;
        }
    }]);

    return ThemeRange;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeRange = ThemeRange;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeUnique = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ServerStyle = __webpack_require__(11);

var _ThemeUniqueItem = __webpack_require__(101);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeUnique
 * @classdesc 单值专题图。
 * @description 单值专题图是利用不同的颜色或符号（线型、填充）表示图层中某一属性信息的不同属性值，属性值相同的要素具有相同的渲染风格。单值专题图多用于具有分类属性的地图上，
 *              比如土壤类型分布图、土地利用图、行政区划图等。单值专题图着重表示现象质的差别，一般不表示数量的特征。尤其是有交叉或重叠现象时，此类不推荐使用，例如：民族分布区等。
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        items - {Array<{@link SuperMap.ThemeUniqueItem}>} 单值专题图子项类数组。<br>
 *        uniqueExpression - {string} 用于制作单值专题图的字段或字段表达式。<br>
 *        defaultStyle - {{@link SuperMap.ServerStyle}} 未参与单值专题图制作的对象的显示风格。<br>
 *        colorGradientType - {{@link SuperMap.ColorGradientType}} 渐变颜色枚举类。<br>
 *        memoryData - {{@link SuperMap.ThemeMemoryData}} 专题图内存数据。
 */
var ThemeUnique = exports.ThemeUnique = function (_Theme) {
    _inherits(ThemeUnique, _Theme);

    function ThemeUnique(options) {
        _classCallCheck(this, ThemeUnique);

        /**
         * @member SuperMap.ThemeUnique.prototype.defaultStyle -{SuperMap.ServerStyle}
         * @description 未参与单值专题图制作的对象的显示风格。<br>
         *              通过单值专题图子项数组 （items）可以指定某些要素参与单值专题图制作，对于那些没有被包含的要素，即不参加单值专题表达的要素，使用该风格显示。
         */
        var _this = _possibleConstructorReturn(this, (ThemeUnique.__proto__ || Object.getPrototypeOf(ThemeUnique)).call(this, "UNIQUE", options));

        _this.defaultStyle = new _ServerStyle.ServerStyle();

        /**
         * @member SuperMap.ThemeUnique.prototype.items -{Array<SuperMap.ThemeUniqueItem>}
         * @description 单值专题图子项类数组。<br>
         *              单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，
         *              Name 字段代表省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有5个专题图子项。
         */
        _this.items = null;

        /**
         * @member SuperMap.ThemeUnique.prototype.uniqueExpression -{string}
         * @description 用于制作单值专题图的字段或字段表达式。<br>
         *              该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必设字段。
         */
        _this.uniqueExpression = null;

        /**
         * @member SuperMap.ThemeUnique.prototype.colorGradientType -{SuperMap.ColorGradientType}
         * @description 渐变颜色枚举类。<br>
         *              渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
         *              该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色方案完成填充。
         *              但如果为某几个子项的风格进行单独设置后（设置了 ThemeUniqueItem 或 ThemeRangeItem 类中Style属性），
         *              该配色方案对于这几个子项将不起作用。
         */
        _this.colorGradientType = _REST.ColorGradientType.YELLOW_RED;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeUnique";
        return _this;
    }

    /**
     * @function SuperMap.ThemeUnique.prototype.destroy
     * @override
     */


    _createClass(ThemeUnique, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeUnique.prototype.__proto__ || Object.getPrototypeOf(ThemeUnique.prototype), 'destroy', this).call(this);
            var me = this;
            me.uniqueExpression = null;
            me.colorGradientType = null;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }

            if (me.defaultStyle) {
                me.defaultStyle.destroy();
                me.defaultStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeUnique.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.defaultStyle) {
                if (obj.defaultStyle.toServerJSONObject) {
                    obj.defaultStyle = obj.defaultStyle.toServerJSONObject();
                }
            }
            if (obj.items) {
                var items = [],
                    len = obj.items.length;
                for (var i = 0; i < len; i++) {
                    items.push(obj.items[i].toServerJSONObject());
                }
                obj.items = items;
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeUnique.fromObj
         * @description 从传入对象获取单值专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeUnique} ThemeUnique对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeUnique();
            var uItems = obj.items;
            var len = uItems ? uItems.length : 0;
            _Util.Util.extend(res, obj);
            res.items = [];
            res.defaultStyle = new _ServerStyle.ServerStyle.fromJson(obj.defaultStyle);
            for (var i = 0; i < len; i++) {
                res.items.push(new _ThemeUniqueItem.ThemeUniqueItem.fromObj(uItems[i]));
            }
            return res;
        }
    }]);

    return ThemeUnique;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeUnique = ThemeUnique;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeUniqueItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerStyle = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeUniqueItem
 * @classdesc 单值专题图子项类。
 * @description 单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，Name 字段代表
 *              省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有5个专题图子项。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 单值专题图子项的标题。<br>
 *        style - {{@link SuperMap.ServerStyle}} 单值专题图子项的风格。<br>
 *        unique - {string} 单值专题图子项的单值。<br>
 *        visible - {boolean} 单值专题图子项是否可见。
 */
var ThemeUniqueItem = exports.ThemeUniqueItem = function () {
    function ThemeUniqueItem(options) {
        _classCallCheck(this, ThemeUniqueItem);

        /**
         * @member SuperMap.ThemeUniqueItem.prototype.caption -{string}
         * @description 单值专题图子项的标题。
         */
        this.caption = null;

        /**
         * @member SuperMap.ThemeUniqueItem.prototype.style -{SuperMap.ServerStyle}
         * @description 单值专题图子项的显示风格。
         */
        this.style = new _ServerStyle.ServerStyle();

        /**
         * @member SuperMap.ThemeUniqueItem.prototype.unique -{string}
         * @description 单值专题图子项的值，可以为数字、字符串等。
         */
        this.unique = null;

        /**
         * @member SuperMap.ThemeUniqueItem.prototype.visible -{boolean}
         * @description 单值专题图子项的可见性。默认为 true，表示可见。
         */
        this.visible = true;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeUniqueItem";
    }

    /**
     * @function SuperMap.ThemeUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeUniqueItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.unique = null;

            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeUniqueItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.style) {
                if (obj.style.toServerJSONObject) {
                    obj.style = obj.style.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeUniqueItem.fromObj
         * @description 从传入对象获取单值专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeUniqueItem} ThemeUniqueItem对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeUniqueItem();
            _Util.Util.copy(res, obj);
            res.style = _ServerStyle.ServerStyle.fromJson(obj.style);
            return res;
        }
    }]);

    return ThemeUniqueItem;
}();

_SuperMap.SuperMap.ThemeUniqueItem = ThemeUniqueItem;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UGCLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Bounds = __webpack_require__(22);

__webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.UGCLayer
 * @classdesc UGC 图层类。
 * @param options - {Object} 可选参数。如：<br>
 *        bounds - {{@link SuperMap.Bounds}} 图层范围。<br>
 *        caption - {string} 图层的标题。<br>
 *        description - {string} 图层的描述信息。<br>
 *        name - {string} 图层的名称。<br>
 *        queryable - {boolean} 图层中的对象是否可以查询。<br>
 *        subUGCLayers - {boolean} 是否允许图层的符号大小随图缩放。<br>
 *        type - {{@link SuperMap.UGCLayerType}} 图层类型。<br>
 *        visible - {boolean} 地图对象在同一范围内时，是否重叠显示，默认为False。
 */
var UGCLayer = exports.UGCLayer = function () {
  function UGCLayer(options) {
    _classCallCheck(this, UGCLayer);

    options = options || {};
    /**
     * @member SuperMap.UGCLayer.prototype.bounds -{SuperMap.Bounds}
     * @description 图层范围。
     */
    this.bounds = null;

    /**
     * @member SuperMap.UGCLayer.prototype.caption -{string}
     * @description 图层的标题。
     */
    this.caption = null;

    /**
     * @member SuperMap.UGCLayer.prototype.description -{string}
     * @description 图层的描述信息。
     */
    this.description = null;

    /**
     * @member SuperMap.UGCLayer.prototype.name -{string}
     * @description 图层的名称。
     */
    this.name = null;

    /**
     * @member SuperMap.UGCLayer.prototype.queryable -{boolean}
     * @description 图层中的对象是否可以查询。
     */
    this.queryable = null;

    /**
     * @member SuperMap.UGCLayer.prototype.subLayers -{Array}
     * @description 子图层集。
     */
    this.subLayers = null;

    /**
     * @member SuperMap.UGCLayer.prototype.type -{SuperMap.UGCLayerType}
     * @description 图层类型。
     */
    this.type = null;

    /**
     * @member SuperMap.UGCLayer.prototype.visible -{boolean}
     * @description 图层是否可视。
     */
    this.visible = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.UGCLayer";
  }

  /**
   * @function SuperMap.UGCLayer.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(UGCLayer, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      _Util.Util.reset(me);
    }

    /**
     * @function SuperMap.UGCLayer.prototype.fromJson
     * @description 将服务端JSON对象转换成当前客户端对象
     * @param jsonObject - {Object} 要转换的 JSON 对象。
     */

  }, {
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      jsonObject = jsonObject ? jsonObject : {};
      _Util.Util.extend(this, jsonObject);
      var b = this.bounds;
      if (b) {
        this.bounds = new _Bounds.Bounds(b.leftBottom.x, b.leftBottom.y, b.rightTop.x, b.rightTop.y);
      }
    }

    /**
     * @function SuperMap.UGCLayer.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @return{Object} 对应的 JSON 格式对象。
     */

  }, {
    key: 'toServerJSONObject',
    value: function toServerJSONObject() {
      var jsonObject = {};
      jsonObject = _Util.Util.copyAttributes(jsonObject, this);
      if (jsonObject.bounds) {
        if (jsonObject.bounds.toServerJSONObject) {
          jsonObject.bounds = jsonObject.bounds.toServerJSONObject();
        }
      }
      return jsonObject;
    }
  }]);

  return UGCLayer;
}();

_SuperMap.SuperMap.UGCLayer = UGCLayer;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Circle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Circle
 * 圆形参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */

var Circle = exports.Circle = function (_ShapeParameters) {
  _inherits(Circle, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Circle
   * 创建一个圆形参数对象。
   *
   * Parameters:
   * x - {Number} 圆心 x 坐标，必设参数。
   * y - {Number} 圆心 y 坐标，必设参数。
   * r - {Number} 圆半径，必设参数。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Circle>} 圆形参数对象。
   */
  function Circle(x, y, r) {
    _classCallCheck(this, Circle);

    /**
     * APIProperty: x
     * {Number} 圆心 x 坐标。
     */
    var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, x, y, r));

    _this.x = !isNaN(x) ? x : 0;

    /**
     * APIProperty: y
     * {Number} 圆心 y 坐标。
     */
    _this.y = !isNaN(y) ? y : 0;

    /**
     * APIProperty: r
     * {Number} 圆半径。
     */
    _this.r = !isNaN(r) ? r : 0;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Circle";
    /**
     * APIProperty: style
     * {Object} 圆形样式对象，可设属性如下：
     *
     * Symbolizer properties:
     * brushType - {string} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {string} 填充颜色,默认值"#000000"
     * strokeColor - {string} 描边颜色,默认值为'#000000'
     * lineCape — {string} 线帽样式，可以是 butt, round, square，默认是butt
     * lineWidth - {number} 描边宽度、默认是1
     * opacity - {number} 绘制透明度、默认是1，不透明
     * shadowBlur - {number} 阴影模糊度，大于0有效，默认是0
     * shadowColor - {string} 阴影颜色，默认是'#000000'
     * shadowOffsetX - {number} 阴影横向偏移，默认是0
     * shadowOffsetY - {number} 阴影纵向偏移，默认是0
     */

    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Circle, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.r = null;
      _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), 'destroy', this).call(this);
    }
  }]);

  return Circle;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Circle = Circle;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Line = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Line
 * 线参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Line = exports.Line = function (_ShapeParameters) {
  _inherits(Line, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Line
   * 创建一个图形线参数对象。
   *
   * Parameters:
   * pointList - {Array} 线要素节点数组，二维数组，必设参数。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Line>} 图形线参数对象。
   */
  function Line(pointList) {
    _classCallCheck(this, Line);

    /**
     * APIProperty: pointList
     * {Array} 线要素节点数组，二维数组。
     *
     * 数组形如：
     * (start code)
     *  [
     *  [10, 20],         //节点
     *  [30, 40],
     *  [25, 30]         //最后一个节点和第一个节点不必相同，绘制时自动封闭
     *   ]
     * (end)
     */
    var _this = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, pointList));

    _this.pointList = pointList;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Line";

    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Line, [{
    key: 'destroy',
    value: function destroy() {
      this.pointList = null;
      _get(Line.prototype.__proto__ || Object.getPrototypeOf(Line.prototype), 'destroy', this).call(this);
    }
  }]);

  return Line;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Line = Line;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Color = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(29);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Color
 * LevelRenderer 工具-颜色辅助类
 *
 */
var Color = exports.Color = function () {
    function Color() {
        _classCallCheck(this, Color);

        /**
         * Property: util
         * {<SuperMap.LevelRenderer.Tool.Util>} LevelRenderer 基础工具对象
         */
        this.util = new _Util.Util();

        /**
         * Property: _ctx
         * {Object} _ctx
         */
        this._ctx = null;

        /**
         * Property: palette
         * {Array} 默认色板
         * 色板是一个包含图表默认颜色系列的数组，当色板中所有颜色被使用过后，又将从新回到色板中的第一个颜色。
         *
         * [
         * '#ff9277', '#dddd00', '#ffc877', '#bbe3ff', '#d5ffbb', '#bbbbff', '#ddb000', '#b0dd00', '#e2bbff', '#ffbbe3',
         * '#ff7777', '#ff9900', '#83dd00', '#77e3ff', '#778fff', '#c877ff', '#ff77ab', '#ff6600', '#aa8800', '#77c7ff',  '
         * #ad77ff', '#ff77ff', '#dd0083', '#777700', '#00aa00', '#0088aa', '#8400dd', '#aa0088', '#dd0000', '#772e00'
         * ];
         */
        this.palette = ['#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb', '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3', '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff', '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff', '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00', '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'];

        /**
         * Property: _palette
         * {Array} 复位色板，用于复位  palette
         */
        this._palette = this.palette;

        /**
         * Property: highlightColor
         * {String} 高亮色
         */
        this.highlightColor = 'rgba(0,0,255,1)';

        /**
         * Property: _highlightColor
         * {String} 复位高亮色
         */
        this._highlightColor = this.highlightColor;

        /**
         * Property: colorRegExp
         * {String} 颜色格式，正则表达式。
         */
        this.colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

        /**
         * Property: _nameColors
         * {String} 颜色名。
         */
        this._nameColors = {
            aliceblue: '#f0f8ff',
            antiquewhite: '#faebd7',
            aqua: '#0ff',
            aquamarine: '#7fffd4',
            azure: '#f0ffff',
            beige: '#f5f5dc',
            bisque: '#ffe4c4',
            black: '#000',
            blanchedalmond: '#ffebcd',
            blue: '#00f',
            blueviolet: '#8a2be2',
            brown: '#a52a2a',
            burlywood: '#deb887',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            cornflowerblue: '#6495ed',
            cornsilk: '#fff8dc',
            crimson: '#dc143c',
            cyan: '#0ff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkgray: '#a9a9a9',
            darkgrey: '#a9a9a9',
            darkgreen: '#006400',
            darkkhaki: '#bdb76b',
            darkmagenta: '#8b008b',
            darkolivegreen: '#556b2f',
            darkorange: '#ff8c00',
            darkorchid: '#9932cc',
            darkred: '#8b0000',
            darksalmon: '#e9967a',
            darkseagreen: '#8fbc8f',
            darkslateblue: '#483d8b',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            darkturquoise: '#00ced1',
            darkviolet: '#9400d3',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            dimgray: '#696969',
            dimgrey: '#696969',
            dodgerblue: '#1e90ff',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            forestgreen: '#228b22',
            fuchsia: '#f0f',
            gainsboro: '#dcdcdc',
            ghostwhite: '#f8f8ff',
            gold: '#ffd700',
            goldenrod: '#daa520',
            gray: '#808080',
            grey: '#808080',
            green: '#008000',
            greenyellow: '#adff2f',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            ivory: '#fffff0',
            khaki: '#f0e68c',
            lavender: '#e6e6fa',
            lavenderblush: '#fff0f5',
            lawngreen: '#7cfc00',
            lemonchiffon: '#fffacd',
            lightblue: '#add8e6',
            lightcoral: '#f08080',
            lightcyan: '#e0ffff',
            lightgoldenrodyellow: '#fafad2',
            lightgray: '#d3d3d3',
            lightgrey: '#d3d3d3',
            lightgreen: '#90ee90',
            lightpink: '#ffb6c1',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            lightskyblue: '#87cefa',
            lightslategray: '#789',
            lightslategrey: '#789',
            lightsteelblue: '#b0c4de',
            lightyellow: '#ffffe0',
            lime: '#0f0',
            limegreen: '#32cd32',
            linen: '#faf0e6',
            magenta: '#f0f',
            maroon: '#800000',
            mediumaquamarine: '#66cdaa',
            mediumblue: '#0000cd',
            mediumorchid: '#ba55d3',
            mediumpurple: '#9370d8',
            mediumseagreen: '#3cb371',
            mediumslateblue: '#7b68ee',
            mediumspringgreen: '#00fa9a',
            mediumturquoise: '#48d1cc',
            mediumvioletred: '#c71585',
            midnightblue: '#191970',
            mintcream: '#f5fffa',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            navajowhite: '#ffdead',
            navy: '#000080',
            oldlace: '#fdf5e6',
            olive: '#808000',
            olivedrab: '#6b8e23',
            orange: '#ffa500',
            orangered: '#ff4500',
            orchid: '#da70d6',
            palegoldenrod: '#eee8aa',
            palegreen: '#98fb98',
            paleturquoise: '#afeeee',
            palevioletred: '#d87093',
            papayawhip: '#ffefd5',
            peachpuff: '#ffdab9',
            peru: '#cd853f',
            pink: '#ffc0cb',
            plum: '#dda0dd',
            powderblue: '#b0e0e6',
            purple: '#800080',
            red: '#f00',
            rosybrown: '#bc8f8f',
            royalblue: '#4169e1',
            saddlebrown: '#8b4513',
            salmon: '#fa8072',
            sandybrown: '#f4a460',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            sienna: '#a0522d',
            silver: '#c0c0c0',
            skyblue: '#87ceeb',
            slateblue: '#6a5acd',
            slategray: '#708090',
            slategrey: '#708090',
            snow: '#fffafa',
            springgreen: '#00ff7f',
            steelblue: '#4682b4',
            tan: '#d2b48c',
            teal: '#008080',
            thistle: '#d8bfd8',
            tomato: '#ff6347',
            turquoise: '#40e0d0',
            violet: '#ee82ee',
            wheat: '#f5deb3',
            white: '#fff',
            whitesmoke: '#f5f5f5',
            yellow: '#ff0',
            yellowgreen: '#9acd32'
        };

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Color";
    }

    /**
     * APIMethod: customPalette
     * 自定义调色板。
     *
     * Parameters:
     * userPalete - {Array} 颜色板。
     */


    _createClass(Color, [{
        key: 'customPalette',
        value: function customPalette(userPalete) {
            this.palette = userPalete;
        }

        /**
         * APIMethod: resetPalette
         * 复位默认色板。
         *
         */

    }, {
        key: 'resetPalette',
        value: function resetPalette() {
            this.palette = this._palette;
        }

        /**
         * APIMethod: getColor
         * 获取色板颜色。
         *
         * Parameters:
         * idx - {Number} 色板位置。
         * userPalete - {Array} 色板。
         *
         * Returns:
         * {String} 颜色值。
         */

    }, {
        key: 'getColor',
        value: function getColor(idx, userPalete) {
            idx = idx | 0;
            userPalete = userPalete || this.palette;
            return userPalete[idx % userPalete.length];
        }

        /**
         * APIMethod: customHighlight
         * 自定义默认高亮颜色。
         *
         * Parameters:
         * userHighlightColor - {String} 自定义高亮色。
         */

    }, {
        key: 'customHighlight',
        value: function customHighlight(userHighlightColor) {
            this.highlightColor = userHighlightColor;
        }

        /**
         * APIMethod: resetHighlight
         * 重置默认高亮颜色。将当前的高亮色作为默认高亮颜色
         *
         */

    }, {
        key: 'resetHighlight',
        value: function resetHighlight() {
            this.highlightColor = this._highlightColor;
        }

        /**
         * APIMethod: getHighlightColor
         * 获取默认高亮颜色
         *
         * Returns:
         * {String} 颜色值。
         */

    }, {
        key: 'getHighlightColor',
        value: function getHighlightColor() {
            return this.highlightColor;
        }

        /**
         * APIMethod: getRadialGradient
         * 径向渐变。
         *
         * Parameters:
         * x0 - {Number} 渐变起点。
         * y0 - {Number}
         * r0 - {Number}
         * x1 - {Number} 渐变终点。
         * y1 - {Number}
         * r1 - {Number}
         * colorList - {Array} 颜色列表。
         *
         * Returns:
         * {CanvasGradient} Cavans 渐变颜色。
         */

    }, {
        key: 'getRadialGradient',
        value: function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
            var util = this.util;

            if (!this._ctx) {
                this._ctx = util.getContext();
            }
            var gradient = this._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
            for (var i = 0, l = colorList.length; i < l; i++) {

                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * APIMethod: getLinearGradient
         * 线性渐变。
         *
         * Parameters:
         * x0 - {Number} 渐变起点。
         * y0 - {Number}
         * x1 - {Number} 渐变终点。
         * y1 - {Number}
         * colorList - {Array} 颜色列表。
         *
         * Returns:
         * {CanvasGradient} Cavans 渐变颜色。
         */

    }, {
        key: 'getLinearGradient',
        value: function getLinearGradient(x0, y0, x1, y1, colorList) {
            var util = this.util;

            if (!this._ctx) {
                this._ctx = util.getContext();
            }
            var gradient = this._ctx.createLinearGradient(x0, y0, x1, y1);
            for (var i = 0, l = colorList.length; i < l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * APIMethod: getStepColors
         * 获取两种颜色之间渐变颜色数组。
         *
         * Parameters:
         * start - {color} 起始颜色。
         * end - {color} 结束颜色。
         * step - {Number} 渐变级数。
         * colorList - {Array} 颜色列表。
         *
         * Returns:
         * {Array} 颜色数组。
         */

    }, {
        key: 'getStepColors',
        value: function getStepColors(start, end, step) {
            start = this.toRGBA(start);
            end = this.toRGBA(end);
            start = this.getData(start);
            end = this.getData(end);

            var colors = [];
            var stepR = (end[0] - start[0]) / step;
            var stepG = (end[1] - start[1]) / step;
            var stepB = (end[2] - start[2]) / step;
            var stepA = (end[3] - start[3]) / step;
            // 生成颜色集合
            // fix by linfeng 颜色堆积
            for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {
                colors[i] = this.toColor([this.adjust(Math.floor(r), [0, 255]), this.adjust(Math.floor(g), [0, 255]), this.adjust(Math.floor(b), [0, 255]), a.toFixed(4) - 0], 'rgba');
                r += stepR;
                g += stepG;
                b += stepB;
                a += stepA;
            }
            r = end[0];
            g = end[1];
            b = end[2];
            a = end[3];
            colors[i] = this.toColor([r, g, b, a], 'rgba');
            return colors;
        }

        /**
         * APIMethod: getGradientColors
         * 获取指定级数的渐变颜色数组。
         *
         * Parameters:
         * colors - {Array{String}} 颜色组。
         * step - {Number}  渐变级数，默认值 20。
         *
         * Returns:
         * {Array{String}} 颜色数组。
         */

    }, {
        key: 'getGradientColors',
        value: function getGradientColors(colors, step) {
            var ret = [];
            var len = colors.length;
            if (step === undefined) {
                step = 20;
            }
            if (len === 1) {
                ret = this.getStepColors(colors[0], colors[0], step);
            } else if (len > 1) {
                for (var i = 0, n = len - 1; i < n; i++) {
                    var steps = this.getStepColors(colors[i], colors[i + 1], step);
                    if (i < n - 1) {
                        steps.pop();
                    }
                    ret = ret.concat(steps);
                }
            }
            return ret;
        }

        /**
         * APIMethod: toColor
         *  颜色值数组转为指定格式颜色。
         *
         * Parameters:
         * data - {Array} 颜色值数组。
         * format - {String}  格式，默认rgb
         *
         * Returns:
         * {String} 颜色。
         */

    }, {
        key: 'toColor',
        value: function toColor(data, format) {
            format = format || 'rgb';
            if (data && (data.length === 3 || data.length === 4)) {
                data = this.map(data, function (c) {
                    return c > 1 ? Math.ceil(c) : c;
                });

                if (format.indexOf('hex') > -1) {
                    return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + +data[2]).toString(16).slice(1);
                } else if (format.indexOf('hs') > -1) {
                    var sx = this.map(data.slice(1, 3), function (c) {
                        return c + '%';
                    });
                    data[1] = sx[0];
                    data[2] = sx[1];
                }

                if (format.indexOf('a') > -1) {
                    if (data.length === 3) {
                        data.push(1);
                    }
                    data[3] = this.adjust(data[3], [0, 1]);
                    return format + '(' + data.slice(0, 4).join(',') + ')';
                }

                return format + '(' + data.slice(0, 3).join(',') + ')';
            }
        }

        /**
         * APIMethod: toArray
         *  颜色字符串转换为rgba数组。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {Array{Number}} 颜色值数组。
         */

    }, {
        key: 'toArray',
        value: function toArray(color) {
            color = this.trim(color);
            if (color.indexOf('rgba') < 0) {
                color = this.toRGBA(color);
            }

            var data = [];
            var i = 0;
            color.replace(/[\d.]+/g, function (n) {
                if (i < 3) {
                    n = n | 0;
                } else {
                    // Alpha
                    n = +n;
                }
                data[i++] = n;
            });
            return data;
        }

        /**
         * APIMethod: convert
         *  颜色格式转化。
         *
         * Parameters:
         * color - {String} 颜色值数组。
         * format - {String} 格式，默认rgb
         *
         * Returns:
         * {String} 颜色。
         */

    }, {
        key: 'convert',
        value: function convert(color, format) {
            if (!this.isCalculableColor(color)) {
                return color;
            }
            var data = this.getData(color);
            var alpha = data[3];
            if (typeof alpha === 'undefined') {
                alpha = 1;
            }

            if (color.indexOf('hsb') > -1) {
                data = this._HSV_2_RGB(data);
            } else if (color.indexOf('hsl') > -1) {
                data = this._HSL_2_RGB(data);
            }

            if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {
                data = this._RGB_2_HSB(data);
            } else if (format.indexOf('hsl') > -1) {
                data = this._RGB_2_HSL(data);
            }

            data[3] = alpha;

            return this.toColor(data, format);
        }

        /**
         * APIMethod: toRGBA
         *  转换为rgba格式的颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} rgba颜色，rgba(rgba)。
         */

    }, {
        key: 'toRGBA',
        value: function toRGBA(color) {
            return this.convert(color, 'rgba');
        }

        /**
         * APIMethod: toRGB
         *  转换为rgb数字格式的颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} rgb颜色，rgb(000)格式
         */

    }, {
        key: 'toRGB',
        value: function toRGB(color) {
            return this.convert(color, 'rgb');
        }

        /**
         * APIMethod: toHex
         *  转换为16进制颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} 16进制颜色，#rrggbb格式
         */

    }, {
        key: 'toHex',
        value: function toHex(color) {
            return this.convert(color, 'hex');
        }

        /**
         * APIMethod: toHSVA
         *  转换为HSV颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} HSVA颜色，hsva(hsva)
         */

    }, {
        key: 'toHSVA',
        value: function toHSVA(color) {
            return this.convert(color, 'hsva');
        }

        /**
         * APIMethod: toHSV
         *  转换为HSV颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} HSV颜色，hsv(hsv)
         */

    }, {
        key: 'toHSV',
        value: function toHSV(color) {
            return this.convert(color, 'hsv');
        }

        /**
         * APIMethod: toHSBA
         *  转换为HSBA颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} HSBA颜色，hsba(hsba)
         */

    }, {
        key: 'toHSBA',
        value: function toHSBA(color) {
            return this.convert(color, 'hsba');
        }

        /**
         * APIMethod: toHSB
         *  转换为HSB颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} HSB颜色，hsb(hsb)
         */

    }, {
        key: 'toHSB',
        value: function toHSB(color) {
            return this.convert(color, 'hsb');
        }

        /**
         * APIMethod: toHSLA
         *  转换为HSLA颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} HSLA颜色，hsla(hsla)
         */

    }, {
        key: 'toHSLA',
        value: function toHSLA(color) {
            return this.convert(color, 'hsla');
        }

        /**
         * APIMethod: toHSL
         *  转换为HSL颜色。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} HSL颜色，hsl(hsl)
         */

    }, {
        key: 'toHSL',
        value: function toHSL(color) {
            return this.convert(color, 'hsl');
        }

        /**
         * APIMethod: toName
         * 转换颜色名。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} 颜色名
         */

    }, {
        key: 'toName',
        value: function toName(color) {
            for (var key in this._nameColors) {
                if (this.toHex(this._nameColors[key]) === this.toHex(color)) {
                    return key;
                }
            }
            return null;
        }

        /**
         * APIMethod: trim
         * 移除颜色中多余空格。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} 无空格颜色
         */

    }, {
        key: 'trim',
        value: function trim(color) {
            return String(color).replace(/\s+/g, '');
        }

        /**
         * APIMethod: normalize
         * 颜色规范化。
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} 规范化后的颜色
         */

    }, {
        key: 'normalize',
        value: function normalize(color) {
            // 颜色名
            if (this._nameColors[color]) {
                color = this._nameColors[color];
            }
            // 去掉空格
            color = this.trim(color);
            // hsv与hsb等价
            color = color.replace(/hsv/i, 'hsb');
            // rgb转为rrggbb
            if (/^#[\da-f]{3}$/i.test(color)) {
                color = parseInt(color.slice(1), 16);
                var r = (color & 0xf00) << 8;
                var g = (color & 0xf0) << 4;
                var b = color & 0xf;

                color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
            }
            // 或者使用以下正则替换，不过 chrome 下性能相对差点
            // color = color.replace(/^#([\da-f])([\da-f])([\da-f])$/i, '#$1$1$2$2$3$3');
            return color;
        }

        /**
         * APIMethod: lift
         * 颜色加深或减淡，当level>0加深，当level<0减淡。
         *
         * Parameters:
         * color - {String} 颜色。
         * level - {Number} 升降程度取值区间[-11]。
         *
         * Returns:
         * {String} 加深或减淡后颜色值
         */

    }, {
        key: 'lift',
        value: function lift(color, level) {
            if (!this.isCalculableColor(color)) {
                return color;
            }
            var direct = level > 0 ? 1 : -1;
            if (typeof level === 'undefined') {
                level = 0;
            }
            level = Math.abs(level) > 1 ? 1 : Math.abs(level);
            color = this.toRGB(color);
            var data = this.getData(color);
            for (var i = 0; i < 3; i++) {
                if (direct === 1) {
                    data[i] = data[i] * (1 - level) | 0;
                } else {
                    data[i] = (255 - data[i]) * level + data[i] | 0;
                }
            }
            return 'rgb(' + data.join(',') + ')';
        }

        /**
         * APIMethod: reverse
         * 颜色翻转[255-r255-g255-b1-a]
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {String} 翻转颜色
         */

    }, {
        key: 'reverse',
        value: function reverse(color) {
            if (!this.isCalculableColor(color)) {
                return color;
            }
            var data = this.getData(this.toRGBA(color));
            data = this.map(data, function (c) {
                return 255 - c;
            });
            return this.toColor(data, 'rgb');
        }

        /**
         * APIMethod: mix
         * 简单两种颜色混合
         *
         * Parameters:
         * color1 - {String} 第一种颜色。
         * color2 - {String} 第二种颜色。
         * weight - {Number} 混合权重[0-1]。
         *
         * Returns:
         * {String} 结果色rgb(rgb)或rgba(rgba)
         */

    }, {
        key: 'mix',
        value: function mix(color1, color2, weight) {
            if (!this.isCalculableColor(color1) || !this.isCalculableColor(color2)) {
                return color1;
            }

            if (typeof weight === 'undefined') {
                weight = 0.5;
            }
            weight = 1 - this.adjust(weight, [0, 1]);

            var w = weight * 2 - 1;
            var data1 = this.getData(this.toRGBA(color1));
            var data2 = this.getData(this.toRGBA(color2));

            var d = data1[3] - data2[3];

            var weight1 = ((w * d === -1 ? w : (w + d) / (1 + w * d)) + 1) / 2;
            var weight2 = 1 - weight1;

            var data = [];

            for (var i = 0; i < 3; i++) {
                data[i] = data1[i] * weight1 + data2[i] * weight2;
            }

            var alpha = data1[3] * weight + data2[3] * (1 - weight);
            alpha = Math.max(0, Math.min(1, alpha));

            if (data1[3] === 1 && data2[3] === 1) {
                // 不考虑透明度
                return this.toColor(data, 'rgb');
            }
            data[3] = alpha;
            return this.toColor(data, 'rgba');
        }

        /**
         * APIMethod: random
         * 随机颜色
         *
         * Returns:
         * {String} 颜色值，#rrggbb格式
         */

    }, {
        key: 'random',
        value: function random() {
            return '#' + Math.random().toString(16).slice(2, 8);
        }

        /**
         * APIMethod: getData
         * 获取颜色值数组返回值范围:
         *
         * RGB 范围[0-255]
         *
         * HSL/HSV/HSB 范围[0-1]
         *
         * A透明度范围[0-1]
         *
         * 支持格式：
         *
         * #rgb
         *
         * #rrggbb
         *
         * rgb(rgb)
         *
         * rgb(r%g%b%)
         *
         * rgba(rgba)
         *
         * hsb(hsb) // hsv与hsb等价
         *
         * hsb(h%s%b%)
         *
         * hsba(hsba)
         *
         * hsl(hsl)
         *
         * hsl(h%s%l%)
         *
         * hsla(hsla)
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {Array{Number}} 颜色值数组或null
         */

    }, {
        key: 'getData',
        value: function getData(color) {
            color = this.normalize(color);
            var r = color.match(this.colorRegExp);
            if (r === null) {
                throw new Error('The color format error'); // 颜色格式错误
            }
            var d;
            var a;
            var data = [];
            var rgb;

            if (r[2]) {
                // #rrggbb
                d = r[2].replace('#', '').split('');
                rgb = [d[0] + d[1], d[2] + d[3], d[4] + d[5]];
                data = this.map(rgb, function (c) {
                    return Color.prototype.adjust.call(this, parseInt(c, 16), [0, 255]);
                });
            } else if (r[4]) {
                // rgb rgba
                var rgba = r[4].split(',');
                a = rgba[3];
                rgb = rgba.slice(0, 3);
                data = this.map(rgb, function (c) {
                    c = Math.floor(c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c);
                    return Color.prototype.adjust.call(this, c, [0, 255]);
                });

                if (typeof a !== 'undefined') {
                    data.push(this.adjust(parseFloat(a), [0, 1]));
                }
            } else if (r[5] || r[6]) {
                // hsb hsba hsl hsla
                var hsxa = (r[5] || r[6]).split(',');
                var h = parseInt(hsxa[0], 0) / 360;
                var s = hsxa[1];
                var x = hsxa[2];
                a = hsxa[3];
                data = this.map([s, x], function (c) {
                    return Color.prototype.adjust.call(this, parseFloat(c) / 100, [0, 1]);
                });
                data.unshift(h);
                if (typeof a !== 'undefined') {
                    data.push(this.adjust(parseFloat(a), [0, 1]));
                }
            }
            return data;
        }

        /**
         * APIMethod: alpha
         * 设置颜色透明度
         *
         * Parameters:
         * color - {String} 颜色。
         * a - {Number} 透明度区间[01]。
         *
         * Returns:
         * {String} rgba颜色值
         */

    }, {
        key: 'alpha',
        value: function alpha(color, a) {
            if (!this.isCalculableColor(color)) {
                return color;
            }
            if (a === null) {
                a = 1;
            }
            var data = this.getData(this.toRGBA(color));
            data[3] = this.adjust(Number(a).toFixed(4), [0, 1]);

            return this.toColor(data, 'rgba');
        }

        /**
         * APIMethod: map
         * 数组映射
         *
         * Parameters:
         * array - {String} 数组。
         * fun - {Number} 函数。
         *
         * Returns:
         * {String} 数组映射结果
         */

    }, {
        key: 'map',
        value: function map(array, fun) {
            if (typeof fun !== 'function') {
                throw new TypeError();
            }
            var len = array ? array.length : 0;
            for (var i = 0; i < len; i++) {
                array[i] = fun(array[i]);
            }
            return array;
        }

        /**
         * APIMethod: adjust
         * 调整值区间
         *
         * Parameters:
         * value - {Number} 数组。
         * region - {Array(Number)} 区间。
         *
         * Returns:
         * {Number} 调整后的值
         */

    }, {
        key: 'adjust',
        value: function adjust(value, region) {
            // < to <= & > to >=
            // modify by linzhifeng 2014-05-25 because -0 == 0
            if (value <= region[0]) {
                value = region[0];
            } else if (value >= region[1]) {
                value = region[1];
            }
            return value;
        }

        /**
         * APIMethod: isCalculableColor
         * 判断是否是可计算的颜色
         *
         * Parameters:
         * color - {String} 颜色。
         *
         * Returns:
         * {Boolean} 是否是可计算的颜色
         */

    }, {
        key: 'isCalculableColor',
        value: function isCalculableColor(color) {
            return color instanceof Array || typeof color === 'string';
        }

        /**
         * APIMethod: _HSV_2_RGB
         * 参见 http:// www.easyrgb.com/index.php?X=MATH
         */

    }, {
        key: '_HSV_2_RGB',
        value: function _HSV_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var V = data[2];
            // HSV from 0 to 1
            var R;
            var G;
            var B;
            if (S === 0) {
                R = V * 255;
                G = V * 255;
                B = V * 255;
            } else {
                var h = H * 6;
                if (h === 6) {
                    h = 0;
                }
                var i = h | 0;
                var v1 = V * (1 - S);
                var v2 = V * (1 - S * (h - i));
                var v3 = V * (1 - S * (1 - (h - i)));
                var r = 0;
                var g = 0;
                var b = 0;

                if (i === 0) {
                    r = V;
                    g = v3;
                    b = v1;
                } else if (i === 1) {
                    r = v2;
                    g = V;
                    b = v1;
                } else if (i === 2) {
                    r = v1;
                    g = V;
                    b = v3;
                } else if (i === 3) {
                    r = v1;
                    g = v2;
                    b = V;
                } else if (i === 4) {
                    r = v3;
                    g = v1;
                    b = V;
                } else {
                    r = V;
                    g = v1;
                    b = v2;
                }

                // RGB results from 0 to 255
                R = r * 255;
                G = g * 255;
                B = b * 255;
            }
            return [R, G, B];
        }

        /**
         * APIMethod: _HSL_2_RGB
         * 参见 http:// www.easyrgb.com/index.php?X=MATH
         */

    }, {
        key: '_HSL_2_RGB',
        value: function _HSL_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var L = data[2];
            // HSL from 0 to 1
            var R;
            var G;
            var B;
            if (S === 0) {
                R = L * 255;
                G = L * 255;
                B = L * 255;
            } else {
                var v2;
                if (L < 0.5) {
                    v2 = L * (1 + S);
                } else {
                    v2 = L + S - S * L;
                }

                var v1 = 2 * L - v2;

                R = 255 * this._HUE_2_RGB(v1, v2, H + 1 / 3);
                G = 255 * this._HUE_2_RGB(v1, v2, H);
                B = 255 * this._HUE_2_RGB(v1, v2, H - 1 / 3);
            }
            return [R, G, B];
        }

        /**
         * APIMethod: _HUE_2_RGB
         * 参见 http:// www.easyrgb.com/index.php?X=MATH
         */

    }, {
        key: '_HUE_2_RGB',
        value: function _HUE_2_RGB(v1, v2, vH) {
            if (vH < 0) {
                vH += 1;
            }
            if (vH > 1) {
                vH -= 1;
            }
            if (6 * vH < 1) {
                return v1 + (v2 - v1) * 6 * vH;
            }
            if (2 * vH < 1) {
                return v2;
            }
            if (3 * vH < 2) {
                return v1 + (v2 - v1) * (2 / 3 - vH) * 6;
            }
            return v1;
        }

        /**
         * APIMethod: _RGB_2_HSB
         * 参见 http:// www.easyrgb.com/index.php?X=MATH
         */

    }, {
        key: '_RGB_2_HSB',
        value: function _RGB_2_HSB(data) {
            // RGB from 0 to 255
            var R = data[0] / 255;
            var G = data[1] / 255;
            var B = data[2] / 255;

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value
            var V = vMax;
            var H;
            var S;

            // HSV results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                S = delta / vMax;

                var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
                var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
                var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = 1 / 3 + deltaR - deltaB;
                } else if (B === vMax) {
                    H = 2 / 3 + deltaG - deltaR;
                }

                if (H < 0) {
                    H += 1;
                }
                if (H > 1) {
                    H -= 1;
                }
            }
            H = H * 360;
            S = S * 100;
            V = V * 100;
            return [H, S, V];
        }

        /**
         * APIMethod: _RGB_2_HSL
         * 参见 http:// www.easyrgb.com/index.php?X=MATH
         */

    }, {
        key: '_RGB_2_HSL',
        value: function _RGB_2_HSL(data) {

            // RGB from 0 to 255
            var R = data[0] / 255;
            var G = data[1] / 255;
            var B = data[2] / 255;

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value

            var L = (vMax + vMin) / 2;
            var H;
            var S;
            // HSL results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                if (L < 0.5) {
                    S = delta / (vMax + vMin);
                } else {
                    S = delta / (2 - vMax - vMin);
                }

                var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
                var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
                var deltaB = ((vMax - B) / 6 + delta / 2) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = 1 / 3 + deltaR - deltaB;
                } else if (B === vMax) {
                    H = 2 / 3 + deltaG - deltaR;
                }

                if (H < 0) {
                    H += 1;
                }

                if (H > 1) {
                    H -= 1;
                }
            }

            H = H * 360;
            S = S * 100;
            L = L * 100;

            return [H, S, L];
        }
    }]);

    return Color;
}();

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicBrokenLine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

var _SmicPolygon = __webpack_require__(80);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicBrokenLine
 * 折线(ic)。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicBrokenLine({
 *         style: {
 *             pointList: [[0, 0], [100, 100], [100, 0]],
 *             smooth: 'bezier',
 *             strokeColor: 'purple'
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicBrokenLine = exports.SmicBrokenLine = function (_Shape) {
    _inherits(SmicBrokenLine, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * pointList - {Array} 节点数组，二维数组。默认值：null，必设参数。其形式如下：
     * (code)
     * (start code)
     *  [
     *  [10, 20],         //单个节点
     *  [30, 40],
     *  [25, 30]
     *   ]
     * (end)
     * smooth - {string} 是否做平滑插值, 平滑算法可以选择 "bezier", "spline"。默认值："";
     * smoothConstraint - {Number} 平滑约束。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style

    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicBrokenLine
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicBrokenLine(options) {
        _classCallCheck(this, SmicBrokenLine);

        /**
         * Property: brushTypeOnly
         * {String}  线条只能描边。
         */
        var _this = _possibleConstructorReturn(this, (SmicBrokenLine.__proto__ || Object.getPrototypeOf(SmicBrokenLine)).call(this, options));

        _this.brushTypeOnly = 'stroke';

        /**
         * Property: textPosition
         * {String} 文本位置。
         */
        _this.textPosition = 'end';

        /**
         * Property: type
         * {String} 图形类型.
         */
        _this.type = 'smicbroken-line';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }

        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicBrokenLine";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicBrokenLine, [{
        key: 'destroy',
        value: function destroy() {
            this.brushTypeOnly = null;
            this.textPosition = null;
            this.type = null;

            _get(SmicBrokenLine.prototype.__proto__ || Object.getPrototypeOf(SmicBrokenLine.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建折线路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }

            var __OP = this.refOriginalPosition;

            var pointList = style.pointList;
            if (pointList.length < 2) {
                // 少于2个点就不画了~
                return;
            }

            var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));

            if (style.smooth && style.smooth !== 'spline') {
                var controlPoints = _SUtil.SUtil.SUtil_smoothBezier(pointList, style.smooth, false, style.smoothConstraint, __OP);

                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                var cp1;
                var cp2;
                var p;
                for (var _i = 0; _i < len - 1; _i++) {
                    cp1 = controlPoints[_i * 2];
                    cp2 = controlPoints[_i * 2 + 1];
                    p = [pointList[_i + 1][0] + __OP[0], pointList[_i + 1][1] + __OP[1]];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
            } else {
                if (style.smooth === 'spline') {
                    pointList = _SUtil.SUtil.SUtil_smoothSpline(pointList, null, null, __OP);
                    len = pointList.length;
                }
                if (!style.lineType || style.lineType === 'solid') {
                    // 默认为实线
                    ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                    for (var _i2 = 1; _i2 < len; _i2++) {
                        ctx.lineTo(pointList[_i2][0] + __OP[0], pointList[_i2][1] + __OP[1]);
                    }
                } else if (style.lineType === 'dashed' || style.lineType === 'dotted' || style.lineType === 'dot' || style.lineType === 'dash' || style.lineType === 'longdash') {
                    var dashLength = style.lineWidth || 1;
                    var pattern1 = dashLength;
                    var pattern2 = dashLength;

                    //dashed
                    if (style.lineType === 'dashed') {
                        pattern1 *= 5;
                        pattern2 *= 5;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 -= dashLength;
                            pattern2 += dashLength;
                        }
                    }

                    //dotted
                    if (style.lineType === 'dotted') {
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 = 1;
                            pattern2 += dashLength;
                        }
                    }

                    //dot
                    if (style.lineType === 'dot') {
                        pattern2 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 = 1;
                            pattern2 += dashLength;
                        }
                    }

                    //dash
                    if (style.lineType === 'dash') {
                        pattern1 *= 4;
                        pattern2 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 -= dashLength;
                            pattern2 += dashLength;
                        }
                    }

                    //longdash
                    if (style.lineType === 'longdash') {
                        pattern1 *= 8;
                        pattern2 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            pattern1 -= dashLength;
                            pattern2 += dashLength;
                        }
                    }

                    ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                    for (var i = 1; i < len; i++) {
                        _SUtil.SUtil.SUtil_dashedLineTo(ctx, pointList[i - 1][0] + __OP[0], pointList[i - 1][1] + __OP[1], pointList[i][0] + __OP[0], pointList[i][1] + __OP[1], dashLength, [pattern1, pattern2]);
                    }
                } else if (style.lineType === 'dashot' || style.lineType === 'longdashdot') {
                    var _dashLength = style.lineWidth || 1;
                    var _pattern = _dashLength;
                    var _pattern2 = _dashLength;
                    var pattern3 = _dashLength;
                    var pattern4 = _dashLength;

                    //dashot
                    if (style.lineType === 'dashot') {
                        _pattern *= 4;
                        _pattern2 *= 4;
                        pattern4 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            _pattern -= _dashLength;
                            _pattern2 += _dashLength;
                            pattern3 = 1;
                            pattern4 += _dashLength;
                        }
                    }

                    //longdashdot
                    if (style.lineType === 'longdashdot') {
                        _pattern *= 8;
                        _pattern2 *= 4;
                        pattern4 *= 4;
                        if (style.lineCap && style.lineCap !== "butt") {
                            _pattern -= _dashLength;
                            _pattern2 += _dashLength;
                            pattern3 = 1;
                            pattern4 += _dashLength;
                        }
                    }

                    _dashLength = (style.lineWidth || 1) * (style.lineType === 'dashed' ? 5 : 1);
                    ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                    for (var _i3 = 1; _i3 < len; _i3++) {
                        _SUtil.SUtil.SUtil_dashedLineTo(ctx, pointList[_i3 - 1][0] + __OP[0], pointList[_i3 - 1][1] + __OP[1], pointList[_i3][0] + __OP[0], pointList[_i3][1] + __OP[1], _dashLength, [_pattern, _pattern2, pattern3, pattern4]);
                    }
                }
            }
            return;
        }

        /**
         * APIMethod: getRect
         * 计算返回折线包围盒矩形。
         * 该包围盒是直接从四个控制点计算，并非最小包围盒。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;
            return _SmicPolygon.SmicPolygon.prototype.getRect.apply(this, [style, __OP]);
        }
    }]);

    return SmicBrokenLine;
}(_Shape2.Shape);

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicImage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicImage
 * 图片绘制。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicImage({
 *         style: {
 *             image: 'test.jpg',
 *             x: 100,
 *             y: 100
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicImage = exports.SmicImage = function (_Shape) {
    _inherits(SmicImage, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 左上角横坐标，必设参数。
     * y - {Number} 左上角纵坐标，必设参数。
     * image - {String/Cavans} 图片地址或cavans对象，必设参数。
     * width - {Number} 绘制到画布上的宽度，默认为图片高度。
     * height - {Number} 绘制到画布上的高度，默认为图片高度。
     * sx - {Number} 从图片中裁剪的左上角横坐标。
     * sy - {Number} 从图片中裁剪的左上角纵坐标。
     * sWidth - {Number} 从图片中裁剪的宽度，默认为图片高度。
     * sHeight - {Number} 绘制到画布上的高度，默认为图片高度。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style

    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicImage
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicImage(options) {
        _classCallCheck(this, SmicImage);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicImage.__proto__ || Object.getPrototypeOf(SmicImage)).call(this, options));

        _this.type = 'smicimage';

        /**
         * Property: _imageCache
         * {String} 图片缓存。
         */
        _this._imageCache = {};
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicImage";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicImage, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            this._imageCache = null;
            _get(SmicImage.prototype.__proto__ || Object.getPrototypeOf(SmicImage.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建图片。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'brush',
        value: function brush(ctx, isHighlight, refresh) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var style = this.style || {};

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }

            var image = style.image;
            var me = this;

            if (typeof image === 'string') {
                var src = image;
                if (this._imageCache[src]) {
                    image = this._imageCache[src];
                } else {
                    image = new Image();
                    image.onload = function () {
                        image.onload = null;
                        clearTimeout(SmicImage._refreshTimeout);
                        SmicImage._needsRefresh.push(me);
                        // 防止因为缓存短时间内触发多次onload事件
                        SmicImage._refreshTimeout = setTimeout(function () {
                            refresh && refresh(SmicImage._needsRefresh);
                            // 清空 needsRefresh
                            SmicImage._needsRefresh = [];
                        }, 10);
                    };

                    image.src = src;
                    this._imageCache[src] = image;
                }
            }
            if (image) {
                // 图片已经加载完成
                if (image.nodeName.toUpperCase() == 'IMG') {
                    if (window.ActiveXObject) {
                        if (image.readyState != 'complete') {
                            return;
                        }
                    } else {
                        if (!image.complete) {
                            return;
                        }
                    }
                }
                // Else is canvas
                var width = style.width || image.width;
                var height = style.height || image.height;
                var x = style.x + __OP[0];
                var y = style.y + __OP[1];

                // 图片加载失败
                if (!image.width || !image.height) {
                    return;
                }

                ctx.save();

                this.doClip(ctx);

                this.setContext(ctx, style);

                // 设置transform
                this.setTransform(ctx);

                if (style.sWidth && style.sHeight) {
                    var sx = style.sx + __OP[0] || 0;
                    var sy = style.sy + __OP[1] || 0;
                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
                } else if (style.sx && style.sy) {
                    var _sx = style.sx + __OP[0];
                    var _sy = style.sy + __OP[1];
                    var sWidth = width - _sx;
                    var sHeight = height - _sy;
                    ctx.drawImage(image, _sx, _sy, sWidth, sHeight, x, y, width, height);
                } else {
                    ctx.drawImage(image, x, y, width, height);
                }
                // 如果没设置宽和高的话自动根据图片宽高设置
                if (!style.width) {
                    style.width = width;
                }
                if (!style.height) {
                    style.height = height;
                }
                if (!this.style.width) {
                    this.style.width = width;
                }
                if (!this.style.height) {
                    this.style.height = height;
                }

                this.drawText(ctx, style, this.style);

                ctx.restore();
            }
        }

        /**
         * APIMethod: getRect
         * 计算返回图片的包围盒矩形。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            return {
                x: style.x + __OP[0],
                y: style.y + __OP[1],
                width: style.width,
                height: style.height
            };
        }

        /**
         * APIMethod: clearCache
         * 清除图片缓存。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'clearCache',
        value: function clearCache() {
            this._imageCache = {};
        }
    }]);

    return SmicImage;
}(_Shape2.Shape);

SmicImage._needsRefresh = [];
SmicImage._refreshTimeout = null;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicPoint = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicPoint
 * 点。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicPoint({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           r: 40,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'point'
 *       }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicPoint = exports.SmicPoint = function (_Shape) {
    _inherits(SmicPoint, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 圆心x坐标，必设参数。
     * y - {Number} 圆心y坐标，必设参数。
     * r - {Number} 半径，必设参数。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style


    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicPoint
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicPoint(options) {
        _classCallCheck(this, SmicPoint);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicPoint.__proto__ || Object.getPrototypeOf(SmicPoint)).call(this, options));

        _this.type = 'smicpoint';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }

        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicPoint";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicPoint, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicPoint.prototype.__proto__ || Object.getPrototypeOf(SmicPoint.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建点触。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            ctx.arc(style.x + __OP[0], style.y + __OP[1], style.r, 0, Math.PI * 2, true);
            return;
        }

        /**
         * APIMethod: getRect
         * 计算返回点的包围盒矩形。
         * 该包围盒是直接从四个控制点计算，并非最小包围盒。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            if (style.__rect) {
                return style.__rect;
            }

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x + __OP[0] - style.r - lineWidth / 2),
                y: Math.round(style.y + __OP[1] - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicPoint;
}(_Shape2.Shape);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicRectangle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicRectangle
 * 矩形。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicRectangle({
 *         style: {
 *             x: 0,
 *             y: 0,
 *             width: 100,
 *             height: 100,
 *             radius: 20
 *         }
 *     });
 *   levelRenderer.addShape(shape);
 * (end)
 */
var SmicRectangle = exports.SmicRectangle = function (_Shape) {
    _inherits(SmicRectangle, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 左上角 x 坐标，必设参数。
     * y - {Number} 左上角 y 坐标，必设参数。
     * width - {Number} 宽度，必设参数。
     * height - {Number} 高度，必设参数。
     * radius - {Array} 矩形圆角，可以用数组分别指定四个角的圆角，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 则 radius为 [r1、r2、r3、r4 ]。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style

    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicRectangle
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicRectangle(options) {
        _classCallCheck(this, SmicRectangle);

        /**
         * Property: type
         * {String} 图形类型.
         */
        var _this = _possibleConstructorReturn(this, (SmicRectangle.__proto__ || Object.getPrototypeOf(SmicRectangle)).call(this, options));

        _this.type = 'smicrectangle';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicRectangle";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicRectangle, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicRectangle.prototype.__proto__ || Object.getPrototypeOf(SmicRectangle.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: _buildRadiusPath
         * 创建矩形的圆角路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: '_buildRadiusPath',
        value: function _buildRadiusPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
            // r缩写为1         相当于 [1, 1, 1, 1]
            // r缩写为[1]       相当于 [1, 1, 1, 1]
            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
            var x = style.x + __OP[0];
            var y = style.y + __OP[1];
            var width = style.width;
            var height = style.height;
            var r = style.radius;
            var r1;
            var r2;
            var r3;
            var r4;

            if (typeof r === 'number') {
                r1 = r2 = r3 = r4 = r;
            } else if (r instanceof Array) {
                if (r.length === 1) {
                    r1 = r2 = r3 = r4 = r[0];
                } else if (r.length === 2) {
                    r1 = r3 = r[0];
                    r2 = r4 = r[1];
                } else if (r.length === 3) {
                    r1 = r[0];
                    r2 = r4 = r[1];
                    r3 = r[2];
                } else {
                    r1 = r[0];
                    r2 = r[1];
                    r3 = r[2];
                    r4 = r[3];
                }
            } else {
                r1 = r2 = r3 = r4 = 0;
            }

            var total;
            if (r1 + r2 > width) {
                total = r1 + r2;
                r1 *= width / total;
                r2 *= width / total;
            }
            if (r3 + r4 > width) {
                total = r3 + r4;
                r3 *= width / total;
                r4 *= width / total;
            }
            if (r2 + r3 > height) {
                total = r2 + r3;
                r2 *= height / total;
                r3 *= height / total;
            }
            if (r1 + r4 > height) {
                total = r1 + r4;
                r1 *= height / total;
                r4 *= height / total;
            }
            ctx.moveTo(x + r1, y);
            ctx.lineTo(x + width - r2, y);
            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
            ctx.lineTo(x + width, y + height - r3);
            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
            ctx.lineTo(x + r4, y + height);
            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
            ctx.lineTo(x, y + r1);
            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
        }

        /**
         * APIMethod: _buildRadiusPath
         * 创建矩形路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            if (!style.radius) {
                ctx.moveTo(style.x + __OP[0], style.y + __OP[1]);
                ctx.lineTo(style.x + __OP[0] + style.width, style.y + __OP[1]);
                ctx.lineTo(style.x + __OP[0] + style.width, style.y + __OP[1] + style.height);
                ctx.lineTo(style.x + __OP[0], style.y + __OP[1] + style.height);
                ctx.lineTo(style.x + __OP[0], style.y + __OP[1]);
                // ctx.rect(style.x, style.y, style.width, style.height);
            } else {
                this._buildRadiusPath(ctx, style);
            }
            ctx.closePath();
            return;
        }

        /**
         * APIMethod: getRect
         * 计算返回矩形包围盒矩阵。
         * 该包围盒是直接从四个控制点计算，并非最小包围盒。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            if (style.__rect) {
                return style.__rect;
            }

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x + __OP[0] - lineWidth / 2),
                y: Math.round(style.y + __OP[1] - lineWidth / 2),
                width: style.width + lineWidth,
                height: style.height + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicRectangle;
}(_Shape2.Shape);

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicText = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicText
 * 文本。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicText({
 *         style: {
 *             text: 'Label',
 *             x: 100,
 *             y: 100,
 *             textFont: '14px Arial'
 *         }
 *     });
 *   levelRenderer.addShape(shape);
 * (end)
 */
var SmicText = exports.SmicText = function (_Shape) {
    _inherits(SmicText, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 横坐标，必设参数。
     * y - {Number} 纵坐标，必设参数。
     * text - {String} 图形中的附加文本。默认值：""。
     * maxWidth - {Number} 最大宽度限制。默认值：null。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     */
    //打开接口 style


    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicText
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicText(options) {
        _classCallCheck(this, SmicText);

        /**
         * APIProperty: type
         * {String} 图形类型.
         */
        var _this = _possibleConstructorReturn(this, (SmicText.__proto__ || Object.getPrototypeOf(SmicText)).call(this, options));

        _this.type = 'smictext';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicText";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicText, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;

            _get(SmicText.prototype.__proto__ || Object.getPrototypeOf(SmicText.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: brush
         * 笔触。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * isHighlight - {Boolean} 是否使用高亮属性。
         *
         */

    }, {
        key: 'brush',
        value: function brush(ctx, isHighlight) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var style = this.style;
            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }

            if (typeof style.text == 'undefined' || style.text === false) {
                return;
            }

            ctx.save();
            this.doClip(ctx);

            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            if (style.textFont) {
                ctx.font = style.textFont;
            }
            ctx.textAlign = style.textAlign || 'start';
            ctx.textBaseline = style.textBaseline || 'middle';

            var text = (style.text + '').split('\n');
            var lineHeight = _SUtil.SUtil.Util_area.getTextHeight('ZH', style.textFont);
            var rect = this.getRectNoRotation(style);
            // var x = style.x;
            var x = style.x + __OP[0];
            var y;
            if (style.textBaseline == 'top') {
                y = rect.y;
            } else if (style.textBaseline == 'bottom') {
                y = rect.y + lineHeight;
            } else {
                y = rect.y + lineHeight / 2;
            }
            var ox = style.x + __OP[0];
            var oy = style.y + __OP[1];

            //文本绘制
            for (var i = 0, l = text.length; i < l; i++) {
                //是否渲染矩形背景及颜色
                if (style.labelRect) {
                    //+4,-2是为了让文字距边框左右边缘有点间隔
                    ctx.fillRect(rect.x - 2, rect.y, rect.width + 4, rect.height);
                    ctx.fillStyle = style.strokeColor;
                    ctx.strokeRect(rect.x - 2, rect.y, rect.width + 4, rect.height);
                    ctx.fillStyle = style.textColor;
                }

                switch (style.brushType) {
                    case 'stroke':
                        this.setCtxGlobalAlpha(ctx, "stroke", style);
                        if (style.textRotation && style.textRotation !== 0) {
                            ctx.save();
                            ctx.translate(ox, oy);
                            ctx.rotate(style.textRotation * Math.PI / 180);
                            if (style.textBaseline == 'top') {
                                if (style.maxWidth) {
                                    ctx.strokeText(text[i], 0, lineHeight * i, style.maxWidth);
                                } else {
                                    ctx.strokeText(text[i], 0, lineHeight * i);
                                }
                            } else if (style.textBaseline == 'bottom') {
                                if (style.maxWidth) {
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                                } else {
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height);
                                }
                            } else {
                                if (style.maxWidth) {
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                                } else {
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                                }
                            }
                            ctx.restore();
                        } else {
                            if (style.maxWidth) {
                                ctx.strokeText(text[i], x, y, style.maxWidth);
                            } else {
                                ctx.strokeText(text[i], x, y);
                            }
                        }
                        this.setCtxGlobalAlpha(ctx, "reset", style);
                        break;
                    case 'both':
                        if (style.textRotation && style.textRotation !== 0) {
                            ctx.save();
                            ctx.translate(ox, oy);
                            ctx.rotate(style.textRotation * Math.PI / 180);
                            if (style.textBaseline == 'top') {
                                if (style.maxWidth) {
                                    this.setCtxGlobalAlpha(ctx, "fill", style);
                                    ctx.fillText(text[i], 0, lineHeight * i, style.maxWidth);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);

                                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                                    ctx.strokeText(text[i], 0, lineHeight * i, style.maxWidth);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);
                                } else {
                                    this.setCtxGlobalAlpha(ctx, "fill", style);
                                    ctx.fillText(text[i], 0, lineHeight * i);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);

                                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                                    ctx.strokeText(text[i], 0, lineHeight * i);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);
                                }
                            } else if (style.textBaseline == 'bottom') {
                                if (style.maxWidth) {
                                    this.setCtxGlobalAlpha(ctx, "fill", style);
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);

                                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);
                                } else {
                                    this.setCtxGlobalAlpha(ctx, "fill", style);
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);

                                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);
                                }
                            } else {
                                if (style.maxWidth) {
                                    this.setCtxGlobalAlpha(ctx, "fill", style);
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);

                                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);
                                } else {
                                    this.setCtxGlobalAlpha(ctx, "fill", style);
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);

                                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                                    ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                                    this.setCtxGlobalAlpha(ctx, "reset", style);
                                }
                            }
                            ctx.restore();
                        } else {
                            if (style.maxWidth) {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], x, y, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], x, y, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            } else {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], x, y);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], x, y);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            }
                        }
                        break;
                    default:
                        //fill or others
                        this.setCtxGlobalAlpha(ctx, "fill", style);
                        if (style.textRotation && style.textRotation !== 0) {
                            ctx.save();
                            ctx.translate(ox, oy);
                            ctx.rotate(style.textRotation * Math.PI / 180);
                            if (style.textBaseline == 'top') {
                                if (style.maxWidth) {
                                    ctx.fillText(text[i], 0, lineHeight * i, style.maxWidth);
                                } else {
                                    ctx.fillText(text[i], 0, lineHeight * i);
                                }
                            } else if (style.textBaseline == 'bottom') {
                                if (style.maxWidth) {
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                                } else {
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height);
                                }
                            } else {
                                if (style.maxWidth) {
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                                } else {
                                    ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                                }
                            }
                            ctx.restore();
                        } else {
                            if (style.maxWidth) {
                                ctx.fillText(text[i], x, y, style.maxWidth);
                            } else {
                                ctx.fillText(text[i], x, y);
                            }
                        }
                        this.setCtxGlobalAlpha(ctx, "reset", style);
                }
                y += lineHeight;
            }

            ctx.restore();
            return;
        }

        /**
         * Method: getRect
         * 返回文字包围盒矩形
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            var left, top, right, bottom;
            var tbg = this.getTextBackground(style, true);
            for (var i = 0, len = tbg.length; i < len; i++) {
                var poi = tbg[i];

                //用第一个点初始化
                if (i == 0) {
                    left = poi[0];
                    right = poi[0];
                    top = poi[1];
                    bottom = poi[1];
                } else {
                    if (poi[0] < left) {
                        left = poi[0];
                    }
                    if (poi[0] > right) {
                        right = poi[0];
                    }
                    if (poi[1] < top) {
                        top = poi[1];
                    }
                    if (poi[1] > bottom) {
                        bottom = poi[1];
                    }
                }
            }

            style.__rect = {
                x: left,
                y: top,
                width: right - left,
                height: bottom - top
            };

            return style.__rect;
        }

        /**
         * Method: getRectNoRotation
         * 返回忽略旋转和maxWidth时文字包围盒矩形
         */

    }, {
        key: 'getRectNoRotation',
        value: function getRectNoRotation(style) {

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var lineHeight = _SUtil.SUtil.Util_area.getTextHeight('ZH', style.textFont);

            var width = _SUtil.SUtil.Util_area.getTextWidth(style.text, style.textFont);
            var height = _SUtil.SUtil.Util_area.getTextHeight(style.text, style.textFont);

            //处理文字位置，注：文本的绘制是由此 rect 决定
            var textX = style.x + __OP[0]; // 默认start == left
            if (style.textAlign == 'end' || style.textAlign == 'right') {
                textX -= width;
            } else if (style.textAlign == 'center') {
                textX -= width / 2;
            }

            var textY;
            if (style.textBaseline == 'top') {
                // textY = style.y;
                textY = style.y + __OP[1];
            } else if (style.textBaseline == 'bottom') {
                textY = style.y + __OP[1] - height;
            } else {
                // middle
                textY = style.y + __OP[1] - height / 2;
            }

            var isWidthChangeByMaxWidth = false;
            var widthBeforeChangeByMaxWidth;

            //处理 maxWidth
            if (style.maxWidth) {
                var maxWidth = parseInt(style.maxWidth);
                if (maxWidth < width) {
                    widthBeforeChangeByMaxWidth = width;
                    isWidthChangeByMaxWidth = true;
                    width = maxWidth;
                }

                textX = style.x + __OP[0];
                if (style.textAlign == 'end' || style.textAlign == 'right') {
                    textX -= width;
                } else if (style.textAlign == 'center') {
                    textX -= width / 2;
                }
            }

            //处理斜体字
            if (style.textFont) {
                var textFont = style.textFont;
                var textFontStr = textFont.toLowerCase();
                if (textFontStr.indexOf("italic") > -1) {
                    if (widthBeforeChangeByMaxWidth && isWidthChangeByMaxWidth === true) {
                        width += lineHeight / 3 * (width / widthBeforeChangeByMaxWidth);
                    } else {
                        width += lineHeight / 3;
                    }
                }
            }

            var rect = {
                x: textX,
                y: textY,
                width: width,
                height: height
            };

            return rect;
        }

        /**
         * Method: getTextBackground
         * 获取文本背景框范围
         *
         * Parameters:
         * style - {Object} 样式。
         * redo - {Boolean} 是否强制重新计算 textBackground。
         */

    }, {
        key: 'getTextBackground',
        value: function getTextBackground(style, redo) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            if ((!redo || redo === false) && style.__textBackground) {
                return style.__textBackground;
            }

            //不旋转时矩形框
            var rect = this.getRectNoRotation(style);

            //旋转中心点
            var ox = style.x + __OP[0];
            var oy = style.y + __OP[1];

            //背景框
            var background = [];

            if (style.textRotation && style.textRotation !== 0) {
                var textRotation = style.textRotation;
                var ltPoi = this.getRotatedLocation(rect.x, rect.y, ox, oy, textRotation);
                var rtPoi = this.getRotatedLocation(rect.x + rect.width, rect.y, ox, oy, textRotation);
                var rbPoi = this.getRotatedLocation(rect.x + rect.width, rect.y + rect.height, ox, oy, textRotation);
                var lbPoi = this.getRotatedLocation(rect.x, rect.y + rect.height, ox, oy, textRotation);

                background.push(ltPoi);
                background.push(rtPoi);
                background.push(rbPoi);
                background.push(lbPoi);
            } else {
                var _ltPoi = [rect.x, rect.y];
                var _rtPoi = [rect.x + rect.width, rect.y];
                var _rbPoi = [rect.x + rect.width, rect.y + rect.height];
                var _lbPoi = [rect.x, rect.y + rect.height];

                background.push(_ltPoi);
                background.push(_rtPoi);
                background.push(_rbPoi);
                background.push(_lbPoi);
            }

            style.__textBackground = background;

            return style.__textBackground;
        }

        /**
         * Method: getRotatedLocation
         * 获取一个点绕旋转中心顺时针旋转后的位置。（此方法用于屏幕坐标）
         *
         * Parameters:
         * x - {Number}  旋转点横坐标。
         * y - {Number}  旋转点纵坐标。
         * rx - {Number}  旋转中心点横坐标。
         * ry - {Number}  旋转中心点纵坐标。
         * angle - {Number} 旋转角度（度）。
         *
         * Returns:
         * {Array} 旋转后的坐标位置，长度为 2 的一维数组，数组第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */

    }, {
        key: 'getRotatedLocation',
        value: function getRotatedLocation(x, y, rx, ry, angle) {
            var loc = new Array(),
                x0,
                y0;

            y = -y;
            ry = -ry;
            angle = -angle; //顺时针旋转
            x0 = (x - rx) * Math.cos(angle / 180 * Math.PI) - (y - ry) * Math.sin(angle / 180 * Math.PI) + rx;
            y0 = (x - rx) * Math.sin(angle / 180 * Math.PI) + (y - ry) * Math.cos(angle / 180 * Math.PI) + ry;

            loc[0] = x0;
            loc[1] = -y0;
            return loc;
        }
    }]);

    return SmicText;
}(_Shape2.Shape);

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeoFeatureThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _iclientCommon = __webpack_require__(5);

var _ThemeLayer = __webpack_require__(284);

var _CommontypesConversion = __webpack_require__(36);

var _ThemeFeature = __webpack_require__(112);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @function L.supermap.GeoFeatureThemeLayer
 * @classdesc  地理几何专题要素型专题图层基类。此类型专题图的专题要素形状就是由 feature.geometry 决定。此类不建议直接实例化调用。
 * @private
 * @extends L.supermap.ThemeLayer
 * @param name - {string} 专题图名
 * @param options - {Object} 需要设置得参数对象。如：<br>
 *        nodesClipPixel - {number}节点抽稀像素距离，默认值 2。<br>
 *        isHoverAble - {boolean} 图形是否在 hover 时高亮 ，默认值：false。<br>
 *        isMultiHover - {boolean} 是否多图形同时高亮，用于高亮同一个数据对应的所有图形（如：多面），默认值：false。<br>
 *        isClickAble - {boolean} 图形是否可点击，默认 true。<br>
 *        isAllowFeatureStyle - {boolean} 是否允许 feature 样式（style） 中的有效属性应用到专题图层。
 *                                        默认值为： false，禁止对专题要素使用数据（feature）的 style。
 *                                        此属性可强制将数据 feature 的 style 中有效属性应用到专题要素上，且拥有比图层 style 和 styleGroups 更高的优先级，使专题要素
 *                                        的样式脱离专题图层的控制。可以通过此方式实现对特殊数据（feature） 对应专题要素赋予独立 style。
 */
var GeoFeatureThemeLayer = exports.GeoFeatureThemeLayer = _ThemeLayer.ThemeLayer.extend({

    options: {

        // {Number} 节点抽稀像素距离，默认值 2。
        nodesClipPixel: 2,

        //{Boolean} 图形是否在 hover 时高亮 ，默认值：false。
        isHoverAble: false,

        //{Boolean} 是否多图形同时高亮，用于高亮同一个数据对应的所有图形（如：多面），默认值：false。
        isMultiHover: false,

        // {Boolean} 图形是否可点击，默认 true
        isClickAble: true,
        //是否允许 feature 样式（style） 中的有效属性应用到专题图层。
        //默认值为： false，禁止对专题要素使用数据（feature）的 style。
        //此属性可强制将数据 feature 的 style 中有效属性应用到专题要素上，且拥有比图层 style 和 styleGroups 更高的优先级，使专题要素
        //的样式脱离专题图层的控制。可以通过此方式实现对特殊数据（feature） 对应专题要素赋予独立 style。
        isAllowFeatureStyle: false
    },

    initialize: function initialize(name, options) {
        _ThemeLayer.ThemeLayer.prototype.initialize.call(this, name, options);
        _leaflet2["default"].Util.setOptions(this, options);
        var me = this;
        me.cache = {};
        me.cacheFields = [];
        me.style = {};
        me.highlightStyle = {};
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.addFeatures
     * @description 向专题图图层中添加数据, 支持的feature类型为:iServer返回的feature json对象 或L.supermap.themeFeature类型
     * @param features - {JSONObject|L.supermap.themeFeature} 待填加的要素
     */
    addFeatures: function addFeatures(features) {
        //数组
        if (!_leaflet2["default"].Util.isArray(features)) {
            features = [features];
        }
        var me = this;
        me.fire("beforefeaturesadded", { features: features });

        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i];
            feature = me._createFeature(feature);
            me.features.push(feature);
        }

        if (!me.isCustomSetMaxCacheCount) {
            me.maxCacheCount = me.features.length * 5;
        }

        if (!me.renderer) {
            return;
        }
        //绘制专题要素
        if (me._map) {
            me.redrawThematicFeatures(me._map.getBounds());
        } else {
            me.redrawThematicFeatures();
        }
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.removeFeatures
     * @description 从专题图中删除 feature。这个函数删除所有传递进来的矢量要素。参数中的 features 数组中的每一项，必须是已经添加到当前图层中的 feature，
     * @param features - {L.features} 要删除得要素
     */
    removeFeatures: function removeFeatures(features) {
        // eslint-disable-line no-unused-vars
        this.clearCache();
        _ThemeLayer.ThemeLayer.prototype.removeFeatures.call(this, arguments);
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.removeAllFeatures
     * @description 清除当前图层所有的矢量要素。
     */
    removeAllFeatures: function removeAllFeatures() {
        this.clearCache();
        _ThemeLayer.ThemeLayer.prototype.removeAllFeatures.call(this, arguments);
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘所有专题要素。
     *              此方法包含绘制专题要素的所有步骤，包含用户数据到专题要素的转换，抽稀，缓存等步骤。
     *              地图漫游时调用此方法进行图层刷新。
     * @param bounds - {L.bounds} 重绘得范围
     */
    redrawThematicFeatures: function redrawThematicFeatures(bounds) {
        var me = this;
        //获取高亮专题要素对应的用户 id
        var hoverone = me.renderer.getHoverOne();
        var hoverFid = null;
        if (hoverone && hoverone.refDataID) {
            hoverFid = hoverone.refDataID;
        }
        if (bounds && bounds instanceof _leaflet2["default"].LatLngBounds) {
            var crs = this._map.options.crs;
            bounds = _leaflet2["default"].bounds(crs.project(bounds.getSouthWest()), crs.project(bounds.getNorthEast()));
        }
        bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(bounds);
        //清除当前所有可视元素
        me.renderer.clearAll();

        var features = me.features;
        var cache = me.cache;
        var cacheFields = me.cacheFields;
        var cmZoom = me._map.getZoom();

        var maxCC = me.maxCacheCount;

        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i];
            var feaBounds = feature.geometry.getBounds();

            //剔除当前视图（地理）范围以外的数据
            if (bounds && !bounds.intersectsBounds(feaBounds)) {
                continue;
            }

            //缓存字段
            var fields = feature.id + "_zoom_" + cmZoom.toString();
            if (cache[fields]) {
                cache[fields].updateAndAddShapes();
                continue;
            }

            var thematicFeature = me.createThematicFeature(features[i]);
            //检查 thematicFeature 是否有可视化图形
            if (thematicFeature.getShapesCount() < 1) {
                continue;
            }
            //加入缓存
            cache[fields] = thematicFeature;
            cacheFields.push(fields);
            //缓存数量限制
            if (cacheFields.length > maxCC) {
                var fieldsTemp = cacheFields[0];
                cacheFields.splice(0, 1);
                delete cache[fieldsTemp];
            }
        }

        me.renderer.render();

        //地图漫游后，重新高亮图形
        if (hoverFid && me.options.isHoverAble && me.options.isMultiHover) {
            var hShapes = this.getShapesByFeatureID(hoverFid);
            this.renderer.updateHoverShapes(hShapes);
        }
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.createThematicFeature
     * @description 创建专题要素
     * @param feature - {L.feature} 要创建得要素
     */
    createThematicFeature: function createThematicFeature(feature) {
        var me = this;
        var style = me.getStyleByData(feature);
        if (feature.style && me.isAllowFeatureStyle) {
            style = _iclientCommon.CommonUtil.copyAttributesWithClip(feature.style);
        }

        //创建专题要素时的可选参数
        var options = {};
        options.nodesClipPixel = me.options.nodesClipPixel;
        options.isHoverAble = me.options.isHoverAble;
        options.isMultiHover = me.options.isMultiHover;
        options.isClickAble = me.options.isClickAble;
        options.highlightStyle = _iclientCommon.ShapeFactory.transformStyle(me.highlightStyle);

        //将数据转为专题要素（Vector）
        var thematicFeature = new _iclientCommon.ThemeVector(feature, me, _iclientCommon.ShapeFactory.transformStyle(style), options);

        //直接添加图形到渲染器
        for (var m = 0; m < thematicFeature.shapes.length; m++) {
            me.renderer.addShape(thematicFeature.shapes[m]);
        }

        return thematicFeature;
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.redraw
     * @description 重绘该图层
     */
    redraw: function redraw() {
        this.clearCache();
        return _ThemeLayer.ThemeLayer.prototype.redraw.apply(this, arguments);
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.clearCache
     * @description 清除缓存数据。
     */
    clearCache: function clearCache() {
        this.cache = {};
        this.cacheFields = [];
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.clear
     * @description 清除的内容包括数据（features） 、专题要素、缓存。
     */
    clear: function clear() {
        var me = this;
        me.renderer.clearAll();
        me.renderer.refresh();
        me.removeAllFeatures();
        me.clearCache();
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.getCacheCount
     * @description 获取当前缓存数量。
     * @return {Number} 返回当前缓存数量。
     */
    getCacheCount: function getCacheCount() {
        return this.cacheFields.length;
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.setMaxCacheCount
     * @description 设置最大缓存数量。
     * @param cacheCount - {number}最大缓存量。
     */
    setMaxCacheCount: function setMaxCacheCount(cacheCount) {
        if (isNaN(cacheCount)) {
            return;
        }
        this.maxCacheCount = cacheCount;
        this.isCustomSetMaxCacheCount = true;
    },

    /**
     * @function L.supermap.GeoFeatureThemeLayer.prototype.getShapesByFeatureID
     * @description 通过 FeatureID 获取 feature 关联的所有图形。如果不传入此参数，函数将返回所有图形。
     * @param featureID - {number}要素ID。
     */
    getShapesByFeatureID: function getShapesByFeatureID(featureID) {
        var me = this,
            list = [],
            shapeList = me.renderer.getAllShapes();

        if (!featureID) {
            return shapeList;
        }

        for (var i = 0, len = shapeList.length; i < len; i++) {
            var si = shapeList[i];
            if (si.refDataID && featureID === si.refDataID) {
                list.push(si);
            }
        }
        return list;
    },

    _createFeature: function _createFeature(feature) {
        if (feature instanceof _ThemeFeature.ThemeFeature) {
            feature = feature.toFeature();
        } else if (!(feature instanceof _iclientCommon.GeometryVector)) {
            feature = new _iclientCommon.ServerFeature.fromJson(feature).toFeature();
        }
        if (!feature.hasOwnProperty("attributes") && feature.fieldNames && feature.filedValues) {
            var attrs = {},
                fieldNames = feature.fieldNames,
                filedValues = feature.filedValues;
            for (var i = 0; i < fieldNames.length; i++) {
                attrs[fieldNames[i]] = filedValues[i];
            }
            feature.attributes = attrs;
        }
        return feature;
    }

});

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.themeFeature = exports.ThemeFeature = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.themeFeature
 * @classdesc 客户端专题图要素类。
 *            支持的geometry参数类型为L.Point,L.LatLng,L.Polyline,L.Polygon
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param geometry - {L.Path|L.Point|L.LatLng} 要素图形
 * @param attributes - {Object} 要素属性
 */
var ThemeFeature = exports.ThemeFeature = _leaflet2["default"].Class.extend({

    initialize: function initialize(geometry, attributes) {
        this.geometry = geometry;
        this.attributes = attributes;
    },

    /**
     * @function L.supermap.themeFeature.prototype.toFeature
     * @description 转为内部矢量要素
     * @return {SuperMap.Feature.Vector} 内部矢量要素
     */
    toFeature: function toFeature() {
        var geometry = this.geometry;
        var points = [];
        if (geometry instanceof _leaflet2["default"].Polyline) {
            points = this.reverseLatLngs(geometry.getLatLngs());
            geometry = new _iclientCommon.LineString(points);
        } else if (geometry instanceof _leaflet2["default"].Polygon) {
            points = this.reverseLatLngs(geometry.getLatLngs());
            geometry = new _iclientCommon.Polygon(points);
        } else if (geometry.length === 3) {
            geometry = new _iclientCommon.GeoText(geometry[1], geometry[0], geometry[2]);
        } else {
            if (geometry instanceof _leaflet2["default"].LatLng) {
                points = [geometry.lng, geometry.lat];
            } else if (geometry instanceof _leaflet2["default"].Point) {
                points = [geometry.x, geometry.y];
            } else {
                points = geometry;
            }
            if (points.length === 2) {
                geometry = new _iclientCommon.GeometryPoint(points[0], points[1]);
            }
        }
        return new _iclientCommon.GeometryVector(geometry, this.attributes);
    },

    /**
     * @function L.supermap.themeFeature.prototype.reverseLatLngs
     * @description 坐标反转
     * @param latlngs - {L.latlng} 坐标值
     */
    reverseLatLngs: function reverseLatLngs(latlngs) {
        if (!_leaflet2["default"].Util.isArray(latlngs)) {
            latlngs = [latlngs];
        }
        for (var i = 0; i < latlngs.length; i++) {
            latlngs[i] = [latlngs[i][1], latlngs[i][0]];
        }
        return latlngs;
    }
});
var themeFeature = exports.themeFeature = function themeFeature(geometry, attributes) {
    return new ThemeFeature(geometry, attributes);
};

_leaflet2["default"].supermap.themeFeature = themeFeature;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var parseCode = __webpack_require__(518);
var extend = __webpack_require__(118);
var projections = __webpack_require__(519);
var deriveConstants = __webpack_require__(515);

function Projection(srsCode,callback) {
  if (!(this instanceof Projection)) {
    return new Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var modifiedJSON = deriveConstants(json);
  var ourProj = Projection.projections.get(modifiedJSON.projName);
  if(ourProj){
    extend(this, modifiedJSON);
    extend(this, ourProj);
    this.init();
    callback(null, this);
  }else{
    callback(srsCode);
  }
}
Projection.projections = projections;
Projection.projections.start();
module.exports = Projection;


/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
};

/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = function(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
};

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = function(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
};

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = function(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimeFlowControl = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _TimeControlBase2 = __webpack_require__(143);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TimeFlowControl
 * @classdesc 时间管理类。
 * @description 此类只负责时间上的控制，具体执行的操作需要用户在初始化时的回调函数内部进行实现。<br>
 *              如设置起始时间为1000，结束时间是2000，步长设置为1，
 *              那么表示按照每次1年（可以通过setSpeed进行修改）的变化从公元1000年开始到公元2000年为止，默认每1秒会1次(通过setFrequency修改)
 * @extends SuperMap.TimeControlBase
 * @param callback - {function} 每次刷新回调函数，必设属性。具体的效果需要用户在此回调函数里面实现。
 * @param options - {Object} 该类开放的可选属性。如：<br>
 *        speed - {number}步长(单位ms)。不能小于0，默认为1（表示每次刷新的数据之间的间隔为1ms）。<br>
 *        frequency -  {number} 刷新频率(单位ms)，默认为1000ms。<br>
 *        startTime - {number}起始时间，必须为数字，且小于等于endTime。如果不设置，初始化时为0，建议设置。<br>
 *        endTime - {number}结束时间，必须为数字，且大于等于startTime。如果不设置，初始化时以当前时间进行设置，建议设置。<br>
 *        repeat - {boolean} 是否重复循环。默认为true。<br>
 *        reverse - {boolean} 是否反向。默认为false。
 */
var TimeFlowControl = exports.TimeFlowControl = function (_TimeControlBase) {
    _inherits(TimeFlowControl, _TimeControlBase);

    function TimeFlowControl(callback, options) {
        _classCallCheck(this, TimeFlowControl);

        var _this = _possibleConstructorReturn(this, (TimeFlowControl.__proto__ || Object.getPrototypeOf(TimeFlowControl)).call(this, options));

        var me = _this;
        /**
         * @member SuperMap.TimeFlowControl.prototype.callback -{function}
         * @description 每次刷新执行的回调函数
         */
        me.callback = callback;

        //先让IE下支持bind方法
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (oThis) {
                if (typeof this !== "function") {
                    throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
                }
                var aArgs = Array.prototype.slice.call(arguments, 1),
                    fToBind = this,
                    fNOP = function fNOP() {
                    //empty Function
                },
                    fBound = function fBound() {
                    return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
                };
                fNOP.prototype = this.prototype;
                fBound.prototype = new fNOP();
                return fBound;
            };
        }
        //保证 this.tick 的上下文还是 TimeControl 这个对象
        me.update = me.update.bind(me);

        me.oldTime = me.currentTime;

        me.CLASS_NAME = "SuperMap.TimeFlowControl";
        return _this;
    }

    /**
     * @function SuperMap.TimeFlowControl.prototype.updateOptions
     * @override
     */


    _createClass(TimeFlowControl, [{
        key: 'updateOptions',
        value: function updateOptions(options) {
            options = options || {};
            _get(TimeFlowControl.prototype.__proto__ || Object.getPrototypeOf(TimeFlowControl.prototype), 'updateOptions', this).call(this, options);
        }

        /**
         * @function SuperMap.TimeFlowControl.prototype.start
         * @override
         */

    }, {
        key: 'start',
        value: function start() {
            var me = this;
            if (me.running) {
                return;
            }
            me.running = true;
            if (me.reverse) {
                if (me.currentTime === me.startTime) {
                    me.oldTime = me.endTime;
                    me.currentTime = me.oldTime;
                }
            } else {
                if (me.oldTime === me.endTime) {
                    me.currentTime = me.startTime;
                    me.oldTime = me.currentTime;
                }
            }
            me.tick();
        }

        /**
         * @function SuperMap.TimeFlowControl.prototype.stop
         * @override
         */

    }, {
        key: 'stop',
        value: function stop() {
            _get(TimeFlowControl.prototype.__proto__ || Object.getPrototypeOf(TimeFlowControl.prototype), 'stop', this).call(this);
            var me = this;
            me.oldTime = me.currentTime;

            if (me.running) {
                me.running = false;
            }
            //清除定时tick
            me.intervalId && window.clearTimeout(me.intervalId);
        }

        /**
         * @function SuperMap.TimeFlowControl.prototype.destroy
         * @override
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            _get(TimeFlowControl.prototype.__proto__ || Object.getPrototypeOf(TimeFlowControl.prototype), 'destroy', this).call(this);
            var me = this;
            me.oldTime = null;
            me.callback = null;
        }

        /**
         * @function SuperMap.TimeFlowControl.prototype.tick
         * @description 定时刷新
         */

    }, {
        key: 'tick',
        value: function tick() {
            var me = this;
            me.intervalId && window.clearInterval(me.intervalId);
            me.intervalId = null;
            me.intervalId = window.setInterval(me.update, me.frequency);
        }

        /**
         * @function SuperMap.TimeFlowControl.prototype.update
         * @override
         */

    }, {
        key: 'update',
        value: function update() {
            var me = this;

            //判定是否还需要继续
            if (!me.running) {
                return;
            }
            //调用回调函数
            me.callback && me.callback(me.currentTime); //destroy之后callback就为空，所以需要判定一下

            if (!me.reverse) {
                //如果相等，则代表上一帧已经运行到了最后，下一帧运行初始化的状态
                if (me.currentTime === me.endTime) {
                    //不循环时
                    if (!me.repeat) {
                        me.running = false;
                        me.stop();
                        return null;
                    }
                    me.stop();
                    me.currentTime = me.startTime;
                    me.oldTime = me.currentTime;
                    me.start();
                } else {
                    ////否则时间递增
                    me.oldTime = me.currentTime;
                    me.currentTime += me.speed;
                }

                if (me.currentTime >= me.endTime) {
                    me.currentTime = me.endTime;
                }
            } else {
                //如果相等，则代表上一帧已经运行到了最前，下一帧运行结束的状态
                if (me.currentTime === me.startTime) {
                    //不循环时
                    if (!me.repeat) {
                        me.running = false;
                        return null;
                    }

                    me.oldTime = me.endTime;
                    me.currentTime = me.oldTime;
                } else {
                    ////否则时间递减
                    me.currentTime = me.oldTime;
                    me.oldTime -= me.speed;
                }

                if (me.oldTime <= me.startTime) {
                    me.oldTime = me.startTime;
                }
            }
        }
    }]);

    return TimeFlowControl;
}(_TimeControlBase2.TimeControlBase);

_SuperMap.SuperMap.TimeFlowControl = TimeFlowControl;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IManager = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _iManagerServiceBase = __webpack_require__(145);

var _iManagerCreateNodeParam = __webpack_require__(144);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.iManager
 * @classdesc iManager服务类。
 * @param serviceUrl - {string} iManager首页地址。
 *
 */
var IManager = exports.IManager = function (_IManagerServiceBase) {
    _inherits(IManager, _IManagerServiceBase);

    function IManager(iManagerUrl) {
        _classCallCheck(this, IManager);

        return _possibleConstructorReturn(this, (IManager.__proto__ || Object.getPrototypeOf(IManager)).call(this, iManagerUrl));
    }

    /**
     * @function SuperMap.iManager.prototype.load
     * @description 获取所有服务接口，验证是否已登录授权。
     * @returns {Promise} Promise对象。
     */


    _createClass(IManager, [{
        key: 'load',
        value: function load() {
            return this.request("GET", this.serviceUrl + '/web/api/service.json');
        }

        /**
         * @function SuperMap.iManager.prototype.createIServer
         * @param createParam - {SuperMap.iManagerCreateNodeParam} 创建参数。
         * @description 创建iServer。
         * @returns {Promise} Promise对象。
         */

    }, {
        key: 'createIServer',
        value: function createIServer(createParam) {
            return this.request("POST", this.serviceUrl + '/icloud/web/nodes/server.json', new _iManagerCreateNodeParam.IManagerCreateNodeParam(createParam));
        }

        /**
         * @function SuperMap.iManager.prototype.createIPortal
         * @param createParam - {SuperMap.iManagerCreateNodeParam} 创建参数。
         * @description 创建iPortal。
         * @returns {Promise} Promise对象。
         */

    }, {
        key: 'createIPortal',
        value: function createIPortal(createParam) {
            return this.request("POST", this.serviceUrl + '/icloud/web/nodes/portal.json', new _iManagerCreateNodeParam.IManagerCreateNodeParam(createParam));
        }

        /**
         * @function SuperMap.iManager.prototype.iServerList
         * @description 获取所有创建的iServer。
         * @returns {Promise} Promise对象。
         */

    }, {
        key: 'iServerList',
        value: function iServerList() {
            return this.request("GET", this.serviceUrl + '/icloud/web/nodes/server.json');
        }

        /**
         * @function SuperMap.iManager.prototype.iPortalList
         * @description 获取所有创建的iPortal。
         * @returns {Promise} Promise对象。
         */

    }, {
        key: 'iPortalList',
        value: function iPortalList() {
            return this.request("GET", this.serviceUrl + '/icloud/web/nodes/portal.json');
        }

        /**
         * @function SuperMap.iManager.prototype.startNodes
         * @param ids - {Array}  需要启动节点的id数组.e.g:['1']。
         * @description 启动节点。
         * @returns {Promise} Promise对象。
         */

    }, {
        key: 'startNodes',
        value: function startNodes(ids) {
            return this.request("POST", this.serviceUrl + '/icloud/web/nodes/started.json', ids);
        }

        /**
         * @function SuperMap.iManager.prototype.stopNodes
         * @param ids - {Array}  需要停止节点的id数组.e.g:['1']。
         * @description 停止节点。
         * @returns {Promise} Promise对象。
         */

    }, {
        key: 'stopNodes',
        value: function stopNodes(ids) {
            return this.request("POST", this.serviceUrl + '/icloud/web/nodes/stopped.json', ids);
        }
    }]);

    return IManager;
}(_iManagerServiceBase.IManagerServiceBase);

_SuperMap.SuperMap.iManager = IManager;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPortal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _iPortalServicesQueryParam = __webpack_require__(149);

var _iPortalMapsQueryParam = __webpack_require__(147);

var _FetchRequest = __webpack_require__(21);

var _iPortalService = __webpack_require__(148);

var _iPortalMap = __webpack_require__(146);

var _iPortalServiceBase = __webpack_require__(65);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.iPortal
 * @classdesc 对接SuperMap iPortal 基础服务
 * @extends SuperMap.iPortalServiceBase
 * @param iportalUrl -{string} 地址
 *
 */
var IPortal = exports.IPortal = function (_IPortalServiceBase) {
    _inherits(IPortal, _IPortalServiceBase);

    function IPortal(iportalUrl) {
        _classCallCheck(this, IPortal);

        var _this = _possibleConstructorReturn(this, (IPortal.__proto__ || Object.getPrototypeOf(IPortal)).call(this, iportalUrl));

        _this.iportalUrl = iportalUrl;
        return _this;
    }

    /**
     * @function SuperMap.iPortal.prototype.load
     * @description 加载页面
     * @returns {Promise} 返回包含iportal web资源信息的Promise对象
     */


    _createClass(IPortal, [{
        key: 'load',
        value: function load() {
            return _FetchRequest.FetchRequest.get(this.iportalUrl + '/web');
        }

        /**
         * @function SuperMap.iPortal.prototype.queryServices
         * @param queryParams -{SuperMap.iPortalServicesQueryParam} 查询参数
         * @description 查询服务
         * @returns {Promise} 返回包含所有服务的Promise对象
         */

    }, {
        key: 'queryServices',
        value: function queryServices(queryParams) {
            if (!(queryParams instanceof _iPortalServicesQueryParam.IPortalServicesQueryParam)) {
                return null;
            }
            var serviceUrl = this.iportalUrl + "/web/services";
            return this.request("GET", serviceUrl, queryParams).then(function (result) {
                var services = [];
                result.content.map(function (serviceJsonObj) {
                    services.push(new _iPortalService.IPortalService(serviceUrl, serviceJsonObj));
                    return serviceJsonObj;
                });
                return services;
            });
        }

        /**
         * @function SuperMap.iPortal.prototype.deleteServices
         * @param ids -{Array} 服务的序号
         * @description 删除服务
         * @returns {Promise} 返回包含服务删除操作状态的Promise对象
         */

    }, {
        key: 'deleteServices',
        value: function deleteServices(ids) {
            var serviceUrl = this.iportalUrl + "/web/services";
            return this.request("DELETE", serviceUrl, { ids: ids });
        }

        /**
         * @function SuperMap.iPortal.prototype.queryMaps
         * @param queryParams -{SuperMap.iPortalMapsQueryParam} 查询参数
         * @description 获取地图信息
         * @returns {Promise} 返回包含所有地图服务信息的Promise对象
         */

    }, {
        key: 'queryMaps',
        value: function queryMaps(queryParams) {
            if (!(queryParams instanceof _iPortalMapsQueryParam.IPortalMapsQueryParam)) {
                return null;
            }
            var mapsUrl = this.iportalUrl + "/web/maps";
            return this.request("GET", mapsUrl, queryParams).then(function (result) {
                var mapRetult = {};
                var maps = [];
                result.content.map(function (mapJsonObj) {
                    maps.push(new _iPortalMap.IPortalMap(mapsUrl + "/" + mapJsonObj.id, mapJsonObj));
                    return mapJsonObj;
                });
                mapRetult.content = maps;
                mapRetult.currentPage = result.currentPage;
                mapRetult.pageSize = result.pageSize;
                mapRetult.total = result.total;
                mapRetult.totalPage = result.totalPage;
                return mapRetult;
            });
        }
    }]);

    return IPortal;
}(_iPortalServiceBase.IPortalServiceBase);

_SuperMap.SuperMap.iPortal = IPortal;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Online = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SecurityManager = __webpack_require__(35);

var _OnlineData = __webpack_require__(256);

var _FetchRequest = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Online
 * @classdesc 对接SuperMap Online 所有基础服务
 * @example
 * var online=new SuperMap.Online();
 * var services = online.queryDatas(param);
 * service.then(function(services){
 *      var service= services[0];
 *      service.updateDataInfo();
 * })
 */
var Online = exports.Online = function () {

    //TODO 目前并没有对接Online的所有操作，需要补充完整
    //所有查询返回的是一个Promise,在外部使用的时候通过Promise的then方法获取异步结果
    function Online() {
        _classCallCheck(this, Online);

        this.rootUrl = "http://www.supermapol.com";
        this.webUrl = this.rootUrl + "/web";

        var mContentUrl = this.webUrl + "/mycontent";
        this.mDatasUrl = mContentUrl + "/datas";

        this.CLASS_NAME = "SuperMap.Online";
    }

    /**
     * @function SuperMap.Online.prototype.load
     * @description 加载online，验证online是否可用
     * @returns {Promise} 返回包含网络请求结果的Promise对象
     */


    _createClass(Online, [{
        key: 'load',
        value: function load() {
            return _FetchRequest.FetchRequest.get(this.rootUrl).then(function (response) {
                return response;
            });
        }

        /**
         * @function SuperMap.Online.prototype.login
         * @description 登录Online
         */

    }, {
        key: 'login',
        value: function login() {
            _SecurityManager.SecurityManager.loginOnline(this.rootUrl, true);
        }

        /**
         * @function SuperMap.Online.prototype.queryDatas
         * @description 查询Online “我的内容”下“我的数据”服务(需要登录状态获取)并返回可操作的服务对象
         * @param parameter -{SuperMap.OnlineQueryDatasParameter} myDatas服务资源查询参数
         * @returns {Promise} 返回包含所有数据服务信息的Promise对象
         */

    }, {
        key: 'queryDatas',
        value: function queryDatas(parameter) {
            var me = this,
                url = me.mDatasUrl;
            if (parameter) {
                parameter = parameter.toJSON();
            }
            return _FetchRequest.FetchRequest.get(url, parameter).then(function (json) {
                if (!json || !json.content || json.content.length < 1) {
                    return;
                }
                var services = [],
                    contents = json.content,
                    len = contents.length;
                for (var i = 0; i < len; i++) {
                    var content = contents[i];
                    var service = new _OnlineData.OnlineData(me.mDatasUrl, content);
                    services.push(service);
                }
                return services;
            });
        }
    }]);

    return Online;
}();

_SuperMap.SuperMap.Online = Online;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ElasticSearch = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Events = __webpack_require__(62);

var _elasticsearch = __webpack_require__(547);

var _elasticsearch2 = _interopRequireDefault(_elasticsearch);

var _Util = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ElasticSearch
 * @classdesc ElasticSearch服务类。
 * @param url - {string} ElasticSearch服务地址。
 * @param options - {Object} 可选参数。如:</br>
 *         change - {function} 服务器返回数据后执行的函数。</br>
 *         openGeoFence - {boolean} 是否开启地理围栏验证，默认为不开启。</br>
 *         outOfGeoFence - {function} 数据超出地理围栏后执行的函数。</br>
 *         geoFence - {Object} 地理围栏。</br>
 */

var ElasticSearch = exports.ElasticSearch = function () {
    function ElasticSearch(url, options) {
        _classCallCheck(this, ElasticSearch);

        options = options || {};
        /**
         *  @member SuperMap.ElasticSearch.prototype.url -{string}
         *  @description ElasticSearch服务地址
         */
        this.url = url;
        /**
         *  @member SuperMap.ElasticSearch.prototype.client -{Object}
         *  @description client ES客户端
         */
        this.client = new _elasticsearch2["default"].Client({
            host: this.url
        });
        /**
         *  @member SuperMap.ElasticSearch.prototype.change -{function}
         *  @description 服务器返回数据后执行的函数
         */
        this.change = null;
        /**
         *  @member SuperMap.ElasticSearch.prototype.openGeoFence -{boolean}
         *  @description 是否开启地理围栏验证，默认为不开启。
         */
        this.openGeoFence = false;
        /**
         *  @member SuperMap.ElasticSearch.prototype.outOfGeoFence -{function}
         *  @description 数据超出地理围栏后执行的函数
         */
        this.outOfGeoFence = null;

        /**
         * @member SuperMap.ElasticSearch.prototype.geoFence -{Object}
         * @description 地理围栏
         * @example {
        *    radius: 1000,//单位是m
        *    center: [104.40, 30.43],
        *    unit: 'meter|degree'
        *  }
         */
        this.geoFence = null;

        /*
         * Constant: EVENT_TYPES
         * {Array<String>}
         * 此类支持的事件类型。
         *
         */
        this.EVENT_TYPES = ['change', 'error', 'outOfGeoFence'];

        /**
         * @member SuperMap.ElasticSearch.prototype.events -{SuperMap.Events}
         * @description 事件
         */
        this.events = new _Events.Events(this, null, this.EVENT_TYPES);

        /**
         * @member SuperMap.ElasticSearch.prototype.eventListeners -{Object}
         * @description 听器对象，在构造函数中设置此参数（可选），对 MapService 支持的两个事件 processCompleted 、processFailed 进行监听，
         * 相当于调用 SuperMap.Events.on(eventListeners)。
         */
        this.eventListeners = null;
        _Util.Util.extend(this, options);
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
    }

    /**
     * @function  SuperMap.ElasticSearch.prototype.setGeoFence
     * @description 设置地理围栏，openGeoFence参数为true的时候，设置的地理围栏才生效。
     * @param geoFence - {SuperMap.Geometry} 地理围栏。
     */

    _createClass(ElasticSearch, [{
        key: 'setGeoFence',
        value: function setGeoFence(geoFence) {
            this.geoFence = geoFence;
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.bulk
         * @description 批量操作API，允许执行多个索引/删除操作。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-bulk</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'bulk',
        value: function bulk(params, callback) {
            return this.client.bulk(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.clearScroll
         * @description 通过指定scroll参数进行查询来清除已经创建的scroll请求。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-clearscroll</br>
         *更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'clearScroll',
        value: function clearScroll(params, callback) {
            return this.client.clearScroll(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.count
         * @description 获取集群、索引、类型或查询的文档个数。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-count</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'count',
        value: function count(params, callback) {
            return this.client.count(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.count
         * @description 在特定索引中添加一个类型化的JSON文档，使其可搜索。如果具有相同index，type且id已经存在的文档将发生错误。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-create</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'create',
        value: function create(params, callback) {
            return this.client.create(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.delete
         * @description 根据其ID从特定索引中删除键入的JSON文档。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-delete</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'delete',
        value: function _delete(params, callback) {
            return this.client["delete"](params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.delete
         * @description 根据其ID从特定索引中删除键入的JSON文档。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletebyquery</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'deleteByQuery',
        value: function deleteByQuery(params, callback) {
            return this.client.deleteByQuery(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.delete
         * @description 根据其ID删除脚本。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletescript</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'deleteScript',
        value: function deleteScript(params, callback) {
            return this.client.deleteScript(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.deleteTemplate
         * @description 根据其ID删除模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletetemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'deleteTemplate',
        value: function deleteTemplate(params, callback) {
            return this.client.deleteTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.exists
         * @description 检查给定文档是否存在。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-exists</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'exists',
        value: function exists(params, callback) {
            return this.client.exists(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.existsSource
         * @description 检查资源是否存在。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-existssource</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'existsSource',
        value: function existsSource(params, callback) {
            return this.client.existsSource(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.explain
         * @description 提供与特定查询相关的特定文档分数的详细信息。它还会告诉您文档是否与指定的查询匹配。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-explain</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'explain',
        value: function explain(params, callback) {
            return this.client.explain(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.fieldCaps
         * @description 允许检索多个索引之间的字段的功能。(实验性API，可能会在未来版本中删除)</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-fieldcaps</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'fieldCaps',
        value: function fieldCaps(params, callback) {
            return this.client.fieldCaps(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.get
         * @description 从索引获取一个基于其id的类型的JSON文档。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'get',
        value: function get(params, callback) {
            return this.client.get(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.getScript
         * @description 获取脚本。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-getscript</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'getScript',
        value: function getScript(params, callback) {
            return this.client.getScript(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.getSource
         * @description 通过索引，类型和ID获取文档的源。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-getsource</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'getSource',
        value: function getSource(params, callback) {
            return this.client.getSource(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.getTemplate
         * @description 获取模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-gettemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'getTemplate',
        value: function getTemplate(params, callback) {
            return this.client.getTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.index
         * @description 在索引中存储一个键入的JSON文档，使其可搜索。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-index</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'index',
        value: function index(params, callback) {
            return this.client.index(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.info
         * @description 从当前集群获取基本信息。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-info</br>
         * 更多信息参考 https://www.elastic.co/guide/index.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'info',
        value: function info(params, callback) {
            return this.client.info(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.mget
         * @description 根据索引，类型（可选）和ids来获取多个文档。mget所需的主体可以采用两种形式：文档位置数组或文档ID数组。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-mget</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'mget',
        value: function mget(params, callback) {
            return this.client.mget(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.msearch
         * @description 在同一请求中执行多个搜索请求。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-msearch</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'msearch',
        value: function msearch(params, callback) {
            var me = this;
            if (me.openGeoFence) {
                return me.client.msearch(params, callback).then(function (resp) {
                    me._update(resp.responses);
                }, function (err) {
                    me.events.triggerEvent('error', { error: err });
                });
            }
            return me.client.msearch(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.msearchTemplate
         * @description 在同一请求中执行多个搜索模板请求。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-msearchtemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'msearchTemplate',
        value: function msearchTemplate(params, callback) {
            return this.client.msearchTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.mtermvectors
         * @description 多termvectors API允许一次获得多个termvectors。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-mtermvectors</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'mtermvectors',
        value: function mtermvectors(params, callback) {
            return this.client.mtermvectors(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.ping
         * @description 测试连接。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-ping</br>
         * 更多信息参考 https://www.elastic.co/guide/index.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'ping',
        value: function ping(params, callback) {
            return this.client.ping(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.putScript
         * @description 添加脚本。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-putscript</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'putScript',
        value: function putScript(params, callback) {
            return this.client.putScript(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.putTemplate
         * @description 添加模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-puttemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'putTemplate',
        value: function putTemplate(params, callback) {
            return this.client.putTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.reindex
         * @description 重新索引。</br>
         * 参数设置参考 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-reindex</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'reindex',
        value: function reindex(params, callback) {
            return this.client.reindex(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.reindexRessrottle
         * @description 重新索引。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-reindexrethrottle</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'reindexRessrottle',
        value: function reindexRessrottle(params, callback) {
            return this.client.reindexRessrottle(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.renderSearchTemplate
         * @description 搜索模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-rendersearchtemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'renderSearchTemplate',
        value: function renderSearchTemplate(params, callback) {
            return this.client.renderSearchTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.scroll
         * @description  在search()调用中指定滚动参数之后，滚动搜索请求（检索下一组结果）。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-scroll</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'scroll',
        value: function scroll(params, callback) {
            return this.client.scroll(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.search
         * @description  在search()调用中指定滚动参数之后，滚动搜索请求（检索下一组结果）。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-search</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'search',
        value: function search(params, callback) {
            var me = this;
            if (me.openGeoFence) {
                return me.client.search(params, callback).then(function (resp) {
                    me._update(resp.responses);
                }, function (err) {
                    me.events.triggerEvent('error', { error: err });
                });
            }
            return me.client.search(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.searchShards
         * @description  返回要执行搜索请求的索引和分片。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-searchshards</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'searchShards',
        value: function searchShards(params, callback) {
            return this.client.searchShards(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.searchTemplate
         * @description  搜索模板。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-searchtemplate</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'searchTemplate',
        value: function searchTemplate(params, callback) {
            return this.client.searchTemplate(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.suggest
         * @description 该建议功能通过使用特定的建议者，基于所提供的文本来建议类似的术语。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-suggest</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'suggest',
        value: function suggest(params, callback) {
            return this.client.suggest(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.termvectors
         * @description 返回有关特定文档字段中的术语的信息和统计信息。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-termvectors</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'termvectors',
        value: function termvectors(params, callback) {
            return this.client.termvectors(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.update
         * @description 更新文档的部分。</br>
         * 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-update</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'update',
        value: function update(params, callback) {
            return this.client.update(params, callback);
        }

        /**
         * @function  SuperMap.ElasticSearch.prototype.update
         * @description 通过查询API来更新文档。</br>
         * 参数设置参考 参数设置参考 https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-updatebyquery</br>
         * 更多信息参考 https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html</br>
         * @param params - {Object} 参数。
         * @param callback - {function} 回调函数。
         */

    }, {
        key: 'updateByQuery',
        value: function updateByQuery(params, callback) {
            return this.client.updateByQuery(params, callback);
        }
    }, {
        key: '_update',
        value: function _update(data) {
            var me = this;
            if (!data) {
                return;
            }
            me.data = data;
            if (me.geoFence) {
                me._validateDatas(data);
            }
            me.events.triggerEvent('change', { data: me.data });
            me.change && me.change(data);
        }
    }, {
        key: '_validateDatas',
        value: function _validateDatas(datas) {
            if (!datas) {
                return;
            }
            if (!(datas instanceof Array)) {
                datas = [datas];
            }
            var i,
                len = datas.length;
            for (i = 0; i < len; i++) {
                this._validateData(datas[i]);
            }
        }
    }, {
        key: '_validateData',
        value: function _validateData(data) {
            var me = this;
            data.hits.hits.map(function (source) {
                var content = source._source;
                var meterUnit = me._getMeterPerMapUnit(me.geoFence.unit);
                var geoFenceCX = me.geoFence.center[0] * meterUnit;
                var geoFenceCY = me.geoFence.center[1] * meterUnit;
                var contentX = content.x * meterUnit;
                var contentY = content.y * meterUnit;
                var distance = me._distance(contentX, contentY, geoFenceCX, geoFenceCY);
                var radius = me.geoFence.radius;
                if (distance > radius) {
                    me.outOfGeoFence && me.outOfGeoFence(data);
                    me.events.triggerEvent('outOfGeoFence', { data: data });
                }
                return source;
            });
        }
    }, {
        key: '_distance',
        value: function _distance(x1, y1, x2, y2) {
            return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
        }
    }, {
        key: '_getMeterPerMapUnit',
        value: function _getMeterPerMapUnit(mapUnit) {
            var earchRadiusInMeters = 6378137;
            var meterPerMapUnit = void 0;
            if (mapUnit === 'meter') {
                meterPerMapUnit = 1;
            } else if (mapUnit === 'degree') {
                // 每度表示多少米。
                meterPerMapUnit = Math.PI * 2 * earchRadiusInMeters / 360;
            }
            return meterPerMapUnit;
        }
    }]);

    return ElasticSearch;
}();

_SuperMap.SuperMap.ElasticSearch = ElasticSearch;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.baiduTileLayer = exports.BaiduTileLayer = undefined;

__webpack_require__(4);

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.baiduTileLayer
 * @classdesc 百度地图图层。
 * @extends L.TileLayer{@linkdoc-leaflet/#tilelayer}
 * @param url -{string} 切片地址
 * @param options -{Object} 切片参数。如：<br>
 *        minZoom - {number} 最小缩放级别 <br>
 *        maxZoom - {number} 最大缩放级别 <br>
 *        bounds - {[L.LatLngBounds]{@linkdoc-leaflet/#latlngbounds}} 显示范围 <br>
 *        retina - {[L.Browser]{@linkdoc-leaflet/#browser}} 浏览器显示分辨率 <br>
 *        attribution - {string} 版权信息 <br>
 */
var BaiduTileLayer = exports.BaiduTileLayer = _leaflet2["default"].TileLayer.extend({

    /**
     * @member L.supermap.baiduTileLayer.prototype.url -{string}
     * @description 切片地址
     */
    url: "http://online{num}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles={styles}&udt=20150815&scaler=1",

    options: {
        minZoom: 3,
        maxZoom: 19,
        bounds: _leaflet2["default"].latLngBounds(_leaflet2["default"].latLng(-85.0511287798, -180), _leaflet2["default"].latLng(85.0511287798, 180)),
        retina: _leaflet2["default"].Browser.retina,
        attribution: "Map Data © 2017 Baidu - GS(2016)2089号 - Data © 长地万方 with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(url, options) {
        if (url) {
            this.url = url;
        }
        _leaflet2["default"].setOptions(this, options);
        if (this.options.retina) {
            this.options.maxZoom = 18;
        }
        _leaflet2["default"].stamp(this);
    },

    /**
     * @function L.supermap.baiduTileLayer.prototype.getTileUrl
     * @description 获取切片地址
     * @param coords - {Object} 行列号
     * @return {string} 切片地址
     */
    getTileUrl: function getTileUrl(coords) {
        return _leaflet2["default"].Util.template(this.url, {
            num: Math.abs((coords.x + coords.y) % 8) + 1,
            x: coords.x,
            y: -coords.y - 1,
            z: this._getZoomForUrl(),
            styles: this.options.retina ? 'ph' : 'pl'
        });
    }
});
var baiduTileLayer = exports.baiduTileLayer = function baiduTileLayer(url, options) {
    return new BaiduTileLayer(url, options);
};

_leaflet2["default"].supermap.baiduTileLayer = baiduTileLayer;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cloudTileLayer = exports.CloudTileLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.cloudTileLayer
 * @classdesc 超图云服务图层。
 * @extends L.TileLayer{@linkdoc-leaflet/#tilelayer}
 * @param url -{string} 服务地址，默认为 http://t2.supermapcloud.com/FileService/image?map={mapName}&type={type}&x={x}&y={y}&z={z}
 * @param options -{Object} 图层可选参数。如：<br>
 *        layersID - {number}图层ID，如果有layersID，则是在使用专题图。<br>
 *        redirect - {boolean} 是否从定向，如果为 true，则将请求重定向到图片的真实地址；如果为 false，则响应体中是图片的字节流。<br>
 *        transparent - {number}设置透明度。<br>
 *        cacheEnabled - {string} 启用缓存。<br>
 *        clipRegionEnabled - {boolean} 是否启用地图裁剪。<br>
 *        prjCoordSys - {Object} 请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}。<br>
 *        overlapDisplayed - {boolean} 地图对象在同一范围内时，是否重叠显示。<br>
 *        overlapDisplayedOptions - {string} 避免地图对象压盖显示的过滤选项。<br>
 *        tileversion - {string} 切片版本名称，cacheEnabled 为 true 时有效。<br>
 *        crs - {{@link L.Proj.CRS}} 坐标系统类。<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        attribution - {string} 版权信息。<br>
 *        minZoom - {number} 最小缩放级别。<br>
 *        maxZoom - {number} 最大缩放级别。<br>
 *        mapName - {string} 地图名称。
 */
var CloudTileLayer = exports.CloudTileLayer = _leaflet2["default"].TileLayer.extend({

    defaultURL: 'http://t2.supermapcloud.com/FileService/image',

    options: {
        /**
         * @member L.supermap.cloudTileLayer.prototype.options -{String}
         * @description 地图名称，默认为 quanguo。
         */
        mapName: "quanguo",
        /**
         * @member L.supermap.cloudTileLayer.prototype.type -{{String} }
         * @description 地图投影。
         */
        type: "web",
        minZoom: 3,
        maxZoom: 18,
        attribution: "Map Data ©2014 SuperMap - GS(2014)6070号-data©Navinfo with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"

    },

    initialize: function initialize(url, options) {
        _leaflet2["default"].setOptions(this, options);
        var cloudURL = url || this.defaultURL;
        this._url = cloudURL + "?map=" + this.options.mapName + "&type=" + this.options.type + "&x={x}&y={y}&z={z}";
        _leaflet2["default"].stamp(this);
    }
});
var cloudTileLayer = exports.cloudTileLayer = function cloudTileLayer(url, options) {
    return new CloudTileLayer(url, options);
};

_leaflet2["default"].supermap.cloudTileLayer = cloudTileLayer;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tiandituTileLayer = exports.TiandituTileLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _TileLayer = __webpack_require__(88);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.tiandituTileLayer
 * @classdesc 天地图图层类。
 * @extends L.supermap.wmtsLayer
 * @param options -{Object} 切片图层参数。如：<br>
 *        url - {string} 地图地址。<br>
 *        layerType - {string} 图层类型。(vec:矢量图层，img:影像图层，ter:地形图层)<br>
 *        style - {string} 图层风格。<br>
 *        format - {string} 格式。<br>
 *        isLabel - {boolean} 是否是标注图层<br>
 *        subdomains - {Array<number>} 子域名数组。<br>
 *        attribution - {string} 版权信息
 */
var TiandituTileLayer = exports.TiandituTileLayer = _TileLayer.WMTSLayer.extend({

    layerLabelMap: {
        "vec": "cva",
        "ter": "cta",
        "img": "cia"
    },
    layerZoomMap: {
        "vec": 18,
        "ter": 14,
        "img": 18
    },
    options: {
        layerType: "vec", //(vec:矢量图层，vec:矢量标签图层，img:影像图层,cia:影像标签图层，ter:地形,cta:地形标签图层)
        isLabel: false,
        attribution: "Map Data <a href='http://www.tianditu.com' target='_blank'><img style='background-color:transparent;bottom:2px;opacity:1;' src='http://api.tianditu.com/img/map/logo.png' width='53px' height='22px' opacity='0'></a> with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>",
        url: "http://t{s}.tianditu.com/{layer}_{proj}/wmts?",
        zoomOffset: 1,
        dpi: 96,
        style: "default",
        format: "tiles",
        subdomains: [0, 1, 2, 3, 4, 5, 6, 7]
    },

    initialize: function initialize(options) {
        options = options || {};
        _leaflet2["default"].setOptions(this, options);
        this.options.layer = this.options.isLabel ? this.layerLabelMap[this.options.layerType] : this.options.layerType;
        this.options.maxZoom = this.layerZoomMap[this.options.layerType];
        _TileLayer.WMTSLayer.prototype.initialize.call(this, this.options.url, this.options);
        _leaflet2["default"].stamp(this);
    },
    onAdd: function onAdd(map) {
        this.options.tilematrixSet = map.options.crs.code === "EPSG:4326" ? "c" : "w";
        this._url = this._url.replace("{layer}", this.options.layer).replace("{proj}", this.options.tilematrixSet);
        _TileLayer.WMTSLayer.prototype.onAdd.call(this, map);
    }
});
var tiandituTileLayer = exports.tiandituTileLayer = function tiandituTileLayer(options) {
    return new TiandituTileLayer(options);
};

_leaflet2["default"].supermap.tiandituTileLayer = tiandituTileLayer;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tiledMapLayer = exports.TiledMapLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

var _Util = __webpack_require__(43);

var Util = _interopRequireWildcard(_Util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.tiledMapLayer
 * @classdesc SuperMap iServer 的 REST 地图服务的图层(SuperMap iServer Java 6R 及以上分块动态 REST 图层)。使用TileImage资源出图.
 * @extends L.TileLayer{@linkdoc-leaflet/#tilelayer}
 * @example
 *      L.superMap.tiledMapLayer(url).addTo(map);
 * @param url -{string} 影像图层地址
 * @param options -{Object} 影像图层参数。如：<br>
 *        layersID - {number}图层ID，如果有layersID，则是在使用专题图。<br>
 *        redirect - {boolean} 是否从定向，如果为 true，则将请求重定向到图片的真实地址；如果为 false，则响应体中是图片的字节流。<br>
 *        transparent - {number}设置透明度。<br>
 *        cacheEnabled - {string} 启用缓存。<br>
 *        clipRegionEnabled - {boolean} 是否启用地图裁剪。<br>
 *        prjCoordSys - {Object} 请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}。<br>
 *        overlapDisplayed - {boolean} 地图对象在同一范围内时，是否重叠显示。<br>
 *        overlapDisplayedOptions - {string} 避免地图对象压盖显示的过滤选项。<br>
 *        tileversion - {string} 切片版本名称，cacheEnabled 为 true 时有效。<br>
 *        crs - {{@link L.Proj.CRS}} 坐标系统类。<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        attribution - {string} 版权信息。<br>
 */
var TiledMapLayer = exports.TiledMapLayer = _leaflet2["default"].TileLayer.extend({

    options: {
        //如果有layersID，则是在使用专题图
        layersID: null,
        //如果为 true，则将请求重定向到图片的真实地址；如果为 false，则响应体中是图片的字节流
        redirect: false,
        transparent: null,
        cacheEnabled: null,
        clipRegionEnabled: false,
        //请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}
        prjCoordSys: null,
        //地图对象在同一范围内时，是否重叠显示
        overlapDisplayed: false,
        //避免地图对象压盖显示的过滤选项
        overlapDisplayedOptions: null,
        //切片版本名称，cacheEnabled 为 true 时有效。
        tileversion: null,

        crs: null,
        serverType: _iclientCommon.ServerType.ISERVER,

        attribution: "Map Data <span>© <a href='http://support.supermap.com.cn/product/iServer.aspx' target='_blank'>SuperMap iServer</a></span> with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(url, options) {
        this._url = url;
        _leaflet2["default"].TileLayer.prototype.initialize.apply(this, arguments);
        _leaflet2["default"].setOptions(this, options);
        _leaflet2["default"].stamp(this);

        //当前切片在切片集中的index
        this.tileSetsIndex = -1;
        this.tempIndex = -1;
    },

    /**
     * @private
     * @function L.supermap.tiledMapLayer.prototype.onAdd
     * @description 添加地图。
     * @param map - {L.map} 待添加的影像地图参数
     */
    onAdd: function onAdd(map) {
        this._crs = this.options.crs || map.options.crs;
        _leaflet2["default"].TileLayer.prototype.onAdd.call(this, map);
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.getTileUrl
     * @description 根据行列号获取瓦片地址
     * @param coords - {Object} 行列号
     * @return {string} 瓦片地址
     */
    getTileUrl: function getTileUrl(coords) {
        var scale = this.getScaleFromCoords(coords);
        var layerUrl = this._getLayerUrl();
        var tileUrl = layerUrl + "&scale=" + scale + "&x=" + coords.x + "&y=" + coords.y;
        return encodeURI(tileUrl);
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.getScale
     * @description 根据缩放级别获取比例尺
     * @param zoom - {number} 缩放级别
     * @return {number} 比例尺
     */
    getScale: function getScale(zoom) {
        var me = this;
        //返回当前比例尺
        var z = zoom || me._map.getZoom();
        return me.scales[z];
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.getScaleFromCoords
     * @description 通过行列号获取比例尺
     * @param coords - {Object} 行列号
     * @return {number} 比例尺
     */
    getScaleFromCoords: function getScaleFromCoords(coords) {
        var me = this,
            scale;
        if (me.scales && me.scales[coords.z]) {
            return me.scales[coords.z];
        }
        me.scales = me.scales || {};
        scale = me.getDefaultScale(coords);
        me.scales[coords.z] = scale;
        return scale;
    },

    /**
     * @private
     * @function L.supermap.tiledMapLayer.prototype.getDefaultScale
     * @description 获取默认比例尺信息
     * @param coords - {Object} 坐标对象参数
     */
    getDefaultScale: function getDefaultScale(coords) {
        var me = this,
            crs = me._crs;
        if (crs.options && crs.options.scaleDenominators) {
            return 1.0 / crs.options.scaleDenominators[coords.z];
        }
        if (crs.options && crs.options.scales) {
            return crs.options.scales[coords.z];
        }
        var resolution;
        if (crs.options && crs.options.resolutions) {
            resolution = crs.options.resolutions[coords.z];
        } else if (crs._scales) {
            resolution = 1 / crs._scales[coords.z];
        } else {
            var tileBounds = me._tileCoordsToBounds(coords);
            var ne = crs.project(tileBounds.getNorthEast());
            var sw = crs.project(tileBounds.getSouthWest());
            var tileSize = me.options.tileSize;
            resolution = Math.max(Math.abs(ne.x - sw.x) / tileSize, Math.abs(ne.y - sw.y) / tileSize);
        }

        var mapUnit = _iclientCommon.Unit.METER;
        if (crs.code) {
            var array = crs.code.split(':');
            if (array && array.length > 1) {
                var code = parseInt(array[1]);
                mapUnit = code && code >= 4000 && code <= 5000 ? _iclientCommon.Unit.DEGREE : _iclientCommon.Unit.METER;
            }
        }
        return Util.resolutionToScale(resolution, 96, mapUnit);
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.setTileSetsInfo
     * @description 设置瓦片集信息
     * @param tileSets - {Object} 瓦片对象集
     */
    setTileSetsInfo: function setTileSetsInfo(tileSets) {
        this.tileSets = tileSets;
        if (_leaflet2["default"].Util.isArray(this.tileSets)) {
            this.tileSets = this.tileSets[0];
        }
        if (!this.tileSets) {
            return;
        }
        this.fire('tilesetsinfoloaded', { tileVersions: this.tileSets.tileVersions });
        this.changeTilesVersion();
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.lastTilesVersion
     * @description 请求上一个版本切片，并重新绘制。
     */
    lastTilesVersion: function lastTilesVersion() {
        this.tempIndex = this.tileSetsIndex - 1;
        this.changeTilesVersion();
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.nextTilesVersion
     * @description 请求下一个版本切片，并重新绘制。
     */
    nextTilesVersion: function nextTilesVersion() {
        this.tempIndex = this.tileSetsIndex + 1;
        this.changeTilesVersion();
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.changeTilesVersion
     * @description 切换到某一版本的切片，并重绘。通过this.tempIndex保存需要切换的版本索引
     */
    changeTilesVersion: function changeTilesVersion() {
        var me = this;
        //切片版本集信息是否存在
        if (me.tileSets == null) {
            //版本信息为空，重新查询，查询成功继续跳转到相应的版本
            //me.getTileSetsInfo();
            return;
        }
        if (me.tempIndex === me.tileSetsIndex || this.tempIndex < 0) {
            return;
        }
        //检测index是否可用
        var tileVersions = me.tileSets.tileVersions;
        if (tileVersions && me.tempIndex < tileVersions.length && me.tempIndex >= 0) {
            var name = tileVersions[me.tempIndex].name;
            var result = me.mergeTileVersionParam(name);
            if (result) {
                me.tileSetsIndex = me.tempIndex;
                me.fire('tileversionschanged', { tileVersion: tileVersions[me.tempIndex] });
            }
        }
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.updateCurrentTileSetsIndex
     * @description 手动设置当前切片集索引,目前主要提供给控件使用
     * @param index - {number}索引值
     */
    updateCurrentTileSetsIndex: function updateCurrentTileSetsIndex(index) {
        this.tempIndex = index;
    },

    /**
     * @function L.supermap.tiledMapLayer.prototype.mergeTileVersionParam
     * @description 更改URL请求参数中的切片版本号,并重绘
     * @param version - {string} 切片版本号
     * @return {boolean} 是否成功
     */
    mergeTileVersionParam: function mergeTileVersionParam(version) {
        if (version) {
            this.requestParams["tileversion"] = version;
            this._paramsChanged = true;
            this.redraw();
            this._paramsChanged = false;
            return true;
        }
        return false;
    },

    _getLayerUrl: function _getLayerUrl() {
        if (this._paramsChanged) {
            this._layerUrl = this._createLayerUrl();
        }
        return this._layerUrl || this._createLayerUrl();
    },

    _createLayerUrl: function _createLayerUrl() {
        var me = this;
        var layerUrl = me._url + "/tileImage.png?";
        layerUrl += me._getRequestParamString();
        layerUrl = this._appendCredential(layerUrl);
        this._layerUrl = layerUrl;
        return layerUrl;
    },

    _getRequestParamString: function _getRequestParamString() {
        this.requestParams = this.requestParams || this._getAllRequestParams();
        var params = [];
        for (var key in this.requestParams) {
            params.push(key + "=" + this.requestParams[key]);
        }
        return params.join('&');
    },

    _getAllRequestParams: function _getAllRequestParams() {
        var me = this,
            options = me.options || {},
            params = {};

        var tileSize = this.options.tileSize;
        if (!(tileSize instanceof _leaflet2["default"].Point)) {
            tileSize = _leaflet2["default"].point(tileSize, tileSize);
        }
        params["width"] = tileSize.x;
        params["height"] = tileSize.y;

        params["redirect"] = options.redirect === true;
        params["transparent"] = options.transparent === true;
        params["cacheEnabled"] = !(options.cacheEnabled === false);

        if (options.prjCoordSys) {
            params["prjCoordSys"] = JSON.stringify(options.prjCoordSys);
        }

        if (options.layersID) {
            params["layersID"] = options.layersID.toString();
        }

        if (options.clipRegionEnabled && options.clipRegion instanceof _leaflet2["default"].Path) {
            options.clipRegion = Util.toSuperMapGeometry(options.clipRegion.toGeoJSON());
            options.clipRegion = _iclientCommon.CommonUtil.toJSON(_iclientCommon.ServerGeometry.fromGeometry(options.clipRegion));
            params["clipRegionEnabled"] = options.clipRegionEnabled;
            params["clipRegion"] = JSON.stringify(options.clipRegion);
        }

        //切片的起始参考点，默认为地图范围的左上角。
        var crs = me._crs;
        if (crs.options && crs.options.origin) {
            params["origin"] = JSON.stringify({ x: crs.options.origin[0], y: crs.options.origin[1] });
        } else if (crs.projection && crs.projection.bounds) {
            var bounds = crs.projection.bounds;
            var tileOrigin = _leaflet2["default"].point(bounds.min.x, bounds.max.y);
            params["origin"] = JSON.stringify({ x: tileOrigin.x, y: tileOrigin.y });
        }

        if (options.overlapDisplayed === false) {
            params["overlapDisplayed"] = false;
            if (options.overlapDisplayedOptions) {
                params["overlapDisplayedOptions"] = me.overlapDisplayedOptions.toString();
            }
        } else {
            params["overlapDisplayed"] = true;
        }

        if (options.cacheEnabled === true && options.tileversion) {
            params["tileversion"] = options.tileversion.toString();
        }

        return params;
    },

    //追加token或key
    _appendCredential: function _appendCredential(url) {
        var newUrl = url,
            credential,
            value;
        switch (this.options.serverType) {
            case _iclientCommon.ServerType.IPORTAL:
                value = _iclientCommon.SecurityManager.getToken(url);
                credential = value ? new _iclientCommon.Credential(value, "token") : null;
                if (!credential) {
                    value = _iclientCommon.SecurityManager.getKey(url);
                    credential = value ? new _iclientCommon.Credential(value, "key") : null;
                }
                break;
            case _iclientCommon.ServerType.ONLINE:
                value = _iclientCommon.SecurityManager.getKey(url);
                credential = value ? new _iclientCommon.Credential(value, "key") : null;
                break;
            default:
                //iserver or others
                value = _iclientCommon.SecurityManager.getToken(url);
                credential = value ? new _iclientCommon.Credential(value, "token") : null;
                break;
        }
        if (credential) {
            newUrl += "&" + credential.getUrlParameters();
        }
        return newUrl;
    }
});

var tiledMapLayer = exports.tiledMapLayer = function tiledMapLayer(url, options) {
    return new TiledMapLayer(url, options);
};

_leaflet2["default"].supermap.tiledMapLayer = tiledMapLayer;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.graphThemeLayer = exports.GraphThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

var _ThemeFeature = __webpack_require__(112);

var _ThemeLayer = __webpack_require__(284);

var _CommontypesConversion = __webpack_require__(36);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.GraphThemeLayer
 * @classdesc 统计专题图图层。
 * @extends L.supermap.ThemeLayer
 * @description 统计专题图通过为每个要素绘制统计图表来反映其对应的专题值的大小。它可同时表示多个字段属性信息，在区域本身与各区域之间形成横向和纵向的对比。<br>
 *              统计专题图多用于具有相关数量特征的地图上，比如表示不同地区多年的粮食产量、GDP、人口等，不同时段客运量、地铁流量等。
 *              目前提供的统计图类型有：柱状图（Bar），折线图（Line），饼图（Pie），三维柱状图（Bar3D），点状图（Point），环状图（Ring）。
 * @param name - {string} 专题图表名称
 * @param chartsType - {string} 图表类型。目前可用："Bar", "Bar3D", "Line","Point","Pie","Ring"。
 * @param options - {Object} 待设置得参数。如：<br>
 *        isOverLay - {boolean} 是否进行压盖处理，如果设为 true，图表绘制过程中将隐藏对已在图层中绘制的图表产生压盖的图表,默认值：true。<br>
 *        chartsType :图表类型。目前可用："Bar", "Line", "Pie"。<br>
 *        chartsSetting:各类型图表的 chartsSetting 对象可设属性请参考具体图表模型类的注释中对 chartsSetting 对象可设属性的描述。<br>
 *  * chartsSetting 对象通常都具有以下 5 个基础可设属性
 *  * width - {number}专题要素（图表）宽度，必设参数。
 *  * height - {number}专题要素（图表）高度，必设参数。
 *  * codomain - {Array<number>} 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。
 *  * XOffset - {Number}  专题要素（图表）在 X 方向上的偏移值，单位像素。
 *  * YOffset - {Number}  专题要素（图表）在 Y 方向上的偏移值，单位像素。
 *  * dataViewBoxParameter - {Array{Number}} 数据视图框 dataViewBox 参数，
 *      它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值，长度为 4 的一维数组。
 *  * decimalNumber - {number}数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。
 *      如果不设置此参数，在取数据值时不对数据做小数位处理。
 */
var GraphThemeLayer = exports.GraphThemeLayer = _ThemeLayer.ThemeLayer.extend({

    options: {
        //是否进行压盖处理，如果设为 true，图表绘制过程中将隐藏对已在图层中绘制的图表产生压盖的图表,默认值：true。
        isOverLay: true
    },

    initialize: function initialize(name, chartsType, options) {
        var newArgs = [];
        newArgs.push(name);
        newArgs.push(options);
        _ThemeLayer.ThemeLayer.prototype.initialize.apply(this, newArgs);
        this.chartsType = chartsType;
        this.themeFields = options && options.themeFields ? options.themeFields : null;
        this.charts = options && options.charts ? options.charts : [];
        this.cache = options && options.cache ? options.cache : {};
        this.chartsSetting = options && options.chartsSetting ? options.chartsSetting : {};
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.setChartsType
     * @description 设置图表类型，此函数可动态改变图表类型。在调用此函数前请通过 chartsSetting 为新类型的图表做相关配置。图表类型，目前支持："Bar", "Bar3D", "Line","Point","Pie","Ring"。
     * @param chartsType  - {string} 图表类型。目前可用："Bar", "Bar3D", "Line","Point","Pie","Ring"。
     */
    setChartsType: function setChartsType(chartsType) {
        this.chartsType = chartsType;
        this.redraw();
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.addFeatures
     * @description 向专题图图层中添加数据, 支持的feature类型为:iServer返回的feature json对象 或L.supermap.themeFeature类型
     * @param features - {L.features} 待添加得要素
     */
    addFeatures: function addFeatures(features) {
        //数组
        if (!_leaflet2["default"].Util.isArray(features)) {
            features = [features];
        }

        var me = this;
        me.fire("beforefeaturesadded", { features: features });

        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i];
            feature = me._createFeature(feature);
            me.features.push(feature);
        }
        //绘制专题要素
        if (!me.renderer) {
            return;
        }

        if (me._map) {
            me.redrawThematicFeatures(me._map.getBounds());
        } else {
            me.redrawThematicFeatures();
        }
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘所有专题要素 此方法包含绘制专题要素的所有步骤，包含用户数据到专题要素的转换，压盖处理，缓存等步骤。地图漫游时调用此方法进行图层刷新。
     * @param bounds - {L.bounds} 重绘得范围
     */
    redrawThematicFeatures: function redrawThematicFeatures(bounds) {
        var me = this;
        //清除当前所有可视元素
        me.renderer.clearAll();
        var features = me.features;
        if (bounds && bounds instanceof _leaflet2["default"].LatLngBounds) {
            var crs = this._map.options.crs;
            bounds = _leaflet2["default"].bounds(crs.project(bounds.getSouthWest()), crs.project(bounds.getNorthEast()));
        }
        bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(bounds);
        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i];
            // 要素范围判断
            var feaBounds = feature.geometry.getBounds();
            //剔除当前视图（地理）范围以外的数据
            if (bounds && !bounds.intersectsBounds(feaBounds)) {
                continue;
            }
            var cache = me.cache;
            // 用feature id 做缓存标识
            var cacheField = feature.id;
            // 数据对应的图表是否已缓存，没缓存则重新创建图表
            if (!cache[cacheField]) {
                cache[cacheField] = cacheField;
                var chart = me.createThematicFeature(feature);
                // 压盖处理权重值
                var isValidOverlayWeightField = me.overlayWeightField && feature.attributes[me.overlayWeightField] && !isNaN(feature.attributes[me.overlayWeightField]);
                if (chart && isValidOverlayWeightField) {
                    chart["__overlayWeight"] = feature.attributes[me.overlayWeightField];
                }

                if (chart) {
                    me.charts.push(chart);
                }
            }
        }

        me.drawCharts();
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.createThematicFeature
     * @description 创建专题要素（图表）
     * @param feature - {L.features} 待创建得要素
     */
    createThematicFeature: function createThematicFeature(feature) {
        var me = this;
        var thematicFeature;
        // 检查图表创建条件并创建图形
        if (_iclientCommon.FeatureTheme[me.chartsType] && me.themeFields && me.chartsSetting) {
            thematicFeature = new _iclientCommon.FeatureTheme[me.chartsType](feature, me, me.themeFields, me.chartsSetting);
        }

        // thematicFeature 是否创建成功
        if (!thematicFeature) {
            return false;
        }
        // 对专题要素执行图形装载
        thematicFeature.assembleShapes();
        return thematicFeature;
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.drawCharts
     * @description 绘制图表。包含压盖处理。
     */
    drawCharts: function drawCharts() {
        var me = this;
        if (!me.renderer) {
            return;
        }

        // 图表权重值处理
        if (me.overlayWeightField) {
            me._sortChart();
        }

        if (me.options && !me.options.isOverLay) {
            // 不进行避让
            me._addOverlayShape();
        } else {
            //进行避让
            me._addNoOverlayShape();
        }
        // 绘制图形
        me.renderer.render();
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.getShapesByFeatureID
     * @description 通过 FeatureID 获取 feature 关联的所有图形。如果不传入此参数，函数将返回所有图形。
     * @param featureID - {number}要素ID
     */
    getShapesByFeatureID: function getShapesByFeatureID(featureID) {
        var me = this,
            list = [];
        var shapeList = me.renderer.getAllShapes();

        if (!featureID) {
            return shapeList;
        }

        for (var i = 0, len = shapeList.length; i < len; i++) {
            var si = shapeList[i];
            if (si.refDataID && featureID === si.refDataID) {
                list.push(si);
            }
        }
        return list;
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.isQuadrilateralOverLap
     * @description 判断两个四边形是否有压盖。
     * @param quadrilateral - {Array<Object>} 四边形节点数组。
     * @example
     * [{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     * quadrilateral2 - {Array<Object>}  第二个四边形节点数组。
     */
    isQuadrilateralOverLap: function isQuadrilateralOverLap(quadrilateral, quadrilateral2) {
        var me = this;
        var quadLen = quadrilateral.length,
            quad2Len = quadrilateral2.length;
        if (quadLen !== 5 || quad2Len !== 5) {
            return null;
        } //不是四边形

        var OverLap = false;
        //如果两四边形互不包含对方的节点，则两个四边形不相交
        for (var i = 0; i < quadLen; i++) {
            if (me.isPointInPoly(quadrilateral[i], quadrilateral2)) {
                OverLap = true;
                break;
            }
        }
        for (var _i = 0; _i < quad2Len; _i++) {
            if (me.isPointInPoly(quadrilateral2[_i], quadrilateral)) {
                OverLap = true;
                break;
            }
        }
        //加上两矩形十字相交的情况
        for (var _i2 = 0; _i2 < quadLen - 1; _i2++) {
            if (OverLap) {
                break;
            }
            for (var j = 0; j < quad2Len - 1; j++) {
                var isLineIn = _iclientCommon.CommonUtil.lineIntersection(quadrilateral[_i2], quadrilateral[_i2 + 1], quadrilateral2[j], quadrilateral2[j + 1]);
                if (isLineIn.CLASS_NAME === "SuperMap.Geometry.Point") {
                    OverLap = true;
                    break;
                }
            }
        }

        return OverLap;
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.isPointInPoly
     * @description 判断一个点是否在多边形里面。(射线法)
     * @param pt - {Object} 需要判定的点对象，该对象含有属性x(横坐标)，属性y(纵坐标)。
     * @param poly - {Array<Object>}  多边形节点数组。<br>
     *        例如一个四边形：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]
     */
    isPointInPoly: function isPointInPoly(pt, poly) {
        for (var isIn = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {
            (poly[i].y <= pt.y && pt.y < poly[j].y || poly[j].y <= pt.y && pt.y < poly[i].y) && pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x && (isIn = !isIn);
        }
        return isIn;
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.isChartInMap
     * @description 判断图表是否在地图里。
     * @param mapPxBounds - {SuperMap.Bounds} 地图像素范围。
     * @param chartPxBounds - {Array<Object>} 图表范围的四边形节点数组。<br>
     *        例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     */
    isChartInMap: function isChartInMap(mapPxBounds, chartPxBounds) {
        var mb = mapPxBounds;

        var isIn = false;
        for (var i = 0, len = chartPxBounds.length; i < len; i++) {
            var cb = chartPxBounds[i];

            if (cb.x >= mb.left && cb.x <= mb.right && cb.y >= mb.top && cb.y <= mb.bottom) {
                isIn = true;
                break;
            }
        }

        return isIn;
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.clearCache
     * @description 清除缓存数据。
     */
    clearCache: function clearCache() {
        this.cache = {};
        this.charts = [];
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.removeFeatures
     * @description 从专题图中删除 feature。这个函数删除所有传递进来的矢量要素（数据）。
     * @param features - {L.features} 待删除得要输
     */
    removeFeatures: function removeFeatures(features) {
        // eslint-disable-line no-unused-vars
        var me = this;
        me.clearCache();
        _ThemeLayer.ThemeLayer.prototype.removeFeatures.apply(me, arguments);
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.removeAllFeatures
     * @description 清除当前图层所有的矢量要素。
     */
    removeAllFeatures: function removeAllFeatures() {
        var me = this;
        me.clearCache();
        _ThemeLayer.ThemeLayer.prototype.removeAllFeatures.apply(me, arguments);
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.redraw
     * @description 重绘该图层，成功则返回true，否则返回false。
     */
    redraw: function redraw() {
        var me = this;
        me.clearCache();
        return _ThemeLayer.ThemeLayer.prototype.redraw.apply(me, arguments);
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.clear
     * @description 清除图层。清除的内容包括数据（features） 、专题要素、缓存。
     */
    clear: function clear() {
        var me = this;
        if (me.renderer) {
            me.renderer.clearAll();
            me.renderer.refresh();
        }
        me.removeAllFeatures();
        me.clearCache();
    },

    /**
     * @function L.supermap.GraphThemeLayer.prototype.getWeightFieldValue
     * @description 获取权重字段的值。
     * @param feature - {SuperMap.Feature.Vector} 矢量要素。
     * @param weightField - {Array<string>} 字段名数组。
     * @param defaultValue - {number}当通过 weightField 获取不到权重值时，使用 defaultValue 作为权重值。
     */
    getWeightFieldValue: function getWeightFieldValue(feature, weightField, defaultValue) {
        if (typeof defaultValue === "undefined" || isNaN(defaultValue)) {
            defaultValue = 0;
        }
        if (!feature.attributes) {
            return defaultValue;
        }

        var fieldValue = feature.attributes[weightField];

        if (typeof fieldValue === "undefined" || isNaN(fieldValue)) {
            fieldValue = defaultValue;
        }

        return fieldValue;
    },

    _sortChart: function _sortChart() {
        var me = this;
        if (!me.charts) {
            return;
        }
        me.charts.sort(function (cs, ce) {
            if (typeof cs["__overlayWeight"] === "undefined" && typeof ce["__overlayWeight"] === "undefined") {
                return 0;
            } else if (typeof cs["__overlayWeight"] !== "undefined" && typeof ce["__overlayWeight"] === "undefined") {
                return -1;
            } else if (typeof cs["__overlayWeight"] === "undefined" && typeof ce["__overlayWeight"] !== "undefined") {
                return 1;
            } else if (typeof cs["__overlayWeight"] !== "undefined" && typeof ce["__overlayWeight"] !== "undefined") {
                return parseFloat(cs["__overlayWeight"]) < parseFloat(ce["__overlayWeight"]) ? 1 : -1;
            }
            return 0;
        });
    },

    _addOverlayShape: function _addOverlayShape() {
        var me = this;
        var charts = me.charts;
        for (var m = 0, len_m = charts.length; m < len_m; m++) {
            var chart_m = charts[m];

            // 图形参考位置  (reSetLocation 会更新 chartBounds)
            var shapeROP_m = chart_m.resetLocation();

            // 添加图形
            var shapes_m = chart_m.shapes;
            for (var n = 0, slen_n = shapes_m.length; n < slen_n; n++) {
                shapes_m[n].refOriginalPosition = shapeROP_m;
                me.renderer.addShape(shapes_m[n]);
            }
        }
    },
    _addNoOverlayShape: function _addNoOverlayShape() {
        var me = this;
        // 压盖判断所需 chartsBounds 集合
        var mapBounds = me._map.getBounds();
        var crs = this._map.options.crs;
        mapBounds = _leaflet2["default"].bounds(crs.project(mapBounds.getSouthWest()), crs.project(mapBounds.getNorthEast()));
        mapBounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(mapBounds);
        var charts = me.charts;
        var chartsBounds = [];
        // 获取地图像素 bounds
        var mapPxLT = me.getLocalXY(new _iclientCommon.LonLat(mapBounds.left, mapBounds.top));
        var mapPxRB = me.getLocalXY(new _iclientCommon.LonLat(mapBounds.right, mapBounds.bottom));
        var mBounds = new _iclientCommon.Bounds(mapPxLT[0], mapPxRB[1], mapPxRB[0], mapPxLT[1]);

        // 压盖处理 & 添加图形
        for (var i = 0, len = charts.length; i < len; i++) {
            var chart = charts[i];
            // 图形参考位置  (reSetLocation 会更新 chartBounds)
            var shapeROP = chart.resetLocation();
            // 图表框
            var cbs = chart.chartBounds;
            var cBounds = [{ "x": cbs.left, "y": cbs.top }, { "x": cbs.left, "y": cbs.bottom }, { "x": cbs.right, "y": cbs.bottom }, { "x": cbs.right, "y": cbs.top }, { "x": cbs.left, "y": cbs.top }];
            // 地图范围外不绘制
            if (mBounds && !me.isChartInMap(mBounds, cBounds)) {
                continue;
            }
            // 是否压盖
            var isOverlay = false;

            for (var j = 0; j < chartsBounds.length; j++) {
                //压盖判断
                if (me.isQuadrilateralOverLap(cBounds, chartsBounds[j])) {
                    isOverlay = true;
                    break;
                }
            }

            if (isOverlay) {
                continue;
            } else {
                chartsBounds.push(cBounds);
            }

            // 添加图形
            var shapes = chart.shapes;
            for (var _j = 0, slen = shapes.length; _j < slen; _j++) {
                shapes[_j].refOriginalPosition = shapeROP;
                me.renderer.addShape(shapes[_j]);
            }
        }
    },

    _createFeature: function _createFeature(feature) {
        if (feature instanceof _ThemeFeature.ThemeFeature) {
            feature = feature.toFeature();
        } else if (!(feature instanceof _iclientCommon.GeometryVector)) {
            feature = new _iclientCommon.ServerFeature.fromJson(feature).toFeature();
        }
        if (!feature.hasOwnProperty("attributes") && feature.fieldNames && feature.filedValues) {
            var attrs = {},
                fieldNames = feature.fieldNames,
                filedValues = feature.filedValues;
            for (var i = 0; i < fieldNames.length; i++) {
                attrs[fieldNames[i]] = filedValues[i];
            }
            feature.attributes = attrs;
        }
        return feature;
    }
});
var graphThemeLayer = exports.graphThemeLayer = function graphThemeLayer(name, chartsType, options) {
    return new GraphThemeLayer(name, chartsType, options);
};

_leaflet2["default"].supermap.graphThemeLayer = graphThemeLayer;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.labelThemeLayer = exports.LabelThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _GeoFeatureThemeLayer = __webpack_require__(111);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.LabelThemeLayer
 * @classdesc 标签专题图。
 * @extends L.supermap.GeoFeatureThemeLayer
 * @param name - {string} 图层名
 * @param options - {Object} 图层参数<br>
 *        isOverLay -{boolean} 是否进行压盖处理,默认true<br>
 *        isAvoid -{boolean} 是否进行地图边缘的避让处理,默认true
 */
var LabelThemeLayer = exports.LabelThemeLayer = _GeoFeatureThemeLayer.GeoFeatureThemeLayer.extend({

    options: {
        //是否进行压盖处理，如果设为true，将隐藏被压盖的标签，默认为true。
        isOverLay: true,
        //是否进行地图边缘的避让处理，如果设为true，将把与地图边缘相交的标签移到地图范围内，默认为 true，在地图边缘处做避让处理。
        isAvoid: true
    },

    initialize: function initialize(name, options) {
        _GeoFeatureThemeLayer.GeoFeatureThemeLayer.prototype.initialize.call(this, name, options);
        _leaflet2["default"].Util.setOptions(this, options);
        //图层中专题要素的样式
        this.style = [];
        //用于指定专题要素样式的属性字段名称。
        // 此属性字段是要用户数据（feature） attributes 中包含的字段，且字段对应的值的类型必须是数值型。使用标签分组显示还需要设置 styleGroups 属性。

        this.themeField = null;

        //使用此属性需要设置 themeField 属性。
        //1.没有同时设置 themeField 和 styleGroups，则所有专题要素都使用本图层的 style 进行渲染；
        //2.同时设置 themeField 和 styleGroups，则按照 themeField 指定的字段名称获取用户数据（feature）attributes 中对应的属性值；
        //   a.如果属性值等于 styleGroups 数组里某个元素定义的 value 值，则此专题要素取 styleGroups 数组中该元素定义的 style 进行渲染。
        //   b.如果属性值不等于 styleGroups 数组里任何元素定义的 value 值，则此专题要素按照本图层的 style 进行渲染。
        //此数组每个元素对象必须有两个属性：value : 与字段 themeField 相对应的属性值；style：专题要素 style。
        this.styleGroups = [];

        this.defaultStyle = {
            //默认文本样式
            fontColor: "#000000",
            fontOpacity: 1,
            fontSize: "12px",
            fontStyle: "normal",
            fontWeight: "normal",
            labelAlign: "cm",
            labelXOffset: 0,
            labelYOffset: 0,
            labelRotation: 0,

            //默认样式
            fill: false,
            fillColor: "#ee9900",
            fillOpacity: 0.4,
            stroke: false,
            strokeColor: "#ee9900",
            strokeOpacity: 1,
            strokeWidth: 1,
            strokeLinecap: "round",
            strokeDashstyle: "solid",

            //默认显示背景框
            labelRect: true,
            //对用户隐藏但必须保持此值的属性
            //cursor: "pointer",

            labelSelect: true,

            //用  _isGeoTextStrategyStyle 标记此style，携带此类style的要素特指GeoText策略中的标签要素
            _isGeoTextStrategyStyle: true
        };

        //获取标签像素 bounds 的方式。0 - 表示通过文本类容和文本风格计算获取像素范围，现在支持中文、英文; 1 - 表示通过绘制的文本标签获取像素范围，支持各个语种的文字范围获取，但性能消耗较大（尤其是采用SVG渲染）。默认值为0。
        this.getPxBoundsMode = 0;
    },
    /**
     * @function L.supermap.ThemeLayer.prototype.onAdd
     * @description 添加专题图
     * @param map - {L.map} 要添加的地图
     */
    onAdd: function onAdd(map) {
        _GeoFeatureThemeLayer.GeoFeatureThemeLayer.prototype.onAdd.call(this, map);
        this.container.style.zIndex = 200;
    },
    /**
     * @function L.supermap.LabelThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘所有专题要素。
     *              此方法包含绘制专题要素的所有步骤，包含用户数据到专题要素的转换，抽稀，缓存等步骤。
     *              地图漫游时调用此方法进行图层刷新。
     * @param bounds -{L.bounds} 重绘范围
     */
    redrawThematicFeatures: function redrawThematicFeatures(bounds) {
        if (!this.labelFeatures || this.labelFeatures.length == 0) {
            var feats = this.setLabelsStyle(this.features);
            this.labelFeatures = [];
            for (var i = 0, len = feats.length; i < len; i++) {
                this.labelFeatures.push(feats[i]);
            }
        }
        this.features = this.getDrawnLabels(this.labelFeatures);
        _GeoFeatureThemeLayer.GeoFeatureThemeLayer.prototype.redrawThematicFeatures.call(this, bounds);
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.getDrawnLabels
     * @description 获取经（压盖）处理后将要绘制在图层上的标签要素
     * @param labelFeatures -{Array<SuperMap.Feature.Vector>}  所有标签要素的数组。
     * @return {Array<SuperMap.Feature.Vector>}  最终要绘制的标签要素数组。
     */
    getDrawnLabels: function getDrawnLabels(labelFeatures) {
        var feas = [],
            //最终要绘制的标签要素集
        fea,
            //最终要绘制的标签要素
        fi,
            //临时标签要素，用户的第i个标签
        labelsB = [],
            //不产生压盖的标签要素范围集
        styTmp,
            //用于临时存储要素style的变量
        feaSty,
            //标签要素最终的style
        // styleTemp用于屏蔽文本style中带有偏移性质style属性，偏移已经在计算bounds的过程中参与了运算，
        // 所以在最终按照bounds来绘制标签时，需屏蔽style中带有偏移性质属性，否则文本的偏移量将扩大一倍。
        styleTemp = {
            labelAlign: "cm",
            labelXOffset: 0,
            labelYOffset: 0
        };

        var map = this._map;
        var mapSize = map.getSize();
        var zoom = map.getZoom();
        //对用户的每个标签要素进行处理与判断
        for (var i = 0, len = labelFeatures.length; i < len; i++) {
            fi = labelFeatures[i];
            //检查fi的style在避让中是否被改变，如果改变，重新设置要素的style
            if (fi.isStyleChange || fi.isStyleChange === undefined) {
                fi = this.setStyle(fi);
            }

            //标签最终的中心点像素位置 （偏移后）
            var loc = this.getLabelPxLocation(fi);

            //过滤掉地图范围外的标签 （偏移后）
            if (loc.x >= 0 && loc.x <= mapSize.x && loc.y >= 0 && loc.y <= mapSize.y) {
                //根据当前地图缩放级别过滤标签
                if (fi.style.minZoomLevel > -1) {
                    if (zoom <= fi.style.minZoomLevel) {
                        continue;
                    }
                }
                if (fi.style.maxZoomLevel > -1) {
                    if (zoom > fi.style.maxZoomLevel) {
                        continue;
                    }
                }

                //计算标签bounds
                var boundsQuad = null;
                if (fi.isStyleChange) {
                    fi.isStyleChange = null;
                    boundsQuad = this.calculateLabelBounds(fi, loc);
                } else {
                    if (fi.geometry.bsInfo.w && fi.geometry.bsInfo.h) {
                        //使用calculateLabelBounds2可以提高bounds的计算效率，尤其是在getPxBoundsMode = 1时
                        boundsQuad = this.calculateLabelBounds2(fi, loc);
                    } else {
                        boundsQuad = this.calculateLabelBounds(fi, loc);
                    }
                }

                //避让处理 -start
                var mapViewBounds = new _iclientCommon.Bounds(0, mapSize.y, mapSize.x, 0),
                    //地图像素范围
                quadlen = boundsQuad.length;

                if (this.options.isAvoid) {
                    var avoidInfo = this.getAvoidInfo(mapViewBounds, boundsQuad); //避让信息

                    if (avoidInfo) {
                        //横向（x方向）上的避让
                        if (avoidInfo.aspectW === "left") {
                            fi.style.labelXOffset += avoidInfo.offsetX;

                            for (var j = 0; j < quadlen; j++) {
                                boundsQuad[j].x += avoidInfo.offsetX;
                            }
                        } else if (avoidInfo.aspectW === "right") {
                            fi.style.labelXOffset += -avoidInfo.offsetX;

                            for (var _j = 0; _j < quadlen; _j++) {
                                boundsQuad[_j].x += -avoidInfo.offsetX;
                            }
                        }

                        //纵向（y方向）上的避让
                        if (avoidInfo.aspectH === "top") {
                            fi.style.labelYOffset += avoidInfo.offsetY;

                            for (var _j2 = 0; _j2 < quadlen; _j2++) {
                                boundsQuad[_j2].y += avoidInfo.offsetY;
                            }
                        } else if (avoidInfo.aspectH === "bottom") {
                            fi.style.labelYOffset += -avoidInfo.offsetY;

                            for (var _j3 = 0; _j3 < quadlen; _j3++) {
                                boundsQuad[_j3].y += -avoidInfo.offsetY;
                            }
                        }

                        //如果style发生变化，记录下来
                        fi.isStyleChange = true;
                    }
                }
                //避让处理 -end

                //压盖处理 -start
                if (this.options.isOverLay) {
                    //是否压盖
                    var isOL = false;

                    if (i != 0) {
                        for (var _j4 = 0; _j4 < labelsB.length; _j4++) {
                            //压盖判断
                            if (this.isQuadrilateralOverLap(boundsQuad, labelsB[_j4])) {
                                isOL = true;
                                break;
                            }
                        }
                    }

                    if (isOL) {
                        continue;
                    } else {
                        labelsB.push(boundsQuad);
                    }
                }
                //压盖处理 -end

                //背景（事件）-start

                //将标签像素范围转为地理范围
                var geoBs = [];
                for (var _j5 = 0; _j5 < quadlen - 1; _j5++) {
                    geoBs.push(map.containerPointToLatLng(boundsQuad[_j5]));
                }

                //屏蔽有偏移性质的style属性,偏移量在算bounds时已经加入计算
                var leftBottom = map.options.crs.project(geoBs[3]);
                var rightTop = map.options.crs.project(geoBs[1]);
                var bounds = new _iclientCommon.Bounds(leftBottom.x, leftBottom.y, rightTop.x, [rightTop.y]);
                var center = bounds.getCenterLonLat();
                var label = new _iclientCommon.GeoText(center.lon, center.lat, fi.attributes[this.themeField]);
                label.calculateBounds();
                styTmp = _iclientCommon.CommonUtil.cloneObject(fi.style);
                feaSty = _iclientCommon.CommonUtil.cloneObject(_iclientCommon.CommonUtil.copyAttributes(styTmp, styleTemp));
                fea = new _iclientCommon.GeometryVector(label, fi.attributes, feaSty);
                //赋予id
                fea.id = fi.id;
                fea.fid = fi.fid;
                feas.push(fea);
            }
        }

        //返回最终要绘制的标签要素
        return feas;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.getStyleByData
     * @description 根据用户数据（feature）设置专题要素的 Style
     * @param feat -{SuperMap.Feature.Vector} 矢量要素对象
     * @return {Array<SuperMap.ThemeStyle>} 专题要素的 Style
     */
    getStyleByData: function getStyleByData(feat) {
        var feature = feat;
        feature.style = _iclientCommon.CommonUtil.copyAttributes(feature.style, this.defaultStyle);
        //将style赋给标签
        if (this.style && this.style.fontSize && parseFloat(this.style.fontSize) < 12) {
            this.style.fontSize = "12px";
        }
        feature.style = _iclientCommon.CommonUtil.copyAttributes(feature.style, this.style);

        if (this.themeField && this.styleGroups && feature.attributes) {
            var Sf = this.themeField;
            var attributes = feature.attributes;
            var groups = this.styleGroups;
            var isSfInAttrs = false; //指定的 groupField 是否是geotext的属性字段之一
            var attr = null; //属性值

            for (var property in attributes) {
                if (Sf === property) {
                    isSfInAttrs = true;
                    attr = attributes[property];
                    break;
                }
            }

            //判断属性值是否属于styleGroups的某一个范围，以便对标签分组
            if (isSfInAttrs) {
                for (var i = 0, len = groups.length; i < len; i++) {
                    if (attr >= groups[i].start && attr < groups[i].end) {
                        var sty1 = groups[i].style;
                        if (sty1 && sty1.fontSize && parseFloat(sty1.fontSize) < 12) {
                            sty1.fontSize = "12px";
                        }
                        feature.style = _iclientCommon.CommonUtil.copyAttributes(feature.style, sty1);
                    }
                }
            }
            feature.style.label = feature.attributes[this.themeField];
        }

        return feature.style;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.setLabelsStyle
     * @description 设置标签要素的Style
     * @param labelFeatures -{Array<SuperMap.Feature.Vector>} 需要设置 Style 的标签要素数组。
     * @return {Array<SuperMap.Feature.Vector>}  赋予 Style 后的标签要素数组。
     */
    setLabelsStyle: function setLabelsStyle(labelFeatures) {
        var fea,
            labelFeas = [];
        for (var i = 0, len = labelFeatures.length; i < len; i++) {
            var feature = labelFeatures[i];
            if (feature.geometry.CLASS_NAME === "SuperMap.Geometry.GeoText") {
                //设置标签的Style
                if (feature.geometry.bsInfo.w || feature.geometry.bsInfo.h) {
                    feature.geometry.bsInfo.w = null;
                    feature.geometry.bsInfo.h = null;
                    feature.geometry.labelWTmp = null;
                }
                fea = this.setStyle(feature);
                //为标签要素指定图层
                fea.layer = this.layer;
                labelFeas.push(fea);
            } else {
                return labelFeatures;
            }
        }
        return labelFeas;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.setStyle
     * @description 设置标签要素的Style
     * @param feat -{SuperMap.Feature.Vector} 需要赋予 style 的要素。
     */
    setStyle: function setStyle(feat) {
        var feature = feat;
        feature.style = _iclientCommon.CommonUtil.copyAttributes(feature.style, this.defaultStyle);
        //将style赋给标签
        if (this.style && this.style.fontSize && parseFloat(this.style.fontSize) < 12) {
            this.style.fontSize = "12px";
        }
        feature.style = _iclientCommon.CommonUtil.copyAttributes(feature.style, this.style);

        if (this.groupField && this.styleGroups && feature.attributes) {
            var Sf = this.groupField;
            var Attrs = feature.attributes;
            var Gro = this.styleGroups;
            var isSfInAttrs = false; //指定的 groupField 是否是geotext的属性字段之一
            var attr = null; //属性值

            for (var property in Attrs) {
                if (Sf === property) {
                    isSfInAttrs = true;
                    attr = Attrs[property];
                    break;
                }
            }

            //判断属性值是否属于styleGroups的某一个范围，以便对标签分组
            if (isSfInAttrs) {
                for (var i = 0, len = Gro.length; i < len; i++) {
                    if (attr >= Gro[i].start && attr < Gro[i].end) {
                        //feature.style = Util.copyAttributes(feature.style, this.defaultStyle);
                        var sty1 = Gro[i].style;
                        if (sty1 && sty1.fontSize && parseFloat(sty1.fontSize) < 12) {
                            sty1.fontSize = "12px";
                        }
                        feature.style = _iclientCommon.CommonUtil.copyAttributes(feature.style, sty1);
                    }
                }
            }
        }

        //将文本内容赋到标签要素的style上
        feature.style.label = feature.geometry.text;

        return feature;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.getLabelPxLocation
     * @description 获取标签要素的像素坐标
     * @param feature -{SuperMap.Feature.Vector}  标签要素。
     * @return {L.point} 标签位置
     */
    getLabelPxLocation: function getLabelPxLocation(feature) {
        var geoText = feature.geometry;
        var styleTmp = feature.style;

        //将标签的地理位置转为像素位置
        var locationTmp = geoText.getCentroid();
        var locTmp = this._map.latLngToContainerPoint(this._map.options.crs.unproject(_leaflet2["default"].point(locationTmp.x, locationTmp.y)));
        var loc = _leaflet2["default"].point(locTmp.x, locTmp.y);

        //偏移处理
        if (styleTmp.labelXOffset || styleTmp.labelYOffset) {
            var xOffset = isNaN(styleTmp.labelXOffset) ? 0 : styleTmp.labelXOffset;
            var yOffset = isNaN(styleTmp.labelYOffset) ? 0 : styleTmp.labelYOffset;
            var point = loc.add(_leaflet2["default"].point(xOffset, -yOffset));
            return _leaflet2["default"].point(point.x, point.y);
        } else {
            return _leaflet2["default"].point(loc.x, loc.y);
        }
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.calculateLabelBounds
     * @description 获得标签要素的最终范围
     *
     * @param feature - {SuperMap.Feature.Vector} 需要计算bounds的标签要素数。
     * @param loc - {L.point} 标签位置
     *
     * @return {Array<Object>}  四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     */
    calculateLabelBounds: function calculateLabelBounds(feature, loc) {
        var geoText = feature.geometry;

        //标签范围（未旋转前）
        var labB = null;
        var labelInfo = null;
        //获取bounds的方式
        if (this.getPxBoundsMode == 0) {
            labB = geoText.getLabelPxBoundsByText(loc, feature.style);
        } else if (this.getPxBoundsMode === 1) {
            //canvas
            labelInfo = this.getLabelInfo(feature.geometry.getCentroid(), feature.style);
            labB = geoText.getLabelPxBoundsByLabel(loc, labelInfo.w, labelInfo.h, feature.style);
        } else {
            return null;
        }

        //旋转Bounds
        var boundsQuad = [];
        if (feature.style.labelRotation % 180 == 0) {
            boundsQuad = [{ "x": labB.left, "y": labB.top }, { "x": labB.right, "y": labB.top }, { "x": labB.right, "y": labB.bottom }, { "x": labB.left, "y": labB.bottom }, { "x": labB.left, "y": labB.top }];
        } else {
            boundsQuad = this.rotationBounds(labB, loc, feature.style.labelRotation);
        }

        //重置GeoText的bounds
        geoText.bounds = new _iclientCommon.Bounds(boundsQuad[1].x, boundsQuad[3].y, boundsQuad[2].x, boundsQuad[4].y);
        return boundsQuad;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.calculateLabelBounds2
     * @description 获得标签要素的最终范围的另一种算法（通过记录下的标签宽高），提高计算bounds的效率。
     *
     * @param feature - {SuperMap.Feature.Vector} 需要计算bounds的标签要素数。
     * @param loc - {L.point} 标签位置
     *
     * @return {Array<Object>}  四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     */
    calculateLabelBounds2: function calculateLabelBounds2(feature, loc) {
        var labB, left, bottom, top, right;
        var labelSize = feature.geometry.bsInfo;
        var style = feature.style;
        var locationPx = _iclientCommon.CommonUtil.cloneObject(loc);

        //处理文字对齐
        if (style.labelAlign && style.labelAlign !== "cm") {
            switch (style.labelAlign) {
                case "lt":
                    locationPx.x += labelSize.w / 2;
                    locationPx.y += labelSize.h / 2;
                    break;
                case "lm":
                    locationPx.x += labelSize.w / 2;
                    break;
                case "lb":
                    locationPx.x += labelSize.w / 2;
                    locationPx.y -= labelSize.h / 2;
                    break;
                case "ct":
                    locationPx.y += labelSize.h / 2;
                    break;
                case "cb":
                    locationPx.y -= labelSize.h / 2;
                    break;
                case "rt":
                    locationPx.x -= labelSize.w / 2;
                    locationPx.y += labelSize.h / 2;
                    break;
                case "rm":
                    locationPx.x -= labelSize.w / 2;
                    break;
                case "rb":
                    locationPx.x -= labelSize.w / 2;
                    locationPx.y -= labelSize.h / 2;
                    break;
                default:
                    break;
            }
        }

        left = locationPx.x - labelSize.w / 2;
        bottom = locationPx.y + labelSize.h / 2;
        //处理斜体字
        if (style.fontStyle && style.fontStyle === "italic") {
            right = locationPx.x + labelSize.w / 2 + parseInt(parseFloat(style.fontSize) / 2);
        } else {
            right = locationPx.x + labelSize.w / 2;
        }
        top = locationPx.y - labelSize.h / 2;

        labB = new _iclientCommon.Bounds(left, bottom, right, top);

        //旋转Bounds
        var boundsQuad = [];
        if (style.labelRotation % 180 == 0) {
            boundsQuad = [{ "x": labB.left, "y": labB.top }, { "x": labB.right, "y": labB.top }, { "x": labB.right, "y": labB.bottom }, { "x": labB.left, "y": labB.bottom }, { "x": labB.left, "y": labB.top }];
        } else {
            boundsQuad = this.rotationBounds(labB, loc, style.labelRotation);
        }

        //重置GeoText的bounds
        feature.geometry.bounds = new _iclientCommon.Bounds(boundsQuad[1].x, boundsQuad[3].y, boundsQuad[2].x, boundsQuad[4].y);
        return boundsQuad;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.getLabelInfo
     * @description 根据当前位置获取绘制后的标签信息，包括标签的宽，高和行数等
     * @return {Object} 绘制后的标签信息
     */
    getLabelInfo: function getLabelInfo(location, style) {
        var LABEL_ALIGN = {
            "l": "left",
            "r": "right",
            "t": "top",
            "b": "bottom"
        },
            LABEL_FACTOR = {
            "l": 0,
            "r": -1,
            "t": 0,
            "b": -1
        };

        style = _iclientCommon.CommonUtil.extend({
            fontColor: "#000000",
            labelAlign: "cm"
        }, style);
        var pt = this.getLocalXY(location);
        var labelWidth = 0;

        if (style.labelXOffset || style.labelYOffset) {
            var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
            var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
            pt[0] += xOffset;
            pt[1] -= yOffset;
        }

        var canvas = document.createElement('canvas');
        canvas.globalAlpha = 0;
        canvas.lineWidth = 1;

        var ctx = canvas.getContext("2d");

        ctx.fillStyle = style.fontColor;
        ctx.globalAlpha = style.fontOpacity || 1.0;
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal", "normal", style.fontWeight ? style.fontWeight : "normal", style.fontSize ? style.fontSize : "1em", style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;
        var vfactor, lineHeight, labelWidthTmp;
        if (ctx.fillText) {
            // HTML5
            ctx.font = fontStyle;
            ctx.textAlign = LABEL_ALIGN[style.labelAlign[0]] || "center";
            ctx.textBaseline = LABEL_ALIGN[style.labelAlign[1]] || "middle";
            vfactor = LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            lineHeight = ctx.measureText('Mg').height || ctx.measureText('xx').width;
            pt[1] += lineHeight * vfactor * (numRows - 1);
            for (var i = 0; i < numRows; i++) {
                labelWidthTmp = ctx.measureText(labelRows[i]).width;
                if (labelWidth < labelWidthTmp) {
                    labelWidth = labelWidthTmp;
                }
            }
        } else if (ctx.mozDrawText) {
            // Mozilla pre-Gecko1.9.1 (<FF3.1)
            ctx.mozTextStyle = fontStyle;
            vfactor = LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            lineHeight = ctx.mozMeasureText('xx');
            pt[1] += lineHeight * (1 + vfactor * numRows);
            for (var _i = 0; _i < numRows; _i++) {
                labelWidthTmp = ctx.measureText(labelRows[_i]).width;
                if (labelWidth < labelWidthTmp) {
                    labelWidth = labelWidthTmp;
                }
            }
        }
        var labelInfo = {}; //标签信息
        if (labelWidth) {
            labelInfo.w = labelWidth; //标签的宽
        } else {
            return null;
        }

        labelInfo.h = style.fontSize; //一行标签的高
        labelInfo.rows = labelRows.length; //标签的行数

        return labelInfo;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.rotationBounds
     * @description 旋转bounds。
     *
     * @param bounds -{SuperMap.Bounds}  要旋转的bounds。
     * @param rotationCenterPoi -{Object}  旋转中心点对象，此对象含有属性x(横坐标)，属性y(纵坐标)。
     * @param angle -{number}  旋转角度（顺时针）。
     *
     * @return {Array<Object>}  bounds旋转后形成的多边形节点数组。是一个四边形，形如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]
     */
    rotationBounds: function rotationBounds(bounds, rotationCenterPoi, angle) {
        var ltPoi = _leaflet2["default"].point(bounds.left, bounds.top);
        var rtPoi = _leaflet2["default"].point(bounds.right, bounds.top);
        var rbPoi = _leaflet2["default"].point(bounds.right, bounds.bottom);
        var lbPoi = _leaflet2["default"].point(bounds.left, bounds.bottom);

        var ver = [];
        ver.push(this.getRotatedLocation(ltPoi.x, ltPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));
        ver.push(this.getRotatedLocation(rtPoi.x, rtPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));
        ver.push(this.getRotatedLocation(rbPoi.x, rbPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));
        ver.push(this.getRotatedLocation(lbPoi.x, lbPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));

        //bounds旋转后形成的多边形节点数组
        var quad = [];

        for (var i = 0; i < ver.length; i++) {
            quad.push({ "x": ver[i].x, "y": ver[i].y });
        }
        quad.push({ "x": ver[0].x, "y": ver[0].y });
        return quad;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.getRotatedLocation
     * @description 获取一个点绕旋转中心顺时针旋转后的位置。（此方法用于屏幕坐标）
     *
     * @param x -{number}  旋转点横坐标。
     * @param y -{number}  旋转点纵坐标。
     * @param rx -{number}  旋转中心点横坐标。
     * @param ry -{number}  旋转中心点纵坐标。
     * @param angle -{number} 旋转角度
     *
     * @return {Object} 旋转后的坐标位置对象，该对象含有属性x(横坐标)，属性y(纵坐标)。
     */
    getRotatedLocation: function getRotatedLocation(x, y, rx, ry, angle) {
        var loc = {},
            x0,
            y0;

        y = -y;
        ry = -ry;
        angle = -angle; //顺时针旋转
        x0 = (x - rx) * Math.cos(angle / 180 * Math.PI) - (y - ry) * Math.sin(angle / 180 * Math.PI) + rx;
        y0 = (x - rx) * Math.sin(angle / 180 * Math.PI) + (y - ry) * Math.cos(angle / 180 * Math.PI) + ry;

        loc.x = x0;
        loc.y = -y0;

        return loc;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.getAvoidInfo
     * @description 获取避让的信息。
     *
     * @param bounds -{SuperMap.Bounds}  地图像素范围。
     * @param quadrilateral -{Array<Object>}  四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     *
     * @return {Object} 避让的信息
     */
    getAvoidInfo: function getAvoidInfo(bounds, quadrilateral) {
        if (quadrilateral.length !== 5) {
            return null;
        } //不是四边形

        //将bound序列化为点数组形式
        var bounddQuad = [{ "x": bounds.left, "y": bounds.top }, { "x": bounds.right, "y": bounds.top }, { "x": bounds.right, "y": bounds.bottom }, { "x": bounds.left, "y": bounds.bottom }, { "x": bounds.left, "y": bounds.top }];

        var isIntersection = false,
            bqLen = bounddQuad.length,
            quadLen = quadrilateral.length;

        var offsetX = 0,
            offsetY = 0,
            aspectH = "",
            aspectW = "";
        for (var i = 0; i < bqLen - 1; i++) {
            for (var j = 0; j < quadLen - 1; j++) {
                var isLineIn = _iclientCommon.CommonUtil.lineIntersection(bounddQuad[i], bounddQuad[i + 1], quadrilateral[j], quadrilateral[j + 1]);
                if (isLineIn.CLASS_NAME === "SuperMap.Geometry.Point") {
                    //设置避让信息
                    setInfo(quadrilateral[j]);
                    setInfo(quadrilateral[j + 1]);
                    isIntersection = true;
                }
            }
        }

        if (isIntersection) {
            //组织避让操作所需的信息
            return {
                "aspectW": aspectW,
                "aspectH": aspectH,
                "offsetX": offsetX,
                "offsetY": offsetY
            };
        } else {
            return null;
        }

        //内部函数：设置避让信息
        //参数：vec-{Object}  quadrilateral四边形单个节点。如：{"x":1,"y":1}。
        function setInfo(vec) {
            //四边形不在bounds内的节点
            if (!bounds.contains(vec.x, vec.y)) {
                //bounds的Top边
                if (vec.y < bounds.top) {
                    var oY = Math.abs(bounds.top - vec.y);
                    if (oY > offsetY) {
                        offsetY = oY;
                        aspectH = "top";
                    }
                }

                //bounds的Bottom边
                if (vec.y > bounds.bottom) {
                    var _oY = Math.abs(vec.y - bounds.bottom);
                    if (_oY > offsetY) {
                        offsetY = _oY;
                        aspectH = "bottom";
                    }
                }

                //bounds的left边
                if (vec.x < bounds.left) {
                    var oX = Math.abs(bounds.left - vec.x);
                    if (oX > offsetX) {
                        offsetX = oX;
                        aspectW = "left";
                    }
                }

                //bounds的right边
                if (vec.x > bounds.right) {
                    var _oX = Math.abs(vec.x - bounds.right);
                    if (_oX > offsetX) {
                        offsetX = _oX;
                        aspectW = "right";
                    }
                }
            }
        }
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.isQuadrilateralOverLap
     * @description 判断两个四边形是否有压盖
     *
     * @param quadrilateral -{Array<Object>}  四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     * @param quadrilateral2 -{Array<Object>}  第二个四边形节点数组。
     *
     * @return {boolean} 是否压盖，true表示压盖
     */
    isQuadrilateralOverLap: function isQuadrilateralOverLap(quadrilateral, quadrilateral2) {
        var quadLen = quadrilateral.length,
            quad2Len = quadrilateral2.length;
        if (quadLen !== 5 || quad2Len !== 5) {
            return null;
        } //不是四边形

        var OverLap = false;
        //如果两四边形互不包含对方的节点，则两个四边形不相交
        for (var i = 0; i < quadLen; i++) {
            if (this.isPointInPoly(quadrilateral[i], quadrilateral2)) {
                OverLap = true;
                break;
            }
        }
        for (var _i2 = 0; _i2 < quad2Len; _i2++) {
            if (this.isPointInPoly(quadrilateral2[_i2], quadrilateral)) {
                OverLap = true;
                break;
            }
        }
        //加上两矩形十字相交的情况
        for (var _i3 = 0; _i3 < quadLen - 1; _i3++) {
            if (OverLap) {
                break;
            }
            for (var j = 0; j < quad2Len - 1; j++) {
                var isLineIn = _iclientCommon.CommonUtil.lineIntersection(quadrilateral[_i3], quadrilateral[_i3 + 1], quadrilateral2[j], quadrilateral2[j + 1]);
                if (isLineIn.CLASS_NAME === "SuperMap.Geometry.Point") {
                    OverLap = true;
                    break;
                }
            }
        }

        return OverLap;
    },

    /**
     * @function L.supermap.LabelThemeLayer.prototype.isPointInPoly
     * @description 判断一个点是否在多边形里面。(射线法)
     *
     * @param pt - {Object} 需要判定的点对象，该对象含有属性x(横坐标)，属性y(纵坐标)。
     * @param poly - {Array<Object>}  多边形节点数组。例如一个四边形：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]
     * @return {boolean} 点是否在多边形内
     */
    isPointInPoly: function isPointInPoly(pt, poly) {
        for (var isIn = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {
            (poly[i].y <= pt.y && pt.y < poly[j].y || poly[j].y <= pt.y && pt.y < poly[i].y) && pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x && (isIn = !isIn);
        }
        return isIn;
    }

});

var labelThemeLayer = exports.labelThemeLayer = function labelThemeLayer(name, options) {
    return new LabelThemeLayer(name, options);
};

_leaflet2["default"].supermap.labelThemeLayer = labelThemeLayer;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rangeThemeLayer = exports.RangeThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _GeoFeatureThemeLayer = __webpack_require__(111);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.rangeThemeLayer
 * @classdesc 范围分段专题图。
 * @description 范围分段专题图对数据（<{@link SuperMap.Feature.Vector}>）属性字段（attributes）的属性值进行分段，使用不同的颜色或符号（线型、填充）渲染不同范围段的属性值。
 *            分段专题图一般用来反映连续分布现象的数量或程度特征，如降水量的分布，土壤侵蚀强度的分布等。
 * @extends L.supermap.GeoFeatureThemeLayer
 * @param name - {string} 图层名
 * @param options - {Object} 图层参数。如：<br>
 *        nodesClipPixel - {number}节点抽稀像素距离，默认值 2。<br>
 *        isHoverAble - {boolean} 图形是否在 hover 时高亮 ，默认值：false。<br>
 *        isMultiHover - {boolean} 是否多图形同时高亮，用于高亮同一个数据对应的所有图形（如：多面），默认值：false。<br>
 *        isClickAble - {boolean} 图形是否可点击，默认 true。<br>
 *        isAllowFeatureStyle - {boolean} 是否允许 feature 样式（style） 中的有效属性应用到专题图层。
 *                                        默认值为： false，禁止对专题要素使用数据（feature）的 style。
 *                                        此属性可强制将数据 feature 的 style 中有效属性应用到专题要素上，且拥有比图层 style 和 styleGroups 更高的优先级，使专题要素
 *                                        的样式脱离专题图层的控制。可以通过此方式实现对特殊数据（feature） 对应专题要素赋予独立 style。
 */
var RangeThemeLayer = exports.RangeThemeLayer = _GeoFeatureThemeLayer.GeoFeatureThemeLayer.extend({

    initialize: function initialize(name, options) {
        _GeoFeatureThemeLayer.GeoFeatureThemeLayer.prototype.initialize.call(this, name, options);
        //{Array<SuperMap.ThemeStyle>} 图层中专题要素的样式
        this.style = [];
        //{String} 用于指定专题要素样式的属性字段名称。
        // 此属性字段是要用户数据（feature） attributes 中包含的字段，且字段对应的值的类型必须是数值型。使用标签分组显示还需要设置 styleGroups 属性。

        this.themeField = null;

        //使用此属性需要设置 themeField 属性。
        //1.没有同时设置 themeField 和 styleGroups，则所有专题要素都使用本图层的 style 进行渲染；
        //2.同时设置 themeField 和 styleGroups，则按照 themeField 指定的字段名称获取用户数据（feature）attributes 中对应的属性值；
        //   a.如果属性值等于 styleGroups 数组里某个元素定义的 value 值，则此专题要素取 styleGroups 数组中该元素定义的 style 进行渲染。
        //   b.如果属性值不等于 styleGroups 数组里任何元素定义的 value 值，则此专题要素按照本图层的 style 进行渲染。
        //此数组每个元素对象必须有两个属性：value : 与字段 themeField 相对应的属性值；style：专题要素 style。
        this.styleGroups = [];
    },

    /**
     * @function L.supermap.rangeThemeLayer.prototype.getStyleByData
     * @description 根据用户数据（feature）设置专题要素的 Style
     * @param feat - {SuperMap.Feature.Vector} 矢量要素对象
     * @return {Array<SuperMap.ThemeStyle>} 专题要素的 Style
     */
    getStyleByData: function getStyleByData(feat) {
        var me = this,
            feature = feat,
            style = _iclientCommon.CommonUtil.copyAttributesWithClip({}, me.style);

        var groups = me.styleGroups,
            isSfInAttributes = false,
            //指定的 themeField 是否是 feature 的属性字段之一
        attribute = null; //属性值

        var isValidStyleGroup = me.styleGroups && me.styleGroups.length > 0;

        if (me.themeField && isValidStyleGroup && feature.attributes) {
            var Sf = me.themeField,
                attributes = feature.attributes;

            for (var property in attributes) {
                if (Sf !== property) {
                    continue;
                }
                isSfInAttributes = true;
                attribute = attributes[property];
                break;
            }
        }

        //判断属性值是否属于styleGroups的某一个范围，以便对获取分组 style
        if (isSfInAttributes && isValidStyleGroup) {
            for (var i = 0, len = groups.length; i < len; i++) {
                if (attribute >= groups[i].start && attribute < groups[i].end) {
                    var sty1 = groups[i].style;
                    style = _iclientCommon.CommonUtil.copyAttributesWithClip(style, sty1);
                }
            }
        }
        return style;
    }

});
var rangeThemeLayer = exports.rangeThemeLayer = function rangeThemeLayer(name, options) {
    return new RangeThemeLayer(name, options);
};

_leaflet2["default"].supermap.rangeThemeLayer = rangeThemeLayer;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unicodeMarker = exports.UnicodeMarker = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.unicodeMarker
 * @classdesc Unicode字符图标。
 * @extends L.Path{@linkdoc-leaflet/#Path}
 * @param latlng -[L.LatLngBounds]{@linkdoc-leaflet/#latlng}} 经纬度坐标
 * @param options -{Object} 符号参数。<br>
 *        label - {string} 符号Unicode值 <br>
 *        labelRotation - {string} 符号旋转角度 <br>
 *        globalAlpha - {string} 符号的透明值 <br>
 *        fontStyle - {string} 符号的风格 <br>
 *        fontWeight - {string} 符号的粗细 <br>
 *        fontSize - {string} 符号的尺寸 <br>
 *        fontFamily - {string} 符号的字体 <br>
 *        textAlign - {string} 符号内容的对齐方式 <br>
 *        textBaseline - {string} 绘制符号时使用的基线 <br>
 */
var UnicodeMarker = exports.UnicodeMarker = _leaflet2["default"].Path.extend({
    // @section
    // @aka CircleMarker options
    options: {
        fontStyle: "normal",
        fontWeight: "normal",
        fontSize: "1em",
        fontFamily: "sans-serif",
        textAlign: "center",
        textBaseline: "middle",
        vfactor: -.5,
        labelRotation: 0,
        globalAlpha: 1,
        label: ""
    },

    initialize: function initialize(latlng, options) {
        _leaflet2["default"].Util.setOptions(this, options);
        this._latlng = latlng;
    },

    // @method setLatLng(latLng: LatLng): this
    // Sets the position of a circle marker to a new location.
    setLatLng: function setLatLng(latlng) {
        this._latlng = latlng;
        this.redraw();
        return this.fire('move', { latlng: this._latlng });
    },

    // @method getLatLng(): LatLng
    // Returns the current geographical position of the circle marker
    getLatLng: function getLatLng() {
        return this._latlng;
    },

    _project: function _project() {
        this._point = this._map.latLngToLayerPoint(this._latlng);
        this._updateBounds();
    },

    _updateBounds: function _updateBounds() {
        var w = this._clickTolerance(),
            p = [w, w];
        this._pxBounds = new _leaflet2["default"].Bounds(this._point.subtract(p), this._point.add(p));
    },
    _update: function _update() {
        if (this._map) {
            this._updatePath();
        }
    },

    _updatePath: function _updatePath() {
        this._renderer._updateUnicode(this);
    },
    // Needed by the `Canvas` renderer for interactivity
    _containsPoint: function _containsPoint(p) {
        return p.distanceTo(this._point) <= this._clickTolerance();
    }
});
var unicodeMarker = exports.unicodeMarker = function unicodeMarker(latlng, options) {
    return new UnicodeMarker(latlng, options);
};

_leaflet2["default"].Canvas.include({
    _updateUnicode: function _updateUnicode(layer) {
        if (!this._drawing) {
            return;
        }
        this._drawnLayers[layer._leaflet_id] = layer;
        var pt = { x: layer._point.x, y: layer._point.y },
            ctx = this._ctx,
            fontStyle = [layer.options.fontStyle, "normal", layer.options.fontWeight, layer.options.fontSize, layer.options.fontFamily].join(" ");
        var label = layer.options.label.replace(/^&#x/, '');
        label = String.fromCharCode(parseInt(label, 16));
        var labelRows = label.split('\n');
        var numRows = labelRows.length;
        // if (layer.options.labelXOffset || layer.options.labelYOffset) {
        //     let xOffset = isNaN(layer.options.labelXOffset) ? 0 : layer.options.labelXOffset;
        //     let yOffset = isNaN(layer.options.labelYOffset) ? 0 : layer.options.labelYOffset;
        //     pt.x += xOffset;
        //     pt.y -= yOffset;
        // }
        ctx.fillStyle = layer.options.fontColor;
        ctx.globalAlpha = 1.0;
        if (layer.options.fontOpacity >= 0 && layer.options.fontOpacity < 1) {
            ctx.globalAlpha = layer.options.fontOpacity;
        }
        if (ctx.fillText) {
            // HTML5
            ctx.font = fontStyle;
            ctx.textAlign = layer.options.textAlign;
            ctx.textBaseline = layer.options.textBaseline;
            var vfactor = layer.options.vfactor;
            var lineHeight = ctx.measureText('Mg').height || ctx.measureText('xx').width;
            pt.y += lineHeight * vfactor * (numRows - 1);
            for (var i = 0; i < numRows; i++) {
                if (layer.options.labelRotation != 0) {
                    ctx.save();
                    ctx.translate(pt.x, pt.y);
                    ctx.rotate(layer.options.labelRotation * Math.PI / 180);
                    ctx.fillText(labelRows[i], 0, lineHeight * i);
                    ctx.restore();
                } else {
                    ctx.fillText(labelRows[i], pt.x, pt.y);
                }
            }
        } else if (ctx.mozDrawText) {
            // Mozilla pre-Gecko1.9.1 (<FF3.1)
            ctx.mozTextStyle = fontStyle;
            // No built-in text alignment, so we measure and adjust the position
            var hfactor = layer.options.textAlign;
            var _vfactor = layer.options.vfactor;
            var _lineHeight = ctx.mozMeasureText('xx');
            pt.y += _lineHeight * (1 + _vfactor * numRows);
            for (var _i = 0; _i < numRows; _i++) {
                var x = pt.x + hfactor * ctx.mozMeasureText(labelRows[_i]);
                var y = pt.y + _i * _lineHeight;
                ctx.translate(x, y);
                ctx.mozDrawText(labelRows[_i]);
                ctx.translate(-x, -y);
            }
        }
    }
});

_leaflet2["default"].supermap.unicodeMarker = unicodeMarker;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uniqueThemeLayer = exports.UniqueThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _GeoFeatureThemeLayer = __webpack_require__(111);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.uniqueThemeLayer
 * @classdesc 客户端单值专题图
 * @description 单值专题图是利用不同的颜色或符号（线型、填充）表示图层中某一属性信息的不同属性值，属性值相同的要素具有相同的渲染风格<br>
 *            比如土壤类型分布图、土地利用图、行政区划图等。单值专题图着重表示现象质的差别，一般不表示数量的特征。
 * @extends L.supermap.GeoFeatureThemeLayer
 * @param name - {string} 专题图层名
 * @param options - {Object} 可选参数<br>
 *        nodesClipPixel - {number}节点抽稀像素距离，默认值 2。<br>
 *        isHoverAble - {boolean} 图形是否在 hover 时高亮 ，默认值：false。<br>
 *        isMultiHover - {boolean} 是否多图形同时高亮，用于高亮同一个数据对应的所有图形（如：多面），默认值：false。<br>
 *        isClickAble - {boolean} 图形是否可点击，默认 true。<br>
 *        isAllowFeatureStyle - {boolean} 是否允许 feature 样式（style） 中的有效属性应用到专题图层。
 *                                        默认值为： false，禁止对专题要素使用数据（feature）的 style。
 *                                        此属性可强制将数据 feature 的 style 中有效属性应用到专题要素上，且拥有比图层 style 和 styleGroups 更高的优先级，使专题要素
 *                                        的样式脱离专题图层的控制。可以通过此方式实现对特殊数据（feature） 对应专题要素赋予独立 style。
 */
var UniqueThemeLayer = exports.UniqueThemeLayer = _GeoFeatureThemeLayer.GeoFeatureThemeLayer.extend({

    initialize: function initialize(name, options) {
        _GeoFeatureThemeLayer.GeoFeatureThemeLayer.prototype.initialize.call(this, name, options);
        //{Array<SuperMap.ThemeStyle>} 图层中专题要素的样式
        this.style = [];
        //{String} 用于指定专题要素样式的属性字段名称。
        // 此属性字段是要用户数据（feature） attributes 中包含的字段，且字段对应的值的类型必须是数值型。使用标签分组显示还需要设置 styleGroups 属性。

        this.themeField = null;

        //使用此属性需要设置 themeField 属性。
        //1.没有同时设置 themeField 和 styleGroups，则所有专题要素都使用本图层的 style 进行渲染；
        //2.同时设置 themeField 和 styleGroups，则按照 themeField 指定的字段名称获取用户数据（feature）attributes 中对应的属性值；
        //   a.如果属性值等于 styleGroups 数组里某个元素定义的 value 值，则此专题要素取 styleGroups 数组中该元素定义的 style 进行渲染。
        //   b.如果属性值不等于 styleGroups 数组里任何元素定义的 value 值，则此专题要素按照本图层的 style 进行渲染。
        //此数组每个元素对象必须有两个属性：value : 与字段 themeField 相对应的属性值；style：专题要素 style。
        this.styleGroups = [];
    },

    /**
     * @private
     * @function L.supermap.uniqueThemeLayer.prototype.getStyleByData
     * @description 根据用户数据（feature）设置专题要素的 Style
     * @param feat {SuperMap.Feature.Vector} 用户要素数据
     * @return {Array<SuperMap.ThemeStyle>} 返回包含专题要素style的对象
     */
    getStyleByData: function getStyleByData(feat) {
        var me = this,
            feature = feat,
            style = _iclientCommon.CommonUtil.copyAttributesWithClip({}, me.style);

        var groups = me.styleGroups,
            isSfInAttributes = false,
            //指定的 themeField 是否是 feature 的属性字段之一
        attribute = null; //属性值

        var isValidStyleGroup = me.styleGroups && me.styleGroups.length > 0;
        if (me.themeField && isValidStyleGroup && feature.attributes) {
            var tf = me.themeField,
                attributes = feature.attributes;
            for (var property in attributes) {
                if (tf !== property) {
                    continue;
                }
                isSfInAttributes = true;
                attribute = attributes[property];
                break;
            }
        }

        //判断属性值是否属于styleGroups的某一个范围，以便对获取分组 style
        if (isSfInAttributes && isValidStyleGroup) {
            for (var i = 0, len = groups.length; i < len; i++) {
                if (attribute.toString() === groups[i].value.toString()) {
                    var sty1 = groups[i].style;
                    style = _iclientCommon.CommonUtil.copyAttributesWithClip(style, sty1);
                }
            }
        }
        return style;
    }
});

var uniqueThemeLayer = exports.uniqueThemeLayer = function uniqueThemeLayer(name, options) {
    return new UniqueThemeLayer(name, options);
};

_leaflet2["default"].supermap.uniqueThemeLayer = uniqueThemeLayer;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.graphic = exports.Graphic = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.graphic
 * @classdesc 图形类。
 * @private
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param options - {Object} 图形参数
 */
var Graphic = exports.Graphic = _leaflet2["default"].Class.extend({

    initialize: function initialize(options) {
        options = options || {};
        this._latlng = _leaflet2["default"].latLng(options._latlng.lat, options._latlng.lng);
        this._canvas = options._canvas;
    },

    /**
     * @function L.supermap.graphic.prototype.setLatlng
     * @description 设置经纬度
     * @param latlng - {L.latlng} 经纬度参数
     */
    setLatlng: function setLatlng(latlng) {
        this._latlng = latlng;
    },

    /**
     * @function L.supermap.graphic.prototype.setCanvas
     * @description 设置画布
     * @param canvas - {Object} 传入需要设置的画布
     */
    setCanvas: function setCanvas(canvas) {
        this._canvas = canvas;
    },

    /**
     * @function L.supermap.graphic.prototype.getLatLng
     * @description 获取经纬度
     */
    getLatLng: function getLatLng() {
        return this._latlng;
    },

    /**
     * @function L.supermap.graphic.prototype.getCanvas
     * @description 获取画布
     */
    getCanvas: function getCanvas() {
        return this._canvas;
    }

});
var graphic = exports.graphic = function graphic(options) {
    return new Graphic(options);
};

_leaflet2["default"].supermap.graphic = graphic;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dataFlowService = exports.DataFlowService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.dataFlowService
 * @classdesc 实时数据服务类
 * @extends L.supermap.ServiceBase
 * @param url - {string} 实时数据服务地址
 * @param options - {Object} 加载实时数据可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        style - {function} 设置数据加载样式。<br>
 *        onEachFeature - {function} 设置每个数据加载popup等。<br>
 *        geometry - {Array<Object>} 设置增添的几何要素对象数组。<br>
 *        excludeField - -{Object} 排除字段
 */
var DataFlowService = exports.DataFlowService = _ServiceBase.ServiceBase.extend({

    options: {
        geometry: null,
        prjCoordSys: null,
        excludeField: null
    },

    initialize: function initialize(url, options) {
        options = options || {};
        _leaflet2["default"].setOptions(this, options);
        if (options.projection) {
            this.options.prjCoordSys = options.projection;
        }
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
        this.dataFlow = new _iclientCommon.DataFlowService(url, options);
        this.dataFlow.events.on({
            "broadcastSocketConnected": this._defaultEvent,
            "broadcastSocketError": this._defaultEvent,
            "broadcastFailed": this._defaultEvent,
            "broadcastSuccessed": this._defaultEvent,
            "subscribeSocketConnected": this._defaultEvent,
            "subscribeSocketError": this._defaultEvent,
            "messageSuccessed": this._defaultEvent,
            "setFilterParamSuccessed": this._defaultEvent,
            scope: this
        });
    },

    /**
     * @function L.supermap.dataFlowService.prototype.initBroadcast
     * @description 初始化广播
     */
    initBroadcast: function initBroadcast() {
        this.dataFlow.initBroadcast();
        return this;
    },

    /**
     * @function L.supermap.dataFlowService.prototype.broadcast
     * @description 加载广播数据
     * @param obj {JSONObject} json格式的要素数据
     */
    broadcast: function broadcast(obj) {
        this.dataFlow.broadcast(obj);
    },

    /**
     * @function L.supermap.dataFlowService.prototype.initSubscribe
     * @description 初始化订阅数据
     */
    initSubscribe: function initSubscribe() {
        this.dataFlow.initSubscribe();
        return this;
    },

    /**
     * @function L.supermap.dataFlowService.prototype.setExcludeField
     * @description 设置排除字段
     * @param excludeField - {Object} 排除字段
     */
    setExcludeField: function setExcludeField(excludeField) {
        this.dataFlow.setExcludeField(excludeField);
        this.options.excludeField = excludeField;
        return this;
    },

    /**
     * @function L.supermap.dataFlowService.prototype.setGeometry
     * @description 设置添加的GeoJSON几何要素数据
     * @param geometry - {Array<Object>} 设置增添的GeoJSON几何要素对象数组。
     */
    setGeometry: function setGeometry(geometry) {
        this.dataFlow.setGeometry(geometry);
        this.options.geometry = geometry;
        return this;
    },

    /**
     * @function L.supermap.dataFlowService.prototype.unSubscribe
     * @description 结束订阅数据
     */
    unSubscribe: function unSubscribe() {
        this.dataFlow.unSubscribe();
    },

    /**
     * @function L.supermap.dataFlowService.prototype.unBroadcast
     * @description 结束加载广播
     */
    unBroadcast: function unBroadcast() {
        this.dataFlow.unBroadcast();
    },

    _defaultEvent: function _defaultEvent(e) {
        this.fire(e.eventType || e.type, e);
    }
});

var dataFlowService = exports.dataFlowService = function dataFlowService(url, options) {
    return new DataFlowService(url, options);
};

_leaflet2["default"].supermap.dataFlowService = dataFlowService;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.featureService = exports.FeatureService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _Util = __webpack_require__(43);

var Util = _interopRequireWildcard(_Util);

var _CommontypesConversion = __webpack_require__(36);

var _iclientCommon = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.featureService
 * @classdesc 要素数据集类。提供：ID查询，范围查询，SQL查询，几何查询，bounds查询，缓冲区查询，地物编辑
 * @example
 *      L.supermap.featureService(url)
 *      .getFeaturesByIDs(param,function(result){
 *          //doSomething
 *      })
 * @extends L.supermap.ServiceBase
 * @param url - {string} 要素数据集服务地址
 * @param options - {Object} 创建要素数据集服务类可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 */
var FeatureService = exports.FeatureService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.featureService.prototype.getFeaturesByIDs
     * @description 数据集ID查询服务
     * @param params {SuperMap.GetFeaturesByIDsParameters} ID 查询参数类
     * @param callback - {function} 回调函数
     * @param resultFormat {SuperMap.DataFormat} 返回结果类型
     */
    getFeaturesByIDs: function getFeaturesByIDs(params, callback, resultFormat) {
        var me = this;
        var getFeaturesByIDsService = new _iclientCommon.GetFeaturesByIDsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        getFeaturesByIDsService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.featureService.prototype.getFeaturesByBounds
     * @description 数据集Bounds查询服务
     * @param params {SuperMap.GetFeaturesByBoundsParameters} 数据集范围查询参数类
     * @param callback - {function} 回调函数
     * @param resultFormat {SuperMap.DataFormat} 返回结果类型
     */
    getFeaturesByBounds: function getFeaturesByBounds(params, callback, resultFormat) {
        var me = this;
        var getFeaturesByBoundsService = new _iclientCommon.GetFeaturesByBoundsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        getFeaturesByBoundsService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.featureService.prototype.getFeaturesByBuffer
     * @description 数据集Buffer查询服务
     * @param params {SuperMap.GetFeaturesByBufferParameters} 数据服务中数据集缓冲区查询参数类
     * @param callback - {function} 回调函数
     * @param resultFormat {SuperMap.DataFormat} 返回结果类型
     */
    getFeaturesByBuffer: function getFeaturesByBuffer(params, callback, resultFormat) {
        var me = this;
        var getFeatureService = new _iclientCommon.GetFeaturesByBufferService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        getFeatureService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.featureService.prototype.getFeaturesBySQL
     * @description 数据集SQL查询服务
     * @param params {SuperMap.GetFeaturesBySQLParameters} 数据服务中数据集SQL查询参数类
     * @param callback - {function} 回调函数
     * @param resultFormat {SuperMap.DataFormat} 返回结果类型
     */
    getFeaturesBySQL: function getFeaturesBySQL(params, callback, resultFormat) {
        var me = this;
        var getFeatureBySQLService = new _iclientCommon.GetFeaturesBySQLService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        getFeatureBySQLService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.featureService.prototype.getFeaturesByGeometry
     * @description 数据集几何查询服务类
     * @param params {SuperMap.GetFeaturesByGeometryParameters} 数据集几何查询参数类
     * @param callback - {function} 回调函数
     * @param resultFormat {SuperMap.DataFormat} 返回结果类型
     */
    getFeaturesByGeometry: function getFeaturesByGeometry(params, callback, resultFormat) {
        var me = this;
        var getFeaturesByGeometryService = new _iclientCommon.GetFeaturesByGeometryService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        getFeaturesByGeometryService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.featureService.prototype.editFeatures
     * @description 地物编辑服务
     * @param params {SuperMap.EditFeaturesParameters} 数据服务中数据集添加、修改、删除参数类
     * @param callback - {function} 回调函数
     */
    editFeatures: function editFeatures(params, callback) {

        if (!params || !params.dataSourceName || !params.dataSetName) {
            return;
        }

        var me = this,
            url = me.url,
            dataSourceName = params.dataSourceName,
            dataSetName = params.dataSetName;

        url += "/datasources/" + dataSourceName + "/datasets/" + dataSetName;
        var editFeatureService = new _iclientCommon.EditFeaturesService(url, {
            eventListeners: {

                processCompleted: callback,
                processFailed: callback
            }
        });
        editFeatureService.processAsync(me._processParams(params));
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }
        params.returnContent = params.returnContent == null ? true : params.returnContent;
        params.fromIndex = params.fromIndex ? params.fromIndex : 0;
        params.toIndex = params.toIndex ? params.toIndex : -1;
        params.isUseBatch = params.isUseBatch == null ? false : params.isUseBatch;
        if (params.bounds) {
            params.bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(params.bounds);
        }
        if (params.geometry) {
            params.geometry = Util.toSuperMapGeometry(params.geometry);
        }

        if (params.editType) {
            params.editType = params.editType.toLowerCase();
        }

        var me = this;
        if (params.features) {
            var features = [];
            if (_leaflet2["default"].Util.isArray(params.features)) {
                params.features.map(function (feature) {
                    features.push(me._createServerFeature(feature));
                    return feature;
                });
            } else {
                features.push(me._createServerFeature(params.features));
            }
            params.features = features;
        }
        return params;
    },

    _createServerFeature: function _createServerFeature(geoFeature) {
        var geoJSONFeature,
            feature = {},
            fieldNames = [],
            fieldValues = [];

        geoJSONFeature = geoFeature || {};

        for (var key in geoJSONFeature.properties) {
            fieldNames.push(key);
            fieldValues.push(geoJSONFeature.properties[key]);
        }
        feature.fieldNames = fieldNames;
        feature.fieldValues = fieldValues;
        if (geoJSONFeature.id) {
            feature.id = geoJSONFeature.id;
        }
        feature.geometry = Util.toSuperMapGeometry(geoJSONFeature);
        return feature;
    },

    _processFormat: function _processFormat(resultFormat) {
        return resultFormat ? resultFormat : _iclientCommon.DataFormat.GEOJSON;
    }
});

var featureService = exports.featureService = function featureService(url, options) {
    return new FeatureService(url, options);
};

_leaflet2["default"].supermap.featureService = featureService;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapService = exports.MapService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class  L.supermap.mapService
 * @classdesc 地图信息服务类
 * @extends L.supermap.ServiceBase
 * @param url -{string} 地图服务地址
 * @param options -{Object} 地图服务信息相关参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 * @example
 * L.supermap.mapService(url)
 *  .getMapInfo(function(result){
 *     //doSomething
 * })
 */
var MapService = exports.MapService = _ServiceBase.ServiceBase.extend({

    options: {
        projection: null
    },

    initialize: function initialize(url, options) {
        options = options || {};
        _leaflet2["default"].setOptions(this, options);
        if (options.projection) {
            this.options.projection = options.projection;
        }
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function  L.supermap.mapService.prototype.getMapInfo
     * @description 获取地图信息
     * @param callback -{function} 回调函数
     */
    getMapInfo: function getMapInfo(callback) {
        var me = this;
        var getMapStatusService = new _iclientCommon.MapService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }, projection: me.options.projection
        });
        getMapStatusService.processAsync();
    },

    /**
     * @function  L.supermap.mapService.prototype.getTilesets
     * @description 获取切片列表信息
     * @param callback -{function} 回调函数
     */
    getTilesets: function getTilesets(callback) {
        var me = this;
        var tilesetsService = new _iclientCommon.TilesetsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });

        tilesetsService.processAsync();
    }
});

var mapService = exports.mapService = function mapService(url, options) {
    return new MapService(url, options);
};

_leaflet2["default"].supermap.mapService = mapService;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Point = __webpack_require__(333);

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) feature.id = pbf.readVarint();else if (tag == 2) readTag(pbf, feature);else if (tag == 3) feature.type = pbf.readVarint();else if (tag == 4) feature._geometry = pbf.pos;
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function () {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) {
                // moveTo
                if (line) lines.push(line);
                line = [];
            }

            line.push(new Point(x, y));
        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }
        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) lines.push(line);

    return lines;
};

VectorTileFeature.prototype.bbox = function () {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) x1 = x;
            if (x > x2) x2 = x;
            if (y < y1) y1 = y;
            if (y > y2) y2 = y;
        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function (x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i,
        j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j],
                y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [(p.x + x0) * 360 / size - 180, 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90];
        }
    }

    switch (this.type) {
        case 1:
            var points = [];
            for (i = 0; i < coords.length; i++) {
                points[i] = coords[i][0];
            }
            coords = points;
            project(coords);
            break;

        case 2:
            for (i = 0; i < coords.length; i++) {
                project(coords[i]);
            }
            break;

        case 3:
            coords = classifyRings(coords);
            for (i = 0; i < coords.length; i++) {
                for (j = 0; j < coords[i].length; j++) {
                    project(coords[i][j]);
                }
            }
            break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) return [rings];

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) continue;

        if (ccw === undefined) ccw = area < 0;

        if (ccw === area < 0) {
            if (polygon) polygons.push(polygon);
            polygon = [rings[i]];
        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) polygons.push(polygon);

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var VectorTileFeature = __webpack_require__(137);

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) layer.version = pbf.readVarint();else if (tag === 1) layer.name = pbf.readString();else if (tag === 5) layer.extent = pbf.readVarint();else if (tag === 2) layer._features.push(pbf.pos);else if (tag === 3) layer._keys.push(pbf.readString());else if (tag === 4) layer._values.push(readValueMessage(pbf));
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function (i) {
    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Event = undefined;

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

/**
 * @name Event
 * @memberOf SuperMap
 * @namespace
 * @description 事件处理函数.
 */
var Event = exports.Event = _SuperMap.SuperMap.Event = {

    /**
     * @description  A hashtable cache of the event observers. Keyed by element._eventCacheID
     * @type {Boolean}
     * @default false
     */
    observers: false,

    /**
     * @description KEY_SPACE
     * @type {number}
     * @default 32
     */
    KEY_SPACE: 32,

    /**
     * @description KEY_BACKSPACE
     * @type {number}
     * @default 8
     */
    KEY_BACKSPACE: 8,

    /**
     * @description KEY_TAB
     * @type {number}
     * @default 9
     */
    KEY_TAB: 9,

    /**
     * @description KEY_RETURN
     * @type {number}
     * @default 13
     */
    KEY_RETURN: 13,

    /**
     * @description KEY_ESC
     * @type {number}
     * @default 27
     */
    KEY_ESC: 27,

    /**
     * @description KEY_LEFT
     * @type {number}
     * @default 37
     */
    KEY_LEFT: 37,

    /**
     * @description KEY_UP
     * @type {number}
     * @default 38
     */
    KEY_UP: 38,

    /**
     * @description KEY_RIGHT
     * @type {number}
     * @default 39
     */
    KEY_RIGHT: 39,

    /**
     * @description KEY_DOWN
     * @type {number}
     * @default 40
     */
    KEY_DOWN: 40,

    /**
     * @description KEY_DELETE
     * @type {number}
     * @default 46
     */
    KEY_DELETE: 46,

    /**
     * @description Cross browser event element detection.
     * @param event - {Event}
     * @returns {HTMLElement} The element that caused the event
     */
    element: function element(event) {
        return event.target || event.srcElement;
    },

    /**
     * @description Determine whether event was caused by a single touch
     * @param event - {Event}
     * @returns {Boolean}
     */
    isSingleTouch: function isSingleTouch(event) {
        return event.touches && event.touches.length === 1;
    },

    /**
     * @description Determine whether event was caused by a multi touch
     * @param event - {Event}
     * @returns {Boolean}
     */
    isMultiTouch: function isMultiTouch(event) {
        return event.touches && event.touches.length > 1;
    },

    /**
     * @description Determine whether event was caused by a left click.
     * @param event - {Event}
     * @returns {Boolean}
     */
    isLeftClick: function isLeftClick(event) {
        return event.which && event.which === 1 || event.button && event.button === 1;
    },

    /**
     * @description Determine whether event was caused by a right mouse click.
     * @param event - {Event}
     * @returns {Boolean}
     */
    isRightClick: function isRightClick(event) {
        return event.which && event.which === 3 || event.button && event.button === 2;
    },

    /**
     * @description Stops an event from propagating.
     * @param event - {Event}
     * @param allowDefault - {Boolean} If true, we stop the event chain but still allow the default browser  behaviour (text selection, radio-button clicking, etc) Default false
     */
    stop: function stop(event, allowDefault) {

        if (!allowDefault) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        }

        if (event.stopPropagation) {
            event.stopPropagation();
        } else {
            event.cancelBubble = true;
        }
    },

    /**
     * @param event - {Event}
     * @param tagName - {string} html标签名
     * @returns {HTMLElement} The first node with the given tagName, starting from the node the event was triggered on and traversing the DOM upwards
     */
    findElement: function findElement(event, tagName) {
        var element = _SuperMap.SuperMap.Event.element(event);
        while (element.parentNode && (!element.tagName || element.tagName.toUpperCase() != tagName.toUpperCase())) {
            element = element.parentNode;
        }
        return element;
    },

    /**
     * @description 监听事件，注册事件处理方法。
     * @param elementParam - {HTMLElement | string} 待监听的DOM对象或者其id标识。
     * @param name - {string} 监听事件的类别名称。
     * @param observer - {function} 注册的事件处理方法。
     * @param useCapture - {Boolean} 是否捕获。
     */
    observe: function observe(elementParam, name, observer, useCapture) {
        var element = _Util.Util.getElement(elementParam);
        useCapture = useCapture || false;

        if (name === 'keypress' && (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || element.attachEvent)) {
            name = 'keydown';
        }

        //if observers cache has not yet been created, create it
        if (!this.observers) {
            this.observers = {};
        }

        //if not already assigned, make a new unique cache ID
        if (!element._eventCacheID) {
            var idPrefix = "eventCacheID_";
            if (element.id) {
                idPrefix = element.id + "_" + idPrefix;
            }
            element._eventCacheID = _Util.Util.createUniqueID(idPrefix);
        }

        var cacheID = element._eventCacheID;

        //if there is not yet a hash entry for this element, add one
        if (!this.observers[cacheID]) {
            this.observers[cacheID] = [];
        }

        //add a new observer to this element's list
        this.observers[cacheID].push({
            'element': element,
            'name': name,
            'observer': observer,
            'useCapture': useCapture
        });

        //add the actual browser event listener
        if (element.addEventListener) {
            element.addEventListener(name, observer, useCapture);
        } else if (element.attachEvent) {
            element.attachEvent('on' + name, observer);
        }
    },

    /**
     * @description Given the id of an element to stop observing, cycle through the
     *   element's cached observers, calling stopObserving on each one,
     *   skipping those entries which can no longer be removed.
     *
     * @param elementParam - {HTMLElement | string}
     */
    stopObservingElement: function stopObservingElement(elementParam) {
        var element = _Util.Util.getElement(elementParam);
        var cacheID = element._eventCacheID;

        this._removeElementObservers(_SuperMap.SuperMap.Event.observers[cacheID]);
    },

    /*
     * @param elementObservers - {Array<Object>} Array of (element, name,
     *                                         observer, usecapture) objects,
     *                                         taken directly from hashtable
     */
    _removeElementObservers: function _removeElementObservers(elementObservers) {
        if (elementObservers) {
            for (var i = elementObservers.length - 1; i >= 0; i--) {
                var entry = elementObservers[i];
                var args = new Array(entry.element, entry.name, entry.observer, entry.useCapture);
                _SuperMap.SuperMap.Event.stopObserving.apply(this, args);
            }
        }
    },

    /**
     * @description 移除事件监听和注册的事件处理方法。注意：事件的移除和监听相对应，移除时的各属性信息必须监听时
     * 保持一致才能确保事件移除成功。
     * @param elementParam - {HTMLElement | string} 被监听的DOM元素或者其id。
     * @param name - {string} 需要移除的被监听事件名称。
     * @param observer - {function} 需要移除的事件处理方法。
     * @param useCapture - {Boolean} 是否捕获。
     * @returns {Boolean} Whether or not the event observer was removed
     */
    stopObserving: function stopObserving(elementParam, name, observer, useCapture) {
        useCapture = useCapture || false;

        var element = _Util.Util.getElement(elementParam);
        var cacheID = element._eventCacheID;

        if (name === 'keypress') {
            if (navigator.appVersion.match(/Konqueror|Safari|KHTML/) || element.detachEvent) {
                name = 'keydown';
            }
        }

        // find element's entry in this.observers cache and remove it
        var foundEntry = false;
        var elementObservers = _SuperMap.SuperMap.Event.observers[cacheID];
        if (elementObservers) {

            // find the specific event type in the element's list
            var i = 0;
            while (!foundEntry && i < elementObservers.length) {
                var cacheEntry = elementObservers[i];

                if (cacheEntry.name === name && cacheEntry.observer === observer && cacheEntry.useCapture === useCapture) {

                    elementObservers.splice(i, 1);
                    if (elementObservers.length == 0) {
                        delete _SuperMap.SuperMap.Event.observers[cacheID];
                    }
                    foundEntry = true;
                    break;
                }
                i++;
            }
        }

        //actually remove the event listener from browser
        if (foundEntry) {
            if (element.removeEventListener) {
                element.removeEventListener(name, observer, useCapture);
            } else if (element && element.detachEvent) {
                element.detachEvent('on' + name, observer);
            }
        }
        return foundEntry;
    },

    /**
     * @description Cycle through all the element entries in the events cache and call
     *   stopObservingElement on each.
     */
    unloadCache: function unloadCache() {
        // check for SuperMap.Event before checking for observers, because
        // SuperMap.Event may be undefined in IE if no map instance was
        // created
        if (_SuperMap.SuperMap.Event && _SuperMap.SuperMap.Event.observers) {
            for (var cacheID in _SuperMap.SuperMap.Event.observers) {
                var elementObservers = _SuperMap.SuperMap.Event.observers[cacheID];
                _SuperMap.SuperMap.Event._removeElementObservers.apply(this, [elementObservers]);
            }
            _SuperMap.SuperMap.Event.observers = false;
        }
    },

    CLASS_NAME: "SuperMap.Event"
};
_SuperMap.SuperMap.Event = Event;
/* prevent memory leaks in IE */
_SuperMap.SuperMap.Event.observe(window, 'unload', _SuperMap.SuperMap.Event.unloadCache, false);

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Feature = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.Feature
 * @classdesc 要素类组合了地理和属性，Feature 类同时具有 marker 和 lonlat 属性。
 * @param layer - {SuperMap.Layer} 图层。
 * @param lonlat - {SuperMap.LonLat} 经纬度。
 * @param data - {Object} 数据对象。
 */
var Feature = exports.Feature = function () {
  function Feature(layer, lonlat, data) {
    _classCallCheck(this, Feature);

    this.CLASS_NAME = "SuperMap.Feature";
    /**
     * @deprecated
     * @member SuperMap.Feature.prototype.layer - {SuperMap.Layer}
     * @description 图层。
     */
    this.layer = layer;

    /**
     * @member SuperMap.Feature.prototype.id - {string}
     * @description 要素id。
     */
    this.id = _Util.Util.createUniqueID(this.CLASS_NAME + "_");

    /**
     * @member SuperMap.Feature.prototype.lonlat - {SuperMap.LonLat}
     * @description 经纬度。
     *
     */
    this.lonlat = lonlat;

    /**
     * @member SuperMap.Feature.prototype.data - {Object}
     * @description 数据对象。
     */
    this.data = data != null ? data : {};
  }

  /**
   * @function SuperMap.Feature.prototype.destroy
   * @description 释放相关资源。
   */


  _createClass(Feature, [{
    key: 'destroy',
    value: function destroy() {
      this.id = null;
      this.lonlat = null;
      this.data = null;
    }
  }]);

  return Feature;
}();

_SuperMap.SuperMap.Feature = Feature;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Size = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  SuperMap.Size
 * @classdesc 此类描绘一对高宽值的实例。
 * @param  w -{number} 宽度，默认值为0.0
 * @param  h -{number} 高度 ，默认值为0.0
 *
 * @example
 * var size = new SuperMap.Size(31,46);
 */
var Size = exports.Size = function () {
    function Size(w, h) {
        _classCallCheck(this, Size);

        /**
         * @member SuperMap.Size.prototype.w -{number}
         * @description  宽，默认值为0.0
         */
        this.w = w ? parseFloat(w) : 0.0;

        /**
         * @member SuperMap.Size.prototype.h -{number}
         * @description 高，默认值为0.0
         */
        this.h = w ? parseFloat(h) : 0.0;
        this.CLASS_NAME = "SuperMap.Size";
    }

    /**
     * @function SuperMap.Size.prototype.toString
     * @description 返回此对象的字符串形式
     * @example
     * var size = new SuperMap.Size(10,5);
     * var str = size.toString();
     * @returns {string} 例如："w=10,h=5"
     */


    _createClass(Size, [{
        key: "toString",
        value: function toString() {
            return "w=" + this.w + ",h=" + this.h;
        }

        /**
         * @function SuperMap.Size.prototype.clone
         * @description 克隆当前size对象.
         * @example
         * var size = new SuperMap.Size(3146);
         * var size2 = size.clone();
         *
         * @returns {SuperMap.Size}  返回一个新的与当前size对象有相同宽、高的Size对象。
         */

    }, {
        key: "clone",
        value: function clone() {
            return new Size(this.w, this.h);
        }

        /**
         *
         * @function SuperMap.Size.prototype.equals
         * @description 比较两个size对象是否相等。
         * @example
         * var size = new SuperMap.Size(3146);
         * var size2 = new SuperMap.Size(3146);
         * var isEquals = size.equals(size2);
         *
         * @param sz -{SuperMap.Size} 用于比较相等的Size对象。
         * @returns {Boolean} 传入的size和当前size高宽相等，注意：如果传入的size为空则返回false
         *
         */

    }, {
        key: "equals",
        value: function equals(sz) {
            var equals = false;
            if (sz != null) {
                equals = this.w === sz.w && this.h === sz.h || isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h);
            }
            return equals;
        }

        /**
         *
         * @function SuperMap.Size.prototype.destroy
         * @description 销毁此对象。销毁后此对象的所有属性为null，而不是初始值。
         * @example
         * var size = new SuperMap.Size(3146);
         * size.destroy();
         */

    }, {
        key: "destroy",
        value: function destroy() {
            this.w = null;
            this.h = null;
        }
    }]);

    return Size;
}();

_SuperMap.SuperMap.Size = Size;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rectangle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Geometry2 = __webpack_require__(26);

var _Bounds = __webpack_require__(22);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class  SuperMap.Geometry.Rectangle
 * @classdesc 矩形几何对象类。
 * @param  x - {float} 矩形左下角点的横坐标。
 * @param y - {float} 矩形左下角点的纵坐标。
 * @param width - {float} 矩形的宽度。
 * @param height -  {float} 矩形的高度。
 * @extends {SuperMap.Geometry}
 * @example
 *  //x为矩形左下角点的横坐标；y为矩形左下角点的纵坐标；w为矩形的宽度；h为矩形的高度
 *  var x = 1;
 *  var y = 2;
 *  var w = 10;
 *  var h = 20;
 *  var recttangle = new SuperMap.Geometry.Rectangle(x, y, w, h);
 */

var Rectangle = exports.Rectangle = function (_Geometry) {
  _inherits(Rectangle, _Geometry);

  function Rectangle(x, y, width, height) {
    _classCallCheck(this, Rectangle);

    /**
     * @member SuperMap.Geometry.Rectangle.prototype.x -{float}
     * @description 矩形左下角点的横坐标。
     */
    var _this = _possibleConstructorReturn(this, (Rectangle.__proto__ || Object.getPrototypeOf(Rectangle)).call(this, x, y, width, height));

    _this.x = x;

    /**
     * @member SuperMap.Geometry.Rectangle.prototype.y -{float}
     * @description 矩形左下角点的纵坐标。
     */
    _this.y = y;

    /**
     * @member SuperMap.Geometry.Rectangle.prototype.width -{float}
     * @description 矩形的宽度。
     */
    _this.width = width;

    /**
     * @member SuperMap.Geometry.Rectangle.prototype.height -{float}
     * @description 矩形的高度。
     */
    _this.height = height;

    _this.CLASS_NAME = "SuperMap.Geometry.Rectangle";
    return _this;
  }

  /**
   * @function SuperMap.Geometry.Rectangle.prototype.calculateBounds
   * @description 计算出此矩形对象的bounds。
   */


  _createClass(Rectangle, [{
    key: 'calculateBounds',
    value: function calculateBounds() {
      this.bounds = new _Bounds.Bounds(this.x, this.y, this.x + this.width, this.y + this.height);
    }

    /**
     * @function SuperMap.Geometry.Rectangle.prototype.getArea
     * @description 获取矩形对象的面积。
     * @returns {float} 矩形对象面积。
     */

  }, {
    key: 'getArea',
    value: function getArea() {
      var area = this.width * this.height;
      return area;
    }
  }]);

  return Rectangle;
}(_Geometry2.Geometry);

_SuperMap.SuperMap.Geometry.Rectangle = Rectangle;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimeControlBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Events = __webpack_require__(62);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TimeControlBase
 * @classdesc 时间控制基类类。
 * @param options - {Object} 该类开放的可选属性。如：<br>
 *        speed - {number}速度。不能小于0，默认为1（表示每帧渲染的数据之间的间隔为1），设置越大速度越快。<br>
 *        startTime - {number}的起始时间，必须为数字，且小于等于endTime。如果不设置，初始化时为0，建议设置。<br>
 *        endTime - {number}的结束时间，必须为数字，且大于等于startTime。如果不设置，初始化时以当前时间进行设置，建议设置。<br>
 *        repeat - {boolean} 是否重复循环。默认为true。<br>
 *        reverse - {boolean} 是否反向。默认为false。<br>
 */
var TimeControlBase = exports.TimeControlBase = function () {
    function TimeControlBase(options) {
        _classCallCheck(this, TimeControlBase);

        //设置步长，刷新频率、开始结束时间、是否循环、是否反向
        var me = this;
        options = options || {};

        /**
         * @member SuperMap.TimeControlBase.prototype.speed -{number}
         * @description 步长，必须为非负数，默认为1（表示前后两次渲染的数据之间的间隔为1）
         */
        this.speed = options.speed && options.speed >= 0 ? options.speed : 1;

        /**
         * @member SuperMap.TimeControlBase.prototype.frequency -{number}
         * @description 刷新频率(单位ms)，服务器刷新的时间间隔，默认为1s
         */
        this.frequency = options.speed && options.frequency >= 0 ? options.frequency : 1000;

        /**
         * @member SuperMap.TimeControlBase.prototype.startTime -{number}
         * @description 记录的起始时间，必须为数字，
         *              如果不设置，初始化时为0，建议设置
         */
        this.startTime = options.startTime && options.startTime != null ? options.startTime : 0;

        /**
         * @member SuperMap.TimeControlBase.prototype.endTime -{number}
         * @description 记录的结束时间，必须为数字，
         *              如果不设置，初始化时以当前时间进行设置，建议设置
         */
        this.endTime = options.endTime && options.endTime != null && options.endTime >= me.startTime ? options.endTime : +new Date();

        /**
         * @member SuperMap.TimeControlBase.prototype.repeat -{boolean}
         * @description 是否重复循环，默认为true。
         */
        this.repeat = options.repeat !== undefined ? options.repeat : true;

        /**
         * @member SuperMap.TimeControlBase.prototype.reverse -{boolean}
         * @description 是否反向，默认为false。
         */
        this.reverse = options.reverse !== undefined ? options.reverse : false;

        /**
         * @member SuperMap.TimeControlBase.prototype.currentTime -{number}
         * @description 记录近期的时间，也就是当前帧运行到的时间。
         */
        this.currentTime = null;

        /**
         * @member SuperMap.TimeControlBase.prototype.oldTime -{number}
         * @description 记录上一帧的时间，也就是之前运行到的时间。
         */
        this.oldTime = null;

        /**
         * @member SuperMap.TimeControlBase.prototype.running -{boolean}
         * @description 记录当前是否处于运行中，默认为false。
         */
        this.running = false;

        /**
         * @private
         * @member SuperMap.TimeControlBase.prototype.EVENT_TYPES -{Array<string>}
         * @description 此类支持的事件类型。
         *
         */
        this.EVENT_TYPES = ["start", "pause", "stop"];

        /**
         * @private
         * @member SuperMap.TimeControlBase.prototype.events -{SuperMap.Events}
         * @description 事件
         */
        me.events = new _Events.Events(this, null, this.EVENT_TYPES);

        me.speed = Number(me.speed);
        me.frequency = Number(me.frequency);
        me.startTime = Number(me.startTime);
        me.endTime = Number(me.endTime);

        me.startTime = Date.parse(new Date(me.startTime));
        me.endTime = Date.parse(new Date(me.endTime));

        //初始化当前时间
        me.currentTime = me.startTime;

        this.CLASS_NAME = "SuperMap.TimeControlBase";
    }

    /**
     * @function SuperMap.TimeControlBase.prototype.updateOptions
     * @param options - {Object} 设置参数得可选参数。设置步长，刷新频率、开始结束时间、是否循环、是否反向。
     */


    _createClass(TimeControlBase, [{
        key: 'updateOptions',
        value: function updateOptions(options) {
            //设置步长，刷新频率、开始结束时间、是否循环、是否反向
            var me = this;
            options = options || {};
            if (options.speed && options.speed >= 0) {
                me.speed = options.speed;
                me.speed = Number(me.speed);
            }

            if (options.speed && options.frequency >= 0) {
                me.frequency = options.frequency;
                me.frequency = Number(me.frequency);
            }

            if (options.startTime && options.startTime != null) {
                me.startTime = options.startTime;
                me.startTime = Date.parse(new Date(me.startTime));
            }

            if (options.endTime && options.endTime != null && options.endTime >= me.startTime) {
                me.endTime = options.endTime;
                me.endTime = Date.parse(new Date(me.endTime));
            }

            if (options.repeat != null) {
                me.repeat = options.repeat;
            }

            if (options.reverse != null) {
                me.reverse = options.reverse;
            }
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.start
         * @description 开始
         */

    }, {
        key: 'start',
        value: function start() {
            var me = this;

            if (!me.running) {
                me.running = true;
                me.tick();
                me.events.triggerEvent('start', me.currentTime);
            }
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.pause
         * @description 暂停
         */

    }, {
        key: 'pause',
        value: function pause() {
            var me = this;
            me.running = false;
            me.events.triggerEvent('pause', me.currentTime);
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.stop
         * @description 停止，停止后返回起始状态
         */

    }, {
        key: 'stop',
        value: function stop() {
            var me = this;
            //停止时 时间设置为开始时间
            me.currentTime = me.startTime;
            //如果正在运行，修改为初始时间即可绘制一帧
            if (me.running) {
                me.running = false;
            }
            me.events.triggerEvent('stop', me.currentTime);
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.toggle
         * @description 开关切换，切换的是开始和暂停
         */

    }, {
        key: 'toggle',
        value: function toggle() {
            var me = this;

            if (me.running) {
                me.pause();
            } else {
                me.start();
            }
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setSpeed
         * @description 设置步长。
         * @param speed - {number}步长，必须为非负数，默认为1
         * @return {boolean} true代表设置成功，false设置失败（speed小于0时失败）
         */

    }, {
        key: 'setSpeed',
        value: function setSpeed(speed) {
            var me = this;
            if (speed >= 0) {
                me.speed = speed;
                return true;
            }
            return false;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getSpeed
         * @description 获取步长。
         * @return {number} 返回当前的步长
         */

    }, {
        key: 'getSpeed',
        value: function getSpeed() {
            return this.speed;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setFrequency
         * @description 设置刷新频率。
         * @param frequency - {number}刷新频率，单位为ms，默认为1s
         * @return {boolean} true代表设置成功，false设置失败（frequency小于0时失败）
         */

    }, {
        key: 'setFrequency',
        value: function setFrequency(frequency) {
            var me = this;
            if (frequency >= 0) {
                me.frequency = frequency;
                return true;
            }
            return false;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getFrequency
         * @description 获取刷新频率。
         * @return {number} 返回当前的刷新频率
         */

    }, {
        key: 'getFrequency',
        value: function getFrequency() {
            return this.frequency;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setStartTime
         * @description 设置起始时间，设置完成后如果当前时间小于起始时间，则从起始时间开始
         * @param startTime - {number}需要设置的起始时间
         * @return {boolean} true代表设置成功，false设置失败（startTime 大于结束时间时失败）
         */

    }, {
        key: 'setStartTime',
        value: function setStartTime(startTime) {
            var me = this;
            startTime = Date.parse(new Date(startTime));
            //起始时间不得大于结束时间
            if (startTime > me.endTime) {
                return false;
            }
            me.startTime = startTime;
            //如果当前时间小于了起始时间，则从当前起始时间开始
            if (me.currentTime < me.startTime) {
                me.currentTime = me.startTime;
                me.tick();
            }
            return true;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getStartTime
         * @description 获取起始时间
         * @return {number} 返回当前的起始时间
         */

    }, {
        key: 'getStartTime',
        value: function getStartTime() {
            return this.startTime;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setEndTime
         * @description 设置结束时间，设置完成后如果当前时间大于结束，则从起始时间开始
         * @param endTime - {number}需要设置的结束时间
         * @return {boolean} true代表设置成功，false设置失败（endTime 小于开始时间时失败）
         */

    }, {
        key: 'setEndTime',
        value: function setEndTime(endTime) {
            var me = this;
            me.endTime = Date.parse(new Date(me.endTime));
            //结束时间不得小于开始时间
            if (endTime < me.startTime) {
                return false;
            }
            me.endTime = endTime;
            //如果当前时间大于了结束时间，则从起始时间开始
            if (me.currentTime >= me.endTime) {
                me.currentTime = me.startTime;
                me.tick();
            }
            return true;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getEndTime
         * @description 获取结束时间
         * @return {number} 返回当前的结束时间
         */

    }, {
        key: 'getEndTime',
        value: function getEndTime() {
            return this.endTime;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setCurrentTime
         * @description 设置当前时间
         * @param currentTime - {number}需要设置的当前时间
         * @return {boolean} true代表设置成功，false设置失败
         */

    }, {
        key: 'setCurrentTime',
        value: function setCurrentTime(currentTime) {
            var me = this;
            me.currentTime = Date.parse(new Date(me.currentTime));
            //结束时间不得小于开始时间
            if (currentTime >= me.startTime && currentTime <= me.endTime) {
                me.currentTime = currentTime;
                me.startTime = me.currentTime;
                me.tick();
                return true;
            }
            return false;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getCurrentTime
         * @description 获取当前时间
         * @return {number} 返回当前时间
         */

    }, {
        key: 'getCurrentTime',
        value: function getCurrentTime() {
            return this.currentTime;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setRepeat
         * @description 设置是否重复循环
         * @param repeat - {boolean} 是否重复循环
         */

    }, {
        key: 'setRepeat',
        value: function setRepeat(repeat) {
            this.repeat = repeat;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getRepeat
         * @description 获取是否重复循环，默认是true。
         * @return {boolean} 返回是否重复循环
         */

    }, {
        key: 'getRepeat',
        value: function getRepeat() {
            return this.repeat;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.setReverse
         * @description 设置是否反向
         * @param reverse - {boolean} 是否反向
         */

    }, {
        key: 'setReverse',
        value: function setReverse(reverse) {
            this.reverse = reverse;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getReverse
         * @description 获取是否反向，默认是false。
         * @return {boolean} 返回是否反向
         */

    }, {
        key: 'getReverse',
        value: function getReverse() {
            return this.reverse;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.getRunning
         * @description 获取运行状态
         * @return {boolean} true代表正在运行，false发表没有运行
         */

    }, {
        key: 'getRunning',
        value: function getRunning() {
            return this.running;
        }

        /**
         * @function SuperMap.TimeControlBase.prototype.destroy
         * @description 销毁Animator对象，释放资源。
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.speed = null;
            me.frequency = null;
            me.startTime = null;
            me.endTime = null;
            me.currentTime = null;
            me.repeat = null;
            me.running = false;
            me.reverse = null;
        }
    }, {
        key: 'tick',
        value: function tick() {
            //TODO 每次刷新执行的操作。子类实现
        }
    }]);

    return TimeControlBase;
}();

_SuperMap.SuperMap.TimeControlBase = TimeControlBase;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IManagerCreateNodeParam = undefined;

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.iManagerCreateNodeParam
 * @classdesc iManager 创建节点参数。
 * @param params - {Object} iManager创建节点参数。
 *
 */
var IManagerCreateNodeParam = exports.IManagerCreateNodeParam = function IManagerCreateNodeParam(params) {
    _classCallCheck(this, IManagerCreateNodeParam);

    params = params || {};
    this.nodeSpec = 'SMALL'; //取值范围: ['SMALL','MEDIUM','LARGE'] 以及自定义的环境规格名称
    this.nodeCount = 1; //要创建vm的个数
    this.nodeName = ''; //vm名称
    this.password = ''; //vm的密码,空表示随机分配
    this.description = ''; //描述信息
    this.physicalMachineName = ''; //vm所属的物理机名称.
    this.ips = []; //vm的ip,空数组表示随机分配
    this.userName = ''; //vm所属用户
    _Util.Util.extend(this, params);
};

_SuperMap.SuperMap.iManagerCreateNodeParam = IManagerCreateNodeParam;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IManagerServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _SecurityManager = __webpack_require__(35);

var _FetchRequest = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.iManagerServiceBase
 * @classdesc iManager服务基类(有权限限制的类需要实现此类)。
 * @param url - {string} iManager首页地址，如：http://localhost:8390/imanager。
 */
var IManagerServiceBase = exports.IManagerServiceBase = function () {
    function IManagerServiceBase(url) {
        _classCallCheck(this, IManagerServiceBase);

        if (url) {
            var end = url.substr(url.length - 1, 1);
            this.serviceUrl = end === "/" ? url.substr(0, url.length - 2) : url;
        }
        this.CLASS_NAME = "SuperMap.iManagerServiceBase";
    }

    /**
     * @function SuperMap.iManagerServiceBase.prototype.request
     * @description 子类统一通过该方法发送请求。
     * @param url - {string} 请求url。
     * @param method - {string} 请求类型。
     * @param requestOptions - {Object} 请求选项。
     * @param param - {Object} 请求参数。
     * @description 发送请求。
     * @returns {Promise} Promise对象。
     */


    _createClass(IManagerServiceBase, [{
        key: 'request',
        value: function request(method, url, param, requestOptions) {
            requestOptions = requestOptions || {
                headers: {
                    'Accept': '*/*',
                    'Content-Type': 'application/json'
                }
            };
            if (!requestOptions.hasOwnProperty("withCredentials")) {
                requestOptions['withCredentials'] = true;
            }
            var token = _SecurityManager.SecurityManager.imanagerToken;
            if (token) {
                if (!requestOptions.headers) {
                    requestOptions.headers = [];
                }
                requestOptions.headers['X-Auth-Token'] = token;
            }
            if (param) {
                param = JSON.stringify(param);
            }
            return _FetchRequest.FetchRequest.commit(method, url, param, requestOptions).then(function (response) {
                return response.json();
            });
        }
    }]);

    return IManagerServiceBase;
}();

_SuperMap.SuperMap.iManagerServiceBase = IManagerServiceBase;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPortalMap = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _iPortalServiceBase = __webpack_require__(65);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.iPortalMap
 * @classdesc iPortal地图服务类
 * @param mapUrl -{string}  地图地址
 * @param params -{Object}  服务参数
 * @extends SuperMap.iPortalServiceBase
 *
 */
var IPortalMap = exports.IPortalMap = function (_IPortalServiceBase) {
    _inherits(IPortalMap, _IPortalServiceBase);

    function IPortalMap(mapUrl, params) {
        _classCallCheck(this, IPortalMap);

        var _this = _possibleConstructorReturn(this, (IPortalMap.__proto__ || Object.getPrototypeOf(IPortalMap)).call(this, mapUrl));

        params = params || {};
        _this.authorizeSetting = [];
        _this.center = "";
        _this.controls = null;
        _this.checkStatus = "";
        _this.createTime = 0;
        _this.description = "";
        _this.epsgCode = 0;
        _this.extent = "";
        _this.id = 0;
        _this.isDefaultBottomMap = false;
        _this.layers = [];
        _this.level = null;
        _this.nickname = "";
        _this.sourceType = "";
        _this.status = null;
        _this.tags = [];
        _this.thumbnail = "";
        _this.title = "";
        _this.units = null;
        _this.updateTime = 0;
        _this.userName = "";
        _this.visitCount = 0;
        _Util.Util.extend(_this, params);
        _this.mapUrl = mapUrl;
        // if (this.id) {
        //     this.mapUrl = mapUrl + "/" + this.id;
        // }
        return _this;
    }

    /**
     * @function SuperMap.iPortalMap.prototype.load
     * @description 加载地图信息
     * @returns {Promise} 返回Promise对象。如果成功，Promise没有返回值，请求返回结果自动填充到该类的属性中；如果失败，Promise返回值包含错误信息
     */


    _createClass(IPortalMap, [{
        key: 'load',
        value: function load() {
            var me = this;
            return me.request("GET", me.mapUrl + ".json").then(function (mapInfo) {
                if (mapInfo.error) {
                    return mapInfo;
                }
                for (var key in mapInfo) {
                    me[key] = mapInfo[key];
                }
            });
        }

        /**
         * @function SuperMap.iPortalMap.prototype.update
         * @description 更新地图参数
         * @returns {Promise} 返回包含更新操作状态的Promise对象
         */

    }, {
        key: 'update',
        value: function update() {
            var mapUpdateParam = {
                units: this.units,
                level: this.level,
                center: this.center,
                controls: this.controls,
                description: this.description,
                epsgCode: this.epsgCode,
                extent: this.extent,
                status: this.status,
                tags: this.tags,
                layers: this.layers,
                title: this.title,
                thumbnail: this.thumbnail,
                sourceType: this.sourceType,
                authorizeSetting: this.authorizeSetting
            };
            var options = {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            };
            return this.request("PUT", this.mapUrl, JSON.stringify(mapUpdateParam), options);
        }
    }]);

    return IPortalMap;
}(_iPortalServiceBase.IPortalServiceBase);

_SuperMap.SuperMap.iPortalMap = IPortalMap;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPortalMapsQueryParam = undefined;

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.iPortalMapsQueryParam
 * @classdesc iPortal地图资源查询参数
 * @param params -{Object} iPortal地图资源查询具体参数
 *
 */
var IPortalMapsQueryParam = exports.IPortalMapsQueryParam = function IPortalMapsQueryParam(params) {
    _classCallCheck(this, IPortalMapsQueryParam);

    params = params || {};
    this.userNames = null;
    this.tags = null;
    this.suggest = false;
    this.sourceTypes = null;
    this.keywords = null;
    this.epsgCode = null;
    this.orderBy = null;
    this.currentPage = null;
    this.pageSize = null;
    this.dirIds = null;
    this.isNotInDir = false;
    this.updateStart = null;
    this.updateEnd = null;
    this.visitStart = null;
    this.visitEnd = null;
    this.filterFields = null;
    _Util.Util.extend(this, params);
};

_SuperMap.SuperMap.iPortalMapsQueryParam = IPortalMapsQueryParam;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPortalService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _iPortalServiceBase = __webpack_require__(65);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.iPortalService
 * @classdesc iPortal服务
 * @extends SuperMap.iPortalServiceBase
 * @param seviceUrl -{string} 服务地址
 * @param params -{Object} 服务请求参数
 *
 */
var IPortalService = exports.IPortalService = function (_IPortalServiceBase) {
    _inherits(IPortalService, _IPortalServiceBase);

    function IPortalService(serviceUrl, params) {
        _classCallCheck(this, IPortalService);

        var _this = _possibleConstructorReturn(this, (IPortalService.__proto__ || Object.getPrototypeOf(IPortalService)).call(this, serviceUrl));

        params = params || {};
        _this.addedMapNames = null;
        _this.addedSceneNames = null;
        _this.authorizeSetting = [];
        _this.checkStatus = "";
        _this.createTime = 0;
        _this.description = "";
        _this.enable = true;
        _this.id = 0;
        _this.isBatch = false;
        _this.isDataItemService = false;
        _this.linkPage = null;
        _this.mapInfos = [];
        _this.metadata = null;
        _this.nickname = "";
        _this.offline = false;
        _this.proxiedUrl = null;
        _this.resTitle = "";
        _this.scenes = [];
        _this.serviceRootUrlId = null;
        _this.tags = [];
        _this.thumbnail = null;
        _this.type = "";
        _this.updateTime = 0;
        _this.userName = "";
        _this.verifyReason = null;
        _this.version = null;
        _this.visitCount = 0;
        _Util.Util.extend(_this, params);
        _this.serviceUrl = serviceUrl;
        if (_this.id) {
            _this.serviceUrl = serviceUrl + "/" + _this.id;
        }
        return _this;
    }

    /**
     * @function SuperMap.iPortalService.prototype.load
     * @description 加载服务信息
     * @returns {Promise} 返回Promise对象。如果成功，Promise没有返回值；如果失败，Promise返回值包含错误信息
     */

    _createClass(IPortalService, [{
        key: 'load',
        value: function load() {
            var me = this;
            return me.request("GET", me.serviceUrl + ".json").then(function (serviceInfo) {
                if (serviceInfo.error) {
                    return serviceInfo;
                }
                for (var key in serviceInfo) {
                    me[key] = serviceInfo[key];
                }
            });
        }

        /**
         * @function SuperMap.iPortalService.prototype.update
         * @description 更新服务
         * @returns {Promise} 返回包含更新操作状态的Promise对象
         */

    }, {
        key: 'update',
        value: function update() {
            var serviceUpdateParam = {
                authorizeSetting: this.authorizeSetting,
                metadata: this.metadata,
                tags: this.tags,
                thumbnail: this.thumbnail
            };
            var options = {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            };
            return this.request("PUT", this.serviceUrl, JSON.stringify(serviceUpdateParam), options);
        }
    }]);

    return IPortalService;
}(_iPortalServiceBase.IPortalServiceBase);

_SuperMap.SuperMap.iPortalService = IPortalService;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPortalServicesQueryParam = undefined;

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.iPortalServicesQueryParam
 * @classdesc iPortal服务查询参数
 * @param params -{Object} 服务参数
 *
 */
var IPortalServicesQueryParam = exports.IPortalServicesQueryParam = function IPortalServicesQueryParam(params) {
    _classCallCheck(this, IPortalServicesQueryParam);

    params = params || {};
    this.tags = [];
    this.userNames = '';
    this.types = [];
    this.checkStatus = '';
    this.offline = false;
    this.orderBy = '';
    this.orderType = '';
    this.keywords = [];
    this.currentPage = 0;
    this.pageSize = 0;
    this.isBatch = false;
    this.dirIds = [];
    this.isNotInDir = false;
    this.filterFields = [];
    this.authorizedOnly = false;
    _Util.Util.extend(this, params);
};

_SuperMap.SuperMap.iPortalServicesQueryParam = IPortalServicesQueryParam;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AreaSolarRadiationParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.AreaSolarRadiationParameters
 * @classdesc 地区太阳辐射参数类。
 * @param options -{Object} 可选参数。如:</br>
 *        dataset - {string} 要用来做地区太阳辐射数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"的形式来表示，例如：JingjinTerrain@Jingjin。（必设参数）。</br>
 *        targetDatasourceName - {string}  指定的存储结果数据集的数据源名称（必设参数）, 例如："Jingjin"。</br>
 *        totalGridName - {string} 指定地区太阳辐射总辐射量数据集的名称（必设参数）。</br>
 *        diffuseDatasetGridName - {string} 指定地区太阳辐射散射辐射量数据集的名称。</br>
 *        durationDatasetGridName - {string} 指定地区太阳辐射太阳直射持续时间数据集的名称。</br>
 *        directDatasetGridName - {string} 指定地区太阳辐射直射辐射量数据集的名称。</br>
 *        latitude - {number} 待计算区域的纬度值。</br>
 *        timeMode - {string} 时间模式。可选值"WITHINDAY"（单日）或"MULTIDAYS"（多日），默认值为"MULTIDAYS"。</br>
 *        dayStart - {number} 起始日期（年内的第几天）。（必设参数）</br>
 *        dayEnd - {number} 结束日期（年内的第几天）。（必设参数）</br>
 *        hourStart - {number} 起始时间（一天中的第几个小时）。</br>
 *        hourEnd - {number} 结束时间（一天中的第几个小时）。</br>
 *        transmittance - {number} 太阳辐射穿过大气的透射率。</br>
 *        hourInterval - {number} 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 默认为0.5小时，如果修改此参数，必须使用整数）</br>
 *        dayInterval - {number} 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 默认为5天，必须使用整数）</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
 */
var AreaSolarRadiationParameters = exports.AreaSolarRadiationParameters = function () {
  function AreaSolarRadiationParameters(options) {
    _classCallCheck(this, AreaSolarRadiationParameters);

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.dataset - {string}
     *  @description  要用来做地区太阳辐射数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin （必设参数）。注：地区太阳辐射数据必须为栅格数据集。
     */
    this.dataset = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.targetDatasourceName - {string}
     * @description 指定的存储结果数据集的数据源名称（必设参数），例如："Jingjin"。
     */
    this.targetDatasourceName = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.totalGridName - {string}
     * @description 指定地区太阳辐射总辐射量数据集的名称（必设参数）。
     */
    this.totalGridName = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.diffuseDatasetGridName - {string}
     * @description 指定地区太阳辐射散射辐射量数据集的名称。
     */
    this.diffuseDatasetGridName = null;

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.durationDatasetGridName - {string}
     * @description  指定地区太阳辐射太阳直射持续时间数据集的名称。
     */
    this.durationDatasetGridName = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.durationDatasetGridName - {string}
     * @description 指定地区太阳辐射直射辐射量数据集的名称。
     */
    this.directDatasetGridName = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.latitude - {number}
     * @description 待计算区域的纬度值。
     */
    this.latitude = null;

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.timeMode - {string}
     *  @description 时间模式。可选值"WITHINDAY"（单日）或"MULTIDAYS"（多日），默认值为"MULTIDAYS";
     */
    this.timeMode = "MULTIDAYS";

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.dayStart - {number}
     *  @description 起始日期（年内的第几天）。（必设参数）
     */
    this.dayStart = null;

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.dayEnd - {number}
     * @description 结束日期（年内的第几天）。（必设参数）
     */
    this.dayEnd = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.hourStart - {number}
     * @description 起始时间（一天中的第几个小时）。
     */
    this.hourStart = null;

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.hourEnd - {number}
     * @description 结束时间（一天中的第几个小时）。
     */
    this.hourEnd = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.transmittance - {number}
     * @description 太阳辐射穿过大气的透射率。
     */
    this.transmittance = null;

    /**
     *  @member SuperMap.AreaSolarRadiationParameters.prototype.hourInterval - {number}
     *  @description 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 默认为0.5小时，如果修改此参数，必须使用整数）
     */
    this.hourInterval = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.dayInterval - {number}
     * @description 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 默认为5天，必须使用整数）
     */
    this.dayInterval = null;

    /**
     * @member SuperMap.AreaSolarRadiationParameters.prototype.deleteExistResultDataset - {boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */
    this.deleteExistResultDataset = false;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.AreaSolarRadiationParameters";
  }

  /**
   * @function SuperMap.AreaSolarRadiationParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(AreaSolarRadiationParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.dataset = null;
      me.zFactor = 1.0;
      me.averageCurvatureName = null;
      me.profileCurvatureName = null;
      me.planCurvatureName = null;
      me.deleteExistResultDataset = true;
    }

    /**
     * @function SuperMap.AreaSolarRadiationParameters.toObject
     * @param param - {SuperMap.AreaSolarRadiationParameters} 地区太阳辐射参数类。
     * @param tempObj - {SuperMap.AreaSolarRadiationParameters} 地区太阳辐射参数对象。
     * @return {object} JSON对象。
     * @description 将SuperMap.AreaSolarRadiationParameters对象转换成JSON对象。
     */

  }], [{
    key: 'toObject',
    value: function toObject(param, tempObj) {
      var parameter = {};
      for (var name in param) {
        if (name !== "dataset") {
          var name1 = name === "latitude" || name === "timeMode" || name === "dayStart";
          var name2 = name === "dayEnd" || name === "hourStart" || name === "hourEnd";
          var name3 = name === "transmittance" || name === "hourInterval" || name === "dayInterval";
          if (name1 || name2 || name3) {
            parameter[name] = param[name];
          } else {
            tempObj[name] = param[name];
          }
        }
      }
      tempObj["parameter"] = parameter;
    }
  }]);

  return AreaSolarRadiationParameters;
}();

_SuperMap.SuperMap.AreaSolarRadiationParameters = AreaSolarRadiationParameters;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferDistance = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BufferDistance
 * @classdesc 缓冲区分析的缓冲距离类。通过该类可以设置缓冲区分析的缓冲距离，距离可以是数值也可以是数值型的字段表达式。
 * @param options - {Object} 缓冲区分析可选参数。如：<br>
 *         exp - {string} 以数值型的字段表达式作为缓冲区分析的距离值。<br>
 *         value - {number}以数值作为缓冲区分析的距离值。默认为100，单位：米。
 */
var BufferDistance = exports.BufferDistance = function () {
  function BufferDistance(options) {
    _classCallCheck(this, BufferDistance);

    /**
     * @member SuperMap.BufferDistance.prototype.exp -{string}
     * @description 以数值型的字段表达式作为缓冲区分析的距离值。
     */
    this.exp = null;

    /**
     * @member SuperMap.BufferDistance.prototype.value -{number}
     * @description 以数值作为缓冲区分析的距离值。默认为100，单位：米。
     */
    this.value = 100;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.BufferDistance";
  }

  /**
   * @function SuperMap.BufferDistance.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(BufferDistance, [{
    key: 'destroy',
    value: function destroy() {
      this.exp = null;
      this.value = null;
    }
  }]);

  return BufferDistance;
}();

_SuperMap.SuperMap.BufferDistance = BufferDistance;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BufferSetting = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _BufferDistance = __webpack_require__(151);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BufferSetting
 * @classdesc 缓冲区分析通用设置类。
 * @param options - {Object} 缓冲区分析设置可选参数。如：<br>
 *         endType - {SuperMap.BufferEndType} 缓冲区端点枚举值。<br>
 *         leftDistance - {{@link SuperMap.BufferDistance}} 左侧缓冲距离。<br>
 *         rightDistance - {{@link SuperMap.BufferDistance}} 右侧缓冲距离。<br>
 *         semicircleLineSegment - {number} 圆头缓冲圆弧处线段的个数。<br>
 *         radiusUnit - {{@link SuperMap.BufferRadiusUnit}} 缓冲半径单位。
 */
var BufferSetting = exports.BufferSetting = function () {
  function BufferSetting(options) {
    _classCallCheck(this, BufferSetting);

    /**
     * @member SuperMap.BufferSetting.prototype.endType - {SuperMap.BufferEndType}
     * @description 缓冲区端点枚举值。分为平头和圆头两种，默认为平头，即 SuperMap.BufferEndType.FLAT
     */
    this.endType = _REST.BufferEndType.FLAT;

    /**
     * @member SuperMap.BufferSetting.prototype.leftDistance - {SuperMap.BufferDistance}
     * @description 左侧缓冲距离。
     * 默认为100。当为GeometryBufferAnalyst时，单位为默认地图的投影系的单位（如3857为米，4326为度），
     * 当为DatasetBufferAnalyst时，单位通过BufferSetting.radiusUnit设置（默认全部为米）。
     */
    this.leftDistance = new _BufferDistance.BufferDistance();

    /**
     * @member SuperMap.BufferSetting.prototype.rightDistance -{SuperMap.BufferDistance}
     * @description 右侧缓冲距离。
     * 默认为100。当为GeometryBufferAnalyst时，单位为默认地图的投影系的单位（如3857为米，4326为度），
     * 当为DatasetBufferAnalyst时，单位通过BufferSetting.radiusUnit设置（默认全部为米）。
     */
    this.rightDistance = new _BufferDistance.BufferDistance();

    /**
     * @member SuperMap.BufferSetting.prototype.semicircleLineSegment -{number}
     * @description 圆头缓冲圆弧处线段的个数。即用多少个线段来模拟一个半圆，默认值为4。
     */
    this.semicircleLineSegment = 4;

    /**
     * @member SuperMap.BufferSetting.prototype.radiusUnit - {SuperMap.BufferRadiusUnit}
     * @description 缓冲半径单位，默认值为SuperMap.BufferRadiusUnit.METER，还可以是SuperMap.BufferRadiusUnit.MILIMETER、SuperMap.BufferRadiusUnit.CENTIMETER、SuperMap.BufferRadiusUnit.DECIMETER、SuperMap.BufferRadiusUnit.KILOMETER、SuperMap.BufferRadiusUnit.FOOT、SuperMap.BufferRadiusUnit.INCH、SuperMap.BufferRadiusUnit.MILE、SuperMap.BufferRadiusUnit.YARD。仅对BufferAnalyst有效
     */
    this.radiusUnit = _REST.BufferRadiusUnit.METER;

    if (options) {
      _Util.Util.extend(this, options);
    }
    this.CLASS_NAME = "SuperMap.BufferSetting";
  }

  /**
   * @function SuperMap.BufferSetting.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(BufferSetting, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.endType = null;
      if (me.leftDistance) {
        me.leftDistance.destroy();
        me.leftDistance = null;
      }
      if (me.rightDistance) {
        me.rightDistance.destroy();
        me.rightDistance = null;
      }
      me.semicircleLineSegment = null;
      me.radiusUnit = null;
    }
  }]);

  return BufferSetting;
}();

_SuperMap.SuperMap.BufferSetting = BufferSetting;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BuffersAnalystJobsParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BuffersAnalystJobsParameter
 * @classdesc 缓冲区分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         bounds - {Object} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *         distance -{string} 缓冲距离，或缓冲区半径。 <br>
 *         distanceField -{string} 缓冲区分析距离字段。 <br>
 *         distanceUnit -{{@link SuperMap.AnalystSizeUnit}} 缓冲距离单位单位。 <br>
 *         distance -{string} 缓冲区半径。 <br>
 */
var BuffersAnalystJobsParameter = exports.BuffersAnalystJobsParameter = function () {
    function BuffersAnalystJobsParameter(options) {
        _classCallCheck(this, BuffersAnalystJobsParameter);

        /**
         * @member SuperMap.BuffersAnalystJobsParameter.prototype.datasetName -{string}
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member SuperMap.BuffersAnalystJobsParameter.prototype.bounds - {Object}
         * @description 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。 <br>
         */
        this.bounds = "";

        /**
         * @member SuperMap.BuffersAnalystJobsParameter.prototype.distance -{string}
         * @description 缓冲距离，或称为缓冲区半径。当缓冲距离字段位空时，此参数有效。
         */
        this.distance = "";

        /**
         * @member SuperMap.BuffersAnalystJobsParameter.prototype.distanceField -{string}
         * @description 缓冲距离字段，
         */
        this.distanceField = "";

        /**
         * @member SuperMap.BuffersAnalystJobsParameter.prototype.distanceField -{SuperMap.AnalystSizeUnit}
         * @description 缓冲距离单位。
         */
        this.distanceUnit = _REST.AnalystSizeUnit.METER;

        /**
         * @member SuperMap.BuffersAnalystJobsParameter.prototype.dissolveField -{string}
         * @description 融合字段，根据字段值对缓冲区结果面对象进行融合。
         */
        this.dissolveField = "";
        if (!options) {
            return this;
        }
        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.BuffersAnalystJobsParameter";
    }

    /**
     * @function SuperMap.BuffersAnalystJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(BuffersAnalystJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.bounds = null;
            this.distance = null;
            this.distanceField = null;
            this.distanceUnit = null;
            this.dissolveField = null;
        }

        /**
         * @function SuperMap.BuffersAnalystJobsParameter.toObject
         * @param BuffersAnalystJobsParameter -{Object} 缓冲区分析任务参数
         * @param tempObj - {Object} 目标对象
         * @description 生成缓冲区分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(BuffersAnalystJobsParameter, tempObj) {
            for (var name in BuffersAnalystJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = BuffersAnalystJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                if (name === 'bounds') {
                    tempObj['analyst'][name] = BuffersAnalystJobsParameter[name].toBBOX();
                } else {
                    tempObj['analyst'][name] = BuffersAnalystJobsParameter[name];
                }
            }
        }
    }]);

    return BuffersAnalystJobsParameter;
}();

_SuperMap.SuperMap.BuffersAnalystJobsParameter = BuffersAnalystJobsParameter;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BurstPipelineAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.BurstPipelineAnalystParameters
 * @classdesc 爆管分析参数类。
 * @param options - {Object} 可选参数。如：<br>
 *         sourceNodeIDs - {Array<number>} 指定的设施点ID数组。<br>
 *         edgeID - {number} 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。<br>
 *         nodeID - {number} 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效；默认false，无效。
 */
var BurstPipelineAnalystParameters = exports.BurstPipelineAnalystParameters = function () {
  function BurstPipelineAnalystParameters(options) {
    _classCallCheck(this, BurstPipelineAnalystParameters);

    var me = this;
    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.sourceNodeIDs -{Array<number>}
     * @description 指定的设施点ID数组,可以为空。
     */
    this.sourceNodeIDs = null;

    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.edgeID -{number}
     * @description 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
     */
    this.edgeID = null;

    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.nodeID -{number}
     * @description 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
     */
    this.nodeID = null;

    /**
     * @member SuperMap.BurstPipelineAnalystParameters.prototype.isUncertainDirectionValid -{boolean}
     * @description 指定不确定流向是否有效，默认为false。
     * 指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行。
     * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
     */
    this.isUncertainDirectionValid = false;

    _Util.Util.extend(me, options);

    this.CLASS_NAME = "SuperMap.BurstPipelineAnalystParameters";
  }

  /**
   * @function SuperMap.BurstPipelineAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(BurstPipelineAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.sourceNodeIDs = null;
      me.edgeID = null;
      me.nodeID = null;
      me.isUncertainDirectionValid = null;
    }
  }]);

  return BurstPipelineAnalystParameters;
}();

_SuperMap.SuperMap.BurstPipelineAnalystParameters = BurstPipelineAnalystParameters;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChartQueryFilterParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ChartQueryFilterParameter
 * @classdesc 海图查询过滤参数类，用于设置海图查询的过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
 * @param options - {Object} 可选参数。如：<br>
 *        isQueryPoint - {boolean} 是否查询点。<br>
 *        isQueryLine  - {boolean} 是否查询线。<br>
 *        isQueryRegion  - {boolean} 是否查询面。<br>
 *        attributeFilter - {string} 属性字段过滤条件。<br>
 *        chartFeatureInfoSpecCode - {number}查询的物标代号。
 */
var ChartQueryFilterParameter = exports.ChartQueryFilterParameter = function () {
  function ChartQueryFilterParameter(options) {
    _classCallCheck(this, ChartQueryFilterParameter);

    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.isQueryPoint -{boolean}
     * @description 是否查询点。
     */
    this.isQueryPoint = null;

    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.isQueryLine -{boolean}
     * @description 是否查询线。
     */
    this.isQueryLine = null;

    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.isQueryRegion -{boolean}
     * @description 是否查询面。
     */
    this.isQueryRegion = null;

    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.attributeFilter -{string}
     * @description 属性字段过滤条件。
     */
    this.attributeFilter = null;

    /**
     * @member SuperMap.ChartQueryFilterParameter.prototype.chartFeatureInfoSpecCode -{number}
     * @description 查询的物标代号。
     */
    this.chartFeatureInfoSpecCode = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.ChartQueryFilterParameter";
  }

  /**
   * @function SuperMap.ChartQueryFilterParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ChartQueryFilterParameter, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isQueryPoint = null;
      me.isQueryLine = null;
      me.isQueryRegion = null;
      me.attributeFilter = null;
      me.chartFeatureInfoSpecCode = null;
    }

    /**
     * @function  SuperMap.ChartQueryFilterParameter.prototype.toJson
     * @description 将属性信息转化成JSON格式字符串。
     */

  }, {
    key: 'toJson',
    value: function toJson() {
      var json = "";
      json += "\"isQueryPoint\":" + this.isQueryPoint + ",";
      json += "\"isQueryLine\":" + this.isQueryLine + ",";
      json += "\"isQueryRegion\":" + this.isQueryRegion + ",";
      if (this.attributeFilter) {
        json += "\"attributeFilter\": \"" + this.attributeFilter + "\",";
      }
      json += "\"chartFeatureInfoSpecCode\":" + this.chartFeatureInfoSpecCode;
      json = "{" + json + "}";
      return json;
    }
  }]);

  return ChartQueryFilterParameter;
}();

_SuperMap.SuperMap.ChartQueryFilterParameter = ChartQueryFilterParameter;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChartQueryParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ChartQueryFilterParameter = __webpack_require__(155);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ChartQueryParameters
 * @classdesc 海图查询参数类，该类用于设置海图查询时的相关参数，海图查询分为海图属性查询和海图范围查询两类，通过属性queryMode指定查询模式。
 *              必设属性有：queryMode、chartLayerNames、chartQueryFilterParameters。当进行海图范围查询时，必设属性还包括bounds。
 * @param options - {Object} 可选参数。如：<br>
 *         queryMode - {string} 海图查询模式类型，支持两种查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询（"ChartBoundsQuery"） 。<br>
 *         bounds - {Object} 海图查询范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *         chartLayerNames - {Array<string>} 查询的海图图层的名称。<br>
 *         chartQueryFilterParameters - {Array <{@link SuperMap.ChartQueryFilterParameter}>} 海图查询过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。<br>
 *         returnContent - {boolean} 获取或设置是返回查询结果记录集 recordsets，还是返回查询结果的资源 resourceInfo。默认为 true，表示返回 recordsets。<br>
 *         startRecord - {number} 查询起始记录位置，默认为0。<br>
 *         expectCount - {number} 期望查询结果返回的记录数，该值大于0。
 */
var ChartQueryParameters = exports.ChartQueryParameters = function () {
    function ChartQueryParameters(options) {
        _classCallCheck(this, ChartQueryParameters);

        /**
         * @member SuperMap.ChartQueryParameters.prototype.queryMode -{string}
         * @description 海图查询模式类型，支持两种查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询（"ChartBoundsQuery"） 。
         */
        this.queryMode = null;

        /**
         * @member SuperMap.ChartQueryParameters.prototype.bounds - {Object}
         * @description 海图查询范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
         */
        this.bounds = null;

        /**
         * @member SuperMap.ChartQueryParameters.prototype.chartLayerNames - {Array<string>}
         * @description 查询的海图图层的名称。
         */
        this.chartLayerNames = null;

        /**
         * @member SuperMap.ChartQueryParameters.prototype.chartQueryFilterParameters - {Array<SuperMap.ChartQueryFilterParameter>}
         * @description 海图查询过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
         */
        this.chartQueryFilterParameters = null;

        /**
         * @member SuperMap.ChartQueryParameters.prototype.returnContent - {boolean}
         * @description 获取或设置是返回查询结果记录集 recordsets，还是返回查询结果的资源 resourceInfo。默认为 true，表示返回 recordsets。
         */
        this.returnContent = true;

        /**
         * @member SuperMap.ChartQueryParameters.prototype.startRecord - {number}
         * @description 查询起始记录位置，默认为0。
         */
        this.startRecord = 0;

        /**
         * @member SuperMap.ChartQueryParameters.prototype.expectCount - {number}
         * @description 期望查询结果返回的记录数，该值大于0。
         */
        this.expectCount = null;
        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.ChartQueryParameters";
    }

    /**
     * @function SuperMap.ChartQueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ChartQueryParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.queryMode = null;
            me.bounds = null;
            me.chartLayerNames = null;
            me.chartQueryFilterParameters = null;
            me.returnContent = true;
            me.startRecord = 0;
            me.expectCount = null;
        }

        /**
         * @function SuperMap.ChartQueryParameters.prototype.getVariablesJson
         * @description 将属性信息转换成能够被服务识别的JSON格式字符串。
         * @return {string} JSON字符串。
         */

    }, {
        key: 'getVariablesJson',
        value: function getVariablesJson() {
            var json = "";

            json += "\"queryMode\":\"" + this.queryMode + "\",";

            if (this.chartLayerNames && this.chartLayerNames.length) {
                var chartLayersArray = [];
                var layerLength = this.chartLayerNames.length;
                for (var i = 0; i < layerLength; i++) {
                    chartLayersArray.push("\"" + this.chartLayerNames[i] + "\"");
                }
                var layerNames = "[" + chartLayersArray.join(",") + "]";
                json += "\"chartLayerNames\":" + layerNames + ",";
            }

            if (this.queryMode === "ChartBoundsQuery" && this.bounds) {
                json += "\"bounds\":" + "{" + "\"leftBottom\":" + "{" + "\"x\":" + this.bounds.left + "," + "\"y\":" + this.bounds.bottom + "}" + "," + "\"rightTop\":" + "{" + "\"x\":" + this.bounds.right + "," + "\"y\":" + this.bounds.top + "}" + "},";
            }

            if (this.chartQueryFilterParameters && this.chartQueryFilterParameters.length) {
                var chartParamArray = [];
                var chartLength = this.chartQueryFilterParameters.length;
                for (var j = 0; j < chartLength; j++) {
                    var chartQueryFilterParameter = this.chartQueryFilterParameters[j];
                    if (!(chartQueryFilterParameter instanceof _ChartQueryFilterParameter.ChartQueryFilterParameter)) {
                        continue;
                    }
                    chartParamArray.push(chartQueryFilterParameter.toJson());
                }
                var chartParamsJson = "[" + chartParamArray.join(",") + "]";
                chartParamsJson = "\"chartQueryParams\":" + chartParamsJson + ",";
                chartParamsJson += "\"startRecord\":" + this.startRecord + ",";
                chartParamsJson += "\"expectCount\":" + this.expectCount;
                chartParamsJson = "{" + chartParamsJson + "}";
                json += "\"chartQueryParameters\":" + chartParamsJson;
            }
            json = "{" + json + "}";
            return json;
        }
    }]);

    return ChartQueryParameters;
}();

_SuperMap.SuperMap.ChartQueryParameters = ChartQueryParameters;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ClipParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ClipParameter
 * @classdesc 用于裁剪的参数。
 * @description 优先使用用户指定的裁剪区域多边形进行裁剪，也可以通过指定数据源和数据集名，从而使用指定数据集的边界多边形进行裁剪。
 * @param options - {Object} 参数。<br>
 *          clipDatasetName - {String} 裁剪的数据集名。<br>
 *          clipDatasourceName - {String} 裁剪的数据集所在数据源的名字。<br>
 *          clipRegion - {Object} 用户指定的裁剪区域。面对象可以是SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *          isClipInRegion - {Boolean} 是否对裁剪区内的数据集进行裁剪。<br>
 *          isExactClip - {Boolean} 是否使用精确裁剪。
 */
var ClipParameter = exports.ClipParameter = function () {
    function ClipParameter(options) {
        _classCallCheck(this, ClipParameter);

        /**
         * @member SuperMap.ClipParameter.prototype.clipDatasetName -{string}
         * @description 用于裁剪的数据集名，当clipRegion不设置时起作用。
         */
        this.clipDatasetName = null;

        /**
         * @member SuperMap.ClipParameter.prototype.clipDatasourceName -{string}
         * @description 用于裁剪的数据集所在数据源的名字。
         */
        this.clipDatasourceName = null;

        /**
         * @member SuperMap.ClipParameter.prototype.clipRegion -{Object}
         * @description 用户指定的裁剪区域，优先使用。<br>
         * 面对象可以是SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。
         */
        this.clipRegion = null;

        /**
         * @member SuperMap.ClipParameter.prototype.isClipInRegion -{boolean}
         * @description 是否对裁剪区内的数据集进行裁剪。
         */
        this.isClipInRegion = false;

        /**
         * @member SuperMap.ClipParameter.prototype.isExactClip -{boolean}
         * @description 是否使用精确裁剪。
         */
        this.isExactClip = null;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ClipParameter";
    }

    /**
     * @function SuperMap.ClipParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ClipParameter, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.clipDatasetName = null;
            me.clipDatasourceName = null;
            me.clipRegion = null;
            me.isClipInRegion = null;
            me.isExactClip = null;
        }

        /**
         * @function SuperMap.ClipParameter.prototype.toJSON
         * @description 将 ClipParameter 对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            if (this.isClipInRegion == false) {
                return null;
            }
            var strClipParameter = "";
            var me = this;

            strClipParameter += "'isClipInRegion':" + _Util.Util.toJSON(me.isClipInRegion);

            if (me.clipDatasetName != null) {
                strClipParameter += "," + "'clipDatasetName':" + _Util.Util.toJSON(me.clipDatasetName);
            }

            if (me.clipDatasourceName != null) {
                strClipParameter += "," + "'clipDatasourceName':" + _Util.Util.toJSON(me.clipDatasourceName);
            }

            if (me.isExactClip != null) {
                strClipParameter += "," + "'isExactClip':" + _Util.Util.toJSON(me.isExactClip);
            }

            if (me.clipRegion != null) {
                var serverGeometry = _ServerGeometry.ServerGeometry.fromGeometry(me.clipRegion);
                if (serverGeometry) {
                    var pointsCount = serverGeometry.parts[0];
                    var point2ds = serverGeometry.points.splice(0, pointsCount);
                    strClipParameter += "," + "'clipRegion':" + "{\"point2Ds\":";
                    strClipParameter += _Util.Util.toJSON(point2ds);
                    strClipParameter += "}";
                }
            }
            return "{" + strClipParameter + "}";
        }
    }]);

    return ClipParameter;
}();

_SuperMap.SuperMap.ClipParameter = ClipParameter;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ColorDictionary = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerColor = __webpack_require__(20);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ColorDictionary
 * @classdesc 颜色对照表类。
 * @description 颜色对照表中的键名为具体的高程值，键值表示该高程值要显示的颜色。对于栅格图层中高程值小于颜色对照表中高程最
 *                小值的点使用颜色对照表中高程最小值对应的颜色，对于栅格图层中高程值大于颜色对照表中高程最大值的点使用颜色对
 *                照表中高程最大值对应的颜色，对于栅格图层中高程值在颜色对照表中没有对应颜色的点，则查找颜色对照表中与当前高
 *                程值相邻的两个高程对应的颜色，然后通过渐变运算要显示的颜色。如果设置了颜色对照表的话，则颜色表设置无效。
 * @param options - {Object} 可选参数。如：<br>
 *        elevation - {number} 高程值。<br>
 *        color - {@link SuperMap.ServerColor} 服务端颜色类。
 */
var ColorDictionary = exports.ColorDictionary = function () {
    function ColorDictionary(options) {
        _classCallCheck(this, ColorDictionary);

        options = options || {};

        /**
         * @member SuperMap.ColorDictionary.prototype.elevation - {number}
         * @description 高程值。
         */
        this.elevation = null;

        /**
         * @member SuperMap.ColorDictionary.prototype.color - {SuperMap.ServerColor}
         * @description 服务端颜色类。
         */
        this.color = null;

        _Util.Util.extend(this, options);

        var me = this,
            c = me.color;
        if (c) {
            me.color = new _ServerColor.ServerColor(c.red, c.green, c.blue);
        }

        this.CLASS_NAME = "SuperMap.ColorDictionary";
    }

    /**
     * @function SuperMap.ColorDictionary.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    _createClass(ColorDictionary, [{
        key: 'destroy',
        value: function destroy() {
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.ColorDictionary.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} JSON对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var dataObj = {};
            dataObj = _Util.Util.copyAttributes(dataObj, this);
            return dataObj;
        }
    }]);

    return ColorDictionary;
}();

_SuperMap.SuperMap.ColorDictionary = ColorDictionary;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComputeWeightMatrixParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystParameter = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ComputeWeightMatrixParameters
 * @classdesc 耗费矩阵分析参数类。根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
 * @param options - {Object} 可选参数。如：<br>
 *         isAnalyzeById - {boolean} 是否通过节点 ID 指定路径分析的结点。<br>
 *         nodes - {Array<Object>} 要计算耗费矩阵的点数组，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *         parameter - {@link SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var ComputeWeightMatrixParameters = exports.ComputeWeightMatrixParameters = function () {
  function ComputeWeightMatrixParameters(options) {
    _classCallCheck(this, ComputeWeightMatrixParameters);

    /**
     * @member SuperMap.ComputeWeightMatrixParameters.prototype.isAnalyzeById {Boolean}
     * @description 是否通过节点 ID 指定路径分析的结点，默认为 false，即通过坐标点指定。
     */
    this.isAnalyzeById = false;

    /**
     * @member SuperMap.ComputeWeightMatrixParameters.prototype.nodes {Array<Object>|Array<number>}
     * @description 要计算耗费矩阵的点数组，必设字段。<br>
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
     *              当 SuperMap.ComputeWeightMatrixParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；<br>
     *              当 SuperMap.ComputeWeightMatrixParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */
    this.nodes = null;

    /**
     * @member SuperMap.ComputeWeightMatrixParameters.prototype.parameter {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。
     */
    this.parameter = new _TransportationAnalystParameter.TransportationAnalystParameter();

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.ComputeWeightMatrixParameters";
  }

  /**
   * @function SuperMap.ComputeWeightMatrixParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ComputeWeightMatrixParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isAnalyzeById = null;
      me.nodes = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return ComputeWeightMatrixParameters;
}();

_SuperMap.SuperMap.ComputeWeightMatrixParameters = ComputeWeightMatrixParameters;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatasetBufferAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _BufferAnalystParameters = __webpack_require__(94);

var _DataReturnOption = __webpack_require__(50);

var _FilterParameter = __webpack_require__(16);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetBufferAnalystParameters
 * @classdesc  数据集缓冲区分析参数类。
 * @param options - {Object} 可选参数。如：</br>
 *        dataset - {string} 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。</br>
 *        filterQueryParameter - {@link SuperMap.FilterParameter} 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。</br>
 *        resultSetting - {@link SuperMap.DataReturnOption} 结果返回设置类。</br>
 *        isAttributeRetained - {boolean} 是否保留进行缓冲区分析的对象的字段属性，默认为 true。当 isUnion 字段为 false 时该字段有效。</br>
 *        isUnion - {boolean} 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。默认为 false。</br>
 *        bufferSetting - {@link SuperMap.BufferSetting} 设置缓冲区通用参数。</br>
 *
 * @extends SuperMap.BufferAnalystParameters
 */
var DatasetBufferAnalystParameters = exports.DatasetBufferAnalystParameters = function (_BufferAnalystParamet) {
    _inherits(DatasetBufferAnalystParameters, _BufferAnalystParamet);

    function DatasetBufferAnalystParameters(options) {
        _classCallCheck(this, DatasetBufferAnalystParameters);

        /**
         * @member SuperMap.DatasetBufferAnalystParameters.prototype.dataset -{string}
         * @description 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
         */
        var _this = _possibleConstructorReturn(this, (DatasetBufferAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetBufferAnalystParameters)).call(this, options));

        _this.dataset = null;

        /**
         *  @member SuperMap.DatasetBufferAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
         *  @description 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。
         */
        _this.filterQueryParameter = new _FilterParameter.FilterParameter();

        /**
         * @member SuperMap.DatasetBufferAnalystParameters.prototype.resultSetting -{SuperMap.DataReturnOption}
         * @description 结果返回设置类。
         */
        _this.resultSetting = new _DataReturnOption.DataReturnOption();

        /**
         * @member SuperMap.DatasetBufferAnalystParameters.prototype.isAttributeRetained -{boolean}
         * @description 是否保留进行缓冲区分析的对象的字段属性，默认为 true。当 isUnion 字段为 false 时该字段有效。
         */
        _this.isAttributeRetained = true;

        /**
         * @member SuperMap.DatasetBufferAnalystParameters.prototype.isUnion -{boolean}
         * @description 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。默认为 false。
         */
        _this.isUnion = false;

        _Util.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.DatasetBufferAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.DatasetBufferAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(DatasetBufferAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetBufferAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetBufferAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.dataset = null;
            if (me.filterQueryParameter) {
                me.filterQueryParameter.destroy();
                me.filterQueryParameter = null;
            }
            if (me.resultSetting) {
                me.resultSetting.destroy();
                me.resultSetting = null;
            }
            me.isAttributeRetained = null;
            me.isUnion = null;
        }

        /**
         * @function SuperMap.DatasetBufferAnalystParameters.toObject
         * @param datasetBufferAnalystParameters - {SuperMap.DatasetBufferAnalystParameters} 数据集缓冲区分析参数类。
         * @param tempObj - {SuperMap.DatasetBufferAnalystParameters} 数据集缓冲区分析参数对象。
         * @description 将数据集缓冲区分析参数对象转换为JSON对象。
         * @return {Object} JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetBufferAnalystParameters, tempObj) {
            for (var name in datasetBufferAnalystParameters) {
                if (name === "bufferSetting") {
                    datasetBufferAnalystParameters.bufferSetting.radiusUnit = datasetBufferAnalystParameters.bufferSetting.radiusUnit.toUpperCase();
                    tempObj.bufferAnalystParameter = datasetBufferAnalystParameters.bufferSetting;
                } else if (name === "resultSetting") {
                    tempObj.dataReturnOption = datasetBufferAnalystParameters.resultSetting;
                } else if (name === "dataset") {
                    continue;
                } else {
                    tempObj[name] = datasetBufferAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetBufferAnalystParameters;
}(_BufferAnalystParameters.BufferAnalystParameters);

_SuperMap.SuperMap.DatasetBufferAnalystParameters = DatasetBufferAnalystParameters;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DatasetInfo = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Bounds = __webpack_require__(22);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DatasetInfo
 * @classdesc 数据集信息类。
 * @description 数据集一般为存储在一起的相关数据的集合；根据数据类型的不同，分为矢量数据集、栅格数据集(griddataset)和
 *              影像数据集(image dataset)，以及为了处理特定问题而设计的数据集，如拓扑数据集，网络数据集等。
 *              数据集是 GIS 数据组织的最小单位。其中矢量数据集是由同种类型空间要素组成的集合，
 *              所以也可以称为要素集。根据要素的空间特征的不同，矢量数据集又分为点数据集，
 *              线数据集，面数据集等，各矢量数据集是空间特征和性质相同的数据组织起来的集合。
 *              目前版本支持的数据集主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD数据集）、
 *              网络数据集，栅格数据集(grid dataset)和影像数据集(image dataset)。
 * @param options - {Object} 可选参数。如：<br>
 *        bounds - {@link SuperMap.Bounds} 数据集范围，该字段只读。<br>
 *        dataSourceName - {string} 数据源名称，该字段只读。<br>
 *        description - {string} 数据集的描述信息。<br>
 *        encodeType - {string} 数据集存储时的压缩编码方式，该字段只读。<br>
 *        isReadOnly - {boolean} 数据集是否为只读。<br>
 *        name - {string} 数据集名称，该字段必须且只读。<br>
 *        prjCoordSys - {@link SuperMap.Projection} 数据集的投影信息。<br>
 *        tableName - {string} 表名，该字段只读。<br>
 *        type - {string} 数据集类型，该字段必设。主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD数据集）、
 *                        网络数据集，栅格数据集(grid dataset)和影像数据集(image dataset)。
 */
var DatasetInfo = exports.DatasetInfo = function () {
  function DatasetInfo(options) {
    _classCallCheck(this, DatasetInfo);

    options = options || {};

    /**
     * @member SuperMap.DatasetInfo.prototype.bounds - {SuperMap.Bounds}
     * @description 数据集范围，该字段只读。
     */
    this.bounds = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.dataSourceName - {string}
     * @description 数据源名称，该字段只读。
     */
    this.dataSourceName = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.description - {string}
     * @description 数据集的描述信息。
     */
    this.description = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.encodeType - {string}
     * @description 数据集存储时的压缩编码方式，该字段只读。
     */
    this.encodeType = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.isReadOnly - {boolean}
     * @description 数据集是否为只读。
     */
    this.isReadOnly = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.name - {string}
     * @description 数据集名称，该字段必须且只读。
     */
    this.name = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.prjCoordSys - {SuperMap.Projection}
     * @description 数据集的投影信息。
     */
    this.prjCoordSys = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.tableName - {string}
     * @description 表名，该字段只读。
     */
    this.tableName = null;

    /**
     * @member SuperMap.DatasetInfo.prototype.type - {string}
     * @description 数据集类型，该字段必设。主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD数据集）、
     *              网络数据集，栅格数据集(grid dataset)和影像数据集(image dataset)。
     */
    this.type = null;

    _Util.Util.extend(this, options);

    var b = this.bounds;
    if (b) {
      this.bounds = new _Bounds.Bounds(b.leftBottom.x, b.leftBottom.y, b.rightTop.x, b.rightTop.y);
    }
    this.CLASS_NAME = "SuperMap.DatasetInfo";
  }

  /**
   * @function SuperMap.DatasetInfo.prototype.destroy
   * @description 释放资源,将引用资源的属性置空。
   */


  _createClass(DatasetInfo, [{
    key: 'destroy',
    value: function destroy() {
      _Util.Util.reset(this);
    }

    /**
     * @function SuperMap.DatasetInfo.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @return {Object} JSON对象。
     */

  }, {
    key: 'toServerJSONObject',
    value: function toServerJSONObject() {
      var dataObj = {};
      dataObj = _Util.Util.copyAttributes(dataObj, this);
      if (dataObj.bounds) {
        if (dataObj.bounds.toServerJSONObject) {
          dataObj.bounds = dataObj.bounds.toServerJSONObject();
        }
      }
      return dataObj;
    }
  }]);

  return DatasetInfo;
}();

_SuperMap.SuperMap.DatasetInfo = DatasetInfo;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatasetOverlayAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _DataReturnOption = __webpack_require__(50);

var _FilterParameter = __webpack_require__(16);

var _OverlayAnalystParameters = __webpack_require__(95);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetOverlayAnalystParameters
 * @classdesc 数据集叠加分析参数类。
 * @param options - {Object} 可选参数。如：</br>
 *        operateDataset - {string} 叠加分析中操作数据集的名称。必设字段。</br>
 *        operateDatasetFields - {Array<string>} 叠加分析中操作数据集保留在结果数据集中的字段名列表。</br>
 *        operateDatasetFilter - {{@link SuperMap.FilterParameter}} 设置操作数据集中空间对象过滤条件。</br>
 *        operateRegions - {Array<Object>} 操作区域。设置了操作区域后，仅对该区域内的对象进行分析。面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *        sourceDataset - {string} 叠加分析中源数据集的名称。必设字段。</br>
 *        sourceDatasetFields - {Array<string>} 叠加分析中源数据集保留在结果数据集中的字段名列表。</br>
 *        sourceDatasetFilter - {{@link SuperMap.FilterParameter}} 设置源数据集中空间对象过滤条件。</br>
 *        tolerance - {integer} 容限。</br>
 *        operation -  {{@link SuperMap.OverlayOperationType}} 叠加操作枚举值。</br>
 *        resultSetting - {{@link SuperMap.DataReturnOption}} 结果返回设置类。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var DatasetOverlayAnalystParameters = exports.DatasetOverlayAnalystParameters = function (_OverlayAnalystParame) {
    _inherits(DatasetOverlayAnalystParameters, _OverlayAnalystParame);

    function DatasetOverlayAnalystParameters(options) {
        _classCallCheck(this, DatasetOverlayAnalystParameters);

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateDataset -{string}
         * @description 叠加分析中操作数据集的名称。
         */
        var _this = _possibleConstructorReturn(this, (DatasetOverlayAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetOverlayAnalystParameters)).call(this, options));

        _this.operateDataset = null;

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateDatasetFields -{Array<string>}
         * @description 叠加分析中操作数据集保留在结果数据集中的字段名列表。
         */
        _this.operateDatasetFields = [];

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateDatasetFilter -{SuperMap.FilterParameter}
         * @description 设置操作数据集中空间对象过滤条件。
         */
        _this.operateDatasetFilter = new _FilterParameter.FilterParameter();

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.operateRegions
         * @description 操作面对象集合，表示与这些面对象进行叠加分析。<br>
         * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。<br>
         * 与 operateDataset 参数互斥，冲突时以operateDataset 为准。
         */
        _this.operateRegions = [];

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.sourceDataset -{string}
         * @description 叠加分析中源数据集的名称。必设字段。
         */
        _this.sourceDataset = null;

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.sourceDatasetFields -{Array<string>}
         * @description 叠加分析中源数据集保留在结果数据集中的字段名列表。
         */
        _this.sourceDatasetFields = [];

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
         * @description 设置源数据集中空间对象过滤条件。
         */
        _this.sourceDatasetFilter = new _FilterParameter.FilterParameter();

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.tolerance -{Integer}
         * @description 容限。
         */
        _this.tolerance = 0;

        /**
         * @member SuperMap.DatasetOverlayAnalystParameters.prototype.resultSetting -{SuperMap.DataReturnOption}
         * @description 结果返回设置类。
         */
        _this.resultSetting = new _DataReturnOption.DataReturnOption();

        _Util.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.DatasetOverlayAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.DatasetOverlayAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(DatasetOverlayAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetOverlayAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetOverlayAnalystParameters.prototype), 'destroy', this).call(this);

            var me = this;
            me.operateDataset = null;
            me.operateDatasetFields = null;
            if (me.operateDatasetFilter) {
                me.operateDatasetFilter.destroy();
                me.operateDatasetFilter = null;
            }
            if (me.operateRegions) {
                for (var i = 0, opRegions = me.operateRegions, len = opRegions.length; i < len; i++) {
                    opRegions[i].destroy();
                }
                me.operateRegions = null;
            }
            me.sourceDataset = null;
            me.sourceDatasetFields = null;
            if (me.sourceDatasetFilter) {
                me.sourceDatasetFilter.destroy();
                me.sourceDatasetFilter = null;
            }
            me.tolerance = null;
            if (me.resultSetting) {
                me.resultSetting.destroy();
                me.resultSetting = null;
            }
        }

        /**
         * @function SuperMap.DatasetOverlayAnalystParameters.toObject
         * @param datasetOverlayAnalystParameters -{SuperMap.DatasetOverlayAnalystParameters} 数据集叠加分析参数类。
         * @param tempObj - {SuperMap.DatasetOverlayAnalystParameters} 数据集叠加分析参数对象。
         * @description  将数据集叠加分析参数类转换为JSON对象。
         * @return {Object} JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetOverlayAnalystParameters, tempObj) {
            for (var name in datasetOverlayAnalystParameters) {
                if (name === "sourceDataset") {
                    continue;
                } else if (name === "operateRegions") {
                    tempObj.operateRegions = [];
                    var ors = datasetOverlayAnalystParameters.operateRegions;
                    for (var index in ors) {
                        if (ors.hasOwnProperty(index)) {
                            //icl542
                            tempObj.operateRegions[index] = _ServerGeometry.ServerGeometry.fromGeometry(ors[index]);
                        }
                    }
                } else if (name === "resultSetting") {
                    tempObj.dataReturnOption = datasetOverlayAnalystParameters.resultSetting;
                } else {
                    tempObj[name] = datasetOverlayAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetOverlayAnalystParameters;
}(_OverlayAnalystParameters.OverlayAnalystParameters);

_SuperMap.SuperMap.DatasetOverlayAnalystParameters = DatasetOverlayAnalystParameters;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatasetSurfaceAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _FilterParameter = __webpack_require__(16);

var _SurfaceAnalystParameters = __webpack_require__(69);

var _ServerGeometry = __webpack_require__(9);

var _Geometry = __webpack_require__(26);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetSurfaceAnalystParameters
 * @classdesc 数据集表面分析参数类。该类对数据集表面分析所用到的参数进行设置。
 * @param options - {Object} 可选参数。如:</br>
 *        dataset - {string} 要用来做数据集表面分析的数据源中数据集的名称。</br>
 *        filterQueryParameter - {{@link SuperMap.FilterParameter}} 获取或设置查询过滤条件参数。</br>
 *        zValueFieldName - {string} 获取或设置用于提取操作的字段名称。</br>
 *        extractParameter - {{@link SuperMap.SurfaceAnalystParametersSetting}} 表面分析参数设置类。获取或设置表面分析参数。</br>
 *        resolution - {integer} 获取或设置指定中间结果（栅格数据集）的分辨率。</br>
 *        resultSetting - {{@link SuperMap.DataReturnOption}} 结果返回设置类。</br>
 *        surfaceAnalystMethod - {{@link SuperMap.SurfaceAnalystMethod}} 获取或设置表面分析的提取方法，提取等值线和提取等值面。</br>
 * @extends SuperMap.SurfaceAnalystParameters
 */
var DatasetSurfaceAnalystParameters = exports.DatasetSurfaceAnalystParameters = function (_SurfaceAnalystParame) {
    _inherits(DatasetSurfaceAnalystParameters, _SurfaceAnalystParame);

    function DatasetSurfaceAnalystParameters(options) {
        _classCallCheck(this, DatasetSurfaceAnalystParameters);

        /**
         * @member SuperMap.DatasetSurfaceAnalystParameters.prototype.dataset -{string}
         * @description 要用来做数据集表面分析的数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：Country@World。必设字段。
         */
        var _this = _possibleConstructorReturn(this, (DatasetSurfaceAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetSurfaceAnalystParameters)).call(this, options));

        _this.dataset = null;

        /**
         *  @member SuperMap.DatasetSurfaceAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
         *  @description 获取或设置查询过滤条件参数。
         */
        _this.filterQueryParameter = new _FilterParameter.FilterParameter();

        /**
         * @member SuperMap.DatasetSurfaceAnalystParameters.prototype.zValueFieldName -{string}
         * @description 获取或设置用于提取操作的字段名称。
         * 提取等值线时，将使用该字段中的值，对点记录集中的点数据进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
         */
        _this.zValueFieldName = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.DatasetSurfaceAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.DatasetSurfaceAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(DatasetSurfaceAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetSurfaceAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetSurfaceAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.dataset = null;
            if (me.filterQueryParameter) {
                me.filterQueryParameter.destroy();
                me.filterQueryParameter = null;
            }
            me.zValueFieldName = null;
        }

        /**
         * @function SuperMap.DatasetSurfaceAnalystParameters.toObject
         * @param datasetSurfaceAnalystParameters -{SuperMap.DatasetSurfaceAnalystParameters} 数据集表面分析参数类。
         * @param tempObj - {SuperMap.DatasetSurfaceAnalystParameters} 数据集表面分析参数对象。
         * @description 将数据集表面分析参数对象转换为JSON对象。
         * @return JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetSurfaceAnalystParameters, tempObj) {
            for (var name in datasetSurfaceAnalystParameters) {
                if (name === "filterQueryParameter") {
                    tempObj.filterQueryParameter = datasetSurfaceAnalystParameters.filterQueryParameter;
                }
                if (name === "extractParameter") {
                    if (datasetSurfaceAnalystParameters.extractParameter.clipRegion instanceof _Geometry.Geometry && datasetSurfaceAnalystParameters.extractParameter.clipRegion.components) {
                        datasetSurfaceAnalystParameters.extractParameter.clipRegion = _ServerGeometry.ServerGeometry.fromGeometry(datasetSurfaceAnalystParameters.extractParameter.clipRegion);
                    }
                    tempObj.extractParameter = datasetSurfaceAnalystParameters.extractParameter;
                } else if (name === "dataset") {
                    continue;
                } else if (name === "surfaceAnalystMethod") {
                    continue;
                } else {
                    tempObj[name] = datasetSurfaceAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetSurfaceAnalystParameters;
}(_SurfaceAnalystParameters.SurfaceAnalystParameters);

_SuperMap.SuperMap.DatasetSurfaceAnalystParameters = DatasetSurfaceAnalystParameters;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DatasetThiessenAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ThiessenAnalystParameters = __webpack_require__(73);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DatasetThiessenAnalystParameters
 * @classdesc 数据集泰森多边形分析参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        filterQueryParameter - {@link SuperMap.FilterParameter} 对待分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
 * @extends SuperMap.ThiessenAnalystParameters
 */
var DatasetThiessenAnalystParameters = exports.DatasetThiessenAnalystParameters = function (_ThiessenAnalystParam) {
    _inherits(DatasetThiessenAnalystParameters, _ThiessenAnalystParam);

    function DatasetThiessenAnalystParameters(options) {
        _classCallCheck(this, DatasetThiessenAnalystParameters);

        /**
         * @member SuperMap.DatasetThiessenAnalystParameters.prototype.filterQueryParameter -{SuperMap.FilterParameter}
         * @description 过滤条件，对待分析数据集中的点进行过滤，不设置时默认为null，即对数据集中的所有点进行分析。
         * @example
         *  var filterQueryParameter = new SuperMap.FilterParameter({
         *   name: "Countries@World",
         *   attributeFilter: "SmID>100"
         *  });
         */
        var _this = _possibleConstructorReturn(this, (DatasetThiessenAnalystParameters.__proto__ || Object.getPrototypeOf(DatasetThiessenAnalystParameters)).call(this, options));

        _this.filterQueryParameter = null;

        /**
         * @member SuperMap.DatasetThiessenAnalystParameters.prototype.dataset -{string}
         * @description 数据集名称待分析的数据集名称，请使用"datasetName@datasourceName"格式来表示。
         */
        _this.dataset = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.DatasetThiessenAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.DatasetThiessenAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(DatasetThiessenAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(DatasetThiessenAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(DatasetThiessenAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.filterQueryParameter) {
                me.filterQueryParameter.destroy();
                me.filterQueryParameter = null;
            }
        }

        /**
         * @function SuperMap.DatasetThiessenAnalystParameters.toObject
         * @param datasetThiessenAnalystParameters -{SuperMap.DatasetThiessenAnalystParameters} 泰森多边形分析服务参数类。
         * @param tempObj - {SuperMap.DatasetThiessenAnalystParameters} 泰森多边形分析服务参数对象。
         * @description 将泰森多边形分析服务参数对象转换为JSON对象。
         * @return JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(datasetThiessenAnalystParameters, tempObj) {
            for (var name in datasetThiessenAnalystParameters) {
                if (name === "clipRegion") {
                    tempObj.clipRegion = _ServerGeometry.ServerGeometry.fromGeometry(datasetThiessenAnalystParameters.clipRegion);
                } else {
                    tempObj[name] = datasetThiessenAnalystParameters[name];
                }
            }
        }
    }]);

    return DatasetThiessenAnalystParameters;
}(_ThiessenAnalystParameters.ThiessenAnalystParameters);

_SuperMap.SuperMap.DatasetThiessenAnalystParameters = DatasetThiessenAnalystParameters;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DatasourceConnectionInfo = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// eslint-disable-line no-unused-vars

/**
 * @class SuperMap.DatasourceConnectionInfo
 * @classdesc 数据源连接信息类。该类包括了进行数据源连接的所有信息，如所要连接的服务器名称、数据库名称、用户名以及密码等。
 *             当保存为工作空间时， 工作空间中的数据源的连接信息都将存储到工作空间文件中。对于不同类型的数据源，其连接信息有所区别。
 *             所以在使 用该类所包含的成员时，请注意该成员所适用的数据源类型。对于从数据源对象中返回的数据连接信息对象，只有 connect 方法可以被修改，
 *             其他内容是不可以被修改的。对于用户创建的数据源连接信息对象，其内容都可以修改。
 * @param options - {Object} 参数。如:</br>
 *         alias - {string} 数据源别名。</br>
 *         connect - {boolean} 数据源是否自动连接数据。</br>
 *         dataBase - {string} 数据源连接的数据库名。</br>
 *         driver - {string} 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。</br>
 *         engineType - {EngineType} 数据源连接的引擎类型。</br>
 *         exclusive - {boolean} 是否以独占方式打开数据源。</br>
 *         OpenLinkTable - {boolean} 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable 打开。</br>
 *         password - {string} 登录数据源连接的数据库或文件的密码。</br>
 *         readOnly - {boolean} 是否以只读方式打开数据源。</br>
 *         server - {string} 数据库服务器名或 SDB 文件名。</br>
 *         user - {string} 登录数据库的用户名。</br>
 */
var DatasourceConnectionInfo = exports.DatasourceConnectionInfo = function () {
  function DatasourceConnectionInfo(options) {
    _classCallCheck(this, DatasourceConnectionInfo);

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.alias -{string}
     * @description 数据源别名。
     */
    this.alias = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.connect -{boolean}
     * @description 数据源是否自动连接数据。
     */
    this.connect = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.dataBase -{string}
     * @description 数据源连接的数据库名。
     */
    this.dataBase = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.driver -{string}
     * @description 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。
     * 其中，对于SQL Server 数据库与 iServer 发布的 WMTS 服务，此为必设参数。
     * 对于SQL Server 数据库，它使用 ODBC 连接，所设置的驱动程序名为 "SQL Server" 或 "SQL Native Client"；
     * 对于 iServer 发布的 WMTS 服务，设置的驱动名称为 "WMTS"。
     */
    this.driver = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.engineType -{EngineType}
     * @description 数据源连接的引擎类型。
     */
    this.engineType = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.exclusive -{boolean}
     * @description 是否以独占方式打开数据源。
     */
    this.exclusive = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.OpenLinkTable -{boolean}
     * @description 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable打开。
     */
    this.OpenLinkTable = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.password -{string}
     * @description 登录数据源连接的数据库或文件的密码。
     */
    this.password = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.readOnly -{boolean}
     * @description 是否以只读方式打开数据源。
     */
    this.readOnly = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.server -{string}
     * @description 数据库服务器名、文件名或服务地址。
     * 1.对于SDB和UDB文件，为其文件的绝对路径。注意：当绝对路径的长度超过UTF-8编码格式的260字节长度，该数据源无法打开。
     * 2.对于Oracle数据库，其服务器名为其TNS服务名称。
     * 3.对于SQL Server数据库，其服务器名为其系统的DSN(Database Source Name)名称。
     * 4.对于PostgreSQL数据库，其服务器名为“IP:端口号”，默认的端口号是 5432。
     * 5.对于DB2数据库，已经进行了编目，所以不需要进行服务器的设置。
     * 6.对于 Kingbase 数据库，其服务器名为其 IP 地址。
     * 7.对于GoogleMaps数据源，其服务器地址，默认设置为“http://maps.google.com”，且不可更改。
     * 8.对于SuperMapCould数据源，为其服务地址。
     * 9.对于MAPWORLD数据源，为其服务地址，默认设置为“http://www.tianditu.cn”，且不可更改。
     * 10.对于OGC和REST数据源，为其服务地址。
     */
    this.server = null;

    /**
     * @member SuperMap.DatasourceConnectionInfo.prototype.user -{string}
     * @description 登录数据库的用户名。
     */
    this.user = null;

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.DatasourceConnectionInfo";
  }

  /**
   * @function SuperMap.DatasourceConnectionInfo.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(DatasourceConnectionInfo, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.alias = null;
      me.connect = null;
      me.dataBase = null;
      me.driver = null;
      me.engineType = null;
      me.exclusive = null;
      me.OpenLinkTable = null;
      me.password = null;
      me.readOnly = null;
      me.server = null;
      me.user = null;
    }
  }]);

  return DatasourceConnectionInfo;
}();

_SuperMap.SuperMap.DatasourceConnectionInfo = DatasourceConnectionInfo;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DensityKernelAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.DensityKernelAnalystParameters
 * @classdesc 核密度分析参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        dataset - {string} 要用来做核密度分析数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。必设字段。</br>
 *        bounds - {Object} 核密度分析的范围，用于确定结果栅格数据集的范围。如果缺省，则默认为原数据集的范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchRadius - {number} 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。</br>
 *        fieldName - {string} 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段，必设字段。</br>
 *        resultGridDatasetResolution - {number} 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。</br>
 *        targetDatasource - {string} 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。</br>
 *        resultGridName - {string} 指定结果数据集名称，必设字段。</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。</br>
 */
var DensityKernelAnalystParameters = exports.DensityKernelAnalystParameters = function () {
  function DensityKernelAnalystParameters(options) {
    _classCallCheck(this, DensityKernelAnalystParameters);

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.dataset -{string}
     * @description 要用来做核密度分析数据源中数据集的名称。
     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：Railway@Changchun。必设字段。
     * 注：核密度分析支持点数据集和线数据集。
     */
    this.dataset = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.bounds
     * @description 核密度分析的范围，用于确定结果栅格数据集的范围。</br>
     * Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
     * 如果缺省，则默认为原数据集的范围。
     */
    this.bounds = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.fieldName -{string}
     * @description 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段，必设字段。
     */
    this.fieldName = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.resultGridDatasetResolution -{number}
     * @description 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。
     */
    this.resultGridDatasetResolution = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.searchRadius -{number}
     * @description 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。
     */
    this.searchRadius = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.targetDatasource -{string}
     * @description 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。
     */
    this.targetDatasource = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.resultGridName -{string}
     * @description 指定结果数据集名称，必设字段。
     */
    this.resultGridName = null;

    /**
     * @member SuperMap.DensityKernelAnalystParameters.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */
    this.deleteExistResultDataset = false;
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.DensityKernelAnalystParameters";
  }

  /**
   * @function SuperMap.DensityKernelAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(DensityKernelAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.dataset = null;
      me.bounds = null;
      me.fieldName = null;
      me.resultGridDatasetResolution = null;
      me.searchRadius = null;

      me.targetDatasource = null;
      me.resultGridName = null;
      me.deleteExistResultDataset = null;
    }

    /**
     * @function SuperMap.DensityKernelAnalystParameters.toObject
     * @param densityKernelAnalystParameters -{SuperMap.DensityKernelAnalystParameters} 核密度分析参数类。
     * @param tempObj - {SuperMap.DensityKernelAnalystParameters} 核密度分析参数对象。
     * @description 将核密度分析参数对象转换成JSON对象。
     * @return JSON对象。
     */

  }], [{
    key: 'toObject',
    value: function toObject(densityKernelAnalystParameters, tempObj) {
      for (var name in densityKernelAnalystParameters) {
        if (name !== "dataset") {
          tempObj[name] = densityKernelAnalystParameters[name];
        }
      }
    }
  }]);

  return DensityKernelAnalystParameters;
}();

_SuperMap.SuperMap.DensityKernelAnalystParameters = DensityKernelAnalystParameters;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditFeaturesParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.EditFeaturesParameters
 * @classdesc 数据服务中数据集添加、修改、删除参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        features - {Array<Object>} 当前需要创建或者是修改的要素集。feature类型可以是：SuperMap.Feature.Vector|GeoJSON|ol.feature。</br>
 *        returnContent - {boolean} 是返回创建要素的ID数组还是返回featureResult资源的URI。</br>
 *        editType - {SuperMap.EditType} POST动作类型(ADD、UPDATE、DELETE)，默认为 SuperMap.EditType.ADD。</br>
 *        IDs - {Array<string|integer>} 删除要素时的要素的ID数组。</br>
 */
var EditFeaturesParameters = exports.EditFeaturesParameters = function () {
    function EditFeaturesParameters(options) {
        _classCallCheck(this, EditFeaturesParameters);

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.dataSourceName -{string}
         * @description 当前需要创建或者是修改的要素的数据源
         */
        this.dataSourceName = null;

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.dataSetName -{string}
         * @description 当前需要创建或者是修改的要素的数据集。
         */
        this.dataSetName = null;

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.features -{Array<Object>}
         * @description 当前需要创建或者是修改的要素集。</br>
         * feature类型可以是：SuperMap.Feature.Vector|GeoJSON|ol.feature。
         */
        this.features = null;

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.dataSetName -{EditType}
         * @description 要素集更新类型(add、update、delete)，默认为 SuperMap.EditType.ADD.
         */
        this.editType = _REST.EditType.ADD;

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.dataSetName -{Array<string>}|{Array<Integer>}
         * @description 执行删除时要素集ID集合。
         */
        this.IDs = null;

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.returnContent -{boolean}
         * @description 要素添加时，isUseBatch 不传或传为 false 的情况下有效。
         *true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。默认不传时为 false。
         */
        this.returnContent = false;

        /**
         * @member SuperMap.EditFeaturesParameters.prototype.isUseBatch -{boolean}
         * @description 是否使用批量添加要素功能，要素添加时有效。批量添加能够提高要素编辑效率。true 表示批量添加；false 表示不使用批量添加。默认不传时为 false。
         */
        this.isUseBatch = false;
        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.EditFeaturesParameters";
    }

    /**
     * @function SuperMap.EditFeaturesParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(EditFeaturesParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.dataSourceName = null;
            me.dataSetName = null;
            me.features = null;
            me.editType = null;
            me.IDs = null;
            me.returnContent = null;
        }

        /**
         * @function SuperMap.EditFeaturesParameters.prototype.toJsonParameters
         * @description 将 <EditFeaturesParameters> 对象参数转换为 JSON 字符串。
         * @param params - {SuperMap.EditFeaturesParameters} 地物编辑参数。
         * @return {string} JSON字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var feature,
                len,
                features,
                editType = params.editType;

            if (editType === _REST.EditType.DELETE) {
                if (params.IDs === null) {
                    return;
                }

                features = { ids: params.IDs };
            } else {
                features = [];
                if (params.features) {
                    len = params.features.length;
                    for (var i = 0; i < len; i++) {
                        feature = params.features[i];
                        feature.geometry = _ServerGeometry.ServerGeometry.fromGeometry(feature.geometry);
                        features.push(feature);
                    }
                }
            }

            return _Util.Util.toJSON(features);
        }
    }]);

    return EditFeaturesParameters;
}();

_SuperMap.SuperMap.EditFeaturesParameters = EditFeaturesParameters;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystSinks3DParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _FacilityAnalyst3DParameters = __webpack_require__(39);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSinks3DParameters
 * @classdesc 最近设施分析参数类(汇查找资源)。最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *              设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟
 *              能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、
 *              转向表、耗费等属性在最近设施分析时同样可设置。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如:<br>
 *         edgeID - {number} 指定的弧段ID。<br>
 *         nodeID - {integer} 指定的结点ID。<br>
 *         weightName - {string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                               指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 */
var FacilityAnalystSinks3DParameters = exports.FacilityAnalystSinks3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystSinks3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystSinks3DParameters(options) {
        _classCallCheck(this, FacilityAnalystSinks3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSinks3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystSinks3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSinks3DParameters";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystSinks3DParameters.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystSinks3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystSinks3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystSinks3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystSinks3DParameters;
}(_FacilityAnalyst3DParameters.FacilityAnalyst3DParameters);

_SuperMap.SuperMap.FacilityAnalystSinks3DParameters = FacilityAnalystSinks3DParameters;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystSources3DParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _FacilityAnalyst3DParameters = __webpack_require__(39);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSources3DParameters
 * @classdesc 最近设施分析参数类(源查找资源)。最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *               设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分
 *               钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍
 *               点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如:<br>
 *         edgeID - {number} 指定的弧段ID。<br>
 *         nodeID - {integer} 指定的结点ID。<br>
 *         weightName - {string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                               指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 */
var FacilityAnalystSources3DParameters = exports.FacilityAnalystSources3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystSources3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystSources3DParameters(options) {
        _classCallCheck(this, FacilityAnalystSources3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSources3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSources3DParameters";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystSources3DParameters.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystSources3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystSources3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystSources3DParameters;
}(_FacilityAnalyst3DParameters.FacilityAnalyst3DParameters);

_SuperMap.SuperMap.FacilityAnalystSources3DParameters = FacilityAnalystSources3DParameters;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FacilityAnalystStreamParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FacilityAnalystStreamParameters
 * @classdesc 上游/下游关键设施查找资源参数类。
 * @param options - {Object} 可选参数。如:<br>
 *         sourceNodeIDs - {Array<number>} 指定的设施点ID数组，可以为空。<br>
 *         edgeID - {number} 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。<br>
 *         nodeID - {number} 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效；默认false，无效。<br>
 *         queryType - {number} 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）。
 */
var FacilityAnalystStreamParameters = exports.FacilityAnalystStreamParameters = function () {
  function FacilityAnalystStreamParameters(options) {
    _classCallCheck(this, FacilityAnalystStreamParameters);

    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.sourceNodeIDs - {Array<number>}
     * @description 指定的设施点ID数组,可以为空。
     */
    this.sourceNodeIDs = null;

    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.edgeID - {number}
     * @description 指定的弧段ID（注：edgeID 与 nodeID 不能同时使用）。
     */
    this.edgeID = null;

    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.nodeID - {number}
     * @description 指定的结点ID （注：edgeID 与 nodeID 不能同时使用）。
     */
    this.nodeID = null;

    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.isUncertainDirectionValid - {boolean}
     * @description 指定不确定流向是否有效，默认为false。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
     *                指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
     */
    this.isUncertainDirectionValid = false;

    /**
     * @member SuperMap.FacilityAnalystStreamParameters.prototype.queryType - {number}
     * @description 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）。
     */
    this.queryType = null;
    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.FacilityAnalystStreamParameters";
  }

  /**
   * @function SuperMap.FacilityAnalystStreamParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FacilityAnalystStreamParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.edgeID = null;
      me.nodeID = null;
      me.weightName = null;
      me.isUncertainDirectionValid = null;
      me.type = null;
    }
  }]);

  return FacilityAnalystStreamParameters;
}();

_SuperMap.SuperMap.FacilityAnalystStreamParameters = FacilityAnalystStreamParameters;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystTracedown3DParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _FacilityAnalyst3DParameters = __webpack_require__(39);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTracedown3DParameters
 * @classdesc 下游追踪资源参数类。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如:<br>
 *         edgeID - {number} 指定的弧段ID。<br>
 *         nodeID - {integer} 指定的结点ID。<br>
 *         weightName - {string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。

 */
var FacilityAnalystTracedown3DParameters = exports.FacilityAnalystTracedown3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystTracedown3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystTracedown3DParameters(options) {
        _classCallCheck(this, FacilityAnalystTracedown3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTracedown3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTracedown3DParameters";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystTracedown3DParameters.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystTracedown3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTracedown3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystTracedown3DParameters;
}(_FacilityAnalyst3DParameters.FacilityAnalyst3DParameters);

_SuperMap.SuperMap.FacilityAnalystTracedown3DParameters = FacilityAnalystTracedown3DParameters;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystTraceup3DParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _FacilityAnalyst3DParameters = __webpack_require__(39);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTraceup3DParameters
 * @classdesc 上游追踪资源参数类。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如:<br>
 *         edgeID - {number} 指定的弧段ID。<br>
 *         nodeID - {integer} 指定的结点ID。<br>
 *         weightName - {string} 指定的权值字段信息对象的名称。<br>
 *         isUncertainDirectionValid - {boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                               指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 */
var FacilityAnalystTraceup3DParameters = exports.FacilityAnalystTraceup3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystTraceup3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystTraceup3DParameters(options) {
        _classCallCheck(this, FacilityAnalystTraceup3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTraceup3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DParameters)).call(this, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTraceup3DParameters";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystTraceup3DParameters.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystTraceup3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTraceup3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return FacilityAnalystTraceup3DParameters;
}(_FacilityAnalyst3DParameters.FacilityAnalyst3DParameters);

_SuperMap.SuperMap.FacilityAnalystTraceup3DParameters = FacilityAnalystTraceup3DParameters;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystUpstream3DParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _FacilityAnalyst3DParameters = __webpack_require__(39);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystUpstream3DParameters
 * @classdesc 上游关键设施查找资源参数类。
 * @extends SuperMap.FacilityAnalyst3DParameters
 * @param options - {Object} 可选参数。如:<br>
 *        edgeID - {number} 指定的弧段ID。<br>
 *        nodeID - {integer} 指定的结点ID。<br>
 *        weightName - {string} 指定的权值字段信息对象的名称。<br>
 *        isUncertainDirectionValid - {boolean} 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。<br>
 *        sourceNodeIDs - {Array<number>} 指定的设施点ID数组。
 */
var FacilityAnalystUpstream3DParameters = exports.FacilityAnalystUpstream3DParameters = function (_FacilityAnalyst3DPar) {
    _inherits(FacilityAnalystUpstream3DParameters, _FacilityAnalyst3DPar);

    function FacilityAnalystUpstream3DParameters(options) {
        _classCallCheck(this, FacilityAnalystUpstream3DParameters);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystUpstream3DParameters.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DParameters)).call(this, options));

        options = options || {};
        /**
         * @member SuperMap.FacilityAnalystUpstream3DParameters.prototype.sourceNodeIDs - {Array<number>}
         * @description 指定的设施点ID数组。
         */
        _this.sourceNodeIDs = null;
        _Util.Util.extend(_this, options);
        _this.CLASS_NAME = "SuperMap.FacilityAnalystUpstream3DParameters";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystUpstream3DParameters.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystUpstream3DParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystUpstream3DParameters.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DParameters.prototype), 'destroy', this).call(this);
            this.sourceNodeIDs = null;
        }
    }]);

    return FacilityAnalystUpstream3DParameters;
}(_FacilityAnalyst3DParameters.FacilityAnalyst3DParameters);

_SuperMap.SuperMap.FacilityAnalystUpstream3DParameters = FacilityAnalystUpstream3DParameters;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FieldParameters
 * @classdesc 字段信息查询参数类。
 * @param options - {Object} 可选参数。如:<br>
 *         datasource - {string} 数据源名称。<br>
 *         dataset - {string} 数据集名称。
 */
var FieldParameters = exports.FieldParameters = function () {
    function FieldParameters(options) {
        _classCallCheck(this, FieldParameters);

        /**
         * @member SuperMap.FieldParameters.prototype.datasource - {string}
         * @description 要查询的数据集所在的数据源名称。
         */
        this.datasource = null;

        /**
         *  @member SuperMap.FieldParameters.prototype.dataset - {string}
         *  @description 要查询的数据集名称。
         */
        this.dataset = null;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.FieldParameters";
    }

    /**
     * @function SuperMap.FieldParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(FieldParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.datasource = null;
            me.dataset = null;
        }
    }]);

    return FieldParameters;
}();

_SuperMap.SuperMap.FieldParameters = FieldParameters;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldStatisticsParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _FieldParameters2 = __webpack_require__(174);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FieldStatisticsParameters
 * @classdesc 字段统计信息查询参数类。
 * @param options - {Object} 可选参数。如:<br>
 *         datasource - {string} 数据源名称。<br>
 *        dataset - {string} 数据集名称。<br>
 *        fieldName - {string} 字段名。<br>
 *        statisticMode - {String<SuperMap.StatisticMode>}|{Array<String<SuperMap.StatisticMode>>} 字段统计方法类型。
 * @extends SuperMap.FieldParameters
 */
var FieldStatisticsParameters = exports.FieldStatisticsParameters = function (_FieldParameters) {
    _inherits(FieldStatisticsParameters, _FieldParameters);

    function FieldStatisticsParameters(options) {
        _classCallCheck(this, FieldStatisticsParameters);

        /**
         * @member SuperMap.FieldStatisticsParameters.prototype.fieldName - {string}
         * @description 字段名
         */
        var _this = _possibleConstructorReturn(this, (FieldStatisticsParameters.__proto__ || Object.getPrototypeOf(FieldStatisticsParameters)).call(this, options));

        _this.fieldName = null;

        /**
         * @member SuperMap.FieldStatisticsParameters.prototype.statisticMode -{string<SuperMap.StatisticMode>}|{Array<string{SuperMap.StatisticMode}>}
         * @description 字段统计方法类型
         */
        _this.statisticMode = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.FieldStatisticsParameters";
        return _this;
    }

    /**
     * @function SuperMap.FieldStatisticsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(FieldStatisticsParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.fieldName = null;
            me.statisticMode = null;
        }
    }]);

    return FieldStatisticsParameters;
}(_FieldParameters2.FieldParameters);

_SuperMap.SuperMap.FieldStatisticsParameters = FieldStatisticsParameters;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindClosestFacilitiesParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystParameter = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindClosestFacilitiesParameters
 * @classdesc 最近设施分析参数类。
 * @param options - {Object} 可选参数。如:</br>
 *         event - {Object/integer} 事件点，一般为需要获得服务设施服务的事件位置，必设字段。
 *                  点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *         expectFacilityCount - {integer} 要查找的设施点数量。默认值为1。</br>
 *         facilities - {Array<Object>|Array<number>} 设施点集合，一般为提供服务的服务设施位置，必设字段。
 *                       点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *         fromEvent - {boolean} 是否从事件点到设施点进行查找。</br>
 *         isAnalyzeById - {boolean} 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。</br>
 *         maxWeight - {number} 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。</br>
 *         parameter - {@link SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindClosestFacilitiesParameters = exports.FindClosestFacilitiesParameters = function () {
  function FindClosestFacilitiesParameters(options) {
    _classCallCheck(this, FindClosestFacilitiesParameters);

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.event - {Object}
     * @description 事件点，一般为需要获得服务设施服务的事件位置，必设字段。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *              可以通过两种方式赋予事件点：当该类中字段 isAnalyzeById = true 时，应输入事件点 ID 号；当 isAnalyzeById = false 时，应输入事件点坐标。
     */
    this.event = null;

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.expectFacilityCount - {number}
     * @description 要查找的设施点数量。默认值为1。
     */
    this.expectFacilityCount = 1;

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.facilities - {Array<Object>|Array<number>}
     * @description 设施点集合，一般为提供服务的服务设施位置，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *              可以通过两种方式赋予设施点：当该类中字段 isAnalyzeById = true 时，应输入设施点 ID 号；当 isAnalyzeById = false 时，应输入设施点坐标。
     */
    this.facilities = null;

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.fromEvent - {boolean}
     * @description 是否从事件点到设施点进行查找。最近设施分析主要是通过设施点和事件点之间最优的路线来分析在一定范围内哪个或哪些设施与事件点有最优路线的关系。
     *              这个行走线路是通过网络图层进行网络分析算法计算出来的两点间的最优路线。由于存在从 A 点到 B 点与从 B 点到 A 点的耗费不一样的情况，因此起止点
     *              不同可能会得到不同的最优路线。因此在进行最近设施分析之前，需要设置获取的最优路线的方向，即是以事件点作为起点到最近设施点的方向分析，还是以最
     *              近设施点为起点到事件点的方向分析。如果需要以事件点作为起点到设施点方向进行查找，设置该字段值为 true；默认为 false，表示从设施点到事件点进行查找。
     */
    this.fromEvent = false;

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.isAnalyzeById - {boolean}
     * @description 事件点和设施点是否通过节点 ID 号来指定，默认为 false，即通过坐标点指定事件点和设施点。
     */
    this.isAnalyzeById = false;

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.maxWeight - {number}
     * @description 查找半径。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。默认值为0，表示查找全网络。
     *               例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。
     *               那么需要将网络分析参数中 parameter.weightFieldName 设置为表示时间的字段，然后设置查找范围的半径值为10。
     */
    this.maxWeight = 0;

    /**
     * @member SuperMap.FindClosestFacilitiesParameters.prototype.parameter {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
     *              它为 SuperMap.TransportationAnalystParameter 类型，虽然为可选参数，但是如果不设置其中的 resultSetting 字段，
     *              则返回结果空间信息等都为空。
     */
    this.parameter = new _TransportationAnalystParameter.TransportationAnalystParameter();
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.FindClosestFacilitiesParameters";
  }

  /**
   * @function SuperMap.FindClosestFacilitiesParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FindClosestFacilitiesParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.event = null;
      me.expectFacilityCount = null;
      me.facilities = null;
      me.fromEvent = null;
      me.isAnalyzeById = null;
      me.maxWeight = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return FindClosestFacilitiesParameters;
}();

_SuperMap.SuperMap.FindClosestFacilitiesParameters = FindClosestFacilitiesParameters;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindLocationParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindLocationParameters
 * @classdesc 选址分区分析参数类。
 * @param options - {Object} 可选参数。如:<br>
 *        expectedSupplyCenterCount - {integer} 期望用于最终设施选址的资源供给中心数量，必设字段。<br>
 *        isFromCenter - {boolean} 是否从中心点开始分配资源。默认为 false。<br>
 *        supplyCenters - {Array<{@link SuperMap.SupplyCenter}>} 资源供给中心集合，必设字段。<br>
 *        turnWeightField - {string} 转向权值字段的名称。<br>
 *        weightName - {string} 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，必设字段。
 */
var FindLocationParameters = exports.FindLocationParameters = function () {
  function FindLocationParameters(options) {
    _classCallCheck(this, FindLocationParameters);

    /**
     * @member SuperMap.FindLocationParameters.prototype.expectedSupplyCenterCount - {number}
     * @description 期望用于最终设施选址的资源供给中心数量，必设字段。<br>
     *              当输入值为0时，最终设施选址的资源供给中心数量默认为覆盖分析区域内的所需最少的供给中心数。
     */
    this.expectedSupplyCenterCount = null;

    /**
     * @member SuperMap.FindLocationParameters.prototype.isFromCenter - {boolean}
     * @description 是否从中心点开始分配资源。默认为 false。
     *              由于网路数据中的弧段具有正反阻力，即弧段的正向阻力值与其反向阻力值可能不同，
     *              因此，在进行分析时，从资源供给中心开始分配资源到需求点与从需求点向资源供给中心分配这两种分配形式下，所得的分析结果会不同。
     */
    this.isFromCenter = false;

    /**
     * @member SuperMap.FindLocationParameters.prototype.supplyCenters - {Array<SuperMap.SupplyCenter>}
     * @description 资源供给中心集合，必设字段。
     *              资源供给中心是提供资源和服务的设施，对应于网络结点，
     *              资源供给中心的相关信息包括资源量、最大阻力值、资源供给中心类型，资源供给中心在网络中所处结点的 ID 等，以便在进行选址分区分析时使用。
     */
    this.supplyCenters = null;

    /**
     * @member SuperMap.FindLocationParameters.prototype.turnWeightField - {string}
     * @description 转向权值字段的名称。
     */
    this.turnWeightField = null;

    /**
     * @member SuperMap.FindLocationParameters.prototype.weightName - {string}
     * @description 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，必设字段。
     */
    this.weightName = null;
    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.FindLocationParameters";
  }

  /**
   * @function SuperMap.FindLocationParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FindLocationParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.expectedSupplyCenterCount = null;
      me.isFromCenter = null;
      me.turnWeightField = null;
      me.weightName = null;
      if (me.supplyCenters) {
        for (var i = 0, supplyCenters = me.supplyCenters, len = supplyCenters.length; i < len; i++) {
          supplyCenters[i].destroy();
        }
        me.supplyCenters = null;
      }
    }
  }]);

  return FindLocationParameters;
}();

_SuperMap.SuperMap.FindLocationParameters = FindLocationParameters;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindMTSPPathsParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystParameter = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindMTSPPathsParameters
 * @classdesc 多旅行商分析参数类
 * @param options - {Object} 可选参数。如:<br>
 *        centers - {Array<Object>|Array<number>} 配送中心集合，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        hasLeastTotalCost - {boolean} 配送模式是否为总花费最小方案。默认为 false。<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。<br>
 *        nodes - {Array<{SuperMap.Point}|number>} 配送目标集合，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        parameter - {@link SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindMTSPPathsParameters = exports.FindMTSPPathsParameters = function () {
  function FindMTSPPathsParameters(options) {
    _classCallCheck(this, FindMTSPPathsParameters);

    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.centers - {Array<Object>|Array<number>}
     * @description 配送中心集合，必设字段。
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = false 时，centers 应为点的坐标数组；
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = true 时，centers 应为点的 ID 数组。
     */
    this.centers = null;

    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.hasLeastTotalCost - {boolean}
     * @description 配送模式是否为总花费最小方案。默认为 false。
     *              若为 true，则按照总花费最小的模式进行配送，此时可能会出现某几个配送中心点配送的花费较多而其他配送中心点的花费很少的情况。
     *              若为 false，则为局部最优，此方案会控制每个配送中心点的花费，使各个中心点花费相对平均，此时总花费不一定最小。
     */
    this.hasLeastTotalCost = false;

    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.isAnalyzeById - {boolean}
     * @description 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。
     */
    this.isAnalyzeById = false;

    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.nodes - {Array<Object>|Array<number>}
     * @description 配送目标集合，必设字段。
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
     *              当 SuperMap.FindMTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */
    this.nodes = null;

    /**
     * @member SuperMap.FindMTSPPathsParameters.prototype.parameter - {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。
     *              通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
     *              SuperMap.TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting 字段，则返回结果空间信息等都为空。
     */
    this.parameter = new _TransportationAnalystParameter.TransportationAnalystParameter();
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.FindMTSPPathsParameters";
  }

  /**
   * @function SuperMap.FindMTSPPathsParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FindMTSPPathsParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.centers = null;
      me.hasLeastTotalCost = null;
      me.isAnalyzeById = null;
      me.nodes = null;
      me.maxWeight = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return FindMTSPPathsParameters;
}();

_SuperMap.SuperMap.FindMTSPPathsParameters = FindMTSPPathsParameters;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindPathParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystParameter = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindPathParameters
 * @classdesc 最佳路径分析参数类。最佳路径是在网络数据集中指定一些结点，按照顺序访问结点从而求解起止点之间阻抗最小的路径。
 *              例如如果要顺序访问1、2、3、4四个结点，则需要分别找到1、2结点间的最佳路径 R1—2，2、3间的最佳路径 R2—3和3、4结点间的最佳路径 R3—4，
 *              顺序访问1、2、3、4四个结点的最佳路径就是 R= R1—2 + R2—3 + R3—4。
 *              阻抗就是指从一点到另一点的耗费，在实际应用中我们可以将距离、时间、花费等作为阻抗条件。
 *              阻抗最小也就可以理解为从一点到另一点距离最短、时间最少、花费最低等。当两点间距离最短时为最短路径，它是最佳路径问题的一个特例。
 *              阻抗值通过 SuperMap.TransportationAnalystParameter.weightFieldName 设置。
 *              计算最佳路径除了受阻抗影响外，还受转向字段的影响。转向值通过 SuperMap.TransportationAnalystParameter.turnWeightField 设置。
 *
 * @param options - {Object} 可选参数。如:<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 指定路径分析的结点。<br>
 *        hasLeastEdgeCount - {boolean} 是否按照弧段数最少的进行最佳路径分析。<br>
 *        nodes - {Array<Object>|Array<number>} 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。<br>
 *                        点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        parameter - {@link SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindPathParameters = exports.FindPathParameters = function () {
  function FindPathParameters(options) {
    _classCallCheck(this, FindPathParameters);

    /**
     * @member SuperMap.FindPathParameters.prototype.isAnalyzeById - {boolean}
     * @description 是否通过节点 ID 指定路径分析的结点，默认为 false。
     *              指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。
     *              当该字段为 true 时，表示通过结点 ID 指定途经点，即 SuperMap.FindPathParameters.nodes = [ID1,ID2,...]；
     *              反之表示通过结点坐标指定途经点，即 SuperMap.FindPathParameters.nodes = [{x1,y1},{x2,y2},...] 。
     */
    this.isAnalyzeById = false;

    /**
     * @member SuperMap.FindPathParameters.prototype.hasLeastEdgeCount - {boolean}
     * @description 是否按照弧段数最少的进行最佳路径分析。
     *               true 表示按照弧段数最少进行分析，返回弧段数最少的路径中一个阻抗最小的最佳路径；
     *               false表示直接返回阻抗最小的路径，而不考虑弧段的多少。
     */
    this.hasLeastEdgeCount = null;

    /**
     * @member SuperMap.FindPathParameters.prototype.nodes -{Array<Object>|Array<number>}
     * @description 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *              当 SuperMap.FindPathParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
     *              当 SuperMap.FindPathParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */
    this.nodes = null;

    /**
     * @member SuperMap.FindPathParameters.prototype.parameter - {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。
     */
    this.parameter = new _TransportationAnalystParameter.TransportationAnalystParameter();
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.FindPathParameters";
  }

  /**
   * @function SuperMap.FindPathParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FindPathParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isAnalyzeById = null;
      me.hasLeastEdgeCount = null;
      me.nodes = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return FindPathParameters;
}();

_SuperMap.SuperMap.FindPathParameters = FindPathParameters;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindServiceAreasParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystParameter = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindServiceAreasParameters
 * @classdesc 服务区分析参数类.<br>
 *              服务区分析是以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。<br>
 *              例如：计算某快餐店能够在30分钟内送达快餐的区域。<br>
 * @param options - {Object} 可选参数。如:<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 指定路径分析的结点。<br>
 *        isCenterMutuallyExclusive - {boolean} 是否中心点互斥。<br>
 *        centers - {Array<Object>|Array<number>} 服务站点数组，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        isFromCenter - {boolean} 是否从中心点开始分析。<br>
 *        weights - {Array<number>} 每个服务站点提供服务的阻力半径，超过这个阻力半径的区域不予考虑，其单位与阻力字段一致，必设字段。<br>
 *        parameter - {@link SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。
 */
var FindServiceAreasParameters = exports.FindServiceAreasParameters = function () {
  function FindServiceAreasParameters(options) {
    _classCallCheck(this, FindServiceAreasParameters);

    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.isAnalyzeById - {boolean}
     * @description 是否通过节点 ID 指定路径分析的结点，默认为 false。<br>
     *               指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。<br>
     *               当该字段为 true 时，表示通过结点 ID 指定途经点，即 SuperMap.FindServiceAreasParameters.centers = [ID1,ID2,...]；<br>
     *               反之表示通过结点坐标指定途经点，即 SuperMap.FindServiceAreasParameters.centers = [{x1,y1},{x2,y2},...]。
     */
    this.isAnalyzeById = false;

    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.isCenterMutuallyExclusive - {boolean}
     * @description 是否中心点互斥，即按照中心点的距离进行判断是否要进行互斥处理，默认为 false。<br>
     *               若分析出的服务区有重叠的部分，则通过设置该参数进行互斥处理。
     */
    this.isCenterMutuallyExclusive = false;

    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.centers - {Array<Object>|Array<number>}
     * @description 服务站点数组，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *                当该类的 iSAnalyzeById = true 时，通过结点 ID 号指定服务站点；当 iSAnalyzeById = false 时，通过点坐标指定服务站点。
     */
    this.centers = null;

    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.isFromCenter - {boolean}
     * @description 是否从中心点开始分析。默认为 false。<br>
     *               从中心点开始分析和不从中心点开始分析，体现了服务中心和需要该服务的需求地的关系模式。<br>
     *               从中心点开始分析，是一个服务中心向服务需求地提供服务；<br>
     *               而不从中心点开始分析，是一个服务需求地主动到服务中心获得服务。
     */
    this.isFromCenter = false;

    /**
     * APIProperty: weights
     * @member SuperMap.FindServiceAreasParameters.prototype.weights - {Array<number>}
     * @description 每个服务站点提供服务的阻力半径，即超过这个阻力半径的区域不予考虑，其单位与阻力字段一致，必设字段。
     *               该字段为一个数组，数组长度跟服务中心个数一致，按照索引顺序与站点一一对应，每个元素表示了在对每个服务中心进行服务区分析时，所用的服务半径。
     */
    this.weights = null;

    /**
     * @member SuperMap.FindServiceAreasParameters.prototype.parameter - {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。
     */
    this.parameter = new _TransportationAnalystParameter.TransportationAnalystParameter();

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.FindServiceAreasParameters";
  }

  /**
   * @function SuperMap.FindServiceAreasParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FindServiceAreasParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isAnalyzeById = null;
      me.isCenterMutuallyExclusive = null;
      me.centers = null;
      me.isFromCenter = null;
      me.weights = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return FindServiceAreasParameters;
}();

_SuperMap.SuperMap.FindServiceAreasParameters = FindServiceAreasParameters;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FindTSPPathsParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _TransportationAnalystParameter = __webpack_require__(34);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.FindTSPPathsParameters
 * @classdesc 旅行商分析参数类
 *              旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
 *              旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
 *              旅行商分析和最佳路径分析都是在网络中寻找遍历所有站点的最经济的路径，区别是在遍历网络所有站点的过程中对结点访问顺序不同
 *              最佳路径分析必须按照指定顺序对站点进行访问，而旅行商分析是无序的路径分析。
 * @param options - {Object} 可选参数。如:<br>
 *        endNodeAssigned - {boolean} 是否指定终止点，将指定的途经点的最后一个点作为终止点。true 表示指定终止点，则旅行商必须最后一个访问终止点。默认为 false。<br>
 *        isAnalyzeById - {boolean} 是否通过节点 ID 号来指定配送中心点和配送目的点，默认为 false，即通过坐标点指定。<br>
 *        nodes - {Array<Object>|Array<number>} 配送目标集合，必设字段。点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。<br>
 *        parameter - {@link SuperMap.TransportationAnalystParameter} 交通网络分析通用参数。<br>
 */
var FindTSPPathsParameters = exports.FindTSPPathsParameters = function () {
  function FindTSPPathsParameters(options) {
    _classCallCheck(this, FindTSPPathsParameters);

    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.endNodeAssigned - {boolean}
     * @description 是否指定终止点，将指定的途经点的最后一个点作为终止点。
     *               true 表示指定终止点，则旅行商必须最后一个访问终止点。默认为 false。
     */
    this.endNodeAssigned = false;

    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.isAnalyzeById - {boolean}
     * @description 是否通过节点 ID 号来指定途经点，默认为 false，即通过坐标点指定。
     */
    this.isAnalyzeById = false;

    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.nodes - {Array<Object>|Array<number>}
     * @description 旅行商分析途经点数组，必设字段。
     *              点坐标类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
     *              当 SuperMap.FindTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
     *              当 SuperMap.FindTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
     */
    this.nodes = null;

    /**
     * @member SuperMap.FindTSPPathsParameters.prototype.parameter - {SuperMap.TransportationAnalystParameter}
     * @description 交通网络分析通用参数。通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
     *              SuperMap.TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting
     *              字段，则返回结果空间信息等都为空。
     */
    this.parameter = new _TransportationAnalystParameter.TransportationAnalystParameter();
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.FindTSPPathsParameters";
  }

  /**
   * @function SuperMap.FindTSPPathsParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(FindTSPPathsParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.endNodeAssigned = null;
      me.isAnalyzeById = null;
      me.nodes = null;
      if (me.parameter) {
        me.parameter.destroy();
        me.parameter = null;
      }
    }
  }]);

  return FindTSPPathsParameters;
}();

_SuperMap.SuperMap.FindTSPPathsParameters = FindTSPPathsParameters;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GenerateSpatialDataParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(50);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GenerateSpatialDataParameters
 * @classdesc 动态分段操作参数类。通过该类可以为动态分段提供参数信息。
 * @param options - {Object} 可选参数。如:</br>
 *        routeTable - {string} 路由数据集。</br>
 *        routeIDField - {string} 路由数据集的标识字段。</br>
 *        eventTable - {string} 用于生成空间数据的事件表名。</br>
 *        eventRouteIDField - {string} 用于生成空间数据的事件表的路由标识字段。</br>
 *        measureField - {string} 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义</br>
 *        measureStartField - {string} 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。</br>
 *        measureEndField - {string} 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。</br>
 *        measureOffsetField - {string} 刻度偏移量字段。</br>
 *        errorInfoField - {string} 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。</br>
 *        retainedFields - {Array<string>} 欲保留到结果空间数据中的字段集合（系统字段除外）。</br>
 *        dataReturnOption - {@link SuperMap.DataReturnOption} 设置数据返回的最大记录。
 */
var GenerateSpatialDataParameters = exports.GenerateSpatialDataParameters = function () {
  function GenerateSpatialDataParameters(options) {
    _classCallCheck(this, GenerateSpatialDataParameters);

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.routeTable - {string}
     * @description 路由数据集。
     */
    this.routeTable = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.routeIDField - {string}
     * @description 路由数据集的标识字段。
     */
    this.routeIDField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.eventTable - {string}
     * @description 用于生成空间数据的事件表名。
     */
    this.eventTable = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.eventRouteIDField - {string}
     * @description 用于生成空间数据的事件表的路由标识字段。
     */
    this.eventRouteIDField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureField -{string}
     * @description 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义
     */
    this.measureField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureStartField - {string}
     * @description 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。
     */
    this.measureStartField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureEndField - {string}
     * @description 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。
     */
    this.measureEndField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.measureOffsetField - {string}
     * @description 刻度偏移量字段。
     */
    this.measureOffsetField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.errorInfoField - {string}
     * @description 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。
     */
    this.errorInfoField = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.retainedFields - {Array<string>}
     * @description 欲保留到结果空间数据中的字段集合（系统字段除外）。
     * 生成空间数据时，无论是否指定保留字段，路由 ID 字段、刻度偏移量字段、刻度值字段（点事件为刻度字段，线事件是起始和终止刻度字段）都会保留到结果空间数据中；
     * 如果没有指定 retainedFields 参数或者retainedFields 参数数组长度为0，则返回所有用户字段。
     */
    this.retainedFields = null;

    /**
     * @member SuperMap.GenerateSpatialDataParameters.prototype.dataReturnOption - {SuperMap.DataReturnOption}
     * @description 设置数据返回的选项。
     */
    this.dataReturnOption = null;
    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.GenerateSpatialDataParameters";
  }

  /**
   * @function SuperMap.GenerateSpatialDataParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(GenerateSpatialDataParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.routeTable) {
        me.routeTable = null;
      }
      me.routeIDField = null;
      me.eventTable = null;
      me.eventRouteIDField = null;
      me.measureField = null;
      me.measureStartField = null;
      me.measureEndField = null;
      me.measureOffsetField = null;
      me.errorInfoField = null;
      if (me.dataReturnOption) {
        me.dataReturnOption.destroy();
        me.dataReturnOption = null;
      }
    }
  }]);

  return GenerateSpatialDataParameters;
}();

_SuperMap.SuperMap.GenerateSpatialDataParameters = GenerateSpatialDataParameters;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoCodingParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GeoCodingParameter
 * @classdesc 地理正向匹配参数类。
 * @param options - {Object} 可选参数。如:</br>
 *         address - {string} 地点关键词。</br>
 *         fromIndex - {number} 设置返回对象的起始索引值。</br>
 *         toIndex - {number} 设置返回对象的结束索引值。</br>
 *         filters - {Array<string>} 过滤字段，限定查询区域。</br>
 *         prjCoordSys - {string} 查询结果的坐标系。</br>
 *         maxReturn - {number} 最大返回结果数。
 */
var GeoCodingParameter = exports.GeoCodingParameter = function () {
  function GeoCodingParameter(options) {
    _classCallCheck(this, GeoCodingParameter);

    if (options.filters) {
      var strs = [];
      var fields = options.filters.split(',');
      fields.map(function (field) {
        strs.push("\"" + field + "\"");
        return field;
      });
      options.filters = strs;
    }
    /**
     * @member SuperMap.GeoCodingParameter.prototype.address - {string}
     * @description 地点关键词。
     */
    this.address = null;

    /**
     * @member SuperMap.GeoCodingParameter.prototype.fromIndex - {number}
     * @description 设置返回对象的起始索引值。
     */
    this.fromIndex = null;

    /**
     * @member SuperMap.GeoCodingParameter.prototype.toIndex - {number}
     * @description 设置返回对象的结束索引值。
     */
    this.toIndex = null;

    /**
     * @member SuperMap.GeoCodingParameter.prototype.filters - {Array<string>}
     * @description 过滤字段，限定查询区域。
     */
    this.filters = null;

    /**
     * @member SuperMap.GeoCodingParameter.prototype.prjCoordSys - {string}
     * @description  查询结果的坐标系。
     */
    this.prjCoordSys = null;

    /**
     * @member SuperMap.GeoCodingParameter.prototype.maxReturn - {number}
     * @description 最大返回结果数。
     */
    this.maxReturn = null;
    _Util.Util.extend(this, options);
  }

  /**
   * @function SuperMap.GeoCodingParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(GeoCodingParameter, [{
    key: 'destroy',
    value: function destroy() {
      this.address = null;
      this.fromIndex = null;
      this.toIndex = null;
      this.filters = null;
      this.prjCoordSys = null;
      this.maxReturn = null;
    }
  }]);

  return GeoCodingParameter;
}();

_SuperMap.SuperMap.GeoCodingParameter = GeoCodingParameter;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoDecodingParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GeoDecodingParameter
 * @classdesc 地理反向匹配参数类。
 * @param options - {Object}可选参数。如:<br>
 *        x - {number} 查询位置的横坐标。<br>
 *        y - {number} 查询位置的纵坐标。<br>
 *        fromIndex - {number} 设置返回对象的起始索引值。<br>
 *        filters - {Array<string>} 过滤字段，限定查询区域。<br>
 *        prjCoordSys - {string} 查询结果的坐标系。<br>
 *        maxReturn - {number} 最大返回结果数。<br>
 *        geoDecodingRadius - {number} 查询半径。
 */
var GeoDecodingParameter = exports.GeoDecodingParameter = function () {
  function GeoDecodingParameter(options) {
    _classCallCheck(this, GeoDecodingParameter);

    if (options.filters) {
      var strs = [];
      var fields = options.filters.split(',');
      fields.map(function (field) {
        strs.push("\"" + field + "\"");
        return field;
      });
      options.filters = strs;
    }
    /**
     * @member SuperMap.GeoDecodingParameter.prototype.x - {number}
     * @description 查询位置的横坐标。
     */
    this.x = null;

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.y - {number}
     * @description 查询位置的纵坐标。
     */
    this.y = null;
    /**
     * @member SuperMap.GeoDecodingParameter.prototype.fromIndex - {number}
     * @description  设置返回对象的起始索引值。
     */
    this.fromIndex = null;

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.toIndex - {number}
     * @description 设置返回对象的结束索引值。
     */
    this.toIndex = null;

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.filters - {Array<string>}
     * @description 过滤字段，限定查询区域。
     */
    this.filters = null;

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.prjCoordSys - {string}
     * @description 查询结果的坐标系。
     */
    this.prjCoordSys = null;

    /**
     *  @member SuperMap.GeoDecodingParameter.prototype.maxReturn - {number}
     *  @description 最大返回结果数。
     */
    this.maxReturn = null;

    /**
     * @member SuperMap.GeoDecodingParameter.prototype.geoDecodingRadius - {number}
     * @description 查询半径。
     */
    this.geoDecodingRadius = null;
    _Util.Util.extend(this, options);
  }

  /**
   * @function SuperMap.GeoDecodingParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(GeoDecodingParameter, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.fromIndex = null;
      this.toIndex = null;
      this.filters = null;
      this.prjCoordSys = null;
      this.maxReturn = null;
      this.geoDecodingRadius = null;
    }
  }]);

  return GeoDecodingParameter;
}();

_SuperMap.SuperMap.GeoDecodingParameter = GeoDecodingParameter;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeoRelationAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(3);

__webpack_require__(16);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GeoRelationAnalystParameters
 * @classdesc
 * 空间关系分析服务参数类。使用该类可以为空间关系分析服务提供所需的参数信息。
 * @param options - {Object} 可选参数。如:</br>
 *        sourceFilter - {{@link SuperMap.FilterParameter}} 空间关系分析中的参考数据集查询参数。仅 name, ids,attributeFilter 和 fields 字段有效。</br>
 *        referenceFilter - {{@link SuperMap.FilterParameter}} 空间关系分析中的参考数据集查询参数。仅 name, ids,attributeFilter 和 fields 字段有效。</br>
 *        spatialRelationType - {{@link SuperMap.SpatialRelationType}} 指定的空间关系类型。</br>
 *        isBorderInside - {boolean} 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。</br>
 *        returnFeature - {boolean} 是否返回Feature信息。</br>
 *        returnGeoRelatedOnly - {boolean} 仅返回满足指定空间关系的空间对象，默认为 True。</br>
 *        startRecord - {integer} 分析结果起始记录位置，默认为0。</br>
 *        expectCount - {integer} 空间关系分析期望返回结果记录数，默认为500条，如果实际不足500条结果则返回所有分析结果。</br>
 */
var GeoRelationAnalystParameters = exports.GeoRelationAnalystParameters = function () {
  function GeoRelationAnalystParameters(options) {
    _classCallCheck(this, GeoRelationAnalystParameters);

    /**
     *  @member SuperMap.GeoRelationAnalystParameters.prototype.dataset - {string}
     *  @description 源数据集名称。
     */
    this.dataset = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.sourceFilter - {SuperMap.FilterParameter}
     * @description 空间关系分析中的源数据集查询参数。仅 ids、attributeFilter 和 fields 字段有效。
     */
    this.sourceFilter = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.referenceFilter - {SuperMap.FilterParameter}
     * @description 空间关系分析中的参考数据集查询参数。仅 name, ids, attributeFilter和 fields 字段有效。
     */
    this.referenceFilter = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.spatialRelationType - {SuperMap.SpatialRelationType}
     * @description 指定的空间关系类型。
     */
    this.spatialRelationType = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.isBorderInside - {boolean}
     * @description 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。
     */
    this.isBorderInside = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.returnFeature - {boolean}
     * @description 是否返回Feature信息。
     */
    this.returnFeature = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.returnGeoRelatedOnly - {boolean}
     * @description 是否仅返回满足指定空间关系的空间对象，默认为 True。
     */
    this.returnGeoRelatedOnly = null;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.returnGeoRelatedOnly - {integer}
     * @description 分析结果起始记录位置，默认为0。
     */
    this.startRecord = 0;

    /**
     * @member SuperMap.GeoRelationAnalystParameters.prototype.expectCount - {integer}
     * @description 空间关系分析期望返回结果记录数，默认为500条，如果实际不足500条结果则返回所有分析结果。
     */
    this.expectCount = 500;
    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.GeoRelationAnalystParameters";
  }

  /**
   * @function SuperMap.GeoRelationAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(GeoRelationAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.sourceFilter) {
        me.sourceFilter.destroy();
      }
      me.sourceFilter = null;

      if (me.referenceFilter) {
        me.referenceFilter.destroy();
      }
      me.referenceFilter = null;

      me.dataset = null;
      me.spatialRelationType = null;
      me.isBorderInside = null;
      me.returnFeature = null;
      me.returnGeoRelatedOnly = null;
      me.startRecord = null;
      me.expectCount = null;
    }
  }]);

  return GeoRelationAnalystParameters;
}();

_SuperMap.SuperMap.GeoRelationAnalystParameters = GeoRelationAnalystParameters;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeometryBufferAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _BufferAnalystParameters = __webpack_require__(94);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometryBufferAnalystParameters
 * @classdesc 几何对象缓冲区分析参数类
 * 对指定的某个几何对象做缓冲区分析。通过该类可以指定要做缓冲区分析的几何对象、缓冲区参数等。
 * @param options - {Object} 可选参数。如:</br>
 *        sourceGeometry - {Object} 要做缓冲区分析的几何对象。必设字段。</br>
 *              点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *              线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *              面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        bufferSetting - {{@link SuperMap.BufferSetting}} 设置缓冲区通用参数。
 * @extends SuperMap.BufferAnalystParameters
 */
var GeometryBufferAnalystParameters = exports.GeometryBufferAnalystParameters = function (_BufferAnalystParamet) {
    _inherits(GeometryBufferAnalystParameters, _BufferAnalystParamet);

    function GeometryBufferAnalystParameters(options) {
        _classCallCheck(this, GeometryBufferAnalystParameters);

        /**
         * @member SuperMap.GeometryBufferAnalystParameters.prototype.sourceGeometry -{Object}
         * @description 要做缓冲区分析的几何对象。必设字段。</br>
         * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
         * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
         * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
         */
        var _this = _possibleConstructorReturn(this, (GeometryBufferAnalystParameters.__proto__ || Object.getPrototypeOf(GeometryBufferAnalystParameters)).call(this, options));

        _this.sourceGeometry = null;

        /**
         * @member SuperMap.GeometryBufferAnalystParameters.prototype.sourceGeometrySRID -{number}
         * @description 缓冲区几何对象投影坐标参数, 如 4326，3857。
         */
        _this.sourceGeometrySRID = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = " SuperMap.GeometryBufferAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.GeometryBufferAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(GeometryBufferAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometryBufferAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometryBufferAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.sourceGeometry) {
                me.sourceGeometry.destroy();
                me.sourceGeometry = null;
            }
        }

        /**
         * @function SuperMap.GeometryBufferAnalystParameters.toObject
         * @param geometryBufferAnalystParameters - {SuperMap.GeometryBufferAnalystParameters} 几何对象缓冲区分析参数类。
         * @param tempObj - {SuperMap.GeometryBufferAnalystParameters} 几何对象缓冲区分析参数对象。
         * @description 将几何对象缓冲区分析参数对象转换为JSON对象。
         * @return {Object} JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(geometryBufferAnalystParameters, tempObj) {
            for (var name in geometryBufferAnalystParameters) {
                if (name === "bufferSetting") {
                    var tempBufferSetting = {};
                    for (var key in geometryBufferAnalystParameters.bufferSetting) {
                        tempBufferSetting[key] = geometryBufferAnalystParameters.bufferSetting[key];
                    }
                    tempObj.analystParameter = tempBufferSetting;
                } else if (name === "sourceGeometry") {
                    tempObj.sourceGeometry = _ServerGeometry.ServerGeometry.fromGeometry(geometryBufferAnalystParameters.sourceGeometry);
                } else {
                    tempObj[name] = geometryBufferAnalystParameters[name];
                }
            }
        }
    }]);

    return GeometryBufferAnalystParameters;
}(_BufferAnalystParameters.BufferAnalystParameters);

_SuperMap.SuperMap.GeometryBufferAnalystParameters = GeometryBufferAnalystParameters;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeometryOverlayAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _OverlayAnalystParameters = __webpack_require__(95);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometryOverlayAnalystParameters
 * @classdesc
 * 几何对象叠加分析参数类。对指定的某两个几何对象做叠加分析。通过该类可以指定要做叠加分析的几何对象、叠加操作类型。
 * @param options - {Object} 可选参数。如:</br>
 *        operateGeometry - {Object} 叠加分析的操作几何对象。必设字段。</br>
 *                      点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                      线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        sourceGeometry - {Object} 叠加分析的源几何对象。必设字段。</br>
 *                      点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                      线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        operation - {{@link SuperMap.OverlayOperationType}} 叠加操作枚举值。</br>
 * @extends SuperMap.OverlayAnalystParameters
 */
var GeometryOverlayAnalystParameters = exports.GeometryOverlayAnalystParameters = function (_OverlayAnalystParame) {
    _inherits(GeometryOverlayAnalystParameters, _OverlayAnalystParame);

    function GeometryOverlayAnalystParameters(options) {
        _classCallCheck(this, GeometryOverlayAnalystParameters);

        /**
         * @member SuperMap.GeometryOverlayAnalystParameters.prototype.operateGeometry -{Object}
         * @description 叠加分析的操作几何对象。必设字段。</br>
         * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
         * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
         * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
         */
        var _this = _possibleConstructorReturn(this, (GeometryOverlayAnalystParameters.__proto__ || Object.getPrototypeOf(GeometryOverlayAnalystParameters)).call(this, options));

        _this.operateGeometry = null;

        /**
         * @member SuperMap.GeometryOverlayAnalystParameters.prototype.sourceGeometry -{Object}
         * @description 叠加分析的源几何对象。必设字段。</br>
         * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
         * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
         * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。
         */
        _this.sourceGeometry = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.GeometryOverlayAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.GeometryOverlayAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(GeometryOverlayAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometryOverlayAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometryOverlayAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.sourceGeometry) {
                me.sourceGeometry.destroy();
                me.sourceGeometry = null;
            }

            if (me.operateGeometry) {
                me.operateGeometry.destroy();
                me.operateGeometry = null;
            }
        }

        /**
         * @function SuperMap.GeometryOverlayAnalystParameters.toObject
         * @param geometryOverlayAnalystParameters - {SuperMap.GeometryOverlayAnalystParameters} 几何对象叠加分析参数类。
         * @param tempObj - {SuperMap.GeometryOverlayAnalystParameters} 几何对象叠加分析参数对象
         * @description 将几何对象叠加分析参数对象转换为JSON对象。
         * @return {Object} JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(geometryOverlayAnalystParameters, tempObj) {
            for (var name in geometryOverlayAnalystParameters) {
                if (name === "sourceGeometry") {
                    tempObj.sourceGeometry = _ServerGeometry.ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.sourceGeometry);
                } else if (name === "operateGeometry") {
                    tempObj.operateGeometry = _ServerGeometry.ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.operateGeometry);
                } else {
                    tempObj[name] = geometryOverlayAnalystParameters[name];
                }
            }
        }
    }]);

    return GeometryOverlayAnalystParameters;
}(_OverlayAnalystParameters.OverlayAnalystParameters);

_SuperMap.SuperMap.GeometryOverlayAnalystParameters = GeometryOverlayAnalystParameters;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeometrySurfaceAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SurfaceAnalystParameters = __webpack_require__(69);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometrySurfaceAnalystParameters
 * @classdesc
 * 几何对象表面分析参数类。该类对几何对象表面分析所用到的参数进行设置。
 * @param options - {Object} 可选参数。如:</br>
 *        points - {Array<Object>} 表面分析的坐标点数组。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *        zValues - {Array<number>} 表面分析的坐标点的 Z 值数组。</br>
 *        resolution - {number} 获取或设置指定中间结果（栅格数据集）的分辨率。</br>
 *        resultSetting - {{@link SuperMap.DataReturnOption}} 结果返回设置类。</br>
 *        extractParameter - {{@link SuperMap.SurfaceAnalystParametersSetting}} 获取或设置表面分析参数。</br>
 *        surfaceAnalystMethod - {SuperMap.SurfaceAnalystMethod} 获取或设置表面分析的提取方法，提取等值线和提取等值面。</br>
 * @extends SuperMap.SurfaceAnalystParameters
 */
var GeometrySurfaceAnalystParameters = exports.GeometrySurfaceAnalystParameters = function (_SurfaceAnalystParame) {
    _inherits(GeometrySurfaceAnalystParameters, _SurfaceAnalystParame);

    function GeometrySurfaceAnalystParameters(options) {
        _classCallCheck(this, GeometrySurfaceAnalystParameters);

        /**
         * @member SuperMap.GeometrySurfaceAnalystParameters.prototype.points - {Array<Object>}
         * @description 获取或设置用于表面分析的坐标点数组。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
         */
        var _this = _possibleConstructorReturn(this, (GeometrySurfaceAnalystParameters.__proto__ || Object.getPrototypeOf(GeometrySurfaceAnalystParameters)).call(this, options));

        _this.points = null;

        /**
         * @member SuperMap.GeometrySurfaceAnalystParameters.prototype.zValues - {Array<number>}
         * @description 获取或设置用于提取操作的值。提取等值线时，将使用该数组中的值，
         * 对几何对象中的坐标点数组进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
         */
        _this.zValues = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.GeometrySurfaceAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.GeometrySurfaceAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(GeometrySurfaceAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometrySurfaceAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometrySurfaceAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.points) {
                for (var i = 0, points = me.points, len = points.length; i < len; i++) {
                    points[i].destroy();
                }
                me.points = null;
            }
            me.zValues = null;
        }
    }]);

    return GeometrySurfaceAnalystParameters;
}(_SurfaceAnalystParameters.SurfaceAnalystParameters);

_SuperMap.SuperMap.GeometrySurfaceAnalystParameters = GeometrySurfaceAnalystParameters;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeometryThiessenAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ThiessenAnalystParameters = __webpack_require__(73);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeometryThiessenAnalystParameters
 * @constructs SuperMap.GeometryThiessenAnalystParameters
 * @classdesc 几何对象泰森多边形分析参数类。对指定的某个几何对象做泰森多边形分析。通过该类可以指定要做泰森多边形分析的几何对象、返回数据集名称等。
 * @param options - {Object} 可选参数。如:</br>
 *         points - {Array<Object>} 使用点数组进行分析时使用的几何对象。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.ThiessenAnalystParameters
 */

var GeometryThiessenAnalystParameters = exports.GeometryThiessenAnalystParameters = function (_ThiessenAnalystParam) {
    _inherits(GeometryThiessenAnalystParameters, _ThiessenAnalystParam);

    function GeometryThiessenAnalystParameters(options) {
        _classCallCheck(this, GeometryThiessenAnalystParameters);

        /**
         * @member SuperMap.GeometryThiessenAnalystParameters.prototype.points -{Array<Object>}|{Array}
         * @description 使用点数组进行分析时使用的几何对象。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
         */
        var _this = _possibleConstructorReturn(this, (GeometryThiessenAnalystParameters.__proto__ || Object.getPrototypeOf(GeometryThiessenAnalystParameters)).call(this, options));

        _this.points = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.GeometryThiessenAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.GeometryThiessenAnalystParameters.prototype.destroy
     * @override
     */


    _createClass(GeometryThiessenAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeometryThiessenAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(GeometryThiessenAnalystParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.points) {
                for (var i = me.points.length - 1; i >= 0; i--) {
                    me.points[i].destroy();
                }
                me.points = null;
            }
        }

        /**
         * @function SuperMap.GeometryThiessenAnalystParameters.toObject
         * @param geometryThiessenAnalystParameters - {SuperMap.GeometryThiessenAnalystParameters} 几何对象泰森多边形分析参数类。
         * @param tempObj - {SuperMap.GeometryThiessenAnalystParameters} 几何对象泰森多边形分析参数对象。
         * @description 将几何对象泰森多边形分析参数对象转换为JSON对象。
         * @return {Object} JSON对象。
         */

    }], [{
        key: 'toObject',
        value: function toObject(geometryThiessenAnalystParameters, tempObj) {
            for (var name in geometryThiessenAnalystParameters) {
                if (name === "clipRegion") {
                    tempObj.clipRegion = _ServerGeometry.ServerGeometry.fromGeometry(geometryThiessenAnalystParameters.clipRegion);
                } else {
                    tempObj[name] = geometryThiessenAnalystParameters[name];
                }
            }
        }
    }]);

    return GeometryThiessenAnalystParameters;
}(_ThiessenAnalystParameters.ThiessenAnalystParameters);

_SuperMap.SuperMap.GeometryThiessenAnalystParameters = GeometryThiessenAnalystParameters;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByBoundsParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _FilterParameter = __webpack_require__(16);

var _GetFeaturesParametersBase = __webpack_require__(40);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBoundsParameters
 * @classdesc 数据集范围查询参数类,该类用于设置数据集范围查询的相关参数。
 * @param options - {Object} 可选参数。如：<br>
 *        bounds - {Object} 用于查询的范围对象。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        attributeFilter - {string} 范围查询属性过滤条件。</br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        spatialQueryMode - {SuperMap.SpatialQueryMode} 空间查询模式常量,必设参数。</br>
 *        queryParameter - {@link SuperMap.FilterParameter} 查询过滤条件参数。</br>
 *        datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {integer} 查询结果的最小索引号。</br>
 *        toIndex - {integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */

var GetFeaturesByBoundsParameters = exports.GetFeaturesByBoundsParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByBoundsParameters, _GetFeaturesParameter);

    function GetFeaturesByBoundsParameters(options) {
        _classCallCheck(this, GetFeaturesByBoundsParameters);

        /**
         * @member SuperMap.GetFeaturesByBoundsParameters.prototype.getFeatureMode - {string}
         * @description 数据集查询模式。范围查询有"BOUNDS"，"BOUNDS_ATTRIBUTEFILTER"两种,当用户设置attributeFilter时会自动切换到BOUNDS_ATTRIBUTEFILTER访问服务。
         */
        var _this = _possibleConstructorReturn(this, (GetFeaturesByBoundsParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsParameters)).call(this, options));

        _this.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS;

        /**
         * @member SuperMap.GetFeaturesByBoundsParameters.prototype.bounds - {Object}
         * @description 用于查询的范围对象。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
         *
         */
        _this.bounds = null;

        /**
         * @member SuperMap.GetFeaturesByBoundsParameters.prototype.fields - {Array<string>}
         * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        _this.fields = null;

        /**
         * @member SuperMap.GetFeaturesByBoundsParameters.prototype.attributeFilter - {string}
         * @description 范围查询属性过滤条件。
         */
        _this.attributeFilter = null;

        /**
         * @member SuperMap.GetFeaturesByBoundsParameters.prototype.spatialQueryMode - {SuperMap.SpatialQueryMode}
         * @description 空间查询模式常量，必设参数，默认为CONTAIN。
         */
        _this.spatialQueryMode = _REST.SpatialQueryMode.CONTAIN;
        _Util.Util.extend(_this, options);
        _this.CLASS_NAME = "SuperMap.GetFeaturesByBoundsParameters";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByBoundsParameters.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByBoundsParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBoundsParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.bounds) {
                me.bounds.destroy();
                me.bounds = null;
            }
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
            me.attributeFilter = null;
            me.spatialQueryMode = null;
            me.getFeatureMode = null;
        }

        /**
         * @function SuperMap.GetFeaturesByBoundsParameters.toJsonParameters
         * @description 将SuperMap.GetFeaturesByBoundsParameters对象参数转换为JSON字符串。
         * @param params - {SuperMap.GetFeaturesByBoundsParameters} 范围查询参数。
         * @return  {string} 转化后的JSON字符串。
         *
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var filterParameter, bounds, parasByBounds;

            bounds = {
                "leftBottom": { "x": params.bounds.left, "y": params.bounds.bottom },
                "rightTop": { "x": params.bounds.right, "y": params.bounds.top }
            };
            parasByBounds = {
                datasetNames: params.datasetNames,
                getFeatureMode: GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS,
                bounds: bounds,
                spatialQueryMode: params.spatialQueryMode
            };
            if (params.fields) {
                filterParameter = new _FilterParameter.FilterParameter();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                parasByBounds.queryParameter = filterParameter;
            }
            if (params.attributeFilter) {
                parasByBounds.attributeFilter = params.attributeFilter;
                parasByBounds.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS_ATTRIBUTEFILTER;
            }
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                parasByBounds.maxFeatures = params.maxFeatures;
            }

            return _Util.Util.toJSON(parasByBounds);
        }
    }]);

    return GetFeaturesByBoundsParameters;
}(_GetFeaturesParametersBase.GetFeaturesParametersBase);

GetFeaturesByBoundsParameters.getFeatureMode = {
    "BOUNDS": "BOUNDS",
    "BOUNDS_ATTRIBUTEFILTER": "BOUNDS_ATTRIBUTEFILTER"
};

_SuperMap.SuperMap.GetFeaturesByBoundsParameters = GetFeaturesByBoundsParameters;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByBufferParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _GetFeaturesParametersBase = __webpack_require__(40);

var _FilterParameter = __webpack_require__(16);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBufferParameters
 * @classdesc 数据服务中数据集缓冲区查询参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        bufferDistance - {number} buffer 距离，单位与所查询图层对应的数据集单位相同。</br>
 *        attributeFilter - {string} 属性查询条件。 </br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        geometry - {@link SuperMap.Geometry} 空间查询条件。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                  线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                  面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        dataSetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {integer} 查询结果的最小索引号。</br>
 *        toIndex - {integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesByBufferParameters = exports.GetFeaturesByBufferParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByBufferParameters, _GetFeaturesParameter);

    function GetFeaturesByBufferParameters(options) {
        _classCallCheck(this, GetFeaturesByBufferParameters);

        /**
         * @member SuperMap.GetFeaturesByBufferParameters.prototype.bufferDistance - {number}
         * @description buffer距离,单位与所查询图层对应的数据集单位相同。
         */
        var _this = _possibleConstructorReturn(this, (GetFeaturesByBufferParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferParameters)).call(this, options));

        _this.bufferDistance = null;

        /**
         * @member SuperMap.GetFeaturesByBufferParameters.prototype.queryParameter - {string}
         * @description 属性查询条件。
         */
        _this.attributeFilter = null;

        /**
         * @member SuperMap.GetFeaturesByBufferParameters.prototype.geometry
         * @description 空间查询条件。</br>
         * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
         * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
         * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
         */
        _this.geometry = null;

        /**
         * @member SuperMap.GetFeaturesByBufferParameters.prototype.fields - {Array<string>}
         * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        _this.fields = null;
        _Util.Util.extend(_this, options);
        _this.CLASS_NAME = "SuperMap.GetFeaturesByBufferParameters";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByBufferParameters.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByBufferParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBufferParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.bufferDistance = null;
            me.attributeFilter = null;
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
            if (me.geometry) {
                me.geometry.destroy();
                me.geometry = null;
            }
        }

        /**
         * @function SuperMap.GetFeaturesByBufferParameters.toJsonParameters
         * @description 将SuperMap.GetFeaturesByBufferParameters对象转换为JSON字符串。
         * @param params - {SuperMap.GetFeaturesByBufferParameters} 数据集缓冲区查询参数对象。
         * @return {string} 转化后的JSON字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var filterParameter, paramsBySql, geometry;
            geometry = _ServerGeometry.ServerGeometry.fromGeometry(params.geometry);
            paramsBySql = {
                datasetNames: params.datasetNames,
                getFeatureMode: "BUFFER",
                bufferDistance: params.bufferDistance,
                geometry: geometry
            };
            if (params.fields) {
                filterParameter = new _FilterParameter.FilterParameter();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                paramsBySql.queryParameter = filterParameter;
            }
            if (params.attributeFilter) {
                paramsBySql.attributeFilter = params.attributeFilter;
                paramsBySql.getFeatureMode = "BUFFER_ATTRIBUTEFILTER";
            }
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                paramsBySql.maxFeatures = params.maxFeatures;
            }
            return _Util.Util.toJSON(paramsBySql);
        }
    }]);

    return GetFeaturesByBufferParameters;
}(_GetFeaturesParametersBase.GetFeaturesParametersBase);

_SuperMap.SuperMap.GetFeaturesByBufferParameters = GetFeaturesByBufferParameters;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByGeometryParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _FilterParameter = __webpack_require__(16);

var _GetFeaturesParametersBase = __webpack_require__(40);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByGeometryParameters
 * @classdesc 数据集几何查询参数类。该类用于设置数据集几何查询的相关参数。
 * @param options - {Object} 可选参数。如:</br>
 *         geometry - {Object} 用于查询的几何对象。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
 *                  线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
 *                  面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。</br>
 *        attributeFilter - {string} 几何查询属性过滤条件。</br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        spatialQueryMode - {SuperMap.SpatialQueryMode} 空间查询模式常量,必设参数。</br>
 *        queryParameter - {@link SuperMap.FilterParameter} 查询过滤条件参数。</br>
 *        datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {integer} 查询结果的最小索引号。</br>
 *        toIndex - {integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesByGeometryParameters = exports.GetFeaturesByGeometryParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByGeometryParameters, _GetFeaturesParameter);

    function GetFeaturesByGeometryParameters(options) {
        _classCallCheck(this, GetFeaturesByGeometryParameters);

        /**
         * @member SuperMap.GetFeaturesByGeometryParameters.prototype.getFeatureMode - {string}
         * @description 数据集查询模式。几何查询有"SPATIAL"，"SPATIAL_ATTRIBUTEFILTER"两种,当用户设置attributeFilter时会自动切换到SPATIAL_ATTRIBUTEFILTER访问服务。
         */
        var _this = _possibleConstructorReturn(this, (GetFeaturesByGeometryParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryParameters)).call(this, options));

        _this.getFeatureMode = "SPATIAL";

        /**
         * @member SuperMap.GetFeaturesByGeometryParameters.prototype.geometry - {Object}
         * @description 用于查询的几何对象。</br>
         * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。</br>
         * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。</br>
         * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
         */
        _this.geometry = null;

        /**
         * @member SuperMap.GetFeaturesByGeometryParameters.prototype.fields - {Array<string>}
         * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        _this.fields = null;

        /**
         * @member SuperMap.GetFeaturesByGeometryParameters.prototype.attributeFilter -{string}
         *  @description 几何查询属性过滤条件。
         */
        _this.attributeFilter = null;

        /**
         * @member SuperMap.GetFeaturesByGeometryParameters.prototype.spatialQueryMode - {SuperMap.SpatialQueryMode}
         * @description 空间查询模式常量，必设参数，默认为CONTAIN。
         */
        _this.spatialQueryMode = _REST.SpatialQueryMode.CONTAIN;
        _Util.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.GetFeaturesByGeometryParameters";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByGeometryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(GetFeaturesByGeometryParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByGeometryParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryParameters.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.geometry) {
                me.geometry.destroy();
                me.geometry = null;
            }
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
            me.attributeFilter = null;
            me.spatialQueryMode = null;
            me.getFeatureMode = null;
        }

        /**
         * @function SuperMap.GetFeaturesByGeometryParameters.toJsonParameters
         * @description 将SuperMap.GetFeaturesByGeometryParameters对象参数转换为JSON字符串。
         * @param params - {SuperMap.GetFeaturesByGeometryParameters} 何查询参数对象。
         * @return {string} 转化后的JSON字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var filterParameter, geometry, parasByGeometry;

            geometry = _ServerGeometry.ServerGeometry.fromGeometry(params.geometry);
            parasByGeometry = {
                datasetNames: params.datasetNames,
                getFeatureMode: "SPATIAL",
                geometry: geometry,
                spatialQueryMode: params.spatialQueryMode
            };
            if (params.fields) {
                filterParameter = new _FilterParameter.FilterParameter();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                parasByGeometry.queryParameter = filterParameter;
            }
            if (params.attributeFilter) {
                parasByGeometry.attributeFilter = params.attributeFilter;
                parasByGeometry.getFeatureMode = "SPATIAL_ATTRIBUTEFILTER";
            }
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                parasByGeometry.maxFeatures = params.maxFeatures;
            }

            return _Util.Util.toJSON(parasByGeometry);
        }
    }]);

    return GetFeaturesByGeometryParameters;
}(_GetFeaturesParametersBase.GetFeaturesParametersBase);

_SuperMap.SuperMap.GetFeaturesByGeometryParameters = GetFeaturesByGeometryParameters;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByIDsParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _FilterParameter = __webpack_require__(16);

var _GetFeaturesParametersBase = __webpack_require__(40);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByIDsParameters
 * @classdesc ID查询参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        IDs - {Array<integer>} 所要查询指定的元素ID信息。</br>
 *        fields - {Array<string>} 设置查询结果返回字段。默认返回所有字段。</br>
 *        dataSetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *        returnContent - {boolean} 是否直接返回查询结果。</br>
 *        fromIndex - {integer} 查询结果的最小索引号。</br>
 *        toIndex - {integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesByIDsParameters = exports.GetFeaturesByIDsParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesByIDsParameters, _GetFeaturesParameter);

    function GetFeaturesByIDsParameters(options) {
        _classCallCheck(this, GetFeaturesByIDsParameters);

        /**
         * @member SuperMap.GetFeaturesByIDsParameters.prototype.getFeatureMode - {string}
         * @description 数据集查询模式。
         */
        var _this = _possibleConstructorReturn(this, (GetFeaturesByIDsParameters.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsParameters)).call(this, options));

        _this.getFeatureMode = "ID";

        /**
         * @member SuperMap.GetFeaturesByIDsParameters.prototype.IDs - {Array<integer>}
         * @description 所要查询指定的元素ID信息。
         */
        _this.IDs = null;

        /**
         *  @member SuperMap.GetFeaturesByIDsParameters.prototype.fields - {Array<string>}
         *  @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        _this.fields = null;
        _Util.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.GetFeaturesByIDsParameters";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByIDsParameters.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByIDsParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByIDsParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.IDs = null;
            me.getFeatureMode = null;
            if (me.fields) {
                while (me.fields.length > 0) {
                    me.fields.pop();
                }
                me.fields = null;
            }
        }

        /**
         * @function SuperMap.GetFeaturesByIDsParameters.toJsonParameters
         * @description 将SuperMap.GetFeaturesByIDsParameters对象转换为JSON字符串。
         * @param params - {SuperMap.GetFeaturesByIDsParameters} ID查询参数对象。
         * @return {string} 转化后的JSON字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var parasByIDs, filterParameter;

            parasByIDs = {
                datasetNames: params.datasetNames,
                getFeatureMode: "ID",
                ids: params.IDs
            };
            if (params.fields) {
                filterParameter = new _FilterParameter.FilterParameter();
                filterParameter.name = params.datasetNames;
                filterParameter.fields = params.fields;
                parasByIDs.queryParameter = filterParameter;
            }
            return _Util.Util.toJSON(parasByIDs);
        }
    }]);

    return GetFeaturesByIDsParameters;
}(_GetFeaturesParametersBase.GetFeaturesParametersBase);

_SuperMap.SuperMap.GetFeaturesByIDsParameters = GetFeaturesByIDsParameters;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesBySQLParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _GetFeaturesParametersBase = __webpack_require__(40);

__webpack_require__(16);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesBySQLParameters
 * @classdesc 数据服务中数据集SQL查询参数类。
 * @param options - {Object} 可選参数。如:</br>
 *        queryParameter - {{@link SuperMap.FilterParameter}} 查询过滤条件参数。</br>
 *         datasetNames - {Array<string>} 数据集集合中的数据集名称列表。</br>
 *         returnContent - {boolean} 是否直接返回查询结果。</br>
 *         fromIndex - {integer} 查询结果的最小索引号。</br>
 *         toIndex - {integer} 查询结果的最大索引号。</br>
 * @extends SuperMap.GetFeaturesParametersBase
 */
var GetFeaturesBySQLParameters = exports.GetFeaturesBySQLParameters = function (_GetFeaturesParameter) {
    _inherits(GetFeaturesBySQLParameters, _GetFeaturesParameter);

    function GetFeaturesBySQLParameters(options) {
        _classCallCheck(this, GetFeaturesBySQLParameters);

        /**
         * @function SuperMap.GetFeaturesBySQLParameters.prototype.getFeatureMode - {string}
         * @description 数据集查询模式。
         */
        var _this = _possibleConstructorReturn(this, (GetFeaturesBySQLParameters.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLParameters)).call(this, options));

        _this.getFeatureMode = "SQL";

        /**
         * @function SuperMap.GetFeaturesBySQLParameters.prototype.queryParameter - {SuperMap.FilterParameter}
         * @description 查询过滤条件参数类。
         */
        _this.queryParameter = null;

        _Util.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.GetFeaturesBySQLParameters";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesBySQLParameters.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesBySQLParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesBySQLParameters.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.getFeatureMode = null;
            if (me.queryParameter) {
                me.queryParameter.destroy();
                me.queryParameter = null;
            }
        }

        /**
         * @function SuperMap.GetFeaturesBySQLParameters.prototype.toJsonParameters
         * @description  将SuperMap.GetFeaturesBySQLParameters对象转换为JSON字符串。
         * @param params - {SuperMap.GetFeaturesBySQLParameters} 数据集SQL查询参数对象。
         * @return {string} 转化后的JSON字符串。
         */

    }], [{
        key: 'toJsonParameters',
        value: function toJsonParameters(params) {
            var paramsBySql = {
                datasetNames: params.datasetNames,
                getFeatureMode: "SQL",
                queryParameter: params.queryParameter
            };
            if (params.maxFeatures && !isNaN(params.maxFeatures)) {
                paramsBySql.maxFeatures = params.maxFeatures;
            }
            return _Util.Util.toJSON(paramsBySql);
        }
    }]);

    return GetFeaturesBySQLParameters;
}(_GetFeaturesParametersBase.GetFeaturesParametersBase);

_SuperMap.SuperMap.GetFeaturesBySQLParameters = GetFeaturesBySQLParameters;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GetGridCellInfosParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.GetGridCellInfosParameters
 * @classdesc 数据服务栅格查询参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        datasetName - {string} 数据集名称。</br>
 *        dataSourceName - {string} 数据源名称</br>
 *        X - {integer} 要查询的地理位置X轴。</br>
 *        Y - {integer} 要查询的地理位置Y轴。
 */
var GetGridCellInfosParameters = exports.GetGridCellInfosParameters = function () {
  function GetGridCellInfosParameters(options) {
    _classCallCheck(this, GetGridCellInfosParameters);

    /**
     * @member SuperMap.GetGridCellInfosParameters.prototype.datasetName - {string}
     * @description 数据集名称。
     */
    this.datasetName = null;

    /**
     * @member SuperMap.GetGridCellInfosParameters.prototype.dataSourceName - {string}
     * @description  数据源名称。
     */
    this.dataSourceName = null;

    /**
     * @member SuperMap.GetGridCellInfosParameters.prototype.X - {integer}
     * @description 要查询的地理位置X轴。
     */
    this.X = null;

    /**
     * @member SuperMap.GetGridCellInfosParameters.prototype.Y - {integer}
     * @description 要查询的地理位置Y轴。
     */
    this.Y = null;
    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.GetGridCellInfosParameters";
  }

  /**
   * @function SuperMap.GetGridCellInfosParameters.prototype.destroy
   * @description 释放资源，将引用的资源属性置空。
   */


  _createClass(GetGridCellInfosParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.datasetName = null;
      me.dataSourceName = null;
      me.X = null;
      me.Y = null;
    }
  }]);

  return GetGridCellInfosParameters;
}();

_SuperMap.SuperMap.GetGridCellInfosParameters = GetGridCellInfosParameters;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Grid = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _UGCSubLayer2 = __webpack_require__(52);

var _ServerColor = __webpack_require__(20);

var _ServerStyle = __webpack_require__(11);

var _ColorDictionary = __webpack_require__(158);

__webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Grid
 * @classdesc UGC 栅格图层类。
 * @extends SuperMap.UGCSubLayer
 * @param options - {Object} 可选参数。如：<br>
 *        colorDictionary - {Array<Object>} 颜色对照表对象。<br>
 *        brightness - {integer} Grid 图层的亮度。<br>
 *        colorGradientType - {boolean} 文本压盖时是否显示压盖的文本对象。<br>
 *        colors - {@link SuperMap.ServerColor} 颜色表对象。<br>
 *        contrast - {integer} Grid 图层的对比度。<br>
 *        gridType - {SuperMap.GridType} 格网类型。<br>
 *        horizontalSpacing - {number}格网水平间隔大小。<br>
 *        sizeFixed - {boolean} 格网是否固定大小，如果不固定大小，则格网随着地图缩放。<br>
 *        solidStyle - {@link SuperMap.ServerStyle} 格网实线的样式。<br>
 *        specialColor - {@link SuperMap.ServerColor} 栅格数据集无值数据的颜色。<br>
 *        specialValue - {number}图层的特殊值。<br>
 *        specialValueTransparent - {boolean} 图层的特殊值（specialValue）所处区域是否透明。<br>
 *        verticalSpacing - {number} 格网垂直间隔大小。
 */
var Grid = exports.Grid = function (_UGCSubLayer) {
    _inherits(Grid, _UGCSubLayer);

    function Grid(options) {
        _classCallCheck(this, Grid);

        options = options || {};

        /**
         * @member SuperMap.Grid.prototype.colorDictionarys - {Array<SuperMap.ColorDictionary>}
         * @description 颜色对照表对象。
         */
        var _this = _possibleConstructorReturn(this, (Grid.__proto__ || Object.getPrototypeOf(Grid)).call(this, options));

        _this.colorDictionarys = null;

        /**
         * @member SuperMap.Grid.prototype.brightness - {integer}
         * @description Grid 图层的亮度。
         */
        _this.brightness = null;

        /**
         * @member SuperMap.Grid.prototype.colorGradientType - {SuperMap.ColorGradientType}
         * @description 渐变颜色枚举值。
         */
        _this.colorGradientType = null;

        /**
         * @member SuperMap.Grid.prototype.colors - {SuperMap.ServerColor}
         * @description 颜色表对象。
         */
        _this.colors = null;

        /**
         * @member SuperMap.Grid.prototype.contrast - {integer}
         * @description Grid 图层的对比度。
         */
        _this.contrast = null;

        /**
         * @member SuperMap.Grid.prototype.dashStyle - {SuperMap.ServerStyle}
         * @description 栅格数据集特殊值数据的颜色。
         */
        _this.dashStyle = null;

        /**
         * @member SuperMap.Grid.prototype.gridType - {SuperMap.GridType}
         * @description 格网类型。
         */
        _this.gridType = null;

        /**
         * @member SuperMap.Grid.prototype.horizontalSpacing - {number}
         * @description 格网水平间隔大小。
         */
        _this.horizontalSpacing = null;

        /**
         * @member SuperMap.Grid.prototype.sizeFixed -{boolean}
         * @description 格网是否固定大小，如果不固定大小，则格网随着地图缩放。
         */
        _this.sizeFixed = null;

        /**
         * @member SuperMap.Grid.prototype.solidStyle - {SuperMap.ServerStyle}
         * @description 格网实线的样式。
         */
        _this.solidStyle = null;

        /**
         * @member SuperMap.Grid.prototype.specialColor - {SuperMap.ServerColor}
         * @description 栅格数据集无值数据的颜色。
         */
        _this.specialColor = null;

        /**
         * @member SuperMap.Grid.prototype.specialValue - {number}
         * @description 图层的特殊值。
         */
        _this.specialValue = null;

        /**
         * @member SuperMap.Grid.prototype.specialValueTransparent - {boolean}
         * @description 图层的特殊值（specialValue）所处区域是否透明。
         */
        _this.specialValueTransparent = null;

        /**
         * @member SuperMap.Grid.prototype.verticalSpacing - {number}
         * @description 格网垂直间隔大小。
         */
        _this.verticalSpacing = null;

        _this.CLASS_NAME = "SuperMap.Grid";
        return _this;
    }

    /**
     * @function SuperMap.Grid.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    _createClass(Grid, [{
        key: 'destroy',
        value: function destroy() {
            _get(Grid.prototype.__proto__ || Object.getPrototypeOf(Grid.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.Grid.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象。
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(Grid.prototype.__proto__ || Object.getPrototypeOf(Grid.prototype), 'fromJson', this).call(this, jsonObject);
            if (this.specialColor) {
                this.specialColor = new _ServerColor.ServerColor(this.specialColor.red, this.specialColor.green, this.specialColor.blue);
            }
            if (this.colors) {
                var colors = [],
                    color;
                for (var i in this.colors) {
                    color = this.colors[i];
                    colors.push(new _ServerColor.ServerColor(color.red, color.green, color.blue));
                }
                this.colors = colors;
            }
            if (this.dashStyle) {
                this.dashStyle = new _ServerStyle.ServerStyle(this.dashStyle);
            }
            if (this.solidStyle) {
                this.solidStyle = new _ServerStyle.ServerStyle(this.solidStyle);
            }
            if (this.colorDictionary) {
                var colorDics = [],
                    colorDic;
                for (var key in this.colorDictionary) {
                    colorDic = this.colorDictionary[key];
                    colorDics.push(new _ColorDictionary.ColorDictionary({ elevation: key, color: colorDic }));
                }
                this.colorDictionarys = colorDics;
            }
            delete this.colorDictionary;
        }

        /**
         * @function SuperMap.Grid.prototype.toServerJSONObject
         * @description 转换成对应的JSON对象。
         * @return JSON对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = _get(Grid.prototype.__proto__ || Object.getPrototypeOf(Grid.prototype), 'toServerJSONObject', this).call(this);

            if (jsonObject.dashStyle) {
                if (jsonObject.dashStyle.toServerJSONObject) {
                    jsonObject.dashStyle = jsonObject.dashStyle.toServerJSONObject();
                }
            }
            if (jsonObject.solidStyle) {
                if (jsonObject.solidStyle.toServerJSONObject) {
                    jsonObject.solidStyle = jsonObject.solidStyle.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return Grid;
}(_UGCSubLayer2.UGCSubLayer);

_SuperMap.SuperMap.Grid = Grid;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UGCImage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _UGCSubLayer2 = __webpack_require__(52);

var _ServerColor = __webpack_require__(20);

var _Util = __webpack_require__(1);

__webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Image
 * @classdesc UGC 影像图层类。
 * @extends SuperMap.UGCSubLayer
 * @param options - {Object} 可选参数。如：<br>
 *        colorSpaceType - {SuperMap.ColorSpaceType} 返回影像图层的色彩显示模式。<br>
 *        brightness - {integer} 影像图层的亮度。<br>
 *        displayBandIndexes - {Array<integer>} 返回当前影像图层显示的波段索引。<br>
 *        contrast - {integer} 影像图层的对比度。<br>
 *        transparent - {boolean} 是否背景透明。<br>
 *        transparentColor - {@link SuperMap.ServerColor} 返回背景透明色。<br>
 *        transparentColorTolerance - {integer} 背景透明色容限。
 */
var UGCImage = exports.UGCImage = function (_UGCSubLayer) {
  _inherits(UGCImage, _UGCSubLayer);

  function UGCImage(options) {
    _classCallCheck(this, UGCImage);

    options = options || {};

    /**
     * @member SuperMap.Image.prototype.brightness - {integer}
     * @description 影像图层的亮度。
     */
    var _this = _possibleConstructorReturn(this, (UGCImage.__proto__ || Object.getPrototypeOf(UGCImage)).call(this, options));

    _this.brightness = null;

    /**
     * @member SuperMap.Image.prototype.colorSpaceType - {SuperMap.ColorSpaceType}
     * @description 返回影像图层的色彩显示模式。
     */
    _this.colorSpaceType = null;

    /**
     * @member SuperMap.Image.prototype.contrast - {integer}
     * @description 影像图层的对比度。
     */
    _this.contrast = null;

    /**
     * @member SuperMap.Image.prototype.displayBandIndexes - {Array<integer>}
     * @description 返回当前影像图层显示的波段索引。
     */
    _this.displayBandIndexes = null;

    /**
     * @member SuperMap.Image.prototype.transparent - {boolean}
     * @description 是否背景透明。
     */
    _this.transparent = null;

    /**
     * @member SuperMap.Image.prototype.transparentColor - {SuperMap.ServerColor}
     * @description 返回背景透明色。
     */
    _this.transparentColor = null;

    /**
     * @member SuperMap.Image.prototype.transparentColorTolerance - {integer}
     * @description 背景透明色容限。
     */
    _this.transparentColorTolerance = null;

    _this.CLASS_NAME = "SuperMap.Image";
    return _this;
  }

  /**
   * @function SuperMap.Image.prototype.destroy
   * @override
   */


  _createClass(UGCImage, [{
    key: 'destroy',
    value: function destroy() {
      _get(UGCImage.prototype.__proto__ || Object.getPrototypeOf(UGCImage.prototype), 'destroy', this).call(this);
      _Util.Util.reset(this);
    }

    /**
     * @function SuperMap.Image.prototype.fromJson
     * @description 将服务端JSON对象转换成当前客户端对象。
     * @param jsonObject - {Object} 要转换的 JSON 对象。
     */

  }, {
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      _get(UGCImage.prototype.__proto__ || Object.getPrototypeOf(UGCImage.prototype), 'fromJson', this).call(this, jsonObject);
      if (this.transparentColor) {
        this.transparentColor = new _ServerColor.ServerColor(this.transparentColor.red, this.transparentColor.green, this.transparentColor.blue);
      }
    }

    /**
     * @function SuperMap.Image.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     */

  }, {
    key: 'toServerJSONObject',
    value: function toServerJSONObject() {
      return _get(UGCImage.prototype.__proto__ || Object.getPrototypeOf(UGCImage.prototype), 'toServerJSONObject', this).call(this);
    }
  }]);

  return UGCImage;
}(_UGCSubLayer2.UGCSubLayer);

_SuperMap.SuperMap.Image = UGCImage;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InterpolationIDWAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _InterpolationAnalystParameters = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationIDWAnalystParameters
 * @classdesc 反距离加权插值（IDW）分析参数类。
 * @param options - {Object}可选参数。如:</br>
 *        power - {number}距离权重计算的幂次。</br>
 *        bounds - {Object} 插值分析的范围，用于确定结果栅格数据集的范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchMode - {string} 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。必设参数。</br>
 *        expectedCount - {number}【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。</br>
 *        searchRadius - {number}【定长查找】方式下，设置查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number} 用于进行插值分析值的缩放比率，默认为1。</br>
 *        resolution - {number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {{@link SuperMap.FilterParameter}} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。必设参数。</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数。</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <Object>} 用于做插值分析的离散点集合。当插值分析类型（SuperMap.InterpolationAnalystType）为 geometry 时，必设参数。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.InterpolationAnalystParameters
 * @example 例如：
 * var myInterpolationIDWAnalystParameters = new SuperMap.InterpolationIDWAnalystParameters({
 *      dataset:"SamplesP@Interpolation",
 *      power: 2,
 *      searchMode: "KDTREE_FIXED_COUNT",
 *      expectedCount: 12,
 *      pixelFormat: "BIT16",
 *      zValueFieldName: "AVG_TMP",
 *      resolution: 3000,
 *      filterQueryParameter: {
 *          attributeFilter: ""
 *      },
 *      outputDatasetName: "myIDW"
 * });
 *
 */
var InterpolationIDWAnalystParameters = exports.InterpolationIDWAnalystParameters = function (_InterpolationAnalyst) {
  _inherits(InterpolationIDWAnalystParameters, _InterpolationAnalyst);

  function InterpolationIDWAnalystParameters(options) {
    _classCallCheck(this, InterpolationIDWAnalystParameters);

    /**
     * @member SuperMap.InterpolationIDWAnalystParameters.prototype.power - {number}
     * @description 距离权重计算的幂次，默认值为2。
     * 该值决定了权值下降的速度，幂次越大，随距离的增大权值下降越快，距离预测点越远的点的权值也越小。
     * 理论上，参数值必须大于0，但是0.5到3之间时运算结果更合理，因此推荐值为0.5~3。
     */
    var _this = _possibleConstructorReturn(this, (InterpolationIDWAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationIDWAnalystParameters)).call(this, options));

    _this.power = 2;

    /**
     * @member SuperMap.InterpolationIDWAnalystParameters.prototype.searchMode - {SuperMap.SearchMode}
     * @description 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。必设参数。
     * 具体如下：
     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
     */
    _this.searchMode = null;

    /**
     * @member SuperMap.InterpolationIDWAnalystParameters.prototype.expectedCount - {number}
     * @description 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
     */
    _this.expectedCount = 12;
    if (options) {
      _Util.Util.extend(_this, options);
    }
    _this.CLASS_NAME = "SuperMap.InterpolationIDWAnalystParameters";
    return _this;
  }

  /**
   * @function SuperMap.InterpolationIDWAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(InterpolationIDWAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(InterpolationIDWAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationIDWAnalystParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.power = null;
      me.searchMode = null;
      me.expectedCount = null;
    }
  }]);

  return InterpolationIDWAnalystParameters;
}(_InterpolationAnalystParameters.InterpolationAnalystParameters);

_SuperMap.SuperMap.InterpolationIDWAnalystParameters = InterpolationIDWAnalystParameters;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InterpolationKrigingAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

__webpack_require__(73);

var _InterpolationAnalystParameters = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationKrigingAnalystParameters
 * @classdesc 克吕金插值分析参数类。
 * @description 通过该类可以设置克吕金插值分析所需的参数。
 * 克吕金（Kriging）法为地统计学上一种空间数据内插处理方法，主要的目的是利用各数据点间变异数（variance）的大小来推求某一未知点与各已知点的权重关系，
 * 再由各数据点的值和其与未知点的权重关系推求未知点的值。Kriging 法最大的特色不仅是提供一个最小估计误差的预测值，并且可明确的指出误差值的大小。
 * 一般而言，许多地质参数，如地形面，本身即具有连续性，故在一段距离内的任两点必有空间上的关系。反之，在一不规则面上的两点若相距甚远，
 * 则在统计意义上可视为互为独立 (stastically indepedent)。这种随距离而改变的空间上连续性，可用半变异图 (semivariogram) 来表现。
 * 因此，若想由已知的散乱点来推求某一未知点的值，则可利用半变异图推求各已知点与未知点的空间关系，即以下四个参数。
 * 然后，由此空间参数推求半变异数，由各数据点间的半变异数可推求未知点与已知点间的权重关系，进而推求出未知点的值。<br>
 *
 * · 块金值（nugget）：当采样点间距为0时，理论上半变异函数值为0，但时间上两采样点非常接近时半变异函数值并不为0，即产生了上图所示的块金效应，
 * 对应的半变异函数值为块金值。块金值可能由于测量误差或者空间变异产生。<br>
 *
 * · 基台值（sill）：随着采样点间距的不断增大，半变异函数的值趋向一个稳定的常数，该常数成为基台值。到达基台值后，半变异函数的值不再随采样点间距而改变，
 *   即大于此间距的采样点不再具有空间相关性。<br>
 *
 * · 偏基台值：基台值与块金值的差值。<br>
 *
 * · 自相关阈值（range）：也称变程，是半变异函数值达到基台值时，采样点的间距。超过自相关阈值的采样点不再具有空间相关性，将不对预测结果产生影响。<br>
 *
 * 由上述可知，半变异函数是克吕金插值的关键，因此选择合适的半变异函数模型非常重要，SuperMap提供了以下三种半变异函数模型：<br>
 *
 * · 指数型（EXPONENTIAL）：适用于空间相关关系随样本间距的增加成指数递减的情况，其空间自相关关系在样本间距的无穷远处完全消失。<br>
 *
 * · 球型（SPHERICAL）：适用于空间自相关关系随样本间距的增加而逐渐减少，直到超出一定的距离时空间自相关关系消失的情况。<br>
 *
 * · 高斯型（GAUSSIAN）：适用于半变异函数值渐进地逼近基台值的情况。<br>
 *
 * 半变异函数中，有一个关键参数即插值的字段值的期望（平均值），由于对于此参数的不同处理方法而衍生出了不同的Kriging方法。SuperMap的差值功能基于以下三种常用Kriging算法：<br>
 *
 * １. 简单克吕金（Simple Kriging）：该方法假定用于插值的字段值的期望（平均值）已知的某一常数。<br>
 *
 * ２. 普通克吕金（Kriging）：该方法假定用于插值的字段值的期望（平均值）未知且恒定。它利用一定的数学函数，通过对给定的空间点进行拟合来估算单元格的值，
 *      生成格网数据集。它不仅可以生成一个表面，还可以给出预测结果的精度或者确定性的度量。因此，此方法计算精度较高，常用于地学领域。<br>
 *
 * ３. 泛克吕金（Universal Kriging）：该方法假定用于插值的字段值的期望（平均值）是未知的变量。在样点数据中存在某种主导趋势且该趋势可以通过某一个确定
 *      的函数或者多项式进行拟合的情况下，适用泛克吕金插值法。<br>
 *
 * 克吕金法的优点是以空间统计学作为其坚实的理论基础，物理含义明确；不但能估计测定参数的空间变异分布，而且还可以估算参数的方差分布。克吕金法的缺点是计算步骤较烦琐，
 * 计算量大，且变异函数有时需要根据经验人为选定。
 * @param options - {Object} 可选参数。如:<br>
 *        type - {string} 克吕金插值的类型。必设参数。<br>
 *        mean - {number} 【简单克吕金】类型下,插值字段的平均值。<br>
 *        angle - {number} 克吕金算法中旋转角度值，默认值为0。<br>
 *        nugget - {number} 克吕金算法中块金效应值，默认值为0。<br>
 *        range - {number} 克吕金算法中自相关阈值，单位与原数据集单位相同，默认值为0。<br>
 *        sill - {number} 克吕金算法中基台值，默认值为0。<br>
 *        variogramMode - {string} 克吕金插值时的半变函数类型，默认为球型（SPHERICAL）。<br>
 *        exponent - {string} 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数，可选值为exp1、exp2，默认值为exp1。<br>
 *        bounds - {Object} 插值分析的范围，用于确定结果栅格数据集的范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *        searchMode - {string} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找，必设参数。<br>
 *        expectedCount - {number} 【固定点数查找】方式下，设置待查找的点数，默认值为12；【定长查找】方式下，设置查找的最小点数，默认值为12。<br>
 *        searchRadius - {number} 【定长查找】方式下，设置参与运算点的查找范围，默认值为0。<br>
 *        maxPointCountForInterpolation - {number} 【块查找】方式下，设置最多参与插值的点数，默认值为200。<br>
 *        maxPointCountInNode - {number} 【块查找】方式下，设置单个块内最多参与运算点数，默认值为50。<br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。<br>
 *        zValueScale - {number} 用于进行插值分析值的缩放比率，默认值为1。<br>
 *        resolution - {number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。<br>
 *        filterQueryParameter - {{@link SuperMap.FilterParameter}} 属性过滤条件。<br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称，必设参数。<br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数<br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。<br>
 *        dataset - {string} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。<br>
 *        inputPoints - {Array <Object} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
 * @extends SuperMap.InterpolationAnalystParameters
 * @example 例如：
 * var myInterpolationKrigingAnalystParameters = new SuperMap.InterpolationKrigingAnalystParameters({
 *     dataset:"SamplesP@Interpolation",
 *     type: "KRIGING",
 *     angle: 0,
 *     mean: 5,
 *     nugget: 30,
 *     range: 50,
 *     sill: 300,
 *     variogramMode: "EXPONENTIAL",
 *     searchMode: "QUADTREE",
 *     maxPointCountForInterpolation: 20,
 *     maxPointCountInNode: 5,
 *     pixelFormat: "BIT16",
 *     zValueFieldName: "AVG_TMP",
 *     resolution: 30000,
 *     filterQueryParameter: {
 *         attributeFilter: ""
 *     },
 *     outputDatasetName: "myKriging"
 * });
 *
 */
var InterpolationKrigingAnalystParameters = exports.InterpolationKrigingAnalystParameters = function (_InterpolationAnalyst) {
  _inherits(InterpolationKrigingAnalystParameters, _InterpolationAnalyst);

  function InterpolationKrigingAnalystParameters(options) {
    _classCallCheck(this, InterpolationKrigingAnalystParameters);

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.type - {SuperMap.InterpolationAlgorithmType}
     * @description 克吕金插值的类型。必设参数。
     * 具体如下：
     * {KRIGING} 普通克吕金插值法。
     * {SimpleKriging} 简单克吕金插值法。
     * {UniversalKriging} 泛克吕金插值法。
     */
    var _this = _possibleConstructorReturn(this, (InterpolationKrigingAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationKrigingAnalystParameters)).call(this, options));

    _this.type = null;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.mean - {number}
     * @description 【简单克吕金】方式下，插值字段的平均值。
     * 即采样点插值字段值总和除以采样点数目。
     */
    _this.mean = null;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.angle - {number}
     * @description 克吕金算法中旋转角度值。默认值为0。
     * 此角度值指示了每个查找邻域相对于水平方向逆时针旋转的角度。
     */
    _this.angle = 0;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.nugget - {number}
     * @description 克吕金算法中块金效应值。默认值为0。
     */
    _this.nugget = 0;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.range - {number}
     * @description 克吕金算法中自相关阈值，单位与原数据集单位相同。默认值为0。
     */
    _this.range = 0;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.sill - {number}
     * @description 克吕金算法中基台值。默认值为0。
     */
    _this.sill = 0;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.variogramMode - {SuperMap.VariogramMode}
     * @description 克吕金插值时的半变函数类型。
     * 默认值为 SuperMap.VariogramMode.SPHERICAL。
     * 用户所选择的半变函数类型会影响未知点的预测，特别是曲线在原点处的不同形状有重要意义。
     * 曲线在原点处越陡，则较近领域对该预测值的影响就越大，因此输出表面就会越不光滑。
     */
    _this.variogramMode = _REST.VariogramMode.SPHERICAL;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.exponent - {SuperMap.Exponent}
     * @description 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数。
     * 默认值为 SuperMap.Exponent.EXP1。
     */
    _this.exponent = _REST.Exponent.EXP1;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.searchMode - {SuperMap.SearchMode}
     * @description 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数。
     * 简单克吕金和泛克吕金不支持块查找。
     * 具体如下：
     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
     */
    _this.searchMode = null;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.expectedCount - {number}
     * @description 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数，默认值为12。
     * 【定长查找】方式下，设置查找的最小点数，默认值为12。
     */
    _this.expectedCount = 12;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.maxPointCountForInterpolation - {number}
     * @description 【块查找】方式下，最多参与插值的点数。默认值为200。
     * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
     */
    _this.maxPointCountForInterpolation = 200;

    /**
     * @member SuperMap.InterpolationKrigingAnalystParameters.prototype.maxPointCountForInterpolation - {number}
     * @description 【块查找】方式下，设置单个块内最多参与运算点数。默认值为50。
     * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
     */
    _this.maxPointCountInNode = 50;
    if (options) {
      _Util.Util.extend(_this, options);
    }
    _this.CLASS_NAME = "SuperMap.InterpolationKrigingAnalystParameters";
    return _this;
  }

  /**
   * @function SuperMap.InterpolationKrigingAnalystParameters.prototype.destroy
   *
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(InterpolationKrigingAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(InterpolationKrigingAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationKrigingAnalystParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.type = null;
      me.mean = null;
      me.angle = null;
      me.nugget = null;
      me.range = null;
      me.sill = null;
      me.variogramMode = null;
      me.exponent = null;
      me.searchMode = null;
      me.expectedCount = null;
      me.maxPointCountForInterpolation = null;
      me.maxPointCountInNode = null;
    }
  }]);

  return InterpolationKrigingAnalystParameters;
}(_InterpolationAnalystParameters.InterpolationAnalystParameters);

_SuperMap.SuperMap.InterpolationKrigingAnalystParameters = InterpolationKrigingAnalystParameters;

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InterpolationRBFAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _InterpolationAnalystParameters = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationRBFAnalystParameters
 * @classdesc 样条插值（径向基函数插值法）分析参数类。
 * @extends SuperMap.InterpolationAnalystParameters
 * @param options - {Object} 可选参数。如：</br>
 *        smooth - {number} 光滑系数，该值表示插值函数曲线与点的逼近程度，值域为 0到1，默认值为0.1。</br>
 *        tension - {number} 张力系数，用于调整结果栅格数据表面的特性，默认为40。</br>
 *        bounds - {Object} 插值分析的范围，用于确定结果栅格数据集的范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchMode - {string} 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数。</br>
 *        expectedCount - {number} 【固定点数查找】方式下，设置参与差值运算的点数，默认值为12。</br>
 *        searchRadius - {number} 【定长查找】方式下，设置参与运算点的查找范围，默认值为0。</br>
 *        maxPointCountForInterpolation - {number} 【块查找】方式下，设置最多参与插值的点数。默认为200。</br>
 *        maxPointCountInNode - {number} 【块查找】方式下，设置单个块内最多参与运算点数。默认为50。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number} 用于进行插值分析值的缩放比率，默认值为1。</br>
 *        resolution - {number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {{@link SuperMap.FilterParameter}} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。必设参数。</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数。</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <Object>} 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，必设参数。点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
 * @example
 * var myInterpolationRBFAnalystParameters = new SuperMap.InterpolationRBFAnalystParameters({
 *     dataset:"SamplesP@Interpolation",
 *     smooth: 0.1,
 *     tension: 40,
 *     searchMode: "QUADTREE",
 *     maxPointCountForInterpolation: 20,
 *     maxPointCountInNode: 5,
 *     pixelFormat: "BIT16",
 *     zValueFieldName: "AVG_TMP",
 *     resolution: 3000,
 *     filterQueryParameter: {
 *         attributeFilter: ""
 *     },
 *     outputDatasetName: "myRBF"
 * });
 */
var InterpolationRBFAnalystParameters = exports.InterpolationRBFAnalystParameters = function (_InterpolationAnalyst) {
  _inherits(InterpolationRBFAnalystParameters, _InterpolationAnalyst);

  function InterpolationRBFAnalystParameters(options) {
    _classCallCheck(this, InterpolationRBFAnalystParameters);

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.smooth - {number}
     * @description 光滑系数，值域为 0到1，默认值为0.1，常用取值如0、0.001、0.01、0.1、和0.5。
     * 该值表示插值函数曲线与点的逼近程度，此数值越大，函数曲线与点的偏差越大，反之越小。
     */
    var _this = _possibleConstructorReturn(this, (InterpolationRBFAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationRBFAnalystParameters)).call(this, options));

    _this.smooth = 0.1;

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.tension - {number}
     * @description 张力系数，默认为40，常用取值如0、1、5和10。
     * 用于调整结果栅格数据表面的特性，张力越大，插值时每个点对计算结果影响越小，反之越大。
     */
    _this.tension = 40;

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.searchMode - {SuperMap.SearchMode}
     * @description 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数。
     * 具体如下：
     * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
     * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
     * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
     */
    _this.searchMode = null;

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.expectedCount - {number}
     * @description 【固定点数查找】方式下，设置待查找的点数，即参与差值运算的点数。默认值为12。
     */
    _this.expectedCount = 12;

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.maxPointCountForInterpolation - {number}
     * @description 【块查找】方式下，最多参与插值的点数。默认值为200。
     */
    _this.maxPointCountForInterpolation = 200;

    /**
     * @member SuperMap.InterpolationRBFAnalystParameters.prototype.maxPointCountInNode - {number}
     * @description 【块查找】方式下，单个块内最多参与运算点数。默认值为50。
     */
    _this.maxPointCountInNode = 50;

    if (options) {
      _Util.Util.extend(_this, options);
    }
    _this.CLASS_NAME = "SuperMap.InterpolationRBFAnalystParameters";

    return _this;
  }

  /**
   * @function SuperMap.InterpolationRBFAnalystParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(InterpolationRBFAnalystParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(InterpolationRBFAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationRBFAnalystParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.smooth = null;
      me.tension = null;
      me.searchMode = null;
      me.expectedCount = null;
      me.maxPointCountForInterpolation = null;
      me.maxPointCountInNode = null;
    }

    /**
     * @function SuperMap.InterpolationRBFAnalystParameters.toObject
     * @param datasetInterpolationRBFAnalystParameters - {SuperMap.InterpolationRBFAnalystParameters} 样条插值（径向基函数插值法）分析参数类
     * @param tempObj - {SuperMap.InterpolationRBFAnalystParameters} 样条插值（径向基函数插值法）分析参数对象
     * @description 将样条插值（径向基函数插值法）分析参数对象转换为JSON对象。
     * @return JSON对象。
     */

  }], [{
    key: 'toObject',
    value: function toObject(datasetInterpolationRBFAnalystParameters, tempObj) {
      for (var name in datasetInterpolationRBFAnalystParameters) {
        tempObj[name] = datasetInterpolationRBFAnalystParameters[name];
      }
    }
  }]);

  return InterpolationRBFAnalystParameters;
}(_InterpolationAnalystParameters.InterpolationAnalystParameters);

_SuperMap.SuperMap.InterpolationRBFAnalystParameters = InterpolationRBFAnalystParameters;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.KernelDensityJobParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.KernelDensityJobParameter
 * @classdesc 密度分析任务参数类。
 * @param options - {Object} 可选参数。如：<br>
 *        datasetName - {string} 数据集名。<br>
 *        query - {Object} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *        resolution - {number} 分辨率。<br>
 *        method - {number} 分析方法。<br>
 *        meshType - {number} 分析类型。<br>
 *        fields - {string} 权重索引。<br>
 *        radius - {number} 分析的影响半径。
 */
var KernelDensityJobParameter = exports.KernelDensityJobParameter = function () {
  function KernelDensityJobParameter(options) {
    _classCallCheck(this, KernelDensityJobParameter);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.datasetName - {string}
     * @description 数据集名。
     */
    this.datasetName = "";

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.query - {Object}
     * @description 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。 <br>
     */
    this.query = "";

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.resolution - {number}
     * @description 网格大小。
     */
    this.resolution = 80;

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.method - {number}
     * @description 分析方法。
     */
    this.method = 0;

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.meshType - {number}
     * @description 分析类型。
     */
    this.meshType = 0;

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.fields - {string}
     * @description 权重索引。
     */
    this.fields = "";

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.radius - {number}
     * @description 分析的影响半径。
     */
    this.radius = 300;

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.meshSizeUnit - {SuperMap.AnalystSizeUnit}
     * @description 网格大小单位。
     */
    this.meshSizeUnit = _REST.AnalystSizeUnit.METER;

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.radiusUnit - {SuperMap.AnalystSizeUnit}
     * @description 搜索半径单位。
     */
    this.radiusUnit = _REST.AnalystSizeUnit.METER;

    /**
     * @member SuperMap.KernelDensityJobParameter.prototype.areaUnit - {SuperMap.AnalystAreaUnit}
     * @description 面积单位。
     */
    this.areaUnit = _REST.AnalystAreaUnit.SQUAREMILE;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.KernelDensityJobParameter";
  }

  /**
   * @function SuperMap.KernelDensityJobParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(KernelDensityJobParameter, [{
    key: 'destroy',
    value: function destroy() {
      this.datasetName = null;
      this.query = null;
      this.resolution = null;
      this.method = null;
      this.radius = null;
      this.meshType = null;
      this.fields = null;
      this.meshSizeUnit = null;
      this.radiusUnit = null;
      this.areaUnit = null;
    }

    /**
     * @function SuperMap.KernelDensityJobParameter.toObject
     * @param kernelDensityJobParameter -{SuperMap.KernelDensityJobParameter} 密度分析任务参数类。
     * @param tempObj - {SuperMap.KernelDensityJobParameter} 密度分析任务参数对象。
     * @description 将密度分析任务参数对象转换为JSON对象。
     * @return JSON对象。
     */

  }], [{
    key: 'toObject',
    value: function toObject(kernelDensityJobParameter, tempObj) {
      for (var name in kernelDensityJobParameter) {
        if (name === "datasetName") {
          tempObj['input'] = tempObj['input'] || {};
          tempObj['input'][name] = kernelDensityJobParameter[name];
          continue;
        }
        tempObj['analyst'] = tempObj['analyst'] || {};
        if (name === 'query') {
          tempObj['analyst'][name] = kernelDensityJobParameter[name].toBBOX();
        } else {
          tempObj['analyst'][name] = kernelDensityJobParameter[name];
        }
      }
    }
  }]);

  return KernelDensityJobParameter;
}();

_SuperMap.SuperMap.KernelDensityJobParameter = KernelDensityJobParameter;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LabelImageCell = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _LabelMatrixCell2 = __webpack_require__(67);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.LabelImageCell
 * @classdesc 图片类型的矩阵标签元素类。
 * @description 该类继承自 {@link SuperMap.LabelMatrixCell}类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（{@link SuperMap.LabelImageCell}）、
 *              符号类型（{@link SuperMap.LabelSymbolCell}）、专题图类型（{@link SuperMap.LabelThemeCell}）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 {@link SuperMap.ThemeLabel.matrixCells} 属性即可。matrixCells 属是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends SuperMap.LabelMatrixCell
 * @param options - {Object} 可选参数。如：<br>
 *        height - {number}设置图片的高度，单位为毫米。<br>
 *        pathField - {string} 设置矩阵标签元素所使用图片的路径。<br>
 *        rotation - {number}图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。<br>
 *        width - {number}设置图片的宽度，单位为毫米。<br>
 *        sizeFixed - {boolean} 是否固定图片的大小。默认值为 false，即图片将随地图缩放。
 */
var LabelImageCell = exports.LabelImageCell = function (_LabelMatrixCell) {
  _inherits(LabelImageCell, _LabelMatrixCell);

  function LabelImageCell(options) {
    _classCallCheck(this, LabelImageCell);

    /**
     * @member SuperMap.LabelImageCell.prototype.height -{number}
     * @description 设置图片的高度，单位为毫米。
     */
    var _this = _possibleConstructorReturn(this, (LabelImageCell.__proto__ || Object.getPrototypeOf(LabelImageCell)).call(this, options));

    _this.height = 0;

    /**
     * @member SuperMap.LabelImageCell.prototype.pathField -{string}
     * @description 设置矩阵标签元素所使用的图片路径对应的字段名。
     */
    _this.pathField = null;

    /**
     * @member SuperMap.LabelImageCell.prototype.rotation -{number}
     * @description 图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。默认值为0.0。
     */
    _this.rotation = 0.0;

    /**
     * @member SuperMap.LabelImageCell.prototype.width -{number}
     * @description 设置图片的宽度，单位为毫米。
     */
    _this.width = 0;

    /**
     * @member SuperMap.LabelImageCell.prototype.sizeFixed -{boolean}
     * @description 是否固定图片的大小。默认值为 false，即图片将随地图缩放。
     */
    _this.sizeFixed = false;

    /**
     * @member SuperMap.LabelImageCell.prototype.type -{boolean}
     * @description 制作矩阵专题图时是必须的。
     */
    _this.type = "IMAGE";

    if (options) {
      _Util.Util.extend(_this, options);
    }

    _this.CLASS_NAME = "SuperMap.LabelImageCell";
    return _this;
  }

  /**
   * @function SuperMap.LabelImageCell.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(LabelImageCell, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.height = null;
      me.pathField = null;
      me.rotation = null;
      me.width = null;
      me.sizeFixed = null;
    }
  }]);

  return LabelImageCell;
}(_LabelMatrixCell2.LabelMatrixCell);

_SuperMap.SuperMap.LabelImageCell = LabelImageCell;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LabelMixedTextStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerTextStyle = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LabelMixedTextStyle
 * @classdesc 标签文本复合风格类。
 * @description 该类主要用于对标签专题图中标签的文本内容进行风格设置。通过该类用户可以使标签的文字显示不同的风格，
 *              比如文本 “喜马拉雅山”，通过本类可以将前三个字用红色显示，后两个字用蓝色显示。
 *              对同一文本设置不同的风格实质上是对文本的字符进行分段，同一分段内的字符具有相同的显示风格。
 *              对字符分段有两种方式，一种是利用分隔符对文本进行分段；另一种是根据分段索引值进行分段。<br>
 *              1. 利用分隔符对文本进行分段: 比如文本 “5&109” 被分隔符 “&” 分为“5”和“109”两部分，
 *                 在显示时，“5” 和分隔符 “&” 使用同一个风格，字符串 “109” 使用相同的风格。<br>
 *              2. 利用分段索引值进行分段: 文本中字符的索引值是以0开始的整数，比如文本“珠穆朗玛峰”，
 *                 第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为1，以此类推；当设置分段索引值为1，3，4，9时，
 *                 字符分段范围相应的就是(-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，可以看出索引号为0的字符（即“珠” ）在第一个分段内，
 *                 索引号为1，2的字符（即“穆”、“朗”）位于第二个分段内，索引号为3的字符（“玛”）在第三个分段内，索引号为4的字符（“峰”）在第四个分段内，其余分段中没有字符。
 * @param options - {Object} 可选参数。如：<br>
 *        defaultStyle - {{@link SuperMap.ServerTextStyle}} 默认的文本复合风格。<br>
 *        separator - {string} 文本的分隔符。<br>
 *        separatorEnabled - Boolean} 文本的分隔符是否有效。<br>
 *        splitIndexes - {Array<number>} 分段索引值，分段索引值用来对文本中的字符进行分段。<br>
 *        styles - {Array<{@link SuperMap.ServerTextStyle}>} 文本样式集合。
 */
var LabelMixedTextStyle = exports.LabelMixedTextStyle = function () {
    function LabelMixedTextStyle(options) {
        _classCallCheck(this, LabelMixedTextStyle);

        /**
         * @member SuperMap.LabelMixedTextStyle.prototype.defaultStyle -{SuperMap.ServerTextStyle}
         * @description 默认的文本复合风格，即 SuperMap.ServerTextStyle 各字段的默认值。
         */
        this.defaultStyle = null;

        /**
         * @member SuperMap.LabelMixedTextStyle.prototype.separator -{string}
         * @description 文本的分隔符，分隔符的风格与前一个字符的风格一样。文本的分隔符是一个将文本分割开的符号，
         *              比如文本 “5_109” 被 “_” 隔符为 “5” 和 “109” 两部分，假设有风格数组：style1、style2。
         *              在显示时，“5” 和分隔符 “_” 使用 Style1 风格渲染，字符串 “109” 使用 Style2 的风格。
         */
        this.separator = null;

        /**
         * @member SuperMap.LabelMixedTextStyle.prototype.separatorEnabled -{boolean}
         * @description 文本的分隔符是否有效。分隔符有效时利用分隔符对文本进行分段；无效时根据文本中字符的位置进行分段。
         *              分段后，同一分段内的字符具有相同的显示风格。默认为 false。
         */
        this.separatorEnabled = false;

        /**
         * @member SuperMap.LabelMixedTextStyle.prototype.splitIndexes -{Array<number>}
         * @description 分段索引值，分段索引值用来对文本中的字符进行分段。
         *              文本中字符的索引值是以0开始的整数，比如文本“珠穆朗玛峰”，第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为1，
         *              以此类推；当设置分段索引值数组为[1，3，4，9]时，字符分段范围相应的就是(-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，
         *              可以看出索引号为0的字符（即“珠” ）在第一个分段内，索引号为1，2的字符（即“穆”、“朗”）位于第二个分段内，
         *              索引号为3的字符（“玛”）在第三个分段内，索引号为4的字符（“峰”）在第四个分段内，其余分段中没有字符。
         */
        this.splitIndexes = null;

        /**
         * @member SuperMap.LabelMixedTextStyle.prototype.styles -{Array<SuperMap.ServerTextStyle>}
         * @description 文本样式集合。文本样式集合中的样式根据索引与不同分段一一对应，
         *              如果有分段没有风格对应则使用 defaultStyle。
         */
        this.styles = new _ServerTextStyle.ServerTextStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.LabelMixedTextStyle";
    }

    /**
     * @function SuperMap.LabelMixedTextStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(LabelMixedTextStyle, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.defaultStyle) {
                me.defaultStyle.destroy();
                me.defaultStyle = null;
            }
            me.separator = null;
            me.separatorEnabled = null;
            if (me.splitIndexes) {
                me.splitIndexes = null;
            }
            if (me.styles) {
                for (var i = 0, styles = me.styles, len = styles.length; i < len; i++) {
                    styles[i].destroy();
                }
                me.styles = null;
            }
        }

        /**
         * @function SuperMap.LabelMixedTextStyle.fromObj
         * @description 从传入对象获取标签文本复合风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.LabelMixedTextStyle} 返回新的LabelMixedTextStyle对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new LabelMixedTextStyle();
            var stys = obj.styles;
            _Util.Util.copy(res, obj);
            res.defaultStyle = new _ServerTextStyle.ServerTextStyle(obj.defaultStyle);
            if (stys) {
                res.styles = [];
                for (var i = 0, len = stys.length; i < len; i++) {
                    res.styles.push(new _ServerTextStyle.ServerTextStyle(stys[i]));
                }
            }
            return res;
        }
    }]);

    return LabelMixedTextStyle;
}();

_SuperMap.SuperMap.LabelMixedTextStyle = LabelMixedTextStyle;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LabelSymbolCell = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerStyle = __webpack_require__(11);

var _LabelMatrixCell2 = __webpack_require__(67);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.LabelSymbolCell
 * @classdesc 符号类型的矩阵标签元素类。
 * @description 该类继承自 {@link SuperMap.LabelMatrixCell}类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（{@link SuperMap.ThemeLabel}）的一种，其中矩阵标签中的填充元素又可分为图片类型（{@link SuperMap.LabelImageCell}）、
 *              符号类型（{@link SuperMap.LabelSymbolCell}）、专题图类型（{@link SuperMap.LabelThemeCell}）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 {@link SuperMap.ThemeLabel.matrixCells} 属性即可。matrixCells 属是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends SuperMap.LabelMatrixCell
 * @param options - {Object} 可选参数。如：<br>
 *        style - {{@link SuperMap.ServerStyle}} 获取或设置符号样式—— {@link SuperMap.ServerStyle} 对象。<br>
 *        symbolIDField - {string} 符号 ID 或符号 ID 所对应的字段名称。
 */
var LabelSymbolCell = exports.LabelSymbolCell = function (_LabelMatrixCell) {
    _inherits(LabelSymbolCell, _LabelMatrixCell);

    function LabelSymbolCell(options) {
        _classCallCheck(this, LabelSymbolCell);

        /**
         * @member SuperMap.LabelSymbolCell.prototype.style -{SuperMap.ServerStyle}
         * @description 获取或设置符号样式—— {@link SuperMap.ServerStyle} 对象，包括符号大小（{@link SuperMap.ServerStyle.markerSize}）
         *              和符号旋转（{@link SuperMap.ServerStyle.markerAngle}）角度，其中用于设置符号 ID 的属性（{@link SuperMap.ServerStyle.markerSymbolID}）在此处不起作用。
         */
        var _this = _possibleConstructorReturn(this, (LabelSymbolCell.__proto__ || Object.getPrototypeOf(LabelSymbolCell)).call(this, options));

        _this.style = new _ServerStyle.ServerStyle();

        /**
         * @member SuperMap.LabelSymbolCell.prototype.symbolIDField -{string}
         * @description 获取或设置符号 ID 或符号 ID 所对应的字段名称，必设属性。
         */
        _this.symbolIDField = null;

        /**
         * @member SuperMap.LabelSymbolCell.prototype.type -{string}
         * @description 制作矩阵专题图时是必须的。
         */
        _this.type = "SYMBOL";

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.LabelSymbolCell";
        return _this;
    }

    /**
     * @function SuperMap.LabelSymbolCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(LabelSymbolCell, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.symbolIDField = null;
        }
    }]);

    return LabelSymbolCell;
}(_LabelMatrixCell2.LabelMatrixCell);

_SuperMap.SuperMap.LabelSymbolCell = LabelSymbolCell;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LabelThemeCell = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ThemeLabel = __webpack_require__(71);

var _LabelMatrixCell2 = __webpack_require__(67);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.LabelThemeCell
 * @classdesc 专题图类型的矩阵标签元素类。
 * @description 该类继承自 {@link SuperMap.LabelMatrixCell}类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（{@link SuperMap.ThemeLabel}）的一种，其中矩阵标签中的填充元素又可分为图片类型（{@link SuperMap.LabelImageCell}）、
 *              符号类型（{@link SuperMap.LabelSymbolCell}）、专题图类型（{@link SuperMap.LabelThemeCell}）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应） 、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 {@link SuperMap.ThemeLabel.matrixCells} 属性即可。matrixCells 属是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends SuperMap.LabelMatrixCell
 * @param options - {Object} 可选参数。如：<br>
 *        themeLabel - {{@link SuperMap.ThemeLabel}} 使用专题图对象作为矩阵标签的一个元素。
 */
var LabelThemeCell = exports.LabelThemeCell = function (_LabelMatrixCell) {
    _inherits(LabelThemeCell, _LabelMatrixCell);

    function LabelThemeCell(options) {
        _classCallCheck(this, LabelThemeCell);

        /**
         * @member SuperMap.LabelThemeCell.prototype.themeLabel -{SuperMap.ThemeLabel}
         * @description 使用专题图对象作为矩阵标签的一个元素。
         */
        var _this = _possibleConstructorReturn(this, (LabelThemeCell.__proto__ || Object.getPrototypeOf(LabelThemeCell)).call(this, options));

        _this.themeLabel = new _ThemeLabel.ThemeLabel();

        /**
         * @member SuperMap.LabelThemeCell.prototype.type -{string}
         * @description 制作矩阵专题图时是必须的。
         */
        _this.type = "THEME";

        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = " SuperMap.LabelThemeCell";
        return _this;
    }

    /**
     * @function SuperMap.LabelThemeCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(LabelThemeCell, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.themeLabel) {
                me.themeLabel.destroy();
                me.themeLabel = null;
            }
        }
    }]);

    return LabelThemeCell;
}(_LabelMatrixCell2.LabelMatrixCell);

_SuperMap.SuperMap.LabelThemeCell = LabelThemeCell;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LayerStatus = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LayerStatus
 * @classdesc 子图层显示参数类。
 * @description 该类存储了各个子图层的名字和是否可见的状态。
 * @param options - {Object} 可选参数。如：<br>
 *        layerName - {string} 获取或设置图层名称。<br>
 *        isVisible - {boolean} 获取或设置图层是否可见，true 表示可见。<br>
 *        displayFilter - {string} 图层显示 SQL 过滤条件。
 */
var LayerStatus = exports.LayerStatus = function () {
    function LayerStatus(options) {
        _classCallCheck(this, LayerStatus);

        /**
         * @member SuperMap.LayerStatus.prototype.layerName -{string}
         * @description 获取或设置图层名称。必设属性。
         */
        this.layerName = null;

        /**
         * @member SuperMap.LayerStatus.prototype.isVisible -{boolean}
         * @description 获取或设置图层是否可见，true 表示可见。必设属性。
         */
        this.isVisible = null;

        /**
         * @member SuperMap.LayerStatus.prototype.displayFilter -{string}
         * @description 图层显示 SQL 过滤条件，如 layerStatus.displayFilter = "smid < 10"，表示仅显示 smid 值小于 10 的对象。
         */
        this.displayFilter = null;

        /**
         * @member SuperMap.LayerStatus.prototype.fieldValuesDisplayFilter -{Object}
         * @description 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode,他们的作用如下：<br>
         *              values：{Array<number>} - 就是要过滤的值；<br>
         *              fieldName：{string} - 要过滤的字段名称 只支持数字类型的字段；<br>
         *              fieldValuesDisplayMode：{string} 目前有两个DISPLAY/DISABLE。当为DISPLAY时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素
         */
        this.fieldValuesDisplayFilter = null;

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.LayerStatus";
    }

    /**
     * @function SuperMap.LayerStatus.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(LayerStatus, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.layerName = null;
            me.isVisible = null;
            me.displayFilter = null;
        }

        /**
         * @function SuperMap.LayerStatus.prototype.toJSON
         * @description 生成对应的json。
         * @return {Object} 对应的json
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            var json = '{';
            json += '"type":"UGC",';
            var v = [];
            if (this.layerName) {
                v.push('"name":"' + this.layerName + '"');
                v.push('"visible":' + this.isVisible);
            }

            if (this.displayFilter) {
                v.push('"displayFilter":"' + this.displayFilter + '"');
            }

            if (this.minScale || this.minScale == 0) {
                v.push('"minScale":' + this.minScale);
            }

            if (this.maxScale || this.maxScale == 0) {
                v.push('"maxScale":' + this.maxScale);
            }

            if (this.fieldValuesDisplayFilter) {
                v.push('"fieldValuesDisplayFilter":' + _Util.Util.toJSON(this.fieldValuesDisplayFilter));
            }

            json += v;
            json += '}';

            return json;
        }
    }]);

    return LayerStatus;
}();

_SuperMap.SuperMap.LayerStatus = LayerStatus;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LinkItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _DatasourceConnectionInfo = __webpack_require__(165);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.LinkItem
 * @constructs SuperMap.LinkItem
 * @classdesc 关联信息类。
 * @description 该类用于矢量数据集与外部表的关联。 外部表是另一个数据集（其中纯属性数据集中没有空间几何信息）中的 DBMS 表,
 *              矢量数据集与外部表可以属于不同的数据源，但数据源类型目前只支持SQL Server和Oracle类型。使用LinkItem时，
 *              空间数据和属性数据必须满足关联条件，即主空间数据集与外部属性表之间存在关联字段。{@link SuperMap.LinkItem}
 *              只支持左连接，UDB、PostgreSQL 和 DB2 数据源不支持 {@link SuperMap.LinkItem};另外，用于建立关联关系的两个表可以不在同一个数据源下。<br>
 *
 *                  注意：
 *                    1. 使用 {@link SuperMap.LinkItem} 的约束条件为：空间数据和属性数据必须有关联条件，即主空间数据集与外部属性表之间存在关联字段；<br>
 *                    2. 使用外关联表制作专题图时，所关联的字段必须设置表名，例如，如果所关联的字段为BaseMap_R数据集的SmID，就要写成BaseMap_R.SMID。
 * @param options - {Object} 参数。</br>
 *        datasourceConnectionInfo - {{@link SuperMap.DatasourceConnectionInfo}} 关联的外部数据源信息。</br>
 *        foreignKeys - {Array<string>} 主空间数据集的外键。</br>
 *        foreignTable - {string} 关联的外部属性表的名称。</br>
 *        linkFields - {Array<string>} 欲保留的外部属性表的字段。</br>
 *        linkFilter - {string} 与外部属性表的连接条件。</br>
 *        name - {string} 此关联信息对象的名称。</br>
 *        primaryKeys - {Array<string>} 需要关联的外部属性表的主键。</br>
 * @example 下面以SQL查询说明linkitem的使用方法：
 *  function queryBySQL() {
 *      // 设置关联的外部数据库信息,alias表示数据库别名
 *      var dc = new SuperMap.DatasourceConnectionInfo({
 *          dataBase: "RelQuery",
 *          server: "192.168.168.39",
 *          user: "sa",
 *          password: "map",
 *          driver: "SQL Server",
 *          connect: true,
 *          OpenLinkTable: false,
 *          alias: "RelQuery",
 *          engineType: EngineType.SQLPLUS,
 *          readOnly: false,
 *          exclusive: false
 *      });
 *     // 设置关联信息
 *      var linkItem = new SuperMap.LinkItem({
 *          datasourceConnectionInfo: dc,
 *          foreignKeys: ["name"],
 *          foreignTable: "Pop_2011",
 *          linkFields: ["SmID as Pid","pop"],
 *          name: "link",
 *          primatryKeys: ["name"],
 *      });
 *      // 设置查询参数，在查询参数中添加linkItem关联条件信息
 *      var queryParam, queryBySQLParams, queryBySQLService;
 *      queryParam = new SuperMap.FilterParameter({
 *          name: "Province@RelQuery",
 *          fields: ["SmID","name"],
 *          attributeFilter: "SmID<7",
 *          linkItems: [linkItem]
 *       }),
 *      queryBySQLParams = new SuperMap.QueryBySQLParameters({
 *           queryParams: [queryParam]
 *              }),
 *      queryBySQLService = new SuperMap.QueryBySQLService(url, {
     *          eventListeners: {
     *              "processCompleted": processCompleted,
     *              "processFailed": processFailed
     *              }
     *      });
     *      queryBySQLService.processAsync(queryBySQLParams);
     *  }
 *  function processCompleted(queryEventArgs) {//todo}
 *  function processFailed(e) {//todo}
 *
 */
var LinkItem = exports.LinkItem = function () {
  function LinkItem(options) {
    _classCallCheck(this, LinkItem);

    /**
     * @member SuperMap.LinkItem.prototype.datasourceConnectionInfo -{SuperMap.DatasourceConnectionInfo}
     * @description 关联的外部数据源信息 。
     */
    this.datasourceConnectionInfo = null;

    /**
     * @member SuperMap.LinkItem.prototype.foreignKeys -{Array<string>}
     * @description 主空间数据集的外键。
     */
    this.foreignKeys = null;

    /**
     * @member SuperMap.LinkItem.prototype.foreignTable - {string}
     * @description 关联的外部属性表的名称，目前仅支持 Supermap 管理的表，即另一个矢量数据集所对应的 DBMS 表。
     */
    this.foreignTable = null;

    /**
     * @member SuperMap.LinkItem.prototype.linkFields - {Array<string>}
     * @description 欲保留的外部属性表的字段。如果不设置字段或者设置的字段在外部属性表中不存在的话则不返
     * 回任何外部属性表的属性信息。如果欲保留的外部表字段与主表字段存在同名，则还需要指定一个不存在字段名作为外部表的字段别名。
     */
    this.linkFields = null;

    /**
     * @member SuperMap.LinkItem.prototype.linkFilter -{string}
     * @description 与外部属性表的连接条件。
     */
    this.linkFilter = null;

    /**
     * @member SuperMap.LinkItem.prototype.name -{string}
     * @description 此关联信息对象的名称。
     */
    this.name = null;

    /**
     * @member SuperMap.LinkItem.prototype.primaryKeys -{Array<string>}
     * @description 需要关联的外部属性表的主键。
     */
    this.primaryKeys = null;

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.LinkItem";
  }

  /**
   * @function SuperMap.LinkItem.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(LinkItem, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.datasourceConnectionInfo instanceof _DatasourceConnectionInfo.DatasourceConnectionInfo) {
        me.datasourceConnectionInfo.destroy();
        me.datasourceConnectionInfo = null;
      }
      me.foreignKeys = null;
      me.foreignTable = null;
      me.linkFields = null;
      me.linkFilter = null;
      me.name = null;
      me.primaryKeys = null;
    }
  }]);

  return LinkItem;
}();

_SuperMap.SuperMap.LinkItem = LinkItem;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MathExpressionAnalysisParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.MathExpressionAnalysisParameters
 * @classdesc 栅格代数运算参数类
 * @param options - {Object} 可选参数。如：</br>
 *        dataset - {string} 要用来做栅格代数运算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。必设字段。</br>
 *        extractRegion - {Object} 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。</br>
 *                     面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *                     如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。</br>
 *        expression - {string} 指定的栅格运算表达式。如：[DatasourceAlias1.Raster1]*2-10；必设字段。</br>
 *        isZip - {boolean} 是否对结果数据集进行压缩处理。默认为 false，表示不压缩。</br>
 *        ignoreNoValue - {boolean} 是否忽略无值栅格数据。true表示忽略无值数据，即无值栅格不参与运算。默认为 false。</br>
 *        targetDatasource - {string} 指定存储结果数据集的数据源，必设字段。</br>
 *        resultGridName - {number}指定结果数据集名称，必设字段。</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。</br>
 */
var MathExpressionAnalysisParameters = exports.MathExpressionAnalysisParameters = function () {
    function MathExpressionAnalysisParameters(options) {
        _classCallCheck(this, MathExpressionAnalysisParameters);

        if (!options) {
            return;
        }
        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.dataset -{string}
         * @description 要用来做栅格代数运算数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
         *
         */
        this.dataset = null;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.extractRegion
         * @description 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。</br>
         * > 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
         * > 如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。
         */
        this.extractRegion = null;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.expression -{string}
         * @description 指定的栅格运算表达式。如："[DatasourceAlias1.Raster1]*2-10"；必设字段。
         */
        this.expression = null;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.isZip -{boolean}
         * @description 是否对结果数据集进行压缩处理。默认为false，表示不压缩。
         */
        this.isZip = false;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.ignoreNoValue -{boolean}
         * @description 是否忽略无值栅格数据，默认为false。
         */
        this.ignoreNoValue = false;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.targetDatasource -{string}
         * @description 指定存储结果数据集的数据源，必设字段。
         */
        this.targetDatasource = null;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.resultGridName -{string}
         * @description 指定结果数据集名称，必设字段。
         */
        this.resultGridName = null;

        /**
         * @member SuperMap.MathExpressionAnalysisParameters.prototype.deleteExistResultDataset -{boolean}
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
         */
        this.deleteExistResultDataset = false;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.MathExpressionAnalysisParameters";
    }

    /**
     * @function SuperMap.MathExpressionAnalysisParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(MathExpressionAnalysisParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.dataset = null;
            me.bounds = null;
            me.expression = null;
            me.isZip = true;
            me.ignoreNoValue = true;
            me.targetDatasource = null;
            me.resultGridName = null;
            me.deleteExistResultDataset = null;
        }

        /**
         * @function SuperMap.MathExpressionAnalysisParameters.toObject
         * @param mathExpressionAnalysisParameters -{Object} 栅格代数运算参数
         * @param tempObj - {Object} 目标对象
         * @description 生成栅格代数运算对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(mathExpressionAnalysisParameters, tempObj) {
            for (var name in mathExpressionAnalysisParameters) {
                if (name !== "dataset") {
                    tempObj[name] = mathExpressionAnalysisParameters[name];
                }

                if (name === "extractRegion") {
                    if (mathExpressionAnalysisParameters[name]) {
                        var bs = mathExpressionAnalysisParameters[name].components[0].components;
                        var region = {},
                            points = [],
                            type = "REGION";

                        var len = bs.length;
                        for (var i = 0; i < len - 1; i++) {
                            var poi = {};
                            poi["x"] = bs[i].x;
                            poi["y"] = bs[i].y;
                            points.push(poi);
                        }

                        region["points"] = points;
                        region["type"] = type;

                        tempObj[name] = region;
                    }
                }
            }
        }
    }]);

    return MathExpressionAnalysisParameters;
}();

_SuperMap.SuperMap.MathExpressionAnalysisParameters = MathExpressionAnalysisParameters;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MeasureParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.MeasureParameters
 * @classdesc 量算参数类。
 * @param geometry - {Object} 要量算的几何对象。<br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
 *                  线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
 *                  面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。<br>
 * @param options - {Object} 可选参数。如：<br>
 *         unit - {Unit} 量算单位。<br>
 *         prjCoordSys -{string} 用来指定该量算操作所使用的投影,该项默认值为空。<br>
 *         distanceMode -{string} 用来指定量算的方式为按球面长度'Geodesic'或者平面长度'Planar'来计算，默认为'Geodesic'。
 */
var MeasureParameters = exports.MeasureParameters = function () {
  function MeasureParameters(geometry, options) {
    _classCallCheck(this, MeasureParameters);

    if (!geometry) {
      return;
    }
    /**
     * @member SuperMap.MeasureParameters.prototype.geometry -{Object}
     * @description 要量算的几何对象（{Line} 或 {Polygon}），必设属性。<br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    this.geometry = geometry;

    /**
     * @member SuperMap.MeasureParameters.prototype.unit -{Unit}
     * @description 量算单位。默认单位：米，即量算结果以米为单位。
     */
    this.unit = _REST.Unit.METER;

    /**
     * @member SuperMap.MeasureParameters.prototype.prjCoordSys -{string}
     * @description 用来指定该量算操作所使用的投影,该项默认值为空。
     */
    this.prjCoordSys = null;

    /**
     * @member SuperMap.MeasureParameters.prototype.distanceMode -{string}
     * @description 用来指定量算的方式为按球面长度'Geodesic'或者平面长度'Planar'来计算，默认为'Geodesic'。
     * @example
     * var param = new SuperMap.MeasureParameters(getmetry,{distanceMode:'Planar'});
     */
    this.distanceMode = null;
    if (options) {
      _Util.Util.extend(this, options);
    }
    this.CLASS_NAME = "SuperMap.MeasureParameters";
  }

  /**
   * @function SuperMap.MeasureParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(MeasureParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.geometry = null;
      me.unit = null;
      me.prjCoordSys = null;
    }
  }]);

  return MeasureParameters;
}();

_SuperMap.SuperMap.MeasureParameters = MeasureParameters;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OverlapDisplayedOptions = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _UGCLayer = __webpack_require__(102);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  SuperMap.OverlapDisplayedOptions
 * @classdesc 地图压盖过滤显示选项。
 * @description 在文本或专题图元素显示较密集的区域，文本之间或专题元素之间会发生相互压盖的现象，
 * 该类可以分别控制各种类型的对象的压盖显示情况，进而很好地处理地图中各种类型对象的压盖显示问题。
 * @param  options - {Object} 过滤显示参数。<br>
 *          allowPointOverlap - {boolean} 点和点压盖时是否显示压盖的点对象。默认值为true。<br>
 *          allowPointWithTextDisplay - {boolean} 标签和相应普通图层上的点是否一起过滤显示,如果过滤显示，
 *                  只以图层集合中对应数据集的索引最小的图层的点风格来绘制点。默认值为true。
 *          allowTextOverlap - {boolean} 文本压盖时是否显示压盖的文本对象。默认值为false。<br>
 *          allowTextAndPointOverlap - {boolean} 文本和点压盖时是否显示压盖的文本或点对象(此属性不处理文本之间的压盖和点之间的压盖)。默认值为true。<br>
 *          allowThemeGraduatedSymbolOverlap - {boolean} 等级符号元素压盖时是否显示压盖的等级符号元素。默认值为false。<br>
 *          allowThemeGraphOverlap - {number} 统计专题图元素压盖时是否显示压盖的统计专题图元素。默认值为false。<br>
 *          horizontalOverlappedSpaceSize - {number} 两个对象之间的横向压盖间距，单位为0.1毫米，跟verticalOverlappedSpaceSize 结合使用，
 *                  当两个对象的横向间距小于该值，且纵向间距小于 verticalOverlappedSpaceSize 时认为压盖。默认值为0。<br>
 *          verticalOverlappedSpaceSize - {number} 两个对象之间的纵向压盖间距，单位为0.1毫米，跟horizontalOverlappedSpaceSize 结合使用，
 *                  当两个对象的纵向间距小于该值，且横向间距小于 horizontalOverlappedSpaceSize 时认为压盖。默认值为0。
 */
var OverlapDisplayedOptions = exports.OverlapDisplayedOptions = function () {
  function OverlapDisplayedOptions(options) {
    _classCallCheck(this, OverlapDisplayedOptions);

    options = options || {};
    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.allowPointOverlap -{boolean}
     * @description 点和点压盖时是否显示压盖的点对象。默认值为true。
     */
    this.allowPointOverlap = true;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.allowPointWithTextDisplay -{boolean}
     * @description 标签和相应普通图层上的点是否一起过滤显示,如果过滤显示，
     * 只以图层集合中对应数据集的索引最小的图层的点风格来绘制点。默认值为true。
     */
    this.allowPointWithTextDisplay = true;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.allowTextOverlap -{boolean}
     * @description 文本压盖时是否显示压盖的文本对象。默认值为false。
     */
    this.allowTextOverlap = false;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.allowTextAndPointOverlap -{boolean}
     * @description  文本和点压盖时是否显示压盖的文本或点对象(此属性不处理文本之间的压盖和点之间的压盖)。默认值为true。
     */
    this.allowTextAndPointOverlap = true;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.allowThemeGraduatedSymbolOverlap -{boolean}
     * @description 等级符号元素压盖时是否显示压盖的等级符号元素。默认值为false。
     */
    this.allowThemeGraduatedSymbolOverlap = false;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.allowThemeGraphOverlap -{boolean}
     * @description 统计专题图元素压盖时是否显示压盖的统计专题图元素。默认值为false。
     */
    this.allowThemeGraphOverlap = false;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.horizontalOverlappedSpaceSize -{number}
     * @description 两个对象之间的横向压盖间距，单位为0.1毫米，跟 verticalOverlappedSpaceSize 结合使用，
     * 当两个对象的横向间距小于该值，且纵向间距小于 verticalOverlappedSpaceSize 时认为压盖。默认值为0。
     */
    this.horizontalOverlappedSpaceSize = 0;

    /**
     * @member SuperMap.OverlapDisplayedOptions.prototype.verticalOverlappedSpaceSize -{number}
     * @description 两个对象之间的纵向压盖间距，单位为0.1毫米，跟 horizontalOverlappedSpaceSize 结合使用，
     * 当两个对象的纵向间距小于该值，且横向间距小于 horizontalOverlappedSpaceSize 时认为压盖。默认值为0。
     */
    this.verticalOverlappedSpaceSize = 0;

    _Util.Util.extend(this, options);
    this.ugcLayer = new _UGCLayer.UGCLayer(options);

    this.CLASS_NAME = "SuperMap.OverlapDisplayedOptions";
  }

  /**
   * @function SuperMap.OverlapDisplayedOptions.prototype.destroy
   * @description 释放资源，将资源的属性置空。
   */


  _createClass(OverlapDisplayedOptions, [{
    key: 'destroy',
    value: function destroy() {
      _Util.Util.reset(this);
    }

    /**
     * @function SuperMap.OverlapDisplayedOptions.prototype.fromJson
     * @description 将服务端JSON对象转换成当前客户端对象
     * @param jsonObject -{Object} 要转换的 JSON 对象。
     */

  }, {
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      this.ugcLayer.fromJson.apply(this, [jsonObject]);
    }

    /**
     * @function SuperMap.OverlapDisplayedOptions.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @return {Object} 对应的 JSON 格式对象
     */

  }, {
    key: 'toServerJSONObject',
    value: function toServerJSONObject() {
      var jsonObject = this.ugcLayer.toServerJSONObject.apply(this, arguments);
      return jsonObject;
    }

    /**
     * @function SuperMap.OverlapDisplayedOptions.prototype.toString
     * @description 转换成对应的 tileLayer请求瓦片时overlapDisplayedOptions参数。
     * @return {string} 对应的 tileLayer请求瓦片时overlapDisplayedOptions参数
     */

  }, {
    key: 'toString',
    value: function toString() {
      var jsonObject = this.ugcLayer.toServerJSONObject.apply(this, arguments);
      var str = "{";
      for (var attr in jsonObject) {
        if (jsonObject.hasOwnProperty(attr)) {
          str += "'" + attr + "':" + jsonObject[attr] + ",";
        }
      }
      str = str.substr(0, str.length - 1);
      str += "}";
      return str;
    }
  }]);

  return OverlapDisplayedOptions;
}();

_SuperMap.SuperMap.OverlapDisplayedOptions = OverlapDisplayedOptions;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OverlayGeoJobParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.OverlayGeoJobParameter
 * @classdesc 叠加分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         datasetOverlay -{string} 叠加对象所在的数据集名称。 <br>
 *         mode -{string} 叠加分析模式 。 <br>
 */
var OverlayGeoJobParameter = exports.OverlayGeoJobParameter = function () {
    function OverlayGeoJobParameter(options) {
        _classCallCheck(this, OverlayGeoJobParameter);

        if (!options) {
            return;
        }
        /**
         * @member SuperMap.OverlayGeoJobParameter.prototype.datasetName -{string}
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member SuperMap.OverlayGeoJobParameter.prototype.datasetOverlay -{string}
         * @description 叠加对象所在的数据集名称。
         */
        this.datasetOverlay = "";

        /**
         * @member SuperMap.OverlayGeoJobParameter.prototype.mode -{string}
         * @description 叠加分析模式
         */
        this.mode = "";

        /**
         * @member SuperMap.OverlayGeoJobParameter.prototype.srcFields -{string}
         * @description 输入数据需要保留的字段
         */
        this.srcFields = "";

        /**
         * @member SuperMap.OverlayGeoJobParameter.prototype.overlayFields -{string}
         * @description 叠加数据需要保留的字段，对分析模式为clip、update、erase时，此参数无效。
         */
        this.overlayFields = "";
        _Util.Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.OverlayGeoJobParameter";
    }

    /**
     * @function SuperMap.OverlayGeoJobParameter.destroy
     * @override
     */


    _createClass(OverlayGeoJobParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.datasetOverlay = null;
            this.mode = null;
            this.srcFields = null;
            this.overlayFields = null;
        }

        /**
         * @function SuperMap.OverlayGeoJobParameter.toObject
         * @param OverlayGeoJobParameter - {Object} 点聚合分析任务参数。
         * @param tempObj - {Object} 目标对象。
         * @description 生成点聚合分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(OverlayGeoJobParameter, tempObj) {
            for (var name in OverlayGeoJobParameter) {
                if (name == "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = OverlayGeoJobParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = OverlayGeoJobParameter[name];
            }
        }
    }]);

    return OverlayGeoJobParameter;
}();

_SuperMap.SuperMap.OverlayGeoJobParameter = OverlayGeoJobParameter;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PointWithMeasure = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Point2 = __webpack_require__(18);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.PointWithMeasure
 * @classdesc 路由点类。路由点是指具有线性度量值(Measure)的二维地理坐标点。
 * @param options - {Object} 可选参数。如:</br>
 *        measure - {number}度量值，即路由对象属性值 M。</br>
 *        x - {number}获取当前点对象在地理坐标系下的 X 坐标值。</br>
 *        y - {number}获取当前点对象在地理坐标系下的 Y 坐标值。</br>
 * @extends SuperMap.Geometry.Point
 */
var PointWithMeasure = exports.PointWithMeasure = function (_Point) {
    _inherits(PointWithMeasure, _Point);

    function PointWithMeasure(options) {
        _classCallCheck(this, PointWithMeasure);

        /**
         * @member SuperMap.PointWithMeasure.prototype.measure -{number}
         * @description 度量值，即路由对象属性值 M。
         */
        var _this = _possibleConstructorReturn(this, (PointWithMeasure.__proto__ || Object.getPrototypeOf(PointWithMeasure)).call(this, options));

        _this.measure = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.PointWithMeasure";
        return _this;
    }

    /**
     * @function SuperMap.PointWithMeasure.prototype.equals
     * @description 判断两个路由点对象是否相等。如果两个路由点对象具有相同的坐标以及度量值，则认为是相等的。
     * @param geom - {SuperMap.PointWithMeasure} 需要判断的路由点对象。
     * @return {boolean} 两个路由点对象是否相等（true为相等，false为不等）。
     */


    _createClass(PointWithMeasure, [{
        key: 'equals',
        value: function equals(geom) {
            var equals = false;
            if (geom != null) {
                var isValueEquals = this.x === geom.x && this.y === geom.y && this.measure === geom.measure;
                var isNaNValue = isNaN(this.x) && isNaN(this.y) && isNaN(this.measure);
                var isNaNGeometry = isNaN(geom.x) && isNaN(geom.y) && isNaN(geom.measure);
                equals = isValueEquals || isNaNValue && isNaNGeometry;
            }
            return equals;
        }

        /**
         * @function SuperMap.PointWithMeasure.prototype.toJson
         * @description 转换为json对象。
         toJson() {
            var result = "{";
            if (this.measure != null && this.measure != undefined) {
                result += "\"measure\":" + this.measure + "";
            }
            result += "\"x\":" + this.x + "";
            result += "\"y\":" + this.y;
            result += "}";
            return result;
        }
             /**
         * @function SuperMap.PointWithMeasure.prototype.destroy
         * @description 释放资源，将引用资源的属性置空。
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.measure = null;
            me.x = null;
            me.y = null;
        }

        /**
         * @function SuperMap.PointWithMeasure.fromJson
         * @description 将 JSON 对象转换为{@link SuperMap.PointWithMeasure} 对象。
         * @param jsonObject - {Object} JSON 对象表示的路由点。
         * @return {SuperMap.PointWithMeasure} 转化后的 PointWithMeasure 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new PointWithMeasure({
                x: jsonObject.x,
                y: jsonObject.y,
                measure: jsonObject.measure
            });
        }
    }]);

    return PointWithMeasure;
}(_Point2.Point);

_SuperMap.SuperMap.PointWithMeasure = PointWithMeasure;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryByBoundsParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryParameters2 = __webpack_require__(32);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByBoundsParameters
 * @classdesc Bounds 查询参数类。该类用于设置 Bounds 查询的相关参数。
 * @extends SuperMap.QueryParameters
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {{@link SuperMap.GeometryType}} 网络数据集对应的查询类型。<br>
 *         queryOption - {{@link SuperMap.QueryOption}} 查询结果类型枚举类。<br>
 *         queryParams - {Array<{@link SuperMap.FilterParameter}>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。<br>
 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
 *         bounds - {{@link SuperMap.Bounds}} 指定的查询范围。<br>
 *                  Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
 */
var QueryByBoundsParameters = exports.QueryByBoundsParameters = function (_QueryParameters) {
    _inherits(QueryByBoundsParameters, _QueryParameters);

    function QueryByBoundsParameters(options) {
        _classCallCheck(this, QueryByBoundsParameters);

        if (!options) {
            return _possibleConstructorReturn(_this);
        }

        /**
         * @member SuperMap.QueryByBoundsParameters.prototype.returnContent -{boolean}
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
         *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
         *               为 false，则返回的是查询结果资源的 URI。默认为 true。
         */
        var _this = _possibleConstructorReturn(this, (QueryByBoundsParameters.__proto__ || Object.getPrototypeOf(QueryByBoundsParameters)).call(this, options));

        _this.returnContent = true;

        /**
         * @member SuperMap.QueryByBoundsParameters.prototype.bounds
         * @description 指定的查询范围。<br>
         * Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
         */
        _this.bounds = null;

        _Util.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.QueryByBoundsParameters";
        return _this;
    }

    /**
     * @function SuperMap.QueryByBoundsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(QueryByBoundsParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByBoundsParameters.prototype.__proto__ || Object.getPrototypeOf(QueryByBoundsParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            if (me.bounds) {
                me.bounds = null;
            }
        }
    }]);

    return QueryByBoundsParameters;
}(_QueryParameters2.QueryParameters);

_SuperMap.SuperMap.QueryByBoundsParameters = QueryByBoundsParameters;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryByDistanceParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryParameters2 = __webpack_require__(32);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByDistanceParameters
 * @classdesc Distance 查询参数类。
 *               该类用于设置 Distance 查询的相关参数。
 * @extends SuperMap.QueryParameters
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {{@link SuperMap.GeometryType}} 网络数据集对应的查询类型。<br>
 *         queryOption - {{@link SuperMap.QueryOption}} 查询结果类型枚举类。<br>
 *         queryParams - {Array<{@link SuperMap.FilterParameter}>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。<br>
 *         distance - {number}查询距离。<br>
 *         geometry - {Object} 用于查询的几何对象。<br>
 *                   点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
 *                   线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
 *                   面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。<br>
 *         isNearest - {boolean} 是否为最近距离查询。<br>
 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
 */
var QueryByDistanceParameters = exports.QueryByDistanceParameters = function (_QueryParameters) {
  _inherits(QueryByDistanceParameters, _QueryParameters);

  function QueryByDistanceParameters(options) {
    _classCallCheck(this, QueryByDistanceParameters);

    if (!options) {
      return _possibleConstructorReturn(_this);
    }

    /**
     * @member SuperMap.QueryByDistanceParameters.prototype.distance -{number}
     * @description 查询距离，默认为0，单位与所查询图层对应的数据集单位相同。
     *               当查找最近地物时，该属性无效。
     * @default 0
     */
    var _this = _possibleConstructorReturn(this, (QueryByDistanceParameters.__proto__ || Object.getPrototypeOf(QueryByDistanceParameters)).call(this, options));

    _this.distance = 0;

    /**
     * @member SuperMap.QueryByDistanceParameters.prototype.geometry
     * @description 用于查询的地理对象，必设属性。<br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    _this.geometry = null;

    /**
     * @member SuperMap.QueryByDistanceParameters.prototype.isNearest -{boolean}
     * @description 是否为最近距离查询。<br>
     *               建议该属性与 expectCount （继承自 {@link SuperMap.QueryParameters}）属性联合使用。<br>
     *               当该属性为 true 时，即表示查找最近地物，如果查询结果数大于期望返回的结果记录数（expectCount），<br>
     *               则查找结果为查询总记录中距离中心最近的expectCount个地物。<br>
     *               当该属性为不为 true 时，如果查询结果数大于期望返回的结果记录数（expectCount），<br>
     *               则查找结果为从查询总记录中随机抽取的expectCount个地物。<br>
     *               目前查询结果不支持按远近距离排序。
     */
    _this.isNearest = null;

    /**
     * @member SuperMap.QueryByDistanceParameters.prototype.returnContent -{boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
     *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
     *               为 false，则返回的是查询结果资源的 URI。默认为 true。
     */
    _this.returnContent = true;

    _Util.Util.extend(_this, options);

    _this.CLASS_NAME = "SuperMap.QueryByDistanceParameters";
    return _this;
  }

  /**
   * @function SuperMap.QueryByDistanceParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(QueryByDistanceParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(QueryByDistanceParameters.prototype.__proto__ || Object.getPrototypeOf(QueryByDistanceParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.returnContent = null;
      me.distance = null;
      me.isNearest = null;
      if (me.geometry) {
        me.geometry.destroy();
        me.geometry = null;
      }
    }
  }]);

  return QueryByDistanceParameters;
}(_QueryParameters2.QueryParameters);

_SuperMap.SuperMap.QueryByDistanceParameters = QueryByDistanceParameters;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QueryByGeometryParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryParameters2 = __webpack_require__(32);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByGeometryParameters
 * @classdesc Geometry 查询参数类。
 *               该类用于设置 Geometry查询的相关参数。
 * @extends SuperMap.QueryParameters
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {{@link SuperMap.GeometryType}} 网络数据集对应的查询类型。<br>
 *         queryOption - {{@link SuperMap.QueryOption}}  查询结果类型枚举类。<br>
 *         queryParams - {Array<{@link SuperMap.FilterParameter}>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。<br>
 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
 *         geometry - {Object} 用于查询的几何对象。<br>
 *                   点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
 *                   线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
 *                   面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON。<br>
 *         spatialQueryMode - {SuperMap.SpatialQueryMode} 空间查询模式。
 */
var QueryByGeometryParameters = exports.QueryByGeometryParameters = function (_QueryParameters) {
  _inherits(QueryByGeometryParameters, _QueryParameters);

  function QueryByGeometryParameters(options) {
    _classCallCheck(this, QueryByGeometryParameters);

    if (!options) {
      return _possibleConstructorReturn(_this);
    }

    /**
     * @member SuperMap.QueryByGeometryParameters.prototype.returnContent -{boolean}
     * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
     *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
     *               为 false，则返回的是查询结果资源的 URI。默认为 true。
     * @default true
     */
    var _this = _possibleConstructorReturn(this, (QueryByGeometryParameters.__proto__ || Object.getPrototypeOf(QueryByGeometryParameters)).call(this, options));

    _this.returnContent = true;

    /**
     * @member SuperMap.QueryByGeometryParameters.prototype.geometry
     * @description 用于查询的几何对象。<br>
     * 点类型可以是：SuperMap.Geometry.Point|L.Point|L.GeoJSON|ol.geom.Point|ol.format.GeoJSON。<br>
     * 线类型可以是：SuperMap.Geometry.LineString|SuperMap.Geometry.LinearRing|L.Polyline|L.GeoJSON|ol.geom.LineString|ol.format.GeoJSON。<br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON
     */
    _this.geometry = null;

    /**
     * @member SuperMap.QueryByGeometryParameters.prototype.spatialQueryMode -{SpatialQueryMode}
     * @description 空间查询模式。
     * @default {@link SuperMap.SpatialQueryMode.INTERSECT}
     */
    _this.spatialQueryMode = _REST.SpatialQueryMode.INTERSECT;

    _Util.Util.extend(_this, options);

    _this.CLASS_NAME = "SuperMap.QueryByGeometryParameters";
    return _this;
  }

  /**
   * @function SuperMap.QueryByGeometryParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(QueryByGeometryParameters, [{
    key: 'destroy',
    value: function destroy() {
      _get(QueryByGeometryParameters.prototype.__proto__ || Object.getPrototypeOf(QueryByGeometryParameters.prototype), 'destroy', this).call(this);
      var me = this;
      me.returnContent = null;
      me.geometry = null;
      me.spatialQueryMode = null;
    }
  }]);

  return QueryByGeometryParameters;
}(_QueryParameters2.QueryParameters);

_SuperMap.SuperMap.QueryByGeometryParameters = QueryByGeometryParameters;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryBySQLParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryParameters2 = __webpack_require__(32);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryBySQLParameters
 * @classdesc SQL 查询参数类。
 *               该类用于设置 SQL 查询的相关参数。
 * @extends SuperMap.QueryParameters
 * @param options - {Object} 可选参数。如：<br>
 *         customParams - {string} 自定义参数，供扩展使用。<br>
 *         prjCoordSys -{Object} 自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}。<br>
 *         expectCount - {number}期望返回结果记录个数。<br>
 *         networkType - {{@link SuperMap.GeometryType}} 网络数据集对应的查询类型。<br>
 *         queryOption - {{@link SuperMap.QueryOption}} 查询结果类型枚举类。<br>
 *         queryParams - {Array<{@link SuperMap.FilterParameter}>} 查询过滤条件参数数组。<br>
 *         startRecord - {number}查询起始记录号。<br>
 *         holdTime - {number}资源在服务端保存的时间。<br>
 *         returnCustomResult -{boolean} 仅供三维使用。<br>
 *         returnContent - {boolean} 是否立即返回新创建资源的表述还是返回新资源的 URI。
 */
var QueryBySQLParameters = exports.QueryBySQLParameters = function (_QueryParameters) {
    _inherits(QueryBySQLParameters, _QueryParameters);

    function QueryBySQLParameters(options) {
        _classCallCheck(this, QueryBySQLParameters);

        if (!options) {
            return _possibleConstructorReturn(_this);
        }

        /**
         * @member SuperMap.QueryBySQLParameters.prototype.returnContent -{boolean}
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
         *               如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
         *               为 false，则返回的是查询结果资源的 URI。默认为 true。
         * @default true
         */
        var _this = _possibleConstructorReturn(this, (QueryBySQLParameters.__proto__ || Object.getPrototypeOf(QueryBySQLParameters)).call(this, options));

        _this.returnContent = true;
        _Util.Util.extend(_this, options);
        _this.CLASS_NAME = "SuperMap.QueryBySQLParameters";
        return _this;
    }

    /**
     * @function SuperMap.QueryBySQLParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(QueryBySQLParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryBySQLParameters.prototype.__proto__ || Object.getPrototypeOf(QueryBySQLParameters.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
        }
    }]);

    return QueryBySQLParameters;
}(_QueryParameters2.QueryParameters);

_SuperMap.SuperMap.QueryBySQLParameters = QueryBySQLParameters;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RouteCalculateMeasureParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(68);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.RouteCalculateMeasureParameters
 * @classdesc 基于路由对象计算指定点M值操作的参数类。通过该类提供参数信息。
 * @param options - {Object} 可选参数。如:</br>
 *        sourceRoute - {Object} 【必选参数】路由对象。该对象可以是用户自己生成或在数据源中查询得到的符合标准的路由对象。</br>
 *        point - {Object} 【必选参数】二维地理坐标点对象，包含x,y坐标值属性的对象。</br>
 *                点坐标对象可以是:SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 *        tolerance - {float} 【可选参数】容限值。</br>
 *        isIgnoreGap - {float}  【可选参数】是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。</br>
 */
var RouteCalculateMeasureParameters = exports.RouteCalculateMeasureParameters = function () {
    function RouteCalculateMeasureParameters(options) {
        _classCallCheck(this, RouteCalculateMeasureParameters);

        if (!options) {
            return this;
        }
        /**
         * @member SuperMap.RouteCalculateMeasureParameters.prototype.sourceRoute -{Object}
         * @description 【必选参数】路由对象。该对象可以是用户自己生成或在数据源中查询得到的符合标准的路由对象；<br>
         * 路由对象可以是：SuperMap.Route|L.Polyline|ol.geom.LineString
         */
        this.sourceRoute = null;

        /**
         * @member SuperMap.RouteCalculateMeasureParameters.prototype.point -{Object}
         * @description 【必选参数】二维地理坐标点对象，包含x,y坐标值属性的对象。</br>
         * 点坐标对象可以是:SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。
         */
        this.point = null;

        /**
         * @member SuperMap.RouteCalculateMeasureParameters.prototype.tolerance -{float}
         * @description 【可选参数】容限值。
         */
        this.tolerance = null;

        /**
         * @member SuperMap.RouteCalculateMeasureParameters.prototype.isIgnoreGap -{boolean}
         * @description 【可选参数】是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。
         * @default false
         */
        this.isIgnoreGap = false;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.RouteCalculateMeasureParameters";
    }

    /**
     * @function SuperMap.RouteCalculateMeasureParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(RouteCalculateMeasureParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.sourceRoute = null;
            me.point = null;
            if (me.tolerance) {
                me.tolerance = null;
            }
            if (me.isIgnoreGap) {
                me.isIgnoreGap = false;
            }
        }
    }]);

    return RouteCalculateMeasureParameters;
}();

_SuperMap.SuperMap.RouteCalculateMeasureParameters = RouteCalculateMeasureParameters;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RouteLocatorParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Geometry = __webpack_require__(26);

__webpack_require__(68);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.RouteLocatorParameters
 * @classdesc
 * 路由对象定位空间对象的参数类。
 * 参数有两种方式，分别为Geometry和Dataset两种，前者需要指定sourceRoute对象作为参数，后者需要dataset，routeIDField，routeID三个参数
 * 如果用户两种参数均设置，优先选择Dataset方式
 * @param options - {Object} 可选参数。如:</br>
 *        sourceRoute -  {Object} 【必选参数】路由对象。路由对象可以是：SuperMap.Route|L.Polyline|ol.geom.LineString。</br>
 *        type -  {string} 【必选参数】类型：点 or 线。</br>
 *        measure - {float} 【必选参数】定位点的M值。只当路由对象定位点时有意义。</br>
 *        offset - {float} 定位点偏移量。只当路由对象定位点时有意义，默认为0。</br>
 *        isIgnoreGap - {boolean} 是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。</br>
 *        startMeasure - {float} 定位线的起始M值。只当路由对象定位线时有意义。</br>
 *        endMeasure -  {float} 定位线的终止M值。只当路由对象定位线时有意义。</br>
 */
var RouteLocatorParameters = exports.RouteLocatorParameters = function () {
  function RouteLocatorParameters(options) {
    _classCallCheck(this, RouteLocatorParameters);

    if (!options) {
      return this;
    }
    /**
     * @member SuperMap.RouteLocatorParameters.prototype.sourceRoute -{Object}
     * @description 路由对象。路由对象可以是：SuperMap.Route|L.Polyline|ol.geom.LineString
     */
    this.sourceRoute = null;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.dataset -{string}
     * @description 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
     */
    this.dataset = null;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.routeIDField -{string}
     * @description  路由对象所在的字段名称。
     *
     */
    this.routeIDField = null;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.routeID -{interger}
     * @description 路由对象标识 。
     *
     */
    this.routeID = null;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.type -{string}
     * @description 【必选参数】类型：点 or 线。
     * 可选值为:
     * LINE :根据起始 M 值及终止 M 值定位线对象。
     * POINT : 根据 M 值定位点对象。
     */
    this.type = null;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.measure -{float}
     * @description 必选参数,定位点的M值。只当路由对象定位点时有意义。
     */
    this.measure = null;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.offset -{float}
     * @description 定位点偏移量。只当路由对象定位点时有意义，默认为0。
     */
    this.offset = 0;

    /**
     * @member SuperMap.RouteLocatorParameters.prototype.isIgnoreGap -{boolean}
     * @description 是否忽略子对象之间的距离。默认为false，即不忽略子对象之间的距离。
     */
    this.isIgnoreGap = false;

    /**
     *  @member SuperMap.RouteLocatorParameters.prototype.startMeasure -{float}
     *  @description 定位线的起始M值。只当路由对象定位线时有意义。
     */
    this.startMeasure = null;

    /**
     *  @member SuperMap.RouteLocatorParameters.prototype.endMeasure -{float}
     *  @description 定位线的终止M值。只当路由对象定位线时有意义。
     */
    this.endMeasure = null;

    var routeFromClient = options.sourceRoute;
    var routeHandle = {};
    if (routeFromClient && routeFromClient instanceof _Geometry.Geometry && routeFromClient.components) {
      routeHandle.type = routeFromClient.type;
      routeHandle.parts = routeFromClient.parts;
      var parts = [];
      for (var i = 0, len = routeFromClient.components.length; i < len; i++) {
        parts = parts.concat(routeFromClient.components[i].components);
      }
      routeHandle.points = parts;
      options.sourceRoute = routeHandle;
    }
    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.RouteLocatorParameters";
  }

  /**
   * @function SuperMap.RouteLocatorParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(RouteLocatorParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.sourceRoute = null;
      me.type = null;
      me.measure = null;
      me.offset = 0;
      me.isIgnoreGap = false;
      me.startMeasure = null;
      me.endMeasure = null;
      me.dataset = null;
      me.routeID = null;
      me.routeIDField = null;
    }
  }]);

  return RouteLocatorParameters;
}();

_SuperMap.SuperMap.RouteLocatorParameters = RouteLocatorParameters;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerTheme = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _LonLat = __webpack_require__(37);

var _ThemeLabel = __webpack_require__(71);

var _ThemeUnique = __webpack_require__(100);

var _ThemeGraph = __webpack_require__(98);

var _ThemeDotDensity = __webpack_require__(96);

var _ThemeGraduatedSymbol = __webpack_require__(97);

var _ThemeRange = __webpack_require__(99);

var _UGCSubLayer2 = __webpack_require__(52);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ServerTheme
 * @classdesc UGC 专题图图层类。
 * @extends SuperMap.UGCSubLayer
 * @param theme - {SuperMap.Theme} 专题图对象。
 * @param themeElementPosition - {SuperMap.LonLat} 专题图元素位置。
 */
var ServerTheme = exports.ServerTheme = function (_UGCSubLayer) {
    _inherits(ServerTheme, _UGCSubLayer);

    /*
     * @class SuperMap.ServerTheme
     * @description UGC 专题图图层类类构造函数。
     * @param theme - {SuperMap.Theme} 专题图对象。
     * @param themeElementPosition - {SuperMap.LonLat} 专题图元素位置。
     */
    function ServerTheme(options) {
        _classCallCheck(this, ServerTheme);

        options = options || {};

        /**
         * @member SuperMap.ServerTheme.prototype.theme -{SuperMap.Theme}
         * @description 专题图对象。
         */
        var _this = _possibleConstructorReturn(this, (ServerTheme.__proto__ || Object.getPrototypeOf(ServerTheme)).call(this, options));

        _this.theme = null;

        /**
         * @member SuperMap.ServerTheme.prototype.themeElementPosition -{SuperMap.LonLat}
         * @description 专题图元素位置。
         */
        _this.themeElementPosition = null;

        _this.CLASS_NAME = "SuperMap.ServerTheme";

        return _this;
    }

    /**
     * @function SuperMap.ServerTheme.prototype.destroy
     * @override
     */


    _createClass(ServerTheme, [{
        key: 'destroy',
        value: function destroy() {
            _get(ServerTheme.prototype.__proto__ || Object.getPrototypeOf(ServerTheme.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.ServerTheme.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(ServerTheme.prototype.__proto__ || Object.getPrototypeOf(ServerTheme.prototype), 'fromJson', this).call(this, jsonObject);
            var themeObj = this.theme;
            var themeT = themeObj && themeObj.type;
            switch (themeT) {
                case 'LABEL':
                    this.theme = _ThemeLabel.ThemeLabel.fromObj(themeObj);
                    break;
                case 'UNIQUE':
                    this.theme = _ThemeUnique.ThemeUnique.fromObj(themeObj);
                    break;
                case 'GRAPH':
                    this.theme = _ThemeGraph.ThemeGraph.fromObj(themeObj);
                    break;
                case 'DOTDENSITY':
                    this.theme = _ThemeDotDensity.ThemeDotDensity.fromObj(themeObj);
                    break;
                case 'GRADUATEDSYMBOL':
                    this.theme = _ThemeGraduatedSymbol.ThemeGraduatedSymbol.fromObj(themeObj);
                    break;
                case 'RANGE':
                    this.theme = _ThemeRange.ThemeRange.fromObj(themeObj);
                    break;
                default:
                    break;
            }
            if (this.themeElementPosition) {
                //待测试
                this.themeElementPosition = new _LonLat.LonLat(this.themeElementPosition.x, this.themeElementPosition.y);
            }
        }

        /**
         * @function  SuperMap.ServerTheme.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            //普通属性直接赋值
            var jsonObject = _get(ServerTheme.prototype.__proto__ || Object.getPrototypeOf(ServerTheme.prototype), 'toServerJSONObject', this).call(this);

            if (jsonObject.themeElementPosition) {
                if (jsonObject.themeElementPosition.toServerJSONObject) {
                    jsonObject.themeElementPosition = jsonObject.themeElementPosition.toServerJSONObject();
                }
            }
            if (jsonObject.theme) {
                if (jsonObject.theme.toServerJSONObject) {
                    jsonObject.theme = jsonObject.theme.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return ServerTheme;
}(_UGCSubLayer2.UGCSubLayer);

_SuperMap.SuperMap.ServerTheme = ServerTheme;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetLayerInfoParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SetLayerInfoParameters
 * @classdesc 设置图层信息参数类.
 * @param options -{Object} 可选参数。如：<br>
 *         resourceID -{string} 临时图层的资源ID。<br>
 *         tempLayerName -{string} 临时图层下的子图层名。<br>
 *         layerInfo -{string} 要更新的图层信息。
 */
var SetLayerInfoParameters = exports.SetLayerInfoParameters = function () {
  function SetLayerInfoParameters(options) {
    _classCallCheck(this, SetLayerInfoParameters);

    options = options || {};
    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.resourceID -{string}
     * @description 临时图层的资源ID
     */
    this.resourceID = null;

    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.tempLayerName -{string}
     * @description 临时图层下子图层(或者其子图层)名,如：Countries@World.3@@World
     */
    this.tempLayerName = null;

    /**
     * @member SuperMap.SetLayerInfoParameters.prototype.layerInfo -{Object}
     * @description 要更新的图层信息。(包含修改和未修改的所有字段)。该参数可以通过图层信息服务获取，然后对返回值中subLayers.layers[i]图层信息属性进行修改。
     */
    this.layerInfo = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.SetLayerInfoParameters";
  }

  /**
   * @function SuperMap.SetLayerInfoParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(SetLayerInfoParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.resourceID = null;
      me.tempLayerName = null;
      me.layerInfo = null;
    }
  }]);

  return SetLayerInfoParameters;
}();

_SuperMap.SuperMap.SetLayerInfoParameters = SetLayerInfoParameters;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SetLayerStatusParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(206);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SetLayerStatusParameters
 * @classdesc 子图层显示控制参数类,该类存储了各子图层是否可见的状态。<br>
 *               注意在 SuperMap iClient 系列产品中所说的图层与 SuperMap Deskpro 的地图对应，子图层与 SuperMap Deskpro 的图层对应。
 * @param options - {Object} 可选参数。如：<br>
 *        layerStatusList - {Array<{@link SuperMap.LayerStatus}>} 获取或设置图层可见状态（{@link SuperMap.LayerStatus}）集合，必设属性。
 *                         集合中的每个 {@link SuperMap.LayerStatus} 对象代表一个子图层的可视状态。<br>
 *        holdTime - {string} 获取或设置资源在服务端保存的时间。<br>
 *        resourceID - {string} 获取或设置资源服务 ID。
 */
var SetLayerStatusParameters = exports.SetLayerStatusParameters = function () {
    function SetLayerStatusParameters(options) {
        _classCallCheck(this, SetLayerStatusParameters);

        /**
         * @member SuperMap.SetLayerStatusParameters.prototype.layerStatusList -{Array<SuperMap.LayerStatus>}
         * @description 获取或设置图层可见状态（SuperMap.LayerStatus）集合，必设属性。<br>
         *                集合中的每个 SuperMap.LayerStatus 对象代表一个子图层的可视状态。
         */
        this.layerStatusList = [];

        /**
         * @member SuperMap.SetLayerStatusParameters.prototype.holdTime -{number}
         * @description 获取或设置资源在服务端保存的时间。 默认为 15 分钟。
         */
        this.holdTime = 15;

        /**
         * @member SuperMap.SetLayerStatusParameters.prototype.resourceID -{string}
         * @description 获取或设置资源服务 ID 。非必设参数，如果设置该参数则会在指定的 TempLayer 进行图层的显示控制；<br>
         *                如果不设置该参数，则会首先创建一个 TempLayer ，然后在新创建的 TempLayer 进行图层的显示控制。
         */
        this.resourceID = null;

        if (options) {
            _Util.Util.extend(this, options);
        }
    }

    /**
     * @function SuperMap.SetLayerStatusParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(SetLayerStatusParameters, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.layerStatusList = null;
            me.holdTime = null;
            me.resourceID = null;
        }

        /**
         * @function SuperMap.SetLayerStatusParameters.prototype.toJSON
         * @description 生成json。
         * @return{Object} 对应的json对象
         */

    }, {
        key: 'toJSON',
        value: function toJSON() {
            var json = '{';
            json += '"layers":[';
            var v = [];
            for (var i = 0, len = this.layerStatusList.length; i < len; i++) {
                v.push(this.layerStatusList[i].toJSON());
            }

            json += v;
            json += ']';
            json += '}';

            return json;
        }
    }]);

    return SetLayerStatusParameters;
}();

_SuperMap.SuperMap.SetLayerStatusParameters = SetLayerStatusParameters;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SetLayersInfoParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SetLayersInfoParameters
 * @classdesc 设置图层信息参数类
 * @param options -{Object} 可选参数。如：<br>
 *        isTempLayers -{boolean} 是否是临时图层。<br>
 *        resourceID -{string} 临时图层资源ID。<br>
 *        layersInfo -{string} 要更新的图层信息。
 */
var SetLayersInfoParameters = exports.SetLayersInfoParameters = function () {
  function SetLayersInfoParameters(options) {
    _classCallCheck(this, SetLayersInfoParameters);

    options = options || {};
    /**
     * @member SuperMap.SetLayersInfoParameters.prototype.isTempLayers -{boolean}
     * @description 是否是临时图层。
     */
    this.isTempLayers = null;
    /**
     * @member SuperMap.SetLayersInfoParameters.prototype.resourceID -{string}
     * @description 临时图层资源ID，
     */
    this.resourceID = null;

    /**
     * @member SuperMap.SetLayersInfoParameters.prototype.layersInfo -{Object}
     * @description 要更新的图层信息。(包含修改和未修改的所有字段)。该参数可以通过图层信息服务获取，然后对返回值中subLayers.layers[i]图层信息属性进行修改。
     */
    this.layersInfo = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.SetLayersInfoParameters";
  }

  /**
   * @function SuperMap.SetLayersInfoParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(SetLayersInfoParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isTempLayers = null;
      me.resourceID = null;
      me.layersInfo = null;
    }
  }]);

  return SetLayersInfoParameters;
}();

_SuperMap.SuperMap.SetLayersInfoParameters = SetLayersInfoParameters;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SingleObjectQueryJobsParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SingleObjectQueryJobsParameter
 * @classdesc 单对象空间查询分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         datasetQuery -{string} 查询对象所在的数据集名称。 <br>
 *         mode -{{@link SuperMap.SpatialQueryMode}} 空间查询模式 。 <br>
 */
var SingleObjectQueryJobsParameter = exports.SingleObjectQueryJobsParameter = function () {
    function SingleObjectQueryJobsParameter(options) {
        _classCallCheck(this, SingleObjectQueryJobsParameter);

        if (!options) {
            return;
        }
        /**
         * @member SuperMap.SingleObjectQueryJobsParameter.prototype.datasetName -{string}
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member SuperMap.SingleObjectQueryJobsParameter.prototype.datasetQuery -{string}
         * @description 查询对象所在的数据集名称。
         */
        this.datasetQuery = "";

        /**
         * @member SuperMap.SingleObjectQueryJobsParameter.prototype.geometryQuery -{string}
         * @description 查询对象所在的几何对象。
         */
        this.geometryQuery = "";

        /**
         * @member SuperMap.SingleObjectQueryJobsParameter.prototype.mode -{SuperMap.SpatialQueryMode}
         * @description 空间查询模式 。
         */
        this.mode = _REST.SpatialQueryMode.CONTAIN;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SingleObjectQueryJobsParameter";
    }

    /**
     * @function SuperMap.SingleObjectQueryJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(SingleObjectQueryJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.datasetQuery = null;
            this.geometryQuery = null;
            this.mode = null;
        }

        /**
         * @function SuperMap.SingleObjectQueryJobsParameter.toObject
         * @param singleObjectQueryJobsParameter -{Object} 单对象空间查询分析任务参数
         * @param tempObj - {Object} 目标对象
         * @description 生成单对象空间查询分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(singleObjectQueryJobsParameter, tempObj) {
            for (var name in singleObjectQueryJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = singleObjectQueryJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = singleObjectQueryJobsParameter[name];
            }
        }
    }]);

    return SingleObjectQueryJobsParameter;
}();

_SuperMap.SuperMap.SingleObjectQueryJobsParameter = SingleObjectQueryJobsParameter;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StopQueryParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.StopQueryParameters
 * @classdesc 站点查询参数类。
 * @param options - {Object} 可选参数。
 */
var StopQueryParameters = exports.StopQueryParameters = function () {
  function StopQueryParameters(options) {
    _classCallCheck(this, StopQueryParameters);

    options = options || {};
    /**
     *  @member SuperMap.StopQueryParameters.prototype.keyWord -{string}
     *  @description 站点名称关键字。
     */
    this.keyWord = null;

    /**
     * @member SuperMap.StopQueryParameters.prototype.returnPosition -{boolean}
     * @description 是否返回站点坐标信息。
     */
    this.returnPosition = false;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.StopQueryParameters";
  }

  /**
   * @function SuperMap.StopQueryParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(StopQueryParameters, [{
    key: 'destroy',
    value: function destroy() {
      _Util.Util.reset(this);
    }
  }]);

  return StopQueryParameters;
}();

_SuperMap.SuperMap.StopQueryParameters = StopQueryParameters;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SummaryAttributesJobsParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SummaryAttributesJobsParameter
 * @classdesc 属性汇总分析任务参数类
 * @param options - {Object} 可选参数。如：<br>
 *        datasetName -{string} 数据集名。<br>
 *        groupField -{string}分组字段。<br>
 *        attributeField -{string} 属性字段。<br>
 *        statisticModes -{string} 统计模式。<br>
 */
var SummaryAttributesJobsParameter = exports.SummaryAttributesJobsParameter = function () {
    function SummaryAttributesJobsParameter(options) {
        _classCallCheck(this, SummaryAttributesJobsParameter);

        if (!options) {
            return;
        }
        this.datasetName = "";
        this.groupField = "";
        this.attributeField = "";
        this.statisticModes = "";
        _Util.Util.extend(this, options);
    }

    /**
     * @function SuperMap.SummaryAttributesJobsParameter.destroy
     * @override
     */


    _createClass(SummaryAttributesJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.groupField = null;
            this.attributeField = null;
            this.statisticModes = null;
        }

        /**
         * @function SuperMap.SummaryAttributesJobsParameter.toObject
         * @param SummaryAttributesJobsParameter -{Object} 属性汇总任务参数
         * @param tempObj - {Object} 目标对象
         * @description 生成属性汇总分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(SummaryAttributesJobsParameter, tempObj) {
            for (var name in SummaryAttributesJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = SummaryAttributesJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = SummaryAttributesJobsParameter[name];
            }
        }
    }]);

    return SummaryAttributesJobsParameter;
}();

_SuperMap.SuperMap.SummaryAttributesJobsParameter = SummaryAttributesJobsParameter;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SummaryMeshJobParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SummaryMeshJobParameter
 * @classdesc 点聚合分析任务参数类
 * @param options - {Object} 可选参数。如：<br>
 *        datasetName -{string} 数据集名。<br>
 *        query -{Object} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
 *        resolution -{number}分辨率。<br>
 *        statisticModes -{{@link SuperMap.StatisticAnalystMode}} 分析模式。<br>
 *        meshType -{number}分析类型。<br>
 *        fields -{number}权重索引。<br>
 *        type -{{@link SuperMap.SummaryType}} 聚合类型。
 */
var SummaryMeshJobParameter = exports.SummaryMeshJobParameter = function () {
    function SummaryMeshJobParameter(options) {
        _classCallCheck(this, SummaryMeshJobParameter);

        if (!options) {
            return;
        }
        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.datasetName -{string}
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.regionDataset -{string}
         * @description 聚合面数据集(聚合类型为多边形聚合时使用的参数)。
         */
        this.regionDataset = "";

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.query -{Object}
         * @description 分析范围(聚合类型为网格面聚合时使用的参数)。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。<br>
         */
        this.query = "";

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.resolution -{number}
         * @description 分辨率(聚合类型为网格面聚合时使用的参数)。
         */
        this.resolution = 100;

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.meshType -{number}
         * @description  网格面类型(聚合类型为网格面聚合时使用的参数),取值：0或1。
         */
        this.meshType = 0;

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.statisticModes -{SuperMap.StatisticAnalystMode}
         * @description 统计模式。
         */
        this.statisticModes = _REST.StatisticAnalystMode.AVERAGE;

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.fields -{number}
         * @description 权重字段。
         */
        this.fields = "";

        /**
         * @member SuperMap.SummaryMeshJobParameter.prototype.type -{SuperMap.SummaryType}
         * @description 聚合类型。
         */
        this.type = _REST.SummaryType.SUMMARYMESH;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SummaryMeshJobParameter";
    }

    /**
     * @function SuperMap.SummaryMeshJobParameter.destroy
     * @override
     */


    _createClass(SummaryMeshJobParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.query = null;
            this.resolution = null;
            this.statisticModes = null;
            this.meshType = null;
            this.fields = null;
            this.regionDataset = null;
            this.type = null;
        }

        /**
         * @function SuperMap.SummaryMeshJobParameter.toObject
         * @param summaryMeshJobParameter - {Object} 点聚合分析任务参数。
         * @param tempObj - {Object} 目标对象。
         * @description 生成点聚合分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(summaryMeshJobParameter, tempObj) {
            for (var name in summaryMeshJobParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = summaryMeshJobParameter[name];
                    continue;
                }
                if (name === "type") {
                    tempObj['type'] = summaryMeshJobParameter[name];
                    continue;
                }
                if (summaryMeshJobParameter.type === 'SUMMARYMESH' && name !== 'regionDataset' || summaryMeshJobParameter.type === 'SUMMARYREGION' && !contains(['meshType', 'resolution', 'query'], name)) {
                    tempObj['analyst'] = tempObj['analyst'] || {};
                    if (name === 'query') {
                        tempObj['analyst'][name] = summaryMeshJobParameter[name].toBBOX();
                    } else {
                        tempObj['analyst'][name] = summaryMeshJobParameter[name];
                    }
                }
            }

            function contains(arr, obj) {
                var i = arr.length;
                while (i--) {
                    if (arr[i] === obj) {
                        return true;
                    }
                }
                return false;
            }
        }
    }]);

    return SummaryMeshJobParameter;
}();

_SuperMap.SuperMap.SummaryMeshJobParameter = SummaryMeshJobParameter;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SummaryRegionJobParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SummaryRegionJobParameter
 * @classdesc 区域汇总分析任务参数类
 * @param options - {Object} 可选参数。如：<br>
 *         datasetName -{string} 数据集名。 <br>
 *         sumShape -{boolean} 是否统计长度或面积。 <br>
 *         query -{Object} 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。 <br>
 *         standardSummaryFields -{boolean} 以标准属字段统计。 <br>
 *         standardFields -{string} 以标准属字段统计的字段名称。 <br>
 *         standardStatisticModes -{{@link SuperMap.StatisticAnalystMode}} 以标准属字段统计的统计模式。 <br>
 *         weightedSummaryFields -{boolean} 以权重字段统计。 <br>
 *         weightedFields -{string} 以权重字段统计的字段名称。 <br>
 *         weightedStatisticModes -{{@link SuperMap.StatisticAnalystMode}} 以权重字段统计的统计模式。 <br>
 *         resolution -{number}网格大小。 <br>
 *         meshType -{number}网格面汇总类型。 <br>
 *         meshSizeUnit -{{@link SuperMap.AnalystSizeUnit}} 网格大小单位。 <br>
 *         type -{{@link SuperMap.SummaryType}} 汇总类型。 <br>
 */
var SummaryRegionJobParameter = exports.SummaryRegionJobParameter = function () {
  function SummaryRegionJobParameter(options) {
    _classCallCheck(this, SummaryRegionJobParameter);

    if (!options) {
      return;
    }

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.datasetName -{string}
     * @description 数据集名。
     */
    this.datasetName = "";

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.regionDataset -{string}
     * @description 汇总数据源（多边形汇总时用到的参数）。
     */
    this.regionDataset = "";

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.sumShape -{boolean}
     * @description 是否统计长度或面积。
     */
    this.sumShape = true;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.query
     * @description 分析范围。范围类型可以是SuperMap.Bounds|L.Bounds|ol.extent。
     */
    this.query = "";

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.standardSummaryFields -{boolean}
     * @description 以标准属字段统计。
     */
    this.standardSummaryFields = false;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.standardFields -{string}
     * @description 以标准属字段统计的字段名称。
     */
    this.standardFields = _REST.StatisticAnalystMode.AVERAGE;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.standardStatisticModes -{SuperMap.StatisticAnalystMode}
     * @description 以标准属字段统计的统计模式。
     */
    this.standardStatisticModes = "";

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.weightedSummaryFields -{boolean}
     * @description 以权重字段统计。
     */
    this.weightedSummaryFields = false;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.weightedFields -{string}
     * @description 以权重字段统计的字段名称。
     */
    this.weightedFields = "";

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.weightedStatisticModes -{SuperMap.StatisticAnalystMode}
     * @description 以权重字段统计的统计模式。
     */
    this.weightedStatisticModes = "";

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.meshType -{number}
     * @description 网格面汇总类型。
     */
    this.meshType = 0;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.resolution -{number}
     * @description 网格大小。
     */
    this.resolution = 100;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.meshSizeUnit -{SuperMap.AnalystSizeUnit}
     * @description 网格大小单位。
     */
    this.meshSizeUnit = _REST.AnalystSizeUnit.METER;

    /**
     * @member SuperMap.SummaryRegionJobParameter.prototype.type -{SuperMap.SummaryType}
     * @description 汇总类型。
     */
    this.type = _REST.SummaryType.SUMMARYMESH;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.SummaryRegionJobParameter";
  }

  /**
   * @function SuperMap.SummaryRegionJobParameter.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(SummaryRegionJobParameter, [{
    key: 'destroy',
    value: function destroy() {
      this.datasetName = null;
      this.sumShape = null;
      this.query = null;
      this.standardSummaryFields = null;
      this.standardFields = null;
      this.standardStatisticModes = null;
      this.weightedSummaryFields = null;
      this.weightedFields = null;
      this.weightedStatisticModes = null;
      this.meshType = null;
      this.resolution = null;
      this.meshSizeUnit = null;
      this.type = null;
    }

    /**
     * @function SuperMap.SummaryRegionJobParameter.toObject
     * @param summaryRegionJobParameter -{Object} 矢量裁剪分析任务参数。
     * @param tempObj - {Object} 目标对象。
     * @description 生成区域汇总分析服务对象
     */

  }], [{
    key: 'toObject',
    value: function toObject(summaryRegionJobParameter, tempObj) {
      for (var name in summaryRegionJobParameter) {
        if (name === "datasetName") {
          tempObj['input'] = tempObj['input'] || {};
          tempObj['input'][name] = summaryRegionJobParameter[name];
          continue;
        }
        if (name === "type") {
          tempObj['type'] = summaryRegionJobParameter[name];
          continue;
        }
        if (summaryRegionJobParameter.type === "SUMMARYREGION" || summaryRegionJobParameter.type === "SUMMARYMESH" && name !== "regionDataset") {
          tempObj['analyst'] = tempObj['analyst'] || {};
          if (name === 'query') {
            tempObj['analyst'][name] = summaryRegionJobParameter[name].toBBOX();
          } else {
            tempObj['analyst'][name] = summaryRegionJobParameter[name];
          }
        }
      }
    }
  }]);

  return SummaryRegionJobParameter;
}();

_SuperMap.SuperMap.SummaryRegionJobParameter = SummaryRegionJobParameter;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SurfaceAnalystParametersSetting = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _REST = __webpack_require__(3);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SurfaceAnalystParametersSetting
 * @classdesc
 * 表面分析参数设置类。
 * 通过该类可以设置表面分析提取等值线、提取等值面的一些参数，包括基准值、等值距、光滑度、光滑方法等。
 * @param options - {Object} 可选参数。如:</br>
 *        clipRegion - {Object} 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用null值取代该参数。</br>
 *                      面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。</br>
 *        datumValue - {number}获取或设置表面分析中提取等值线、提取等值面的基准值。</br>
 *        expectedZValues - {Array<number>} 获取或设置期望分析结果的 Z 值集合。</br>
 *        interval - {number}获取或设置等值距。等值距是两条等值线之间的间隔值。</br>
 *        resampleTolerance - {number}获取或设置重采样容限。</br>
 *        smoothMethod - {{@link SuperMap.SmoothMethod}} 获取或设置光滑处理所使用的方法。</br>
 *        smoothness - {number}获取或设置表面分析中等值线或等值面的边界线的光滑度。</br>
 */
var SurfaceAnalystParametersSetting = exports.SurfaceAnalystParametersSetting = function () {
  function SurfaceAnalystParametersSetting(options) {
    _classCallCheck(this, SurfaceAnalystParametersSetting);

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.clipRegion -{Object}
     * @description 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用null值取代该参数。</br>
     * 面类型可以是：SuperMap.Geometry.Polygon|L.Polygon|ol.geom.Polygon。
     */
    this.clipRegion = null;

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.datumValue -{number}
     * @description 获取或设置表面分析中提取等值线、提取等值面的基准值。
     * 基准值是作为一个生成等值线的初始起算值，并不一定是最小等值线的值。 例如，高程范围为 220 -1550 的 DEM 栅格数据，
     * 如果设基准值为0， 等值距为50，则提取等值线时，以基准值0为起点，等值距50为间隔提取等值线，
     * 因为给定高程的最小值是220，所以，在给定范围内提取等值线的最小高程是250。
     * 提取等值线的结果是：最小等值线值为250，最大等值线值为1550。
     */
    this.datumValue = 0;
    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.expectedZValues -{Array<number>}
     * @description 获取或设置期望分析结果的 Z 值集合。
     * Z 值集合存储一系列数值，该数值为待提取等值线的值。即仅高程值在Z值集合中的等值线会被提取。
     */
    this.expectedZValues = null;

    /**
     *  @member SuperMap.SurfaceAnalystParametersSetting.prototype.interval -{number}
     *  @description 获取或设置等值距。等值距是两条等值线之间的间隔值。
     */
    this.interval = 0;

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.resampleTolerance -{number}
     * @description 获取或设置重采样容限。
     * 容限值越大，采样结果数据越简化。当分析结果出现交叉时，可通过调整重采样容限为较小的值来处理。
     */
    this.resampleTolerance = 0;

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.smoothMethod -{SuperMap.SmoothMethod}
     * @description 获取或设置光滑处理所使用的方法。
     */
    this.smoothMethod = _REST.SmoothMethod.BSPLINE;

    /**
     * @member SuperMap.SurfaceAnalystParametersSetting.prototype.smoothness -{number}
     * @description 获取或设置表面分析中等值线或等值面的边界线的光滑度。
     * 以为0-5为例，光滑度为0表示不进行光滑操作，值越大表示光滑度越高。
     * 随着光滑度的增加，提取的等值线越光滑.当然光滑度越大，
     * 计算所需的时间和占用的内存也就越大。而且，当等值距较小时，
     * 光滑度太高会出现等值线相交的问题。
     */
    this.smoothness = 0;

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.SurfaceAnalystParametersSetting";
  }

  /**
   * @function SuperMap.SurfaceAnalystParametersSetting.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(SurfaceAnalystParametersSetting, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      if (me.clipRegion) {
        me.clipRegion.destroy();
        me.clipRegion = null;
      }

      me.datumValue = null;
      me.expectedZValues = null;
      me.interval = null;
      me.resampleTolerance = null;
      me.smoothMethod = null;
      me.smoothness = null;
    }
  }]);

  return SurfaceAnalystParametersSetting;
}();

_SuperMap.SuperMap.SurfaceAnalystParametersSetting = SurfaceAnalystParametersSetting;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TerrainCurvatureCalculationParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TerrainCurvatureCalculationParameters
 * @classdesc 地形曲率计算参数类。
 * @param options - {Object} 可选参数。如</br>
 *        dataset - {string} 要用来做地形曲率计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。</br>
 *        zFactor - {number}指定的高程缩放系数。默认值为 1.0，表示不缩放。</br>
 *        averageCurvatureName - {string} 结果数据集：平均曲率数据集的名称，必设字段。</br>
 *        profileCurvatureName - {string} 结果数据集：剖面曲率数据集的名称。</br>
 *        planCurvatureName - {string} 结果数据集：平面曲率数据集的名称。</br>
 *        deleteExistResultDataset - {boolean} 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。</br>
 */
var TerrainCurvatureCalculationParameters = exports.TerrainCurvatureCalculationParameters = function () {
  function TerrainCurvatureCalculationParameters(options) {
    _classCallCheck(this, TerrainCurvatureCalculationParameters);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.dataset -{string}
     * @description 要用来做地形曲率计算数据源中数据集的名称。
     * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。必设字段。
     * 注：地形曲率计算必须为栅格数据集。
     */
    this.dataset = null;

    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.zFactor -{number}
     * @description 指定的高程缩放系数。默认值为 1.0，表示不缩放。
     * 该值是指在 DEM 栅格数据中，栅格值（Z 坐标，即高程值）相对于 X 和 Y 坐标的单位变换系数。
     * 通常有 X，Y，Z 都参加的计算中，需要将高程值乘以一个高程缩放系数，使得三者单位一致。
     * 例如，X、Y 方向上的单位是米，而 Z 方向的单位是英尺，由于 1 英尺等于 0.3048 米，则需要指定缩放系数为 0.3048。
     */
    this.zFactor = 1.0;

    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.averageCurvatureName -{string}
     * @description 结果数据集：平均曲率数据集的名称，必设字段。
     */
    this.averageCurvatureName = null;

    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.profileCurvatureName -{string}
     * @description 结果数据集：剖面曲率数据集的名称。
     */
    this.profileCurvatureName = "";

    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.planCurvatureName -{string}
     * @description 结果数据集：平面曲率数据集的名称。
     */
    this.planCurvatureName = "";

    /**
     * @member SuperMap.TerrainCurvatureCalculationParameters.prototype.deleteExistResultDataset -{boolean}
     * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。默认为 false，即不删除。
     */
    this.deleteExistResultDataset = false;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.TerrainCurvatureCalculationParameters";
  }

  /**
   * @function SuperMap.TerrainCurvatureCalculationParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(TerrainCurvatureCalculationParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.dataset = null;
      me.zFactor = 1.0;
      me.averageCurvatureName = null;
      me.profileCurvatureName = null;
      me.planCurvatureName = null;
      me.deleteExistResultDataset = true;
    }

    /**
     * @function SuperMap.TerrainCurvatureCalculationParameters.toObject
     * @param derrainCurvatureCalculationParameters - {Object}  地形曲率计算参数
     * @param tempObj - {Object} 目标对象。
     * @description 生成地形曲率计算对象
     */

  }], [{
    key: 'toObject',
    value: function toObject(derrainCurvatureCalculationParameters, tempObj) {
      for (var name in derrainCurvatureCalculationParameters) {
        if (name !== "dataset") {
          tempObj[name] = derrainCurvatureCalculationParameters[name];
        }
      }
    }
  }]);

  return TerrainCurvatureCalculationParameters;
}();

_SuperMap.SuperMap.TerrainCurvatureCalculationParameters = TerrainCurvatureCalculationParameters;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeGraduatedSymbolStyle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _ServerStyle = __webpack_require__(11);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraduatedSymbolStyle
 * @classdesc 等级符号专题图正负零值显示风格类
 * @param options - {Object} 可选参数。如：<br>
 *        negativeDisplayed - {boolean} 是否显示负值。默认为 false。<br>
 *        negativeStyle - {{@link SuperMap.ServerStyle}} 负值的等级符号风格。<br>
 *        positiveStyle - {{@link SuperMap.ServerStyle}}  正值的等级符号风格。<br>
 *        zeroDisplayed - {boolean} 是否显示0值。默认为 false。<br>
 *        zeroStyle - {{@link SuperMap.ServerStyle}} 0值的等级符号风格。
 */
var ThemeGraduatedSymbolStyle = exports.ThemeGraduatedSymbolStyle = function () {
  function ThemeGraduatedSymbolStyle(options) {
    _classCallCheck(this, ThemeGraduatedSymbolStyle);

    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.negativeDisplayed -{boolean}
     * @description 是否显示负值。默认为 false。
     */
    this.negativeDisplayed = false;

    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.negativeStyle -{SuperMap.ServerStyle} 负值的等级符号风格。
     */
    this.negativeStyle = new _ServerStyle.ServerStyle();

    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.positiveStyle -{SuperMap.ServerStyle}
     * @description 正值的等级符号风格。
     */
    this.positiveStyle = new _ServerStyle.ServerStyle();

    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.zeroDisplayed -{boolean}
     * @description 是否显示0值。默认为 false。
     */
    this.zeroDisplayed = false;

    /**
     * @member SuperMap.ThemeGraduatedSymbolStyle.prototype.zeroStyle -{SuperMap.ServerStyle}
     * @description 0值的等级符号风格。
     */
    this.zeroStyle = new _ServerStyle.ServerStyle();

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.ThemeGraduatedSymbolStyle";
  }

  /**
   * @function SuperMap.ThemeGraduatedSymbolStyle.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ThemeGraduatedSymbolStyle, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.negativeDisplayed = null;
      me.negativeStyle = null;
      me.positiveStyle = null;
      me.zeroDisplayed = null;
      me.zeroStyle = null;
    }

    /**
     * @function SuperMap.ThemeGraduatedSymbolStyle.fromObj
     * @description 从传入对象获取等级符号专题图正负零值显示风格类。
     * @param obj - {Object} 传入对象
     * @return {SuperMap.ThemeGraduatedSymbolStyle} ThemeGraduatedSymbolStyle对象
     */

  }], [{
    key: 'fromObj',
    value: function fromObj(obj) {
      if (!obj) {
        return;
      }
      var res = new ThemeGraduatedSymbolStyle();
      _Util.Util.copy(res, obj);
      res.negativeStyle = _ServerStyle.ServerStyle.fromJson(obj.negativeStyle);
      res.positiveStyle = _ServerStyle.ServerStyle.fromJson(obj.positiveStyle);
      res.zeroStyle = _ServerStyle.ServerStyle.fromJson(obj.zeroStyle);
      return res;
    }
  }]);

  return ThemeGraduatedSymbolStyle;
}();

_SuperMap.SuperMap.ThemeGraduatedSymbolStyle = ThemeGraduatedSymbolStyle;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGraphAxes = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerColor = __webpack_require__(20);

var _ServerTextStyle = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphAxes
 * @classdesc 统计专题图坐标轴样式类。
 * @param  options - {Object} 可选参数。<br>
 *         axesColor - {{@link SuperMap.ServerColor}} 坐标轴颜色。<br>
 *         axesDisplayed - {boolean} 是否显示坐标轴。<br>
 *         axesGridDisplayed - {boolean} 是否在统计图坐标轴上显示网格。<br>
 *         axesTextDisplayed - {boolean} 是否显示坐标轴的文本标注。<br>
 *         axesTextStyle - {{@link SuperMap.ServerTextStyle}} 统计符号的最大最小尺寸。
 */
var ThemeGraphAxes = exports.ThemeGraphAxes = function () {
    function ThemeGraphAxes(options) {
        _classCallCheck(this, ThemeGraphAxes);

        /**
         * @member SuperMap.ThemeGraphAxes.prototype.axesColor -{SuperMap.ServerColor}
         * @description 坐标轴颜色，默认为黑色。当 axesDisplayed = true 时有效。
         */
        this.axesColor = new _ServerColor.ServerColor(0, 0, 0);

        /**
         * @member SuperMap.ThemeGraphAxes.prototype.axesDisplayed -{boolean}
         * @description 是否显示坐标轴。默认为 false，即不显示。<br>
         *              由于饼状图和环状图无坐标轴，故该属性以及所有与坐标轴设置相关的属性都不适用于它们。并且只有当该值为 true 时，其它设置坐标轴的属性才起作用。
         */
        this.axesDisplayed = false;

        /**
         * @member SuperMap.ThemeGraphAxes.prototype.axesGridDisplayed -{boolean}
         * @description 是否在统计图坐标轴上显示网格。默认为 false，即不显示。
         */
        this.axesGridDisplayed = false;

        /**
         * @member SuperMap.ThemeGraphAxes.prototype.axesTextDisplayed -{boolean}
         * @description 是否显示坐标轴的文本标注。默认为 false，即不显示。
         */
        this.axesTextDisplayed = false;

        /**
         * @member SuperMap.ThemeGraphAxes.prototype.axesTextStyle -{SuperMap.ServerTextStyle}
         * @description 坐标轴文本风格。当 axesTextDisplayed = true 时有效。
         */
        this.axesTextStyle = new _ServerTextStyle.ServerTextStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphAxes";
    }

    /**
     * @function SuperMap.ThemeGraphAxes.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGraphAxes, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            if (me.axesColor) {
                me.axesColor.destroy();
                me.axesColor = null;
            }
            me.axesDisplayed = null;
            me.axesGridDisplayed = null;
            me.axesTextDisplayed = null;
            if (me.axesTextStyle) {
                me.axesTextStyle.destroy();
                me.axesTextStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeGraphAxes.fromObj
         * @description 从传入对象获取统计专题图坐标轴样式类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphAxes} ThemeGraphAxes对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeGraphAxes();
            _Util.Util.copy(res, obj);
            res.axesColor = _ServerColor.ServerColor.fromJson(obj.axesColor);
            res.axesTextStyle = _ServerTextStyle.ServerTextStyle.fromObj(obj.axesTextStyle);
            return res;
        }
    }]);

    return ThemeGraphAxes;
}();

_SuperMap.SuperMap.ThemeGraphAxes = ThemeGraphAxes;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGraphItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerStyle = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphItem
 * @classdesc 统计专题图子项类
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 专题图子项的名称。<br>
 *        graphExpression - {string} 统计专题图的专题变量。<br>
 *        memoryDoubleValues - {Array<number>} 内存数组方式制作专题图时的值数组。<br>
 *        uniformStyle - {{@link SuperMap.ServerStyle}} 统计专题图子项的显示风格
 */
var ThemeGraphItem = exports.ThemeGraphItem = function () {
    function ThemeGraphItem(options) {
        _classCallCheck(this, ThemeGraphItem);

        /**
         * @member SuperMap.ThemeGraphItem.prototype.caption -{string}
         * @description 专题图子项的名称。
         */
        this.caption = null;

        /**
         * @member SuperMap.ThemeGraphItem.prototype.graphExpression -{string}
         * @description 统计专题图的专题变量。专题变量可以是一个字段或字段表达式。字段必须为数值型；表达式只能为数值型的字段间的运算。必设字段。
         */
        this.graphExpression = null;

        /**
         * @member SuperMap.ThemeGraphItem.prototype.memoryDoubleValues -{Array<number>}
         * @description 内存数组方式制作专题图时的值数组。<br>
         *              内存数组方式制作专题图时，只对 SmID 值在键数组（{@link SuperMap.ThemeGraph.memoryKeys}）中的记录制作专题图。<br>
         *              值数组的数值个数必须与键数组中数值的个数一致。 值数组中的值将代替原来的专题值来制作统计专题图。<br>
         *              比如：利用面积字段和周长字段（即有两个统计专题图子项 ）作为专题变量制作统计专题图。
         */
        this.memoryDoubleValues = null;

        /**
         * @member SuperMap.ThemeGraphItem.prototype.uniformStyle -{SuperMap.ServerStyle}
         * @description 统计专题图子项的显示风格。
         *              每一个统计专题图子项都对应一种显示风格。
         */
        this.uniformStyle = new _ServerStyle.ServerStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphItem";
    }

    /**
     * @function SuperMap.ThemeGraphItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGraphItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.graphExpression = null;
            me.memoryDoubleValues = null;
            me.uniformStyle = null;
        }

        /**
         * @function SuperMap.ThemeGraphItem.fromObj
         * @description 从传入对象获取统计专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphItem} ThemeGraphItem对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeGraphItem();
            _Util.Util.copy(res, obj);
            res.uniformStyle = _ServerStyle.ServerStyle.fromJson(obj.uniformStyle);
            return res;
        }
    }]);

    return ThemeGraphItem;
}();

_SuperMap.SuperMap.ThemeGraphItem = ThemeGraphItem;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGraphSize = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphSize
 * @classdesc 统计专题图符号尺寸类。
 * @param  options - {Object} 可选参数。如：<br>
 *         maxGraphSize - {number}统计图中显示的最大图表尺寸基准值。<br>
 *         minGraphSize - {number}统计图中显示的最小图表尺寸基准值。
 */
var ThemeGraphSize = exports.ThemeGraphSize = function () {
    function ThemeGraphSize(options) {
        _classCallCheck(this, ThemeGraphSize);

        /**
         * @member SuperMap.ThemeGraphSize.prototype.maxGraphSize -{number}
         * @description 获取或设置统计图中显示的最大图表尺寸基准值，默认为0像素。
         */
        this.maxGraphSize = 0;

        /**
         * @member SuperMap.ThemeGraphSize.prototype.minGraphSize -{number}
         * @description 获取或设置统计图中显示的最小图表尺寸基准值，默认为0像素。
         */
        this.minGraphSize = 0;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphSize";
    }

    /**
     * @function SuperMap.ThemeGraphSize.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGraphSize, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.maxGraphSize = null;
            me.minGraphSize = null;
        }

        /**
         * @function SuperMap.ThemeGraphSize.fromObj
         * @description 从传入对象获统计专题图符号尺寸类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphSize}  ThemeGraphSize对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGraphSize();
            _Util.Util.copy(res, obj);
            return res;
        }
    }]);

    return ThemeGraphSize;
}();

_SuperMap.SuperMap.ThemeGraphSize = ThemeGraphSize;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGraphText = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerTextStyle = __webpack_require__(33);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGraphText
 * @classdesc 统计图文字标注风格类。
 * @param options - {Object} 可选参数。<br>
 *        graphTextDisplayed - {boolean} 是否显示统计图上的文字标注。<br>
 *        graphTextFormat - {{@link SuperMap.ThemeGraphTextFormat}} 统计专题图文本显示格式。<br>
 *        graphTextStyle - {{@link SuperMap.ServerTextStyle}} 统计图上的文字标注风格。
 */
var ThemeGraphText = exports.ThemeGraphText = function () {
    function ThemeGraphText(options) {
        _classCallCheck(this, ThemeGraphText);

        /**
         * @member SuperMap.ThemeGraphText.prototype.graphTextDisplayed -{boolean}
         * @description 是否显示统计图上的文字标注。默认为 false，即不显示。
         */
        this.graphTextDisplayed = false;

        /**
         * @member SuperMap.ThemeGraphText.prototype.graphTextFormat -{SuperMap.ThemeGraphTextFormat}
         * @description 统计专题图文本显示格式。<br>
         *              文本显示格式包括百分数、真实数值、标题、标题+百分数、标题+真实数值。默认为 SuperMap.ThemeGraphTextFormat.CAPTION。
         */
        this.graphTextFormat = _REST.ThemeGraphTextFormat.CAPTION;

        /**
         * @member SuperMap.ThemeGraphText.prototype.graphTextStyle -{SuperMap.ServerTextStyle}
         * @description 统计图上的文字标注风格。
         */
        this.graphTextStyle = new _ServerTextStyle.ServerTextStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphText";
    }

    /**
     * @function SuperMap.ThemeGraphText.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGraphText, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.graphTextDisplayed = null;
            me.graphTextFormat = null;
            if (me.graphTextStyle) {
                me.graphTextStyle.destroy();
                me.graphTextStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeGraphText.fromObj
         * @description 从传入对象获取统计图文字标注风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGraphText} ThemeGraphText对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGraphText();
            _Util.Util.copy(res, obj);
            res.graphTextStyle = _ServerTextStyle.ServerTextStyle.fromObj(obj.graphTextStyle);
            return res;
        }
    }]);

    return ThemeGraphText;
}();

_SuperMap.SuperMap.ThemeGraphText = ThemeGraphText;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGridRange = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ThemeGridRangeItem = __webpack_require__(236);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGridRange
 * @classdesc 栅格分段专题图。
 * @description 栅格分段专题图，是将所有单元格的值按照某种分段方式分成多个范围段，值在同一个范围段中的单元格使用相同的颜色进行显示。<br>
 *              栅格分段专题图一般用来反映连续分布现象的数量或程度特征。比如某年的全国降水量分布图，将各气象站点的观测值经过内插之后生成的栅格数据进行分段显示。<br>
 *              该类类似于分段专题图类，不同点在于分段专题图的操作对象是矢量数据，而栅格分段专题图的操作对象是栅格数据。<br>
 * @extends SuperMap.Theme
 * @param options - {Object} 参数。<br>
 *        items - {Array<{@link SuperMap.ThemeGridRangeItem}>} 栅格分段专题图子项数组。<br>
 *        reverseColor - {boolean} 是否对栅格分段专题图中分段的颜色风格进行反序显示。<br>
 *        rangeMode - {{@link SuperMap.RangeMode}} 分段专题图的分段模式。<br>
 *        rangeParameter - {number}分段参数。<br>
 *        colorGradientType - {{@link SuperMap.ColorGradientType}} 渐变颜色枚举类。
 */
var ThemeGridRange = exports.ThemeGridRange = function (_Theme) {
    _inherits(ThemeGridRange, _Theme);

    function ThemeGridRange(options) {
        _classCallCheck(this, ThemeGridRange);

        /**
         * @member SuperMap.ThemeGridRange.prototype.items -{Array<SuperMap.ThemeGridRangeItem>}
         * @description 栅格分段专题图子项数组。<br>
         *              在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。<br>
         *              本类用来设置每个栅格范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。
         */
        var _this = _possibleConstructorReturn(this, (ThemeGridRange.__proto__ || Object.getPrototypeOf(ThemeGridRange)).call(this, "GRIDRANGE", options));

        _this.items = null;

        /**
         * @member SuperMap.ThemeGridRange.prototype.rangeMode -{SuperMap.RangeMode}
         * @description 分段专题图的分段模式。<br>
         *              默认值为 SuperMap.RangeMode.EQUALINTERVAL（等距离分段）。<br>
         *              在栅格分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。<br>
         *              目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，<br>
         *              显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
         */
        _this.rangeMode = _REST.RangeMode.EQUALINTERVAL;

        /**
         * @member SuperMap.ThemeGridRange.prototype.rangeParameter -{number}
         * @description 分段参数。<br>
         *              当分段模式为等距离分段法，平方根分段，对数分段法，计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，<br>
         *              该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。默认值为 -1。
         */
        _this.rangeParameter = 0;

        /**
         * @member SuperMap.ThemeGridRange.prototype.colorGradientType -{SuperMap.ColorGradientType}
         * @description 渐变颜色枚举类
         *
         */
        _this.colorGradientType = _REST.ColorGradientType.YELLOW_RED;

        /**
         * @member SuperMap.ThemeGridRange.prototype.reverseColor -{boolean}
         * @description 是否对栅格分段专题图中分段的颜色风格进行反序显示。
         */
        _this.reverseColor = false;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeGridRange";
        return _this;
    }

    /**
     * @function SuperMap.ThemeGridRange.prototype.destroy
     * @override
     */


    _createClass(ThemeGridRange, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGridRange.prototype.__proto__ || Object.getPrototypeOf(ThemeGridRange.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }
            me.reverseColor = null;
            me.rangeMode = null;
            me.rangeParameter = null;
            me.colorGradientType = null;
        }

        /**
         * @function SuperMap.ThemeGridRange.fromObj
         * @description 从传入对象获取栅格分段专题图。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridRange} ThemeGridRange对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeGridRange();
            _Util.Util.copy(res, obj);
            var itemsR = obj.items;
            var len = itemsR ? itemsR.length : 0;
            res.items = [];
            for (var i = 0; i < len; i++) {
                res.items.push(_ThemeGridRangeItem.ThemeGridRangeItem.fromObj(itemsR[i]));
            }
            return res;
        }
    }]);

    return ThemeGridRange;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeGridRange = ThemeGridRange;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGridRangeItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerColor = __webpack_require__(20);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGridRangeItem
 * @classdesc 栅格分段专题图子项类。
 * @description  在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。<br>
 *            本类用来设置每个范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。<br>
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 栅格分段专题图子项的标题。<br>
 *        color - {{@link SuperMap.ServerColor}}栅格分段专题图中每一个分段专题图子项的对应的颜色。<br>
 *        end - {number}栅格分段专题图子项的终止值。<br>
 *        start - {number}栅格分段专题图子项的起始值。<br>
 *        visible - {boolean} 栅格分段专题图子项是否可见。
 */
var ThemeGridRangeItem = exports.ThemeGridRangeItem = function () {
    function ThemeGridRangeItem(options) {
        _classCallCheck(this, ThemeGridRangeItem);

        /**
         * @member SuperMap.ThemeGridRangeItem.prototype.caption -{string}
         * @description 栅格分段专题图子项的标题。
         */
        this.caption = null;

        /**
         * @member SuperMap.ThemeGridRangeItem.prototype.color -{SuperMap.ServerColor}
         * @description 栅格分段专题图中每一个分段专题图子项的对应的颜色。
         */
        this.color = new _ServerColor.ServerColor();

        /**
         * @member SuperMap.ThemeGridRangeItem.prototype.end -{number}
         * @description 栅格分段专题图子项的终止值，即该段专题值范围的最大值，默认值为 0。
         */
        this.end = 0;

        /**
         * @member SuperMap.ThemeGridRangeItem.prototype.start -{number}
         * @description 栅格分段专题图子项的起始值，即该段专题值范围的最小值，默认值为 0。
         */
        this.start = 0;

        /**
         * @member SuperMap.ThemeGridRangeItem.prototype.visible -{boolean}
         * @description 栅格分段专题图子项是否可见。默认为 true。
         */
        this.visible = true;

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeGridRangeItem";
    }

    /**
     * @function SuperMap.ThemeGridRangeItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGridRangeItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.end = null;
            me.start = null;
            //需要验证是够存在destroy方法
            if (me.color) {
                me.color.destroy();
                me.color = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeGridRangeItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象。
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.color) {
                if (obj.color.toServerJSONObject) {
                    obj.color = obj.color.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGridRangeItem.fromObj
         * @description 从传入对象获取栅格分段专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridRangeItem} ThemeGridRangeItem对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeGridRangeItem();
            _Util.Util.copy(res, obj);
            res.color = _ServerColor.ServerColor.fromJson(obj.color);
            return res;
        }
    }]);

    return ThemeGridRangeItem;
}();

_SuperMap.SuperMap.ThemeGridRangeItem = ThemeGridRangeItem;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGridUnique = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(23);

var _ServerColor = __webpack_require__(20);

var _ThemeGridUniqueItem = __webpack_require__(238);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeGridUnique
 * @classdesc 栅格单值专题图类。
 * @description 栅格单值专题图，是将单元格值相同的归为一类，为每一类设定一种颜色，从而用来区分不同的类别。<br>
 *              栅格单值专题图适用于离散栅格数据和部分连续栅格数据，对于单元格值各不相同的那些连续栅格数据，使用栅格单值专题图不具有任何意义。<br>
 * @extends SuperMap.Theme
 * @param options - {Object} 可选参数。如：<br>
 *        items - {Array<{@link SuperMap.ThemeGridUniqueItem}>} 栅格单值专题图子项数组。<br>
 *        defaultcolor - {{@link SuperMap.ServerColor}} 栅格单值专题图的默认颜色。
 */
var ThemeGridUnique = exports.ThemeGridUnique = function (_Theme) {
    _inherits(ThemeGridUnique, _Theme);

    function ThemeGridUnique(options) {
        _classCallCheck(this, ThemeGridUnique);

        /**
         * @member SuperMap.ThemeGridUnique.prototype.defaultcolor -{SuperMap.ServerColor}
         * @description 栅格单值专题图的默认颜色。
         *              对于那些未在格网单值专题图子项之列的要素使用该颜色显示。
         */
        var _this = _possibleConstructorReturn(this, (ThemeGridUnique.__proto__ || Object.getPrototypeOf(ThemeGridUnique)).call(this, "GRIDUNIQUE", options));

        _this.defaultcolor = new _ServerColor.ServerColor();

        /**
         * @member SuperMap.ThemeGridUnique.prototype.items -{Array<SuperMap.ThemeGridUniqueItem>}
         * @description 栅格单值专题图子项数组。
         *              栅格单值专题图将值相同的单元格归为一类，每一类是一个专题图子项。
         */
        _this.items = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.ThemeGridUnique";
        return _this;
    }

    /**
     * @function SuperMap.ThemeGridUnique.prototype.destroy
     * @override
     */


    _createClass(ThemeGridUnique, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeGridUnique.prototype.__proto__ || Object.getPrototypeOf(ThemeGridUnique.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.items) {
                if (me.items.length > 0) {
                    for (var item in me.items) {
                        me.items[item].destroy();
                        me.items[item] = null;
                    }
                }
                me.items = null;
            }

            if (me.defaultcolor) {
                me.defaultcolor.destroy();
                me.defaultcolor = null;
            }
        }

        /**
         * @function SuperMap.ThemeGridUnique.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.defaultcolor) {
                if (obj.defaultcolor.toServerJSONObject) {
                    obj.defaultcolor = obj.defaultcolor.toServerJSONObject();
                }
            }
            if (obj.items) {
                var items = [],
                    len = obj.items.length;
                for (var i = 0; i < len; i++) {
                    items.push(obj.items[i].toServerJSONObject());
                }
                obj.items = items;
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGridUnique.fromObj
         * @description 从传入对象获取栅格单值专题图类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridUnique} ThemeGridUnique对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGridUnique();
            var uItems = obj.items;
            var len = uItems ? uItems.length : 0;
            _Util.Util.extend(res, obj);
            res.items = [];
            res.defaultcolor = new _ServerColor.ServerColor.fromJson(obj.defaultcolor);
            for (var i = 0; i < len; i++) {
                res.items.push(new _ThemeGridUniqueItem.ThemeGridUniqueItem.fromObj(uItems[i]));
            }
            return res;
        }
    }]);

    return ThemeGridUnique;
}(_Theme2.Theme);

_SuperMap.SuperMap.ThemeGridUnique = ThemeGridUnique;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeGridUniqueItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerColor = __webpack_require__(20);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeGridUniqueItem
 * @classdesc 栅格单值专题图子项类。<br>
 *              栅格单值专题图是将值相同的单元格归为一类，每一类是一个专题图子项。<br>
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 栅格单值专题图子项的名称。<br>
 *        color - {{@link SuperMap.ServerColor}} 栅格单值专题图子项的显示颜色。<br>
 *        unique - {number}栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。<br>
 *        visible - {boolean} 栅格单值专题图子项是否可见。
 */
var ThemeGridUniqueItem = exports.ThemeGridUniqueItem = function () {
    function ThemeGridUniqueItem(options) {
        _classCallCheck(this, ThemeGridUniqueItem);

        /**
         * @member SuperMap.ThemeGridUniqueItem.prototype.caption -{string}
         * @description 栅格单值专题图子项的名称。
         */
        this.caption = null;

        /**
         * @member SuperMap.ThemeGridUniqueItem.prototype.color -{SuperMap.ServerColor}
         * @description 栅格单值专题图子项的显示颜色。
         */
        this.color = new _ServerColor.ServerColor();

        /**
         * @member SuperMap.ThemeGridUniqueItem.prototype.unique -{number}
         * @description 栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。
         */
        this.unique = null;

        /**
         * @member SuperMap.ThemeGridUniqueItem.prototype.visible -{boolean}
         * @description 栅格单值专题图子项是否可见。默认为true。
         */
        this.visible = true;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGridUniqueItem";
    }

    /**
     * @function SuperMap.ThemeGridUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeGridUniqueItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.unique = null;

            if (me.color) {
                me.color.destroy();
                me.color = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeGridUniqueItem.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.color) {
                if (obj.color.toServerJSONObject) {
                    obj.color = obj.color.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeGridUniqueItem.fromObj
         * @description 从传入对象获取栅格单值专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeGridUniqueItem} ThemeGridUniqueItem对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            var res = new ThemeGridUniqueItem();
            _Util.Util.copy(res, obj);
            res.color = _ServerColor.ServerColor.fromJson(obj.color);
            return res;
        }
    }]);

    return ThemeGridUniqueItem;
}();

_SuperMap.SuperMap.ThemeGridUniqueItem = ThemeGridUniqueItem;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeLabelAlongLine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelAlongLine
 * @classdesc 标签沿线标注样式类。
 * @param options - {Object} 可选参数。如：<br>
 *        isAlongLine - {boolean} 是否沿线显示文本。<br>
 *        alongLineDirection - {{@link SuperMap.AlongLineDirection}} 标签沿线标注方向。<br>
 *        angleFixed - {boolean} 当沿线显示文本时，是否将文本角度固定。<br>
 *        repeatedLabelAvoided - {boolean} 沿线循环标注时是否避免标签重复标注。<br>
 *        repeatIntervalFixed - {boolean} 循环标注间隔是否固定。<br>
 *        labelRepeatInterval - {number}沿线且循环标注时循环标注的间隔。
 */
var ThemeLabelAlongLine = exports.ThemeLabelAlongLine = function () {
  function ThemeLabelAlongLine(options) {
    _classCallCheck(this, ThemeLabelAlongLine);

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.isAlongLine -{boolean}
     * @description 是否沿线显示文本。true 表示沿线显示文本，false 表示正常显示文本，默认为 true。
     */
    this.isAlongLine = true;

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.alongLineDirection -{SuperMap.AlongLineDirection}
     * @description 标签沿线标注方向。默认为 SuperMap.AlongLineDirection.LB_TO_RT（从上到下，从左到右放置）。
     */
    this.alongLineDirection = _REST.AlongLineDirection.LB_TO_RT;

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.angleFixed -{boolean}
     * @description 当沿线显示文本时，是否将文本角度固定。true 表示按固定文本角度显示文本，false 表示按照沿线角度显示文本。
     *              默认值为 false。如果固定角度，则所有标签均按所设置的文本风格中字体的旋转角度来显示，不考虑沿线标注的方向；
     *              如果不固定角度，在显示标签时会同时考虑字体的旋转角度和沿线标注的方向。
     */
    this.angleFixed = false;

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.repeatedLabelAvoided -{boolean}
     * @description 沿线循环标注时是否避免标签重复标注。
     */
    this.repeatedLabelAvoided = false;

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.repeatIntervalFixed -{boolean}
     * @description 循环标注间隔是否固定。true 表示使用固定循环标注间隔，即使用逻辑坐标来显示循环标注间隔；
     *              false 表示循环标注间隔随地图的缩放而变化，即使用地理坐标来显示循环标注间隔。默认值为 false。
     */
    this.repeatIntervalFixed = false;

    /**
     * @member SuperMap.ThemeLabelAlongLine.prototype.labelRepeatInterval -{number}
     * @description 沿线且循环标注时循环标注的间隔。长度的单位与地图的地理单位一致。只有设定 RepeatedLabelAvoided 为 true
     *              的时候，labelRepeatInterval 属性才有效。默认为0地图单位。
     */
    this.labelRepeatInterval = 0;

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.ThemeLabelAlongLine";
  }

  /**
   * @function SuperMap.ThemeLabelAlongLine.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ThemeLabelAlongLine, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.isAlongLine = null;
      me.alongLineDirection = null;
      me.angleFixed = null;
      me.repeatedLabelAvoided = null;
      me.repeatIntervalFixed = null;
      me.labelRepeatInterval = null;
    }

    /**
     * @function SuperMap.ThemeLabelAlongLine.fromObj
     * @description 从传入对象获取标签沿线标注样式类。
     * @param obj - {Object} 传入对象
     * @return {SuperMap.ThemeLabelAlongLine} ThemeLabelAlongLine对象
     */

  }], [{
    key: 'fromObj',
    value: function fromObj(obj) {
      if (!obj) {
        return;
      }
      var t = new ThemeLabelAlongLine();
      _Util.Util.copy(t, obj);
      return t;
    }
  }]);

  return ThemeLabelAlongLine;
}();

_SuperMap.SuperMap.ThemeLabelAlongLine = ThemeLabelAlongLine;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeLabelBackground = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerStyle = __webpack_require__(11);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelBackground
 * @classdesc 标签背景风格类。通过该类可以设置标签的背景形状和风格。
 * @param options - {Object} 可选参数。如：<br>
 *        labelBackShape - {{@link SuperMap.LabelBackShape}} 标签专题图中标签背景风格。<br>
 *        backStyle - {{@link SuperMap.ServerStyle}} 标签专题图中标签背景的形状枚举类。
 */
var ThemeLabelBackground = exports.ThemeLabelBackground = function () {
    function ThemeLabelBackground(options) {
        _classCallCheck(this, ThemeLabelBackground);

        /**
         * @member SuperMap.ThemeLabelBackground.prototype.labelBackShape -{SuperMap.LabelBackShape}
         * @description 标签专题图中标签背景风格。当背景形状
         *              labelBackShape 属性设为 NONE（即无背景形状） 时，backStyle 属性无效。
         */
        this.labelBackShape = _REST.LabelBackShape.NONE;

        /**
         * @member SuperMap.ThemeLabelBackground.prototype.backStyle -{SuperMap.ServerStyle}
         * @description 标签专题图中标签背景的形状枚举类。背景类型可
         *              以是矩形、圆角矩形、菱形、椭圆形、三角形和符号等，默认为 {@link SuperMap.LabelBackShape.NONE}，
         *              即不使用任何的形状作为标签的背景。
         */
        this.backStyle = new _ServerStyle.ServerStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeLabelBackground";
    }

    /**
     * @function SuperMap.ThemeLabelBackground.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeLabelBackground, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.labelBackShape = null;
            if (me.backStyle) {
                me.backStyle.destroy();
                me.backStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeLabelBackground.fromObj
         * @description 从传入对象获取标签背景风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelBackground} ThemeLabelBackground对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var t = new ThemeLabelBackground();
            t.labelBackShape = obj.labelBackShape;
            t.backStyle = _ServerStyle.ServerStyle.fromJson(obj.backStyle);

            return t;
        }
    }]);

    return ThemeLabelBackground;
}();

_SuperMap.SuperMap.ThemeLabelBackground = ThemeLabelBackground;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeLabelItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerTextStyle = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelItem
 * @classdesc 分段标签专题图的子项。
 * @description 标签专题图用专题值对点、线、面等对象做标注，值得注意的是，分段标签专题图允许用户通过 rangeExpression <br>
 *              字段指定用于分段的数值型字段，同一范围段内的标签具有相同的显示风格，其中每一个范围段就是一个专题图子项，<br>
 *              每一个子项都具有其名称、风格、起始值和终止值。注意：每个分段所表示的范围为 [Start, End)。例如：标签专题图的分段点有两个子项，<br>
 *              他们所代表的分段区间分别为[0,5)，[5,10)。那么需要分别设置 SuperMap.ThemeLabelItem[0].start=0，<br>
 *              SuperMap.ThemeLabelItem[0].end=5，SuperMap.ThemeLabelItem[1].start=5，SuperMap.ThemeLabelItem[1].end=10。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 专题图子项的名称。<br>
 *        end - {number}标签专题图子项的终止值。<br>
 *        start - {number}标签专题图子项的分段起始值。<br>
 *        visible - {boolean} 标签专题图子项是否可见。<br>
 *        style - {{@link SuperMap.ServerTextStyle}} 标签专题图子项文本的显示风格。
 */
var ThemeLabelItem = exports.ThemeLabelItem = function () {
    function ThemeLabelItem(options) {
        _classCallCheck(this, ThemeLabelItem);

        /**
         * @member SuperMap.ThemeLabelItem.prototype.caption -{string}
         * @description 标签专题子项的标题。
         */
        this.caption = null;

        /**
         * @member SuperMap.ThemeLabelItem.prototype.end -{number}
         * @description 标签专题图子项的终止值。如果该子项是分段中最后一个子项，那么该终止值就是分段的最大值；
         *              如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常。默认为0。
         */
        this.end = 0;

        /**
         * @member SuperMap.ThemeLabelItem.prototype.start -{number}
         * @description 标签专题图子项的分段起始值。如果该子项是分段中第一项，那么该起始值就是分段的最小值；
         *              如果该子项的序号大于等于 1 的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。默认为0。
         */
        this.start = 0;

        /**
         * @member SuperMap.ThemeLabelItem.prototype.visible -{boolean}
         * @description 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。默认值为 true。
         */
        this.visible = true;

        /**
         * @member SuperMap.ThemeLabelItem.prototype.style -{SuperMap.ServerTextStyle}
         * @description 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：<br>
         *              uniformMixedStyle（标签文本的复合风格），SuperMap.ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.style = new _ServerTextStyle.ServerTextStyle();

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeLabelItem";
    }

    /**
     * @function SuperMap.ThemeLabelItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeLabelItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.end = null;
            me.start = null;
            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeLabelItem.fromObj
         * @description 从传入对象获取分段标签专题图的子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelItem} ThemeLabelItem对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var t = new ThemeLabelItem();
            _Util.Util.copy(t, obj);
            return t;
        }
    }]);

    return ThemeLabelItem;
}();

_SuperMap.SuperMap.ThemeLabelItem = ThemeLabelItem;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeLabelText = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerTextStyle = __webpack_require__(33);

var _LabelMixedTextStyle = __webpack_require__(203);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelText
 * @classdesc 标签中文本风格类。
 *              通过该类可以设置标签中的文本字体大小和显示风格。
 * @param options - {Object} 可选参数。如：<br>
 *        maxTextHeight - {number}标签中文本的最大高度。<br>
 *        maxTextWidth - {number}标签中文本的最大宽度。<br>
 *        minTextHeight - {number}标签中文本的最小高度。<br>
 *        minTextWidth - {number}标签中文本的最小宽度。<br>
 *        uniformStyle - {{@link SuperMap.ServerTextStyle}} 统一文本风格。<br>
 *        uniformMixedStyle - {{@link SuperMap.LabelMixedTextStyle}} 标签专题图统一的文本复合风格。
 */
var ThemeLabelText = exports.ThemeLabelText = function () {
    function ThemeLabelText(options) {
        _classCallCheck(this, ThemeLabelText);

        /**
         * @member SuperMap.ThemeLabelText.prototype.maxTextHeight -{number}
         * @description 标签中文本的最大高度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
         *              当放大后的文本高度超过最大高度之后就不再放大。高度单位为0.1毫米。高度单位为0.1毫米。默认为 0 毫米。
         */
        this.maxTextHeight = 0;

        /**
         * @member SuperMap.ThemeLabelText.prototype.maxTextWidth -{number}
         * @description 标签中文本的最大宽度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
         *              当放大后的文本宽度超过最大高度之后就不再放大。宽度单位为0.1毫米。默认为0毫米。
         */
        this.maxTextWidth = 0;

        /**
         * @member SuperMap.ThemeLabelText.prototype.minTextHeight -{number}
         * @description 标签中文本的最小高度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
         *              当缩小后的文本高度小于最小高度之后就不再缩小。宽度单位为0.1毫米。默认为0毫米。
         */
        this.minTextHeight = 0;

        /**
         * @member SuperMap.ThemeLabelText.prototype.minTextWidth -{number}
         * @description 标签中文本的最小宽度。当标签文本不固定大小时，即 SuperMap.ServerTextStyle.sizeFixed = false 有效，
         *              当缩小后的文本宽度小于最小宽度之后就不再缩小。宽度单位为0.1毫米。默认为0毫米。
         */
        this.minTextWidth = 0;

        /**
         * @member SuperMap.ThemeLabelText.prototype.uniformStyle -{SuperMap.ServerTextStyle}
         * @description 统一文本风格。当标签专题图子项的个数大于等于1时，
         *              uniformStyle 不起作用，各标签的风格使用子项中设置的风格。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
         *              SuperMap.ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.uniformStyle = new _ServerTextStyle.ServerTextStyle();

        /**
         *@member SuperMap.ThemeLabelText.prototype.uniformMixedStyle -{SuperMap.LabelMixedTextStyle}
         *@description  标签专题图统一的文本复合风格。通过该类可以使同一个标
         *              签中的文字使用多种风格显示。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
         *              SuperMap.ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.uniformMixedStyle = null;

        if (options) {
            _Util.Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeLabelText";
    }

    /**
     * @function SuperMap.ThemeLabelText.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeLabelText, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.maxTextHeight = null;
            me.maxTextWidth = null;
            me.minTextHeight = null;
            me.minTextWidth = null;
            if (me.uniformStyle) {
                me.uniformStyle.destroy();
                me.uniformStyle = null;
            }
            if (me.uniformMixedStyle) {
                me.uniformMixedStyle.destroy();
                me.uniformMixedStyle = null;
            }
        }

        /**
         * @function SuperMap.ThemeLabelText.fromObj
         * @description 从传入对象获取标签中文本风格类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeLabelText} ThemeLabelText对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeLabelText();
            _Util.Util.copy(res, obj);
            res.uniformStyle = _ServerTextStyle.ServerTextStyle.fromObj(obj.uniformStyle);
            res.uniformMixedStyle = _LabelMixedTextStyle.LabelMixedTextStyle.fromObj(obj.uniformMixedStyle);
            return res;
        }
    }]);

    return ThemeLabelText;
}();

_SuperMap.SuperMap.ThemeLabelText = ThemeLabelText;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeMemoryData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeMemoryData
 * @classdesc 专题图内存数据类。
 * @param srcData - {Array} 原始值数组。
 * @param targetData - {Array} 外部值数组。
 */
var ThemeMemoryData = exports.ThemeMemoryData = function () {
    function ThemeMemoryData(srcData, targetData) {
        _classCallCheck(this, ThemeMemoryData);

        /**
         * @member SuperMap.ThemeMemoryData.prototype.srcData -{Array}
         * @description 原始值数组，该属性值将被 targetData 属性所指定的值替换掉，然后制作专题图，但数据库中的值并不会改变。
         */
        this.srcData = srcData;

        /**
         * @member SuperMap.ThemeMemoryData.prototype.targetData -{Array}
         * @description 外部值数组，即用于制作专题图的内存数据，设定该属性值后，会将 srcData 属性所指定的原始值替换掉制作专题图，但数据库中的值并不会改变。
         */
        this.targetData = targetData;

        this.CLASS_NAME = "SuperMap.ThemeMemoryData";
    }

    /**
     * @function SuperMap.ThemeMemoryData.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeMemoryData, [{
        key: "destroy",
        value: function destroy() {
            var me = this;
            me.srcData = null;
            me.targetData = null;
        }

        /**
         * @function SuperMap.ThemeMemoryData.prototype.toJSON
         * @description 将 SuperMap.ThemeMemoryData 对象转化为json字符串。
         * @return {string} 返回转换后的 JSON 字符串。
         */

    }, {
        key: "toJSON",
        value: function toJSON() {
            if (this.srcData && this.targetData) {
                var memoryDataStr = "";
                var count = Math.min(this.srcData.length, this.targetData.length);
                for (var i = 0; i < count; i++) {
                    memoryDataStr += "\'" + this.srcData[i] + "\':\'" + this.targetData[i] + "\',";
                }
                //去除多余的逗号
                if (i > 0) {
                    memoryDataStr = memoryDataStr.substring(0, memoryDataStr.length - 1);
                }
                return "{" + memoryDataStr + "}";
            } else {
                return null;
            }
        }
    }]);

    return ThemeMemoryData;
}();

_SuperMap.SuperMap.ThemeMemoryData = ThemeMemoryData;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(66);

__webpack_require__(96);

__webpack_require__(97);

__webpack_require__(98);

__webpack_require__(71);

__webpack_require__(99);

__webpack_require__(100);

__webpack_require__(235);

__webpack_require__(237);

__webpack_require__(202);

__webpack_require__(204);

__webpack_require__(205);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeParameters
 * @classdesc 专题图参数类。
 *               该类存储了制作专题所需的参数，包括数据源、数据集名称和专题图对象。
 * @param options - {Object} 可选参数。如：<br>
 *        datasetNames - {Array<string>} 要制作专题图的数据集数组，必设。<br>
 *        dataSourceNames - {Array<string>} 要制作专题图的数据集所在的数据源数组，必设。<br>
 *        joinItems - {Array<{@link SuperMap.JoinItem}>} 专题图外部表的连接信息 JoinItem 数组。<br>
 *        themes - {Array<{@link SuperMap.Theme}>} 专题图对象列表。<br>
 *        displayFilters -{Array<string>} 专题图属性过滤条件。<br>
 *        displayOrderBys -{Array<string>} 专题图对象生成符号叠加次序排序字段。<br>
 *        fieldValuesDisplayFilter -{Object} 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode。
 */
var ThemeParameters = exports.ThemeParameters = function () {
  function ThemeParameters(options) {
    _classCallCheck(this, ThemeParameters);

    /**
     * @member SuperMap.ThemeParameters.prototype.datasetNames -{Array<string>}
     * @description 要制作专题图的数据集数组，必设。
     */
    this.datasetNames = null;

    /**
     * @member SuperMap.ThemeParameters.prototype.dataSourceNames -{Array<string>}
     * @description 要制作专题图的数据集所在的数据源数组，必设。
     */
    this.dataSourceNames = null;

    /**
     * @member SuperMap.ThemeParameters.prototype.joinItems -{Array<SuperMap.JoinItem>}
     * @description 设置与外部表的连接信息 JoinItem 数组。
     *               使用此属性可以制作与外部表连接的专题图。
     */
    this.joinItems = null;

    /**
     * @member SuperMap.ThemeParameters.prototype.themes -{Array<SuperMap.Theme>}
     * @description 专题图对象列表。
     *               该参数为实例化的各类专题图对象的集合。
     */
    this.themes = null;

    /**
     * @member SuperMap.ThemeParameters.prototype.displayFilters -{Array<string>}
     * @description 专题图属性过滤条件。
     */
    this.displayFilters = null;

    /**
     * @member SuperMap.ThemeParameters.prototype.displayOrderBys -{Array<string>}
     * @description 专题图对象生成符号叠加次序排序字段
     */
    this.displayOrderBys = null;

    /**
     * @member SuperMap.ThemeParameters.prototype.fieldValuesDisplayFilter -{Object}
     * @description 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode,他们的作用如下：<br>
     *  * values：{Array<number>} - 就是要过滤的值；<br>
     *  * fieldName：{string} - 要过滤的字段名称 只支持数字类型的字段；<br>
     *  * fieldValuesDisplayMode：{string} 目前有两个DISPLAY/DISABLE。当为DISPLAY时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素
     */
    this.fieldValuesDisplayFilter = null;

    if (options) {
      _Util.Util.extend(this, options);
    }

    this.CLASS_NAME = "SuperMap.ThemeParameters";
  }

  /**
   * @function SuperMap.ThemeParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ThemeParameters, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.datasetNames = null;
      me.dataSourceNames = null;
      if (me.joinItems) {
        for (var i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
          joinItems[i].destroy();
        }
        me.joinItems = null;
      }
      if (me.themes) {
        for (var _i = 0, themes = me.themes, _len = themes.length; _i < _len; _i++) {
          themes[_i].destroy();
        }
        me.themes = null;
      }
    }
  }]);

  return ThemeParameters;
}();

_SuperMap.SuperMap.ThemeParameters = ThemeParameters;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeRangeItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerStyle = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeRangeItem
 * @classdesc 范围分段专题图子项类。
 * @description 在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。
 *              每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 分段专题图子项的标题。<br>
 *        end - {number}分段专题图子项的终止值。<br>
 *        start - {number}分段专题图子项的起始值。<br>
 *        style - {{@link SuperMap.ServerStyle}} 分段专题图子项的风格。<br>
 *        visible - {boolean} 分段专题图子项是否可见。
 */
var ThemeRangeItem = exports.ThemeRangeItem = function () {
    function ThemeRangeItem(options) {
        _classCallCheck(this, ThemeRangeItem);

        /**
         * @member SuperMap.ThemeRangeItem.prototype.caption -{string}
         * @description 分段专题图子项的标题。
         */
        this.caption = null;

        /**
         * @member SuperMap.ThemeRangeItem.prototype.end -{number}
         * @description 分段专题图子项的终止值，即该段专题值范围的最大值，默认值为 0。<br>
         *              如果该子项是分段中最后一个子项，则该终止值应大于分段字段（ThemeRange 类的 rangeExpression 属性）的最大值，若该终止值小于分段字段最大值，
         *              则剩余部分由内部随机定义其颜色；如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常；
         *              如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
         */
        this.end = 0;

        /**
         * @member SuperMap.ThemeRangeItem.prototype.start -{number}
         * @description 分段专题图子项的起始值，即该段专题值范围的最小值，默认值为 0。<br>
         *              如果该子项是分段中第一个子项，那么该起始值就是分段的最小值；如果子项的序号大于等于1的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。
         *              如果设置了范围分段模式和分段数，则会自动计算每段的范围[start, end)，故无需设置[start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
         */
        this.start = 0;

        /**
         * @member SuperMap.ThemeRangeItem.prototype.style -{SuperMap.ServerStyle}
         * @description 分段专题图子项的风格。
         *              每一个分段专题图子项都对应一种显示风格。
         */
        this.style = new _ServerStyle.ServerStyle();

        /**
         * @member SuperMap.ThemeRangeItem.prototype.visible -{boolean}
         * @description 分段专题图子项是否可见。默认为 true。
         */
        this.visible = true;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeRangeItem";
    }

    /**
     * @function SuperMap.ThemeRangeItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(ThemeRangeItem, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.caption = null;
            me.end = null;
            me.start = null;

            if (me.style) {
                me.style.destroy();
                me.style = null;
            }
            me.visible = null;
        }

        /**
         * @function SuperMap.ThemeRangeItem.prototypetoServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var obj = {};
            obj = _Util.Util.copyAttributes(obj, this);
            if (obj.style) {
                if (obj.style.toServerJSONObject) {
                    obj.style = obj.style.toServerJSONObject();
                }
            }
            return obj;
        }

        /**
         * @function SuperMap.ThemeRangeItem.fromObj
         * @description 从传入对象获取范围分段专题图子项类。
         * @param obj - {Object} 传入对象
         * @return {SuperMap.ThemeRangeItem} ThemeRangeItem对象
         */

    }], [{
        key: 'fromObj',
        value: function fromObj(obj) {
            if (!obj) {
                return;
            }
            var res = new ThemeRangeItem();
            _Util.Util.copy(res, obj);
            res.style = _ServerStyle.ServerStyle.fromJson(obj.style);
            return res;
        }
    }]);

    return ThemeRangeItem;
}();

_SuperMap.SuperMap.ThemeRangeItem = ThemeRangeItem;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TopologyValidatorJobsParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TopologyValidatorJobsParameter
 * @classdesc 拓扑检查分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         datasetTopology -{string} 检查对象所在的数据集名称。 <br>
 *         rule -{{@link SuperMap.TopologyValidatorRule}} 拓扑检查规则 。 <br>
 *         tolerance -{string} 容限 <br>
 */
var TopologyValidatorJobsParameter = exports.TopologyValidatorJobsParameter = function () {
    function TopologyValidatorJobsParameter(options) {
        _classCallCheck(this, TopologyValidatorJobsParameter);

        if (!options) {
            return;
        }
        /**
         * @member SuperMap.TopologyValidatorJobsParameter.prototype.datasetName -{string}
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member SuperMap.TopologyValidatorJobsParameter.prototype.datasetTopology -{string}
         * @description 拓扑检查对象所在的数据集名称。
         */
        this.datasetTopology = "";

        /**
         * @member SuperMap.TopologyValidatorJobsParameter.prototype.tolerance -{string}
         * @description 容限，指定的拓扑错误检查时使用的容限。
         */
        this.tolerance = "";

        /**
         * @member SuperMap.TopologyValidatorJobsParameter.prototype.rule -{SuperMap.TopologyValidatorRule}
         * @description 拓扑检查模式 。
         */
        this.rule = _REST.TopologyValidatorRule.RegionNoOverlap;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TopologyValidatorJobsParameter";
    }

    /**
     * @function SuperMap.TopologyValidatorJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(TopologyValidatorJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.datasetTopology = null;
            this.tolerance = null;
            this.rule = null;
        }

        /**
         * @function SuperMap.TopologyValidatorJobsParameter.toObject
         * @param TopologyValidatorJobsParameter -{Object} 拓扑检查分析任务参数
         * @param tempObj - {Object} 目标对象
         * @description 生成拓扑检查分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(TopologyValidatorJobsParameter, tempObj) {
            for (var name in TopologyValidatorJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = TopologyValidatorJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = TopologyValidatorJobsParameter[name];
            }
        }
    }]);

    return TopologyValidatorJobsParameter;
}();

_SuperMap.SuperMap.TopologyValidatorJobsParameter = TopologyValidatorJobsParameter;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransferLine = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransferLine
 * @classdesc 换乘路线信息类。
 * @param options - {Object} 可选参数。如:</br>
 *        lineID - {string} 乘车路线名称。</br>
 *        lineName - {string} 乘车路线名称。</br>
 *        lineAliasName - {string} 乘车路线别名。</br>
 *        startStopIndex - {number}上车站点在本公交路线中的索引。</br>
 *        startStopName - {string} 上车站点名称。</br>
 *        startStopAliasName - {string} 上车站点别名。</br>
 *        endStopIndex - {number}下车站点在本公交路线中的索引</br>
 *        endStopName - {string} 下车站点名称。</br>
 *        endStopAliasName - {string} 下车站点别名。</br>
 */
var TransferLine = exports.TransferLine = function () {
  function TransferLine(options) {
    _classCallCheck(this, TransferLine);

    options = options || {};
    /**
     * @memberSuperMap.TransferLine.prototype.lineID -{number}
     * @description 乘车路线名称。
     */
    this.lineID = null;

    /**
     * @memberSuperMap.TransferLine.prototype.lineName -{string}
     * @description 乘车路线名称。
     */
    this.lineName = null;

    /**
     * @memberSuperMap.TransferLine.prototype.lineAliasName -{string}
     * @description 乘车路线别名。
     */
    this.lineAliasName = null;

    /**
     * @memberSuperMap.TransferLine.prototype.startStopIndex -{number}
     * @description 上车站点在本公交路线中的索引。
     */
    this.startStopIndex = null;

    /**
     * @memberSuperMap.TransferLine.prototype.startStopName -{string}
     * @description 上车站点名称。
     */
    this.startStopName = null;

    /**
     * @memberSuperMap.TransferLine.prototype.startStopAliasName -{string}
     * @description 上车站点别名。
     */
    this.startStopAliasName = null;

    /**
     * @memberSuperMap.TransferLine.prototype.endStopIndex -{number}
     * @description 下车站点在本公交路线中的索引。
     */
    this.endStopIndex = null;

    /**
     * @memberSuperMap.TransferLine.prototype.endStopName -{string}
     * @description 下车站点名称。
     */
    this.endStopName = null;

    /**
     * @memberSuperMap.TransferLine.prototype.endStopAliasName -{string}
     * @description 下车站点别名。
     */
    this.endStopAliasName = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.TransferLine";
  }

  /**
   * @function SuperMap.TransferLine.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(TransferLine, [{
    key: 'destroy',
    value: function destroy() {
      _Util.Util.reset(this);
    }

    /**
     * @function SuperMap.TransferLine.fromJson
     * @description 将返回结果转化为 SuperMap.TransferLine 对象。
     * @param jsonObject - {Object} 新的返回结果。
     * @return {SuperMap.TransferLine} 转化后的 SuperMap.TransferLine 对象。
     */

  }], [{
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      if (!jsonObject) {
        return;
      }
      return new TransferLine({
        lineID: jsonObject['lineID'],
        lineName: jsonObject['lineName'],
        lineAliasName: jsonObject['lineAliasName'],
        startStopIndex: jsonObject['startStopIndex'],
        startStopName: jsonObject['startStopName'],
        startStopAliasName: jsonObject['startStopAliasName'],
        endStopIndex: jsonObject['endStopIndex'],
        endStopName: jsonObject['endStopName'],
        endStopAliasName: jsonObject['endStopAliasName']
      });
    }
  }]);

  return TransferLine;
}();

_SuperMap.SuperMap.TransferLine = TransferLine;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransferPathParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(247);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransferPathParameters
 * @classdesc 交通换乘线路查询参数类。
 * @param options - {Object} 参数。如:</br>
 *        transferLines -{Array<{@link SuperMap.TransferLine}>} 本换乘分段内可乘车的路线集合。</br>
 *        points - {Array<string>|Array<Object>} 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
 *
 */
var TransferPathParameters = exports.TransferPathParameters = function () {
    function TransferPathParameters(options) {
        _classCallCheck(this, TransferPathParameters);

        options = options || {};
        /**
         * @member SuperMap.TransferPathParameters.prototype.transferLines -{Array<SuperMap.TransferLine>}
         * @description 本换乘分段内可乘车的路线集合，通过交通换乘方案查询得到
         */
        this.transferLines = null;

        /**
         *  @member SuperMap.TransferPathParameters.prototype.points -{Array<string>|Array<Object>}
         *  @description 点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
         *  两种查询方式：
         *           1. 按照公交站点的起止ID进行查询，则points参数的类型为int[]，形如：[起点ID、终点ID]，公交站点的ID对应服务提供者配置中的站点ID字段；
         *           2. 按照起止点的坐标进行查询，则points参数的类型为Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
         */
        this.points = false;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TransferPathParameters";
    }

    /**
     * @function SuperMap.TransferPathParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(TransferPathParameters, [{
        key: 'destroy',
        value: function destroy() {
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.TransferPathParameters.toJson
         * @description 将 <SuperMap.TransferPathParameters> 对象参数转换为 json 字符串。
         * @param params - {SuperMap.TransferPathParameters} 交通换乘参数。
         * @return{string} 转化后的 json字符串。
         */

    }], [{
        key: 'toJson',
        value: function toJson(params) {
            if (params) {
                return _Util.Util.toJSON(params);
            }
        }
    }]);

    return TransferPathParameters;
}();

_SuperMap.SuperMap.TransferPathParameters = TransferPathParameters;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransferSolutionParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransferSolutionParameters
 * @classdesc 交通换乘方案查询参数类。
 * @param options - {Object} 参数。如:</br>
 *        solutionCount - {boolean} 乘车方案的数量。默认为6。</br>
 *        transferTactic - {{@link SuperMap.TransferTactic}} 交通换乘策略类型，
 *                      包括时间最短、距离最短、最少换乘、最少步行四种选择。</br>
 *        transferPreference - {{@link SuperMap.TransferPreference}} 乘车偏好枚举。</br>
 *        walkingRatio - {Array<number>} 步行与公交的消耗权重比，默认值为 10。</br>
 *        points - {Array<Object>|Array<number>} 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。</br>
 *                  点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
 *        evadeLines - {Array<number>} 避让路线的ID，默认为null。</br>
 *        evadeStops - {Array<number>} 避让站点的ID，默认为null。</br>
 *        priorLines - {Array<number>} 优先路线的ID，默认为null。</br>
 *        priorStops - {Array<number>} 优先站点的ID，默认为null。</br>
 *        travelTime - {string} 出行的时间。</br>
 */
var TransferSolutionParameters = exports.TransferSolutionParameters = function () {
  function TransferSolutionParameters(options) {
    _classCallCheck(this, TransferSolutionParameters);

    options = options || {};
    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.solutionCount -{number}
     *  @description 乘车方案的数量。默认为6。
     */
    this.solutionCount = 6;
    /**
     * @member SuperMap.TransferSolutionParameters.prototype.transferPreference -{SuperMap.TransferPreference}
     *  @description 乘车偏好枚举。默认为{@link TransferPreference|SuperMap.TransferPreference.NONE}
     */
    this.transferPreference = _REST.TransferPreference.NONE;

    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.transferTactic - {SuperMap.TransferTactic}
     *  @description 交通换乘策略类型，包括时间最短、距离最短、最少换乘、最少步行四种选择。默认为{@link TransferTactic|SuperMap.TransferTactic.LESS_TIME}
     */
    this.transferTactic = _REST.TransferTactic.LESS_TIME;

    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.walkingRatio - {number}
     *  @description 步行与公交的消耗权重比，默认值为 10。此值越大，则步行因素对于方案选择的影响越大。例如：</br>
     * 例如现在有两种换乘方案（在仅考虑消耗因素的情况下）：</br>
     * 方案1：坐车10公里，走路1公里；</br>
     * 方案2：坐车15公里，走路0.5公里；</br>
     *      1. 假设权重比为15：
     *          •方案1的总消耗为：10 + 1*15 = 25
     *          •方案2的总消耗为：15 + 0.5*15 = 22.5
     *          此时方案2消耗更低。
     *      2. 假设权重比为2：
     *          •方案1的总消耗为：10+1*2 = 12
     *          •方案2的总消耗为：15+0.5*2 = 17
     *          此时方案1消耗更低。
     */

    this.walkingRatio = null;

    /**
     *  @member SuperMap.TransferSolutionParameters.prototype.points - {Array<string>|{Array<Object>}
     *  @description 点类型可以是：SuperMap.Geometry.Point|L.Point|L.LatLng|ol.geom.Point。</br>
     *  两种查询方式：
     *           1. 按照公交站点的起止ID进行查询，则points参数的类型为int[]，形如：[起点ID、终点ID]，公交站点的ID对应服务提供者配置中的站点ID字段；
     *           2. 按照起止点的坐标进行查询，则points参数的类型为Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
     */
    this.points = false;

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.evadeLines -{Array<number>}
     * @description 避让路线ID。
     * */
    this.evadeLines = null;

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.evadeStops -{Array<number>}
     * @description 避让站点ID。
     * */
    this.evadeStops = null;

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.priorLines -{Array<number>}
     * @description 优先路线ID。
     * */
    this.priorLines = null;

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.priorStops -{Array<number>}
     * @description 优先站点ID。
     * */
    this.priorStops = null;

    /**
     * @member SuperMap.TransferSolutionParameters.prototype.travelTime -{string}
     * @description 出行的时间； 格式是："小时:分钟"，如："08:30"。如果设置了该参数，在分析时，则会考虑线路的首末班车时间的限制，即在返回的结果中会提示公交的首末班发车时间。
     */
    this.travelTime = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.TransferSolutionParameters";
  }

  /**
   * @function SuperMap.TransferSolutionParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(TransferSolutionParameters, [{
    key: 'destroy',
    value: function destroy() {
      _Util.Util.reset(this);
    }

    /**
     * @function SuperMap.TransferSolutionParameters.toJsonParameters
     * @description 将 <SuperMap.TransferSolutionParameters> 对象参数转换为 json 字符串。
     * @param  params - {SuperMap.TransferSolutionParameters} 交通换乘参数。
     * @return {string} 转化后的 json字符串。
     */

  }], [{
    key: 'toJson',
    value: function toJson(params) {
      if (params) {
        return _Util.Util.toJSON(params);
      }
    }
  }]);

  return TransferSolutionParameters;
}();

_SuperMap.SuperMap.TransferSolutionParameters = TransferSolutionParameters;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransportationAnalystResultSetting = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TransportationAnalystResultSetting
 * @classdesc 交通网络分析结果参数类。
 * @description 通过该类设置交通网络分析返回的结果，包括是否返回图片、是否返回弧段空间信息、是否返回结点空间信息等。
 * @param options - {Object} 可选参数。如:</br>
 *        returnEdgeFeatures - {boolean} 是否在分析结果中包含弧段要素集合。</br>
 *        returnEdgeGeometry - {boolean} 返回的弧段要素集合中是否包含几何对象信息。默认为 false。</br>
 *        returnEdgeIDs - {boolean} 返回结果中是否包含经过弧段 ID 集合。默认为 false。</br>
 *        returnNodeFeatures - {boolean} 是否在分析结果中包含结点要素集合。</br>
 *        returnNodeGeometry - {boolean} 返回的结点要素集合中是否包含几何对象信息。默认为 false。</br>
 *        returnNodeIDs - {boolean} 返回结果中是否包含经过结点 ID 集合。默认为 false。</br>
 *        returnPathGuides - {boolean} 返回分析结果中是否包含行驶导引集合。</br>
 *        returnRoutes - {boolean} 返回分析结果中是否包含路由对象的集合。
 */
var TransportationAnalystResultSetting = exports.TransportationAnalystResultSetting = function () {
  function TransportationAnalystResultSetting(options) {
    _classCallCheck(this, TransportationAnalystResultSetting);

    if (!options) {
      return;
    }

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnEdgeFeatures -{boolean}
     * @description 是否在分析结果中包含弧段要素集合。弧段要素包括弧段的空间信息和属性信息。
     */
    this.returnEdgeFeatures = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnEdgeGeometry -{boolean}
     * @description 返回的弧段要素集合中是否包含几何对象信息。默认为 false。
     */
    this.returnEdgeGeometry = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnEdgeIDs -{boolean}
     * @description 返回结果中是否包含经过弧段 ID 集合。默认为 false。
     */
    this.returnEdgeIDs = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnNodeFeatures -{boolean}
     * @description 是否在分析结果中包含结点要素集合。
     * 结点要素包括结点的空间信息和属性信息。其中返回的结点要素是否包含空间信息可通过 returnNodeGeometry 字段设置。默认为 false。
     */
    this.returnNodeFeatures = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnNodeGeometry -{boolean}
     * @description 返回的结点要素集合中是否包含几何对象信息。默认为 false。
     */
    this.returnNodeGeometry = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnNodeIDs -{boolean}
     * @description 返回结果中是否包含经过结点 ID 集合。默认为 false。
     */
    this.returnNodeIDs = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnPathGuides -{boolean}
     * @description 返回分析结果中是否包含行驶导引集合。
     */
    this.returnPathGuides = false;

    /**
     * @member SuperMap.TransportationAnalystResultSetting.prototype.returnRoutes -{boolean}
     * @description 返回分析结果中是否包含路由对象的集合。
     */
    this.returnRoutes = false;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.TransportationAnalystResultSetting";
  }

  /**
   * @function SuperMap.TransportationAnalystResultSetting.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(TransportationAnalystResultSetting, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.returnEdgeFeatures = null;
      me.returnEdgeGeometry = null;
      me.returnEdgeIDs = null;
      me.returnNodeFeatures = null;
      me.returnNodeGeometry = null;
      me.returnNodeIDs = null;
      me.returnPathGuides = null;
      me.returnRoutes = null;
    }
  }]);

  return TransportationAnalystResultSetting;
}();

_SuperMap.SuperMap.TransportationAnalystResultSetting = TransportationAnalystResultSetting;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UGCMapLayer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _UGCLayer2 = __webpack_require__(102);

__webpack_require__(210);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UGCMapLayer
 * @classdesc UGC 地图图层类。
 * @extends SuperMap.UGCLayer
 * @param options - {Object} 可选参数。如：<br>
 *        completeLineSymbolDisplayed - {boolean} 是否显示完整线型。<br>
 *        maxScale - {number}地图最大比例尺。<br>
 *        minScale - {number}地图最小比例尺。<br>
 *        minVisibleGeometrySize - {number}几何对象的最小可见大小，以像素为单位。<br>
 *        opaqueRate - {integer} 图层的不透明度。<br>
 *        symbolScalable - {boolean} 是否允许图层的符号大小随图缩放。<br>
 *        symbolScale - {number}图层的符号缩放基准比例尺。<br>
 *        overlapDisplayed - {boolean} 地图对象在同一范围内时，是否重叠显示，默认为False。<br>
 *        overlapDisplayedOptions - {{@link SuperMap.OverlapDisplayedOptions}} 地图的压盖过滤显示选项，当
 *                                   overlapDisplayed 为 false 时有效。
 */
var UGCMapLayer = exports.UGCMapLayer = function (_UGCLayer) {
  _inherits(UGCMapLayer, _UGCLayer);

  /*
   * Constructor: SuperMap.UGCMapLayer
   * UGC 地图图层类构造函数。
   */
  function UGCMapLayer(options) {
    _classCallCheck(this, UGCMapLayer);

    options = options || {};

    /**
     * @member SuperMap.UGCMapLayer.prototype.completeLineSymbolDisplayed -{boolean}
     * @description 是否显示完整线型。
     */
    var _this = _possibleConstructorReturn(this, (UGCMapLayer.__proto__ || Object.getPrototypeOf(UGCMapLayer)).call(this, options));

    _this.completeLineSymbolDisplayed = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.maxScale -{number}
     * @description 地图最大比例尺。
     */
    _this.maxScale = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.minScale -{number}
     * @description 地图最小比例尺。
     */
    _this.minScale = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.minVisibleGeometrySize -{number}
     * @description 几何对象的最小可见大小，以像素为单位。
     */
    _this.minVisibleGeometrySize = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.opaqueRate -{integer}
     * @description 图层的不透明度。
     */
    _this.opaqueRate = null;
    /**
     * @member SuperMap.UGCMapLayer.prototype.symbolScalable -{boolean}
     * @description 是否允许图层的符号大小随图缩放。
     */
    _this.symbolScalable = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.symbolScale -{number}
     * @description 图层的符号缩放基准比例尺。
     */
    _this.symbolScale = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.overlapDisplayed -{boolean}
     * @description 地图对象在同一范围内时，是否重叠显示，默认为False。
     */
    _this.overlapDisplayed = null;

    /**
     * @member SuperMap.UGCMapLayer.prototype.overlapDisplayedOptions -{SuperMap.OverlapDisplayedOptions}
     * @description 地图的压盖过滤显示选项，当 overlapDisplayed 为 false 时有效。
     */
    _this.overlapDisplayedOptions = null;

    _this.CLASS_NAME = "SuperMap.UGCMapLayer";
    return _this;
  }

  /**
   * @function SuperMap.UGCMapLayer.prototype.destroy
   * @override
   */


  _createClass(UGCMapLayer, [{
    key: 'destroy',
    value: function destroy() {
      _get(UGCMapLayer.prototype.__proto__ || Object.getPrototypeOf(UGCMapLayer.prototype), 'destroy', this).call(this);
      _Util.Util.reset(this);
    }

    /**
     * @function SuperMap.UGCMapLayer.prototype.fromJson
     * @description 将服务端JSON对象转换成当前客户端对象
     * @param jsonObject - {Object} 要转换的 JSON 对象。
     */

  }, {
    key: 'fromJson',
    value: function fromJson(jsonObject) {
      _get(UGCMapLayer.prototype.__proto__ || Object.getPrototypeOf(UGCMapLayer.prototype), 'fromJson', this).call(this, jsonObject);
    }

    /**
     * @function SuperMap.UGCMapLayer.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @return{Object} 对应的 JSON 格式对象。
     */

  }, {
    key: 'toServerJSONObject',
    value: function toServerJSONObject() {
      return _get(UGCMapLayer.prototype.__proto__ || Object.getPrototypeOf(UGCMapLayer.prototype), 'toServerJSONObject', this).call(this);
    }
  }]);

  return UGCMapLayer;
}(_UGCLayer2.UGCLayer);

_SuperMap.SuperMap.UGCMapLayer = UGCMapLayer;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateEdgeWeightParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.UpdateEdgeWeightParameters
 * @classdesc 边的耗费权重更新服务参数类。
 * @param options - {Object} 可选参数。如：<br>
 *        edgeId - {string} 所在边的id。<br>
 *        fromNodeId - {string} 起始转向点的id。<br>
 *        toNodeId - {string} 终止转向点的id。<br>
 *        weightField - {string} 边的耗费字段。<br>
 *        edgeWeight - {string} 耗费权重。
 */
var UpdateEdgeWeightParameters = exports.UpdateEdgeWeightParameters = function () {
  function UpdateEdgeWeightParameters(options) {
    _classCallCheck(this, UpdateEdgeWeightParameters);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.edgeId -{string}
     * @description 所在边的id
     */
    this.edgeId = "";

    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.fromNodeId -{string}
     * @description 起始转向点的id
     */
    this.fromNodeId = "";

    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.toNodeId -{string}
     * @description 终止转向点的id
     */
    this.toNodeId = "";

    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.weightField -{string}
     * @description 边的耗费字段
     */
    this.weightField = "";

    /**
     * @member SuperMap.UpdateEdgeWeightParameters.prototype.edgeWeight -{string}
     * @description 耗费权重
     */
    this.edgeWeight = "";

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.UpdateEdgeWeightParameters";
  }

  /**
   * @function SuperMap.UpdateEdgeWeightParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(UpdateEdgeWeightParameters, [{
    key: 'destroy',
    value: function destroy() {
      this.edgeId = null;
      this.fromNodeId = null;
      this.toNodeId = null;
      this.weightField = null;
      this.edgeWeight = null;
    }
  }]);

  return UpdateEdgeWeightParameters;
}();

_SuperMap.SuperMap.UpdateEdgeWeightParameters = UpdateEdgeWeightParameters;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UpdateTurnNodeWeightParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.UpdateTurnNodeWeightParameters
 * @classdesc 转向耗费权重更新服务参数类
 * @param options - {Object} 可选参数。如：<br>
 *         nodeId - {string} 转向结点的id。<br>
 *        fromEdgeId - {string} 起始边的id。<br>
 *        toEdgeId - {string} 终止边的id。<br>
 *        weightField - {string} 转向结点的耗费字段。<br>
 *        turnNodeWeight - {string} 耗费权重
 */
var UpdateTurnNodeWeightParameters = exports.UpdateTurnNodeWeightParameters = function () {
  function UpdateTurnNodeWeightParameters(options) {
    _classCallCheck(this, UpdateTurnNodeWeightParameters);

    if (!options) {
      return;
    }
    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.nodeId -{string}
     * @description 转向结点的id
     */
    this.nodeId = "";

    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.fromEdgeId -{string}
     * @description 起始边的id
     */
    this.fromEdgeId = "";

    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.toEdgeId -{string}
     * @description 终止边的id
     */
    this.toEdgeId = "";

    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.weightField -{string}
     * @description 转向结点的耗费字段
     */
    this.weightField = "";

    /**
     * @member SuperMap.UpdateTurnNodeWeightParameters.prototype.turnNodeWeight -{string}
     * @description 耗费权重
     */
    this.turnNodeWeight = "";
    _Util.Util.extend(this, options);
    this.CLASS_NAME = "SuperMap.UpdateTurnNodeWeightParameters";
  }

  /**
   * @function SuperMap.UpdateTurnNodeWeightParameters.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(UpdateTurnNodeWeightParameters, [{
    key: 'destroy',
    value: function destroy() {
      this.nodeId = null;
      this.fromEdgeId = null;
      this.toEdgeId = null;
      this.weightField = null;
      this.turnNodeWeight = null;
    }
  }]);

  return UpdateTurnNodeWeightParameters;
}();

_SuperMap.SuperMap.UpdateTurnNodeWeightParameters = UpdateTurnNodeWeightParameters;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Vector = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _UGCSubLayer2 = __webpack_require__(52);

var _ServerStyle = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Vector
 * @classdesc UGC 矢量图层类。
 * @extends SuperMap.UGCSubLayer
 * @param options - {Object} 可选参数。如：
 *        style - {{@link SuperMap.ServerStyle}} 矢量图层的风格。
 */

var Vector = exports.Vector = function (_UGCSubLayer) {
    _inherits(Vector, _UGCSubLayer);

    function Vector(options) {
        _classCallCheck(this, Vector);

        options = options || {};

        /**
         * @member SuperMap.Vector.prototype.style -{SuperMap.ServerStyle}
         * @description 矢量图层的风格。
         */
        var _this = _possibleConstructorReturn(this, (Vector.__proto__ || Object.getPrototypeOf(Vector)).call(this, options));

        _this.style = null;

        _this.CLASS_NAME = "SuperMap.Vector";
        return _this;
    }

    /**
     * @function SuperMap.Vector.prototype.destroy
     * @override
     */


    _createClass(Vector, [{
        key: 'destroy',
        value: function destroy() {
            _get(Vector.prototype.__proto__ || Object.getPrototypeOf(Vector.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.Vector.prototype.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         */

    }, {
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            _get(Vector.prototype.__proto__ || Object.getPrototypeOf(Vector.prototype), 'fromJson', this).call(this, jsonObject);
            var sty = this.style;
            if (sty) {
                this.style = new _ServerStyle.ServerStyle(sty);
            }
        }

        /**
         * @function SuperMap.Vector.prototype.toServerJSONObject
         * @description 转换成对应的 JSON 格式对象。
         * @return {Object} 对应的 JSON 格式对象
         */

    }, {
        key: 'toServerJSONObject',
        value: function toServerJSONObject() {
            var jsonObject = _SuperMap.SuperMap.toServerJSONObject();
            if (jsonObject.style) {
                if (jsonObject.style.toServerJSONObject) {
                    jsonObject.style = jsonObject.style.toServerJSONObject();
                }
            }
            return jsonObject;
        }
    }]);

    return Vector;
}(_UGCSubLayer2.UGCSubLayer);

_SuperMap.SuperMap.Vector = Vector;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorClipJobsParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.VectorClipJobsParameter
 * @classdesc 矢量裁剪分析任务参数类
 * @param options - {Object} 必填参数。<br>
 *         datasetName -{string} 数据集名。 <br>
 *         datasetOverlay -{string} 裁剪对象数据集。 <br>
 *         mode -{{@link SuperMap.ClipAnalystMode}} 裁剪分析模式 。 <br>
 */
var VectorClipJobsParameter = exports.VectorClipJobsParameter = function () {
    function VectorClipJobsParameter(options) {
        _classCallCheck(this, VectorClipJobsParameter);

        options = options || {};

        /**
         * @member SuperMap.VectorClipJobsParameter.prototype.datasetName -{string}
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member SuperMap.VectorClipJobsParameter.prototype.datasetOverlay -{string}
         * @description 裁剪对象数据集。
         */
        this.datasetVectorClip = "";

        /**
         * @member SuperMap.VectorClipJobsParameter.prototype.geometryClip -{string}
         * @description 裁剪几何对象。
         */
        this.geometryClip = "";

        /**
         * @member SuperMap.VectorClipJobsParameter.prototype.mode -{SuperMap.ClipAnalystMode}
         * @description 裁剪分析模式 。
         */
        this.mode = _REST.ClipAnalystMode.CLIP;

        _Util.Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.VectorClipJobsParameter";
    }

    /**
     * @function SuperMap.VectorClipJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(VectorClipJobsParameter, [{
        key: 'destroy',
        value: function destroy() {
            this.datasetName = null;
            this.datasetVectorClip = null;
            this.geometryClip = null;
            this.mode = null;
        }

        /**
         * @function SuperMap.VectorClipJobsParameter.toObject
         * @param vectorClipJobsParameter -{Object} 区域汇总分析服务参数
         * @param tempObj - {Object} 目标对象。
         * @description 矢量裁剪分析任务对象
         */

    }], [{
        key: 'toObject',
        value: function toObject(vectorClipJobsParameter, tempObj) {
            for (var name in vectorClipJobsParameter) {
                if (name === "datasetName") {
                    tempObj['input'] = tempObj['input'] || {};
                    tempObj['input'][name] = vectorClipJobsParameter[name];
                    continue;
                }
                tempObj['analyst'] = tempObj['analyst'] || {};
                tempObj['analyst'][name] = vectorClipJobsParameter[name];
            }
        }
    }]);

    return VectorClipJobsParameter;
}();

_SuperMap.SuperMap.VectorClipJobsParameter = VectorClipJobsParameter;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OnlineData = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _OnlineServiceBase2 = __webpack_require__(258);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.OnlineData
 * @classdesc Online myData服务
 * @param serviceRootUrl -{string} 服务根地址
 * @param options -{string} 服务相关参数
 */
var OnlineData = exports.OnlineData = function (_OnlineServiceBase) {
    _inherits(OnlineData, _OnlineServiceBase);

    //TODO 目前并没有对接服务支持的所有操作，日后需要补充完整
    function OnlineData(serviceRootUrl, options) {
        _classCallCheck(this, OnlineData);

        var _this = _possibleConstructorReturn(this, (OnlineData.__proto__ || Object.getPrototypeOf(OnlineData)).call(this, serviceRootUrl));

        options = options || {};
        //MD5
        _this.MD5 = null;
        //文件类型。
        _this.type = null;
        //数据上传者名称。
        _this.userName = null;
        //文件名称。
        _this.fileName = null;
        //文件大小，单位为 B 。
        _this.size = null;
        //服务发布状态。
        _this.serviceStatus = null;
        //服务 id 。
        _this.serviceId = null;
        //数据项 id 。
        _this.id = null;
        //最后修改时间。
        _this.lastModfiedTime = null;
        //文件状态。
        _this.status = null;
        //数据文件存储 id 。
        _this.storageId = null;
        //数据的发布信息。
        _this.publishInfo = null;
        //数据的权限信息。
        _this.authorizeSetting = null;
        //用户的昵称。
        _this.nickname = null;
        //数据的标签。
        _this.tags = [];
        //数据的描述信息。
        _this.description = null;
        //数据发布的服务信息集合。
        _this.dataItemServices = null;
        //数据坐标类型。
        _this.coordType = null;
        //数据审核信息
        _this.dataCheckResult = null;
        //数据元数据信息
        _this.dataMetaInfo = null;
        //数据的缩略图路径。
        _this.thumbnail = null;

        _Util.Util.extend(_this, options);
        if (_this.id) {
            _this.serviceUrl = serviceRootUrl + "/" + _this.id;
        }
        _this.CLASS_NAME = "SuperMap.OnlineData";
        return _this;
    }

    /**
     * @function SuperMap.OnlineData.prototype.load
     * @description 通过url请求获取该服务完整信息
     * @returns {Promise} 返回不包含请求结果的Promise对象,请求返回结果自动填充到该类属性中
     */


    _createClass(OnlineData, [{
        key: 'load',
        value: function load() {
            if (!this.serviceUrl) {
                return;
            }
            var me = this;
            return me.request("GET", this.serviceUrl).then(function (result) {
                _Util.Util.extend(me, result);
            });
        }

        /**
         * @function SuperMap.OnlineData.prototype.getPublishedServices
         * @description 获取数据发布的所有服务
         * @returns {Object} 数据发布的所有服务
         */

    }, {
        key: 'getPublishedServices',
        value: function getPublishedServices() {
            return this.dataItemServices;
        }

        /**
         * @function SuperMap.OnlineData.prototype.getAuthorizeSetting
         * @description 获取数据的权限信息
         * @returns {Object} 权限信息
         */

    }, {
        key: 'getAuthorizeSetting',
        value: function getAuthorizeSetting() {
            return this.authorizeSetting;
        }
    }]);

    return OnlineData;
}(_OnlineServiceBase2.OnlineServiceBase);

_SuperMap.SuperMap.OnlineData = OnlineData;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FilterField = exports.DataItemOrderBy = exports.DataItemType = exports.ServiceStatus = undefined;

var _SuperMap = __webpack_require__(0);

/*
 * 服务发布状态
 */
var ServiceStatus = exports.ServiceStatus = _SuperMap.SuperMap.ServiceStatus = {
    DOES_NOT_INVOLVE: "DOES_NOT_INVOLVE",
    PUBLISH_FAILED: "PUBLISH_FAILED",
    PUBLISHED: "PUBLISHED",
    PUBLISHING: "PUBLISHING",
    UNPUBLISHED: "UNPUBLISHED",
    UNPUBLISHED_FAILED: "UNPUBLISHED_FAILED"
};

/*
 * 数据项类型
 */
var DataItemType = exports.DataItemType = _SuperMap.SuperMap.DataItemType = {
    AUDIO: "AUDIO",
    COLOR: "COLOR",
    COLORSCHEME: "COLORSCHEME",
    CSV: "CSV",
    EXCEL: "EXCEL",
    FILLSYMBOL: "FILLSYMBOL",
    IMAGE: "IMAGE",
    LAYERTEMPLATE: "LAYERTEMPLATE",
    LAYOUTTEMPLATE: "LAYOUTTEMPLATE",
    LINESYMBOL: "LINESYMBOL",
    MAPTEMPLATE: "MAPTEMPLATE",
    MARKERSYMBOL: "MARKERSYMBOL",
    MBTILES: "MBTILES",
    PHOTOS: "PHOTOS",
    SHP: "SHP",
    SMTILES: "SMTILES",
    SVTILES: "SVTILES",
    THEMETEMPLATE: "THEMETEMPLATE",
    TPK: "TPK",
    UDB: "UDB",
    UGCV5: "UGCV5",
    UNKNOWN: "UNKNOWN",
    VIDEO: "VIDEO",
    WORKENVIRONMENT: "WORKENVIRONMENT",
    WORKSPACE: "WORKSPACE"
};

/*
 * 数据排序字段
 */
var DataItemOrderBy = exports.DataItemOrderBy = _SuperMap.SuperMap.DataItemOrderBy = {
    FILENAME: "FILENAME",
    ID: "ID",
    LASTMODIFIEDTIME: "LASTMODIFIEDTIME",
    NICKNAME: "NICKNAME",
    SERVICESTATUS: "SERVICESTATUS",
    SIZE: "SIZE",
    STATUS: "STATUS",
    TYPE: "TYPE",
    UPDATETIME: "UPDATETIME",
    USERNAME: "USERNAME"
};

/*
 * 关键字查询时的过滤字段
 */
var FilterField = exports.FilterField = _SuperMap.SuperMap.FilterField = {
    LINKPAGE: "LINKPAGE",
    MAPTITLE: "MAPTITLE",
    NICKNAME: "NICKNAME",
    RESTITLE: "RESTITLE",
    USERNAME: "USERNAME"
};

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OnlineServiceBase = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// import {SecurityManager} from '../security/SecurityManager';


var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _FetchRequest = __webpack_require__(21);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.OnlineServiceBase
 * @classdesc Online服务基类(使用key作为权限限制的类需要实现此类)
 * @param options -{Object} 服务参数
 */
var OnlineServiceBase = exports.OnlineServiceBase = function () {
    function OnlineServiceBase(options) {
        _classCallCheck(this, OnlineServiceBase);

        options = options || {};
        _Util.Util.extend(this, options);
        this.serverType = _REST.ServerType.ONLINE;
        this.CLASS_NAME = "SuperMap.OnlineServiceBase";
    }

    /**
     * @function SuperMap.OnlineServiceBase.prototype.request
     * @description 请求online服务
     * @param method - {string} 请求方式, 'get','put','post','delete'
     * @param url - {string} 服务地址
     * @param param -{Object} Url查询参数
     * @param requestOptions -{Object} http请求参数, 比如请求头，超时时间等
     * @return {Promise}  返回包含请求结果的Promise对象
     */


    _createClass(OnlineServiceBase, [{
        key: 'request',
        value: function request(method, url, param, requestOptions) {
            url = this.createCredentialUrl(url);
            return _FetchRequest.FetchRequest.commit(method, url, param, requestOptions).then(function (response) {
                return response.json();
            });
        }

        /**
         * @function SuperMap.OnlineServiceBase.prototype.createCredentialUrl
         * @description 追加授权信息
         * @param url - {string} 对接的online服务地址
         */

    }, {
        key: 'createCredentialUrl',
        value: function createCredentialUrl(url) {
            var newUrl = url,
                key = this.getCredential();
            if (key) {
                var paramStr = "key=" + key;
                var endStr = newUrl.substring(newUrl.length - 1, newUrl.length);
                if (newUrl.indexOf("?") > -1 && endStr === "?") {
                    newUrl += paramStr;
                } else if (newUrl.indexOf("?") > -1 && endStr !== "?") {
                    newUrl += "&" + paramStr;
                } else {
                    newUrl += "?" + paramStr;
                }
            }
            return newUrl;
        }

        //其子类需要重写该方法，修改其中获取key的字段
        //存储key可能是服务id字段，可能是url，或者是WebAPI类型

    }, {
        key: 'getCredential',
        value: function getCredential() {
            //return SecurityManager.getKey(this.id);
            //或
            //return SecurityManager.getKey(this.serviceUrl);
        }
    }]);

    return OnlineServiceBase;
}();

_SuperMap.SuperMap.OnlineServiceBase = OnlineServiceBase;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
        value: true
});
exports.RankSymbol = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.RankSymbol
 * @classdesc 符号专题要素基类。
 * @description 此类定义了符号专题要素基础模型，具体的图表模型通过继承此类，在子类中实现 assembleShapes 方法。
 * 符号专题要素模型采用了可视化图形大小自适应策略，用较少的参数控制着图表诸多图形，图表配置对象 <SuperMap.Feature.Theme.RankSymbol::setting> 的基础属性只有 5 个，
 * 它们控制着图表结构、值域范围、数据小数位等基础图表形态。构成图表的图形必须在图表结构里自适应大小。
 * 此类不可实例化，此类的可实例化子类必须实现 assembleShapes() 方法。
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.RankSymbol} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 *
 * @extends SuperMap.Feature.Theme.Graph
 *
 */
var RankSymbol = exports.RankSymbol = function (_Graph) {
        _inherits(RankSymbol, _Graph);

        function RankSymbol(data, layer, fields, setting, lonlat, options) {
                _classCallCheck(this, RankSymbol);

                /**
                 * @member SuperMap.Feature.Theme.RankSymbol.prototype.setting -{Object}
                 * @description 符号配置对象，该对象控制着图表的可视化显示。
                 * 下面是此配置对象的 5 个基础可设属性：</br>
                 * codomain - {Array<number>} 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
                 * XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。</br>
                 * YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。</br>
                 * dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。</br>
                 * decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
                 * 除了以上 5 个基础属性，此对象的可设属性在不同子类中有较大差异，不同子类中对同一属性的解释也可能不同。
                 * 请在此类的子类中查看 setting 对象的可设属性和属性含义。
                 */
                var _this = _possibleConstructorReturn(this, (RankSymbol.__proto__ || Object.getPrototypeOf(RankSymbol)).call(this, data, layer, fields, setting, lonlat, options));

                _this.setting = null;
                // 配置项检测与赋值
                if (setting && setting.codomain) {
                        _this.setting = setting;
                        _this.DVBCodomain = _this.setting.codomain;
                }
                _this.CLASS_NAME = "SuperMap.Feature.Theme.RankSymbol";
                return _this;
        }

        /**
         * @function SuperMap.Feature.Theme.RankSymbol.prototype.destroy
         * @description 销毁专题要素。
         */


        _createClass(RankSymbol, [{
                key: 'destroy',
                value: function destroy() {
                        this.setting = null;
                        _get(RankSymbol.prototype.__proto__ || Object.getPrototypeOf(RankSymbol.prototype), 'destroy', this).call(this);
                }

                /**
                 * @function SuperMap.Feature.Theme.RankSymbol.prototype.initBaseParameter
                 * @description 初始化专题要素（图形）基础参数。
                 * 在调用此方法前，此类的图表模型相关属性都是不可用的 ，此方法在 assembleShapes 函数中调用。
                 * 调用此函数关系到 setting 对象的以下属性</br>
                 * codomain - {Array<number>} 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
                 * XOffset - {number} 专题要素（图形）在 X 方向上的偏移值，单位像素。</br>
                 * YOffset - {number} 专题要素（图形）在 Y 方向上的偏移值，单位像素。</br>
                 * dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，它是指图形框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。</br>
                 * decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
                 * @returns {boolean} 初始化参数是否成功。
                 */

        }, {
                key: 'initBaseParameter',
                value: function initBaseParameter() {
                        // 参数初始化是否成功
                        var isSuccess = true;

                        // setting 属性是否已成功赋值
                        if (!this.setting) {
                                return false;
                        }
                        var sets = this.setting;

                        // 图表偏移
                        if (sets.XOffset) {
                                this.XOffset = sets.XOffset;
                        }
                        if (sets.YOffset) {
                                this.YOffset = sets.YOffset;
                        }
                        this.XOffset = sets.XOffset ? sets.XOffset : 0;
                        this.YOffset = sets.YOffset ? sets.YOffset : 0;

                        // 其他默认值
                        this.origonPoint = [];
                        this.chartBox = [];
                        this.dataViewBox = [];

                        this.DVBParameter = sets.dataViewBoxParameter ? sets.dataViewBoxParameter : [0, 0, 0, 0];

                        this.DVBOrigonPoint = [];
                        this.DVBCenterPoint = [];
                        this.origonPointOffset = [];

                        // 图表位置
                        this.resetLocation();

                        // 专题要素宽度 w
                        var w = this.width;
                        // 专题要素高度 h
                        var h = this.height;
                        // 专题要素像素位置 loc
                        var loc = this.location;

                        // 专题要素像素位置 loc
                        this.origonPoint = [loc[0] - w / 2, loc[1] - h / 2];
                        // 专题要素原点（左上角）
                        var op = this.origonPoint;

                        // 图表框（[left, bottom, right, top]）
                        this.chartBox = [op[0], op[1] + h, op[0] + w, op[1]];
                        // 图表框
                        var cb = this.chartBox;

                        // 数据视图框参数，它是图表框各方向对应的内偏距
                        var dbbP = this.DVBParameter;
                        // 数据视图框 （[left, bottom, right, top]）
                        this.dataViewBox = [cb[0] + dbbP[0], cb[1] - dbbP[1], cb[2] - dbbP[2], cb[3] + dbbP[3]];
                        // 数据视图框
                        var dvb = this.dataViewBox;
                        //检查数据视图框是否合法
                        if (dvb[0] >= dvb[2] || dvb[1] <= dvb[3]) {
                                return false;
                        }

                        // 数据视图框原点
                        this.DVBOrigonPoint = [dvb[0], dvb[3]];
                        // 数据视图框宽度
                        this.DVBWidth = Math.abs(dvb[2] - dvb[0]);
                        // 数据视图框高度
                        this.DVBHeight = Math.abs(dvb[1] - dvb[3]);
                        // 数据视图框中心点
                        this.DVBCenterPoint = [this.DVBOrigonPoint[0] + this.DVBWidth / 2, this.DVBOrigonPoint[1] + this.DVBHeight / 2];

                        // 数据视图框原点与图表框的原点偏移量
                        this.origonPointOffset = [this.DVBOrigonPoint[0] - op[0], this.DVBOrigonPoint[1] - op[1]];

                        return isSuccess;
                }
        }]);

        return RankSymbol;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.RankSymbol = RankSymbol;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Image = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Image
 * 图片参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Image = exports.Image = function (_ShapeParameters) {
  _inherits(Image, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Image
   * 创建一个图片参数对象。
   *
   * Parameters:
   * x - {Number} 左上角横坐标，必设参数。
   * y - {Number} 左上角纵坐标，必设参数。
   * image - {String/Cavans} 图片地址或cavans对象，必设参数。
   * width - {Number} 绘制到画布上的宽度，默认为图片高度。
   * height - {Number} 绘制到画布上的高度，默认为图片高度。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Image>} 图片参数对象。
   */
  //     * sx - {Number} 从图片中裁剪的左上角横坐标。
  //     * sy - {Number} 从图片中裁剪的左上角纵坐标。
  //     * sWidth - {Number} 从图片中裁剪的宽度，默认为图片高度。
  //     * sHeight - {Number} 绘制到画布上的高度，默认为图片高度。
  function Image(x, y, image, width, height, sx, sy, sWidth, sHeight) {
    _classCallCheck(this, Image);

    /**
     * APIProperty: x
     * {Number} 图片左上角横坐标。
     */
    var _this = _possibleConstructorReturn(this, (Image.__proto__ || Object.getPrototypeOf(Image)).call(this, x, y, image, width, height, sx, sy, sWidth, sHeight));

    _this.x = x;

    /**
     * APIProperty: y
     * {Number} 左上角纵坐标。
     */
    _this.y = y;

    /**
     * APIProperty: image
     * {String} 图片地址。
     */
    _this.image = image;

    /**
     * APIProperty: width
     * {Number} 绘制到画布上的宽度，默认为图片高度。
     */
    _this.width = width;

    /**
     * APIProperty: height
     * {Number} 绘制到画布上的高度，默认为图片高度。
     */
    _this.height = height;

    /**
     * Property: sx
     * {Number} 从图片中裁剪的左上角横坐标。
     */
    _this.sx = sx;

    /**
     * Property: sy
     * {Number} 从图片中裁剪的左上角纵坐标。
     */
    _this.sy = sy;

    /**
     * Property: sWidth
     * {Number} 从图片中裁剪的宽度，默认为图片高度。
     */
    _this.sWidth = sWidth;

    /**
     * Property: sHeight
     * {Number} 绘制到画布上的高度，默认为图片高度。
     */
    _this.sHeight = sHeight;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Image";

    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Image, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.image = null;
      this.width = null;
      this.height = null;
      this.sx = null;
      this.sy = null;
      this.sWidth = null;
      this.sHeight = null;
      _get(Image.prototype.__proto__ || Object.getPrototypeOf(Image.prototype), 'destroy', this).call(this);
    }
  }]);

  return Image;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Image = Image;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Label = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Label
 * 标签参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Label = exports.Label = function (_ShapeParameters) {
  _inherits(Label, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Label
   * 创建一个标签参数对象。
   *
   * Parameters:
   * x - {Number} 横坐标，必设参数。
   * y - {Number} 纵坐标，必设参数。
   * text - {String} 图形中的附加文本，必设参数。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Label>} 标签参数对象。
   */
  function Label(x, y, text) {
    _classCallCheck(this, Label);

    /**
     * APIProperty: x
     * {Number} 标签 x 坐标。
     */
    var _this = _possibleConstructorReturn(this, (Label.__proto__ || Object.getPrototypeOf(Label)).call(this, x, y, text));

    _this.x = x;

    /**
     * APIProperty: y
     * {Number} 标签 y 坐标。
     */
    _this.y = y;

    /**
     * APIProperty: text
     * {String} 标签的文本内容。
     */
    _this.text = text;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Label";
    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Label, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.text = null;

      _get(Label.prototype.__proto__ || Object.getPrototypeOf(Label.prototype), 'destroy', this).call(this);
    }
  }]);

  return Label;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Label = Label;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rectangle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeParameters2 = __webpack_require__(25);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.Feature.ShapeParameters.Rectangle
 * 矩形参数对象。
 *
 * Inherits:
 *  - <SuperMap.Feature.ShapeParameters>
 */
var Rectangle = exports.Rectangle = function (_ShapeParameters) {
  _inherits(Rectangle, _ShapeParameters);

  /**
   * Constructor: SuperMap.Feature.ShapeParameters.Rectangle
   * 创建一个图形矩形参数对象。
   *
   * Parameters:
   * x - {Number} 矩形 x 坐标，必设参数。
   * y - {Number} 矩形 y 坐标，必设参数。
   * width - {Number} 矩形 width 坐标，必设参数。
   * height - {Number} 矩形 height 坐标，必设参数。
   *
   * Returns:
   * {<SuperMap.Feature.ShapeParameters.Rectangle>} 图形矩形参数对象。
   */
  function Rectangle(x, y, width, height) {
    _classCallCheck(this, Rectangle);

    /**
     * APIProperty: x
     * {Number} 左上角 x 坐标。
     */
    var _this = _possibleConstructorReturn(this, (Rectangle.__proto__ || Object.getPrototypeOf(Rectangle)).call(this, x, y, width, height));

    _this.x = !isNaN(x) ? x : 0;

    /**
     * APIProperty: y
     * {Number} 左上角 y 坐标。
     */
    _this.y = !isNaN(x) ? y : 0;

    /**
     * APIProperty: width
     * {Number} 宽度。
     */
    _this.width = !isNaN(width) ? width : 0;

    /**
     * APIProperty: height
     * {Number} 高度。
     */
    _this.height = !isNaN(height) ? height : 0;

    _this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Rectangle";
    return _this;
  }

  /**
   * APIMethod: destroy
   * 销毁对象。
   */


  _createClass(Rectangle, [{
    key: 'destroy',
    value: function destroy() {
      this.x = null;
      this.y = null;
      this.width = null;
      this.height = null;

      _get(Rectangle.prototype.__proto__ || Object.getPrototypeOf(Rectangle.prototype), 'destroy', this).call(this);
    }
  }]);

  return Rectangle;
}(_ShapeParameters2.ShapeParameters);

_SuperMap.SuperMap.Feature = _SuperMap.SuperMap.Feature || {};
_SuperMap.SuperMap.Feature.ShapeParameters.Rectangle = Rectangle;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Animator = exports.Animation = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(29);

var _Eventful2 = __webpack_require__(53);

var _Clip = __webpack_require__(265);

var _SUtil = __webpack_require__(12);

var _Util2 = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class SuperMap.LevelRenderer.Animation
 * @classdesc 动画主类, 调度和管理所有动画控制器。
 * @extends SuperMap.LevelRenderer.Eventful
 */
var Animation = exports.Animation = function (_Eventful) {
    _inherits(Animation, _Eventful);

    /*
     * Constructor: SuperMap.LevelRenderer.Animation
     * 构造函数。
     *
     * Parameters:
     * options - {Object} 动画参数选项，可设属性如下：
     *
     * Symbolizer properties:
     * onframe - {Object} onframe。
     * stage - {Object} stage。
     *
     * (code)
     *     var animation = new SuperMap.LevelRenderer.Animation();
     *     var obj = {
     *         x: 100,
     *         y: 100
     *     };
     *     animation.animate(node.position)
     *         .when(1000, {
     *             x: 500,
     *             y: 500
     *         })
     *         .when(2000, {
     *             x: 100,
     *             y: 100
     *         })
     *         .start('spline');
     * (end)
     */
    function Animation(options) {
        _classCallCheck(this, Animation);

        var _this = _possibleConstructorReturn(this, (Animation.__proto__ || Object.getPrototypeOf(Animation)).call(this, options));

        options = options || {};
        /**
         * Property: stage
         * {Object}
         *
         */
        _this.stage = {};

        /**
         * Property: onframe
         * {Object}
         *
         */
        _this.onframe = function () {};

        /**
         * Property: _clips
         * {Array}
         *
         */
        _this._clips = [];

        /**
         * Property: _running
         * {Boolean}
         *
         */
        _this._running = false;

        /**
         * Property: _time
         * {Number}
         *
         */
        _this._time = 0;

        _Util2.Util.extend(_this, options);

        _this.CLASS_NAME = "SuperMap.LevelRenderer.Animation";

        return _this;
    }

    /**
     * APIMethod: add
     * 添加动画片段
     *
     * Parameters:
     * clip - {<SuperMap.LevelRenderer.Animation.Clip>} 动画片段
     *
     */


    _createClass(Animation, [{
        key: 'add',
        value: function add(clip) {
            this._clips.push(clip);
        }

        /**
         * APIMethod: remove
         * 删除动画片段
         *
         * Parameters:
         * clip - {<SuperMap.LevelRenderer.Animation.Clip>} 动画片段
         *
         */

    }, {
        key: 'remove',
        value: function remove(clip) {
            var idx = new _Util.Util().indexOf(this._clips, clip);
            if (idx >= 0) {
                this._clips.splice(idx, 1);
            }
        }

        /**
         * Method: _update
         *
         */

    }, {
        key: '_update',
        value: function _update() {
            var time = new Date().getTime();
            var delta = time - this._time;
            var clips = this._clips;
            var len = clips.length;

            var deferredEvents = [];
            var deferredClips = [];
            for (var i = 0; i < len; i++) {
                var clip = clips[i];
                var e = clip.step(time);
                // Throw out the events need to be called after
                // stage.update, like destroy
                if (e) {
                    deferredEvents.push(e);
                    deferredClips.push(clip);
                }
            }
            if (this.stage.update) {
                this.stage.update();
            }

            // Remove the finished clip
            for (var _i = 0; _i < len;) {
                if (clips[_i]._needsRemove) {
                    clips[_i] = clips[len - 1];
                    clips.pop();
                    len--;
                } else {
                    _i++;
                }
            }

            len = deferredEvents.length;
            for (var _i2 = 0; _i2 < len; _i2++) {
                deferredClips[_i2].fire(deferredEvents[_i2]);
            }

            this._time = time;

            this.onframe(delta);

            this.dispatch('frame', delta);
        }

        /**
         * APIMethod: start
         * 开始运行动画
         *
         */

    }, {
        key: 'start',
        value: function start() {
            var requestAnimationFrame = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (func) {
                setTimeout(func, 16);
            };

            var self = this;

            this._running = true;

            function step() {
                if (self._running) {
                    self._update();
                    requestAnimationFrame(step);
                }
            }

            this._time = new Date().getTime();
            requestAnimationFrame(step);
        }

        /**
         * APIMethod: stop
         * 停止运行动画
         *
         */

    }, {
        key: 'stop',
        value: function stop() {
            this._running = false;
        }

        /**
         * APIMethod: clear
         * 清除所有动画片段
         *
         */

    }, {
        key: 'clear',
        value: function clear() {
            this._clips = [];
        }

        /**
         * Method: animate
         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
         *
         * Parameters:
         * target - {Object} target
         * options - {Object} 动画参数选项，可设属性如下：
         *
         * Symbolizer properties:
         * loop - {Boolean} 是否循环播放动画。默认值：false。
         * getter - {Function} 如果指定getter函数，会通过getter函数取属性值。默认值：null。
         * setter - {Function} 如如果指定setter函数，会通过setter函数设置属性值。默认值：null。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Animation.Animator>} Animator
         */

    }, {
        key: 'animate',
        value: function animate(target, options) {
            options = options || {};
            var deferred = new Animator(target, options.loop, options.getter, options.setter);
            deferred.animation = this;
            return deferred;
        }
    }], [{
        key: '_interpolateNumber',
        value: function _interpolateNumber(p0, p1, percent) {
            return (p1 - p0) * percent + p0;
        }
    }, {
        key: '_interpolateArray',
        value: function _interpolateArray(p0, p1, percent, out, arrDim) {
            var len = p0.length;
            if (arrDim == 1) {
                for (var i = 0; i < len; i++) {
                    out[i] = Animation._interpolateNumber(p0[i], p1[i], percent);
                }
            } else {
                var len2 = p0[0].length;
                for (var _i3 = 0; _i3 < len; _i3++) {
                    for (var j = 0; j < len2; j++) {
                        out[_i3][j] = Animation._interpolateNumber(p0[_i3][j], p1[_i3][j], percent);
                    }
                }
            }
        }
    }, {
        key: '_isArrayLike',
        value: function _isArrayLike(data) {
            switch (typeof data === 'undefined' ? 'undefined' : _typeof(data)) {
                case 'undefined':
                case 'string':
                    return false;
            }

            return typeof data.length !== 'undefined';
        }
    }, {
        key: '_catmullRomInterpolateArray',
        value: function _catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
            var len = p0.length;
            if (arrDim == 1) {
                for (var i = 0; i < len; i++) {
                    out[i] = Animation._catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
                }
            } else {
                var len2 = p0[0].length;
                for (var _i4 = 0; _i4 < len; _i4++) {
                    for (var j = 0; j < len2; j++) {
                        out[_i4][j] = Animation._catmullRomInterpolate(p0[_i4][j], p1[_i4][j], p2[_i4][j], p3[_i4][j], t, t2, t3);
                    }
                }
            }
        }
    }, {
        key: '_catmullRomInterpolate',
        value: function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        }
    }, {
        key: '_cloneValue',
        value: function _cloneValue(value) {
            var arraySlice = Array.prototype.slice;

            if (Animation._isArrayLike(value)) {
                var len = value.length;
                if (Animation._isArrayLike(value[0])) {
                    var ret = [];
                    for (var i = 0; i < len; i++) {
                        ret.push(arraySlice.call(value[i]));
                    }
                    return ret;
                } else {
                    return arraySlice.call(value);
                }
            } else {
                return value;
            }
        }
    }, {
        key: 'rgba2String',
        value: function rgba2String(rgba) {
            rgba[0] = Math.floor(rgba[0]);
            rgba[1] = Math.floor(rgba[1]);
            rgba[2] = Math.floor(rgba[2]);

            return 'rgba(' + rgba.join(',') + ')';
        }
    }]);

    return Animation;
}(_Eventful2.Eventful);

/**
 * @private
 * @class SuperMap.LevelRenderer.Animation.Animator
 */


var Animator = exports.Animator = function () {

    /*
     * Constructor: SuperMap.LevelRenderer.Animation.Animator
     * 构造函数。
     *
     * Parameters:
     * target - {Object} target
     * loop - {Boolean} 是否循环播放动画。默认值：false。
     * getter - {Function} 如果指定getter函数，会通过getter函数取属性值。默认值：null。
     * setter - {Function} 如如果指定setter函数，会通过setter函数设置属性值。默认值：null。
     *
     */
    function Animator(target, loop, getter, setter) {
        _classCallCheck(this, Animator);

        /**
         * Property: _tracks
         * {Object}
         */
        this._tracks = {};

        /**
         * Property: _target
         * {Object}
         */
        this._target = target;

        /**
         * Property: _loop
         * {Boolean}
         */
        this._loop = loop || false;

        /**
         * Property: _getter
         * {Function}
         */
        this._getter = getter || _defaultGetter;

        /**
         * Property: _setter
         * {Function}
         */
        this._setter = setter || _defaultSetter;

        /**
         * Property: _clipCount
         * {Number}
         */
        this._clipCount = 0;

        /**
         * Property: _delay
         * {Number}
         */
        this._delay = 0;

        /**
         * Property: _doneList
         * {Array}
         */
        this._doneList = [];

        /**
         * Property: _onframeList
         * {Array}
         */
        this._onframeList = [];

        /**
         * Property: _clipList
         * {Array}
         */
        this._clipList = [];
        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation.Animator";
        //Function
        function _defaultGetter(target, key) {
            return target[key];
        }

        function _defaultSetter(target, key, value) {
            target[key] = value;
        }
    }

    /**
     * Method: when
     * 设置动画关键帧
     *
     * Parameters:
     * time - {Number} 关键帧时间，单位是ms
     * props - {Object} 关键帧的属性值，key-value表示
     *
     * Returns:
     * {<SuperMap.LevelRenderer.Animation.Animator>} Animator
     */


    _createClass(Animator, [{
        key: 'when',
        value: function when(time /* ms */, props) {
            for (var propName in props) {
                if (!this._tracks[propName]) {
                    this._tracks[propName] = [];
                    // If time is 0
                    //  Then props is given initialize value
                    // Else
                    //  Initialize value from current prop value
                    if (time !== 0) {
                        this._tracks[propName].push({
                            time: 0,
                            value: Animation._cloneValue(this._getter(this._target, propName))
                        });
                    }
                }
                this._tracks[propName].push({
                    time: parseInt(time, 10),
                    value: props[propName]
                });
            }
            return this;
        }

        /**
         * Method: during
         * 添加动画每一帧的回调函数
         *
         * Parameters:
         * callback - {Function} callback
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Animation.Animator>} Animator
         */

    }, {
        key: 'during',
        value: function during(callback) {
            this._onframeList.push(callback);
            return this;
        }

        /**
         * Method: start
         * 开始执行动画
         *
         * Parameters:
         * easing - {String|Function} 动画缓动函数。详见：<SuperMap.LevelRenderer.Animation.easing>。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Animation.Animator>} Animator
         */

    }, {
        key: 'start',
        value: function start(easing) {
            var self = this;
            var setter = this._setter;
            var getter = this._getter;
            var onFrameListLen = self._onframeList.length;
            var useSpline = easing === 'spline';

            var ondestroy = function ondestroy() {
                self._clipCount--;
                if (self._clipCount === 0) {
                    // Clear all tracks
                    self._tracks = {};

                    var len = self._doneList.length;
                    for (var i = 0; i < len; i++) {
                        self._doneList[i].call(self);
                    }
                }
            };

            var createTrackClip = function createTrackClip(keyframes, propName) {
                var trackLen = keyframes.length;
                if (!trackLen) {
                    return;
                }
                // Guess data type
                var firstVal = keyframes[0].value;
                var isValueArray = Animation._isArrayLike(firstVal);
                var isValueColor = false;

                // For vertices morphing
                var arrDim = isValueArray && Animation._isArrayLike(firstVal[0]) ? 2 : 1;
                // Sort keyframe as ascending
                keyframes.sort(function (a, b) {
                    return a.time - b.time;
                });
                var trackMaxTime = keyframes[trackLen - 1].time;
                // Percents of each keyframe
                var kfPercents = [];
                // Value of each keyframe
                var kfValues = [];
                for (var _i5 = 0; _i5 < trackLen; _i5++) {
                    kfPercents.push(keyframes[_i5].time / trackMaxTime);
                    // Assume value is a color when it is a string
                    var value = keyframes[_i5].value;
                    if (typeof value == 'string') {
                        value = _SUtil.SUtil.Util_color.toArray(value);
                        if (value.length === 0) {
                            // Invalid color
                            value[0] = value[1] = value[2] = 0;
                            value[3] = 1;
                        }
                        isValueColor = true;
                    }
                    kfValues.push(value);
                }

                // Cache the key of last frame to speed up when
                // animation playback is sequency
                var cacheKey = 0;
                var cachePercent = 0;
                var start;
                var i;
                var w;
                var p0;
                var p1;
                var p2;
                var p3;

                if (isValueColor) {
                    var rgba = [0, 0, 0, 0];
                }

                var onframe = function onframe(target, percent) {
                    // Find the range keyframes
                    // kf1-----kf2---------current--------kf3
                    // find kf2 and kf3 and do interpolation
                    if (percent < cachePercent) {
                        // Start from next key
                        start = Math.min(cacheKey + 1, trackLen - 1);
                        for (i = start; i >= 0; i--) {
                            if (kfPercents[i] <= percent) {
                                break;
                            }
                        }
                        i = Math.min(i, trackLen - 2);
                    } else {
                        for (i = cacheKey; i < trackLen; i++) {
                            if (kfPercents[i] > percent) {
                                break;
                            }
                        }
                        i = Math.min(i - 1, trackLen - 2);
                    }
                    cacheKey = i;
                    cachePercent = percent;

                    var range = kfPercents[i + 1] - kfPercents[i];
                    if (range === 0) {
                        return;
                    } else {
                        w = (percent - kfPercents[i]) / range;
                    }
                    if (useSpline) {
                        p1 = kfValues[i];
                        p0 = kfValues[i === 0 ? i : i - 1];
                        p2 = kfValues[i > trackLen - 2 ? trackLen - 1 : i + 1];
                        p3 = kfValues[i > trackLen - 3 ? trackLen - 1 : i + 2];
                        if (isValueArray) {
                            Animation._catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
                        } else {
                            var _value = void 0;
                            if (isValueColor) {
                                // value = SuperMap.LevelRenderer.Animation._catmullRomInterpolateArray(
                                //     p0, p1, p2, p3, w, w * w, w * w * w,
                                //     rgba, 1
                                // );
                                _value = Animation.rgba2String(rgba);
                            } else {
                                _value = Animation._catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
                            }
                            setter(target, propName, _value);
                        }
                    } else {
                        if (isValueArray) {
                            Animation._interpolateArray(kfValues[i], kfValues[i + 1], w, getter(target, propName), arrDim);
                        } else {
                            var _value2 = void 0;
                            if (isValueColor) {
                                Animation._interpolateArray(kfValues[i], kfValues[i + 1], w, rgba, 1);
                                _value2 = Animation.rgba2String(rgba);
                            } else {
                                _value2 = Animation._interpolateNumber(kfValues[i], kfValues[i + 1], w);
                            }
                            setter(target, propName, _value2);
                        }
                    }

                    for (i = 0; i < onFrameListLen; i++) {
                        self._onframeList[i](target, percent);
                    }
                };

                var clip = new _Clip.Clip({
                    target: self._target,
                    life: trackMaxTime,
                    loop: self._loop,
                    delay: self._delay,
                    onframe: onframe,
                    ondestroy: ondestroy
                });

                if (easing && easing !== 'spline') {
                    clip.easing = easing;
                }
                self._clipList.push(clip);
                self._clipCount++;
                self.animation.add(clip);
            };

            for (var propName in this._tracks) {
                createTrackClip(this._tracks[propName], propName);
            }
            return this;
        }

        /**
         * Method: stop
         * 停止动画
         */

    }, {
        key: 'stop',
        value: function stop() {
            for (var i = 0; i < this._clipList.length; i++) {
                var clip = this._clipList[i];
                this.animation.remove(clip);
            }
            this._clipList = [];
        }

        /**
         * Method: delay
         * 设置动画延迟开始的时间
         *
         * Parameters:
         * time - {Number} time 单位ms
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Animation.Animator>} Animator
         */

    }, {
        key: 'delay',
        value: function delay(time) {
            this._delay = time;
            return this;
        }

        /**
         * Method: done
         * 添加动画结束的回调
         *
         * Parameters:
         * cb - {Function} Function
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Animation.Animator>} Animator
         */

    }, {
        key: 'done',
        value: function done(cb) {
            if (cb) {
                this._doneList.push(cb);
            }
            return this;
        }
    }]);

    return Animator;
}();

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Area = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(29);

var _Curve = __webpack_require__(79);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Area
 * LevelRenderer 工具-图形范围判断
 *
 */
var Area = exports.Area = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Area
     * 构造函数。
     *
     */
    function Area() {
        _classCallCheck(this, Area);

        /**
         * Property: util
         * {<SuperMap.LevelRenderer.Tool.Util>} 基础工具对象
         */
        this.util = new _Util.Util();

        /**
         * Property: curve
         * {<SuperMap.LevelRenderer.Tool.Curve>} 曲线工具对象
         */
        this.curve = new _Curve.Curve();

        /**
         * Property: _ctx
         * {Object} Cavans2D 渲染上下文
         */
        this._ctx = null;

        /**
         * Property: _textWidthCache
         * {Object} 文本宽度缓存
         */
        this._textWidthCache = {};

        /**
         * Property: _textHeightCache
         * {Object} 文本高度缓存
         */
        this._textHeightCache = {};

        /**
         * Property: _textWidthCacheCounter
         * {Object} 文本宽度缓存数量
         */
        this._textWidthCacheCounter = 0;

        /**
         * Property: _textHeightCacheCounter
         * {Object} 文本高度缓存数量
         */
        this._textHeightCacheCounter = 0;

        /**
         * Property: TEXT_CACHE_MAX
         * {Object} 文本最大缓存数量
         */
        this.TEXT_CACHE_MAX = 5000;

        /**
         * Property: PI2
         * {Object} 2*PI 的值
         */
        this.PI2 = Math.PI * 2;

        /**
         * Property: roots
         * {Array} 临时数组
         */
        this.roots = [-1, -1, -1];

        /**
         * Property: extrema
         * {Array} 临时数组
         */
        this.extrema = [-1, -1];

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Area";
    }

    /**
     * Method: normalizeRadian
     * 弧度标准化函数。
     *
     * Parameters:
     * angle - {Number} 弧度值。
     *
     * Returns:
     * {Number} 标准化后的弧度值。
     */


    _createClass(Area, [{
        key: 'normalizeRadian',
        value: function normalizeRadian(angle) {
            angle %= this.PI2;
            if (angle < 0) {
                angle += this.PI2;
            }
            return angle;
        }

        /**
         * APIMethod: normalizeRadian
         * 包含判断。
         *
         * Parameters:
         * shape - {Object} 图形。
         * area - {Number} 目标区域。
         * x - {Number} 横坐标。
         * y - {Number} 纵坐标。
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置。
         */

    }, {
        key: 'isInside',
        value: function isInside(shape, area, x, y) {
            if (!area || !shape) {
                // 无参数或不支持类型
                return false;
            }
            var zoneType = shape.type;

            this._ctx = this._ctx || this.util.getContext();

            // 未实现或不可用时则数学运算，主要是line，brokenLine，ring
            var _mathReturn = this._mathMethod(shape, area, x, y);
            if (typeof _mathReturn != 'undefined') {
                return _mathReturn;
            }

            if (shape.buildPath && this._ctx.isPointInPath) {
                return this._buildPathMethod(shape, this._ctx, area, x, y);
            }

            // 上面的方法都行不通时
            switch (zoneType) {
                case 'ellipse': // Todo，不精确
                case 'smicellipse':
                    // Todo，不精确
                    return true;
                // 旋轮曲线  不准确
                case 'trochoid':
                    var _r = area.location == 'out' ? area.r1 + area.r2 + area.d : area.r1 - area.r2 + area.d;
                    return this.isInsideCircle(area, x, y, _r);
                // 玫瑰线 不准确
                case 'rose':
                    return this.isInsideCircle(area, x, y, area.maxr);
                // 路径，椭圆，曲线等-----------------13
                default:
                    return false; // Todo，暂不支持
            }
        }

        /**
         * Method: _mathMethod
         * 用数学方法判断，三个方法中最快，但是支持的shape少。
         *
         * Parameters:
         * shape - {Object} 图形。
         * area - {Number} 目标区域。
         * x - {Number} 横坐标。
         * y - {Number} 纵坐标。
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置，true表示坐标处在图形中。
         */

    }, {
        key: '_mathMethod',
        value: function _mathMethod(shape, area, x, y) {
            var zoneType = shape.type;
            // 在矩形内则部分图形需要进一步判断
            switch (zoneType) {
                // 贝塞尔曲线
                case 'bezier-curve':
                    if (typeof area.cpX2 === 'undefined') {
                        return this.isInsideQuadraticStroke(area.xStart, area.yStart, area.cpX1, area.cpY1, area.xEnd, area.yEnd, area.lineWidth, x, y);
                    }
                    return this.isInsideCubicStroke(area.xStart, area.yStart, area.cpX1, area.cpY1, area.cpX2, area.cpY2, area.xEnd, area.yEnd, area.lineWidth, x, y);
                // 线
                case 'line':
                    return this.isInsideLine(area.xStart, area.yStart, area.xEnd, area.yEnd, area.lineWidth, x, y);
                // 折线
                case 'broken-line':
                    return this.isInsideBrokenLine(area.pointList, area.lineWidth, x, y);
                // 扩展折线
                case 'smicbroken-line':
                    {
                        // SMIC-修改 - start
                        var icX = x;
                        var icY = y;
                        if (shape.refOriginalPosition) {
                            icX = x - shape.refOriginalPosition[0];
                            icY = y - shape.refOriginalPosition[1];
                        }
                        return this.isInsideBrokenLine(area.pointList, area.lineWidth, icX, icY);
                    }
                //初始代码：
                //      return isInsideBrokenLine(
                //          area.pointList, area.lineWidth, x, y
                //      );
                // SMIC-修改 - end
                // 圆环
                case 'ring':
                    return this.isInsideRing(area.x, area.y, area.r0, area.r, x, y);
                case 'smicring':
                    {
                        var areaX = area.x;
                        var areaY = area.y;
                        if (shape.refOriginalPosition) {
                            areaX = area.x + shape.refOriginalPosition[0];
                            areaY = area.y + shape.refOriginalPosition[1];
                        }
                        return this.isInsideRing(areaX, areaY, area.r0, area.r, x, y);
                    }
                // 圆形
                case 'circle':
                    return this.isInsideCircle(area.x, area.y, area.r, x, y);
                // 扩展-点
                case 'smicpoint':
                    {
                        // SMIC-修改 - start
                        var _icX = x;
                        var _icY = y;
                        if (shape.refOriginalPosition) {
                            _icX = x - shape.refOriginalPosition[0];
                            _icY = y - shape.refOriginalPosition[1];
                        }
                        return this.isInsideCircle(area.x, area.y, area.r, _icX, _icY);
                    }
                //初始代码：
                //  无
                // SMIC-修改 - end
                // 扇形
                case 'sector':
                    {
                        var startAngle = area.startAngle * Math.PI / 180;
                        var endAngle = area.endAngle * Math.PI / 180;
                        if (!area.clockWise) {
                            startAngle = -startAngle;
                            endAngle = -endAngle;
                        }
                        return this.isInsideSector(area.x, area.y, area.r0, area.r, startAngle, endAngle, !area.clockWise, x, y);
                    }
                //初始代码：
                //  无
                // SMIC-增加 - end
                // 扇形
                case 'smicsector':
                    {
                        var _startAngle = area.startAngle * Math.PI / 180;
                        var _endAngle = area.endAngle * Math.PI / 180;
                        if (!area.clockWise) {
                            _startAngle = -_startAngle;
                            _endAngle = -_endAngle;
                        }

                        var _areaX = area.x;
                        var _areaY = area.y;
                        if (shape.refOriginalPosition) {
                            _areaX = area.x + shape.refOriginalPosition[0];
                            _areaY = area.y + shape.refOriginalPosition[1];
                        }

                        return this.isInsideSector(_areaX, _areaY, area.r0, area.r, _startAngle, _endAngle, !area.clockWise, x, y);
                    }
                // 多边形
                case 'path':
                    return this.isInsidePath(area.pathArray, Math.max(area.lineWidth, 5), area.brushType, x, y);
                case 'polygon':
                case 'star':
                case 'smicstar':
                case 'isogon':
                case 'smicisogon':
                    return this.isInsidePolygon(area.pointList, x, y);
                // 扩展多边形
                case 'smicpolygon':
                    {
                        // SMIC-修改 - start
                        var _icX2 = x;
                        var _icY2 = y;
                        if (shape.refOriginalPosition) {
                            _icX2 = x - shape.refOriginalPosition[0];
                            _icY2 = y - shape.refOriginalPosition[1];
                        }

                        //岛洞面
                        if (shape.holePolygonPointLists && shape.holePolygonPointLists.length > 0) {
                            var isOnBase = this.isInsidePolygon(area.pointList, _icX2, _icY2);

                            // 遍历岛洞子面
                            var holePLS = shape.holePolygonPointLists;
                            var isOnHole = false;
                            for (var i = 0, holePLSen = holePLS.length; i < holePLSen; i++) {
                                var holePL = holePLS[i];
                                var isOnSubHole = this.isInsidePolygon(holePL, _icX2, _icY2);
                                if (isOnSubHole === true) {
                                    isOnHole = true;
                                }
                            }

                            // 捕获判断
                            if (isOnBase === true && isOnHole === false) {
                                return true;
                            } else {
                                return false;
                            }
                        } else {
                            return this.isInsidePolygon(area.pointList, _icX2, _icY2);
                        }
                    }
                // 初始代码：
                //  无
                // SMIC-修改 - end
                // 文本
                case 'text':
                    var rect = area.__rect || shape.getRect(area);
                    return this.isInsideRect(rect.x, rect.y, rect.width, rect.height, x, y);
                // 扩展文本
                case 'smictext':
                    //用文本背景矩形判断
                    var textBg = shape.getTextBackground(area);
                    return this.isInsidePolygon(textBg, x, y);
                //初始代码：
                //  无
                // SMIC-修改 - end
                // 矩形
                case 'rectangle':
                case 'image':
                    // 图片
                    return this.isInsideRect(area.x, area.y, area.width, area.height, x, y);
                case 'smicimage':
                    {
                        var _areaX2 = area.x;
                        var _areaY2 = area.y;
                        if (shape.refOriginalPosition) {
                            _areaX2 = area.x + shape.refOriginalPosition[0];
                            _areaY2 = area.y + shape.refOriginalPosition[1];
                        }
                        return this.isInsideRect(_areaX2, _areaY2, area.width, area.height, x, y);
                    }
                //// 扩展矩形
                //case 'smicpolygon':
                //    // SMIC-修改 - start
                //    var icX = x;
                //    var icY = y;
                //    if(shape.refOriginalPosition) {
                //        icX = x - shape.refOriginalPosition[0];
                //        icY = y - shape.refOriginalPosition[1];
                //    }
                //    return this.isInsideRect(
                //        area.x, area.y, area.width, area.height, icX, icY
                //    );
                //初始代码：
                //  无
                // SMIC-修改 - end
            }
        }

        /**
         * Method: _buildPathMethod
         * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的 shape
         *
         * Parameters:
         * shape - {Object} 图形。
         * context - {Object} 上下文。
         * area - {Number} 目标区域。
         * x - {Number} 横坐标。
         * y - {Number} 纵坐标。
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置 true表示坐标处在图形中。
         */

    }, {
        key: '_buildPathMethod',
        value: function _buildPathMethod(shape, context, area, x, y) {
            // 图形类实现路径创建了则用类的path
            context.beginPath();
            shape.buildPath(context, area);
            context.closePath();
            return context.isPointInPath(x, y);
        }

        /**
         * APIMethod: isOutside
         * 图形是否不包含鼠标位置。
         *
         * Parameters:
         * shape - {Object} 图形。
         * area - {Number} 目标区域。
         * x - {Number} 横坐标。
         * y - {Number} 纵坐标。
         *
         * Returns:
         * {Boolean} 图形是否不包含鼠标位置 true表示坐标处在图形外。
         */

    }, {
        key: 'isOutside',
        value: function isOutside(shape, area, x, y) {
            return !this.isInside(shape, area, x, y);
        }

        /**
         * APIMethod: isInsideLine
         * 线段包含判断。
         *
         * Parameters:
         * x0 - {Number}
         * y0 - {Number}
         * x1 - {Number}
         * y1 - {Number}
         * lineWidth - {Number}
         * x - {Number}
         * y - {Number}
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideLine',
        value: function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            var _a = 0;
            var _b = 0;
            // Quick reject
            if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
                return false;
            }

            if (x0 !== x1) {
                _a = (y0 - y1) / (x0 - x1);
                _b = (x0 * y1 - x1 * y0) / (x0 - x1);
            } else {
                return Math.abs(x - x0) <= _l / 2;
            }
            var tmp = _a * x - y + _b;
            var _s = tmp * tmp / (_a * _a + 1);
            return _s <= _l / 2 * _l / 2;
        }

        /**
         * Method: isInsideCubicStroke
         * 三次贝塞尔曲线描边包含判断。
         *
         * Parameters:
         * x0 - {Number}
         * y0 - {Number}
         * x1 - {Number}
         * y1 - {Number}
         * x2 - {Number}
         * y2 - {Number}
         * x3 - {Number}
         * y3 - {Number}
         * lineWidth - {Number}
         * x - {Number}
         * y - {Number}
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideCubicStroke',
        value: function isInsideCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            // Quick reject
            if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
                return false;
            }
            var d = this.curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
            return d <= _l / 2;
        }

        /**
         * Method: isInsideQuadraticStroke
         * 二次贝塞尔曲线描边包含判断。
         *
         * Parameters:
         * x0 - {Number}
         * y0 - {Number}
         * x1 - {Number}
         * y1 - {Number}
         * x2 - {Number}
         * y2 - {Number}
         * lineWidth - {Number} 纵坐标。
         * x - {Number}
         * y - {Number}
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideQuadraticStroke',
        value: function isInsideQuadraticStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);
            // Quick reject
            if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
                return false;
            }
            var d = this.curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
            return d <= _l / 2;
        }

        /**
         * Method: isInsideArcStroke
         * 圆弧描边包含判断。
         *
         * Parameters:
         * cx - {Number}
         * cy - {Number}
         * r - {Number}
         * startAngle - {Number}
         * endAngle - {Number}
         * anticlockwise - {Number}
         * lineWidth - {Number}
         * x - {Number}
         * y - {Number}
         *
         * Returns:
         * {Boolean} 图形是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideArcStroke',
        value: function isInsideArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
            var PI2 = this.PI2;

            if (lineWidth === 0) {
                return false;
            }
            var _l = Math.max(lineWidth, 5);

            x -= cx;
            y -= cy;
            var d = Math.sqrt(x * x + y * y);
            if (d - _l > r || d + _l < r) {
                return false;
            }
            if (Math.abs(startAngle - endAngle) >= PI2) {
                // Is a circle
                return true;
            }
            if (anticlockwise) {
                var tmp = startAngle;
                startAngle = this.normalizeRadian(endAngle);
                endAngle = this.normalizeRadian(tmp);
            } else {
                startAngle = this.normalizeRadian(startAngle);
                endAngle = this.normalizeRadian(endAngle);
            }
            if (startAngle > endAngle) {
                endAngle += PI2;
            }

            var angle = Math.atan2(y, x);
            if (angle < 0) {
                angle += PI2;
            }
            return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
        }

        /**
         * APIMethod: isInsideBrokenLine
         * 图形 BrokenLine 是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideBrokenLine',
        value: function isInsideBrokenLine(points, lineWidth, x, y) {
            var _lineWidth = Math.max(lineWidth, 10);
            for (var i = 0, l = points.length - 1; i < l; i++) {
                var x0 = points[i][0];
                var y0 = points[i][1];
                var x1 = points[i + 1][0];
                var y1 = points[i + 1][1];

                if (this.isInsideLine(x0, y0, x1, y1, _lineWidth, x, y)) {
                    return true;
                }
            }

            return false;
        }

        /**
         * Method: isInsideRing
         * 图形 Ring 是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideRing',
        value: function isInsideRing(cx, cy, r0, r, x, y) {
            var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);
            return d < r * r && d > r0 * r0;
        }

        /**
         * APIMethod: isInsideRect
         * 图形 Rect 是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideRect',
        value: function isInsideRect(x0, y0, width, height, x, y) {
            return x >= x0 && x <= x0 + width && y >= y0 && y <= y0 + height;
        }

        /**
         * APIMethod: isInsideCircle
         * 图形 Circle 是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideCircle',
        value: function isInsideCircle(x0, y0, r, x, y) {
            return (x - x0) * (x - x0) + (y - y0) * (y - y0) < r * r;
        }

        /**
         * APIMethod: isInsideSector
         * 图形 Sector 是否包含鼠标位置 true表示坐标处在图形内。
         */

    }, {
        key: 'isInsideSector',
        value: function isInsideSector(cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y) {
            return this.isInsideArcStroke(cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise, r - r0, x, y);
        }

        /**
         * APIMethod: isInsidePolygon
         * 图形 Polygon 是否包含鼠标位置 true表示坐标处在图形内。与 canvas 一样采用 non-zero winding rule
         */

    }, {
        key: 'isInsidePolygon',
        value: function isInsidePolygon(points, x, y) {
            var N = points.length;
            var w = 0;

            for (var i = 0, j = N - 1; i < N; i++) {
                var x0 = points[j][0];
                var y0 = points[j][1];
                var x1 = points[i][0];
                var y1 = points[i][1];
                w += this.windingLine(x0, y0, x1, y1, x, y);
                j = i;
            }
            return w !== 0;
        }

        /**
         * Method: windingLine
         */

    }, {
        key: 'windingLine',
        value: function windingLine(x0, y0, x1, y1, x, y) {
            if (y > y0 && y > y1 || y < y0 && y < y1) {
                return 0;
            }
            if (y1 == y0) {
                return 0;
            }
            var dir = y1 < y0 ? 1 : -1;
            var t = (y - y0) / (y1 - y0);
            var x_ = t * (x1 - x0) + x0;

            return x_ > x ? dir : 0;
        }

        /**
         * Method: swapExtrema
         */

    }, {
        key: 'swapExtrema',
        value: function swapExtrema() {
            var tmp = this.extrema[0];
            this.extrema[0] = this.extrema[1];
            this.extrema[1] = tmp;
        }

        /**
         * Method: windingCubic
         */

    }, {
        key: 'windingCubic',
        value: function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
            var curve = this.curve;
            var roots = this.roots;
            var extrema = this.extrema;

            // Quick reject
            if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
                return 0;
            }
            var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
            if (nRoots === 0) {
                return 0;
            } else {
                var w = 0;
                var nExtrema = -1;
                var y0_, y1_;
                for (var i = 0; i < nRoots; i++) {
                    var t = roots[i];
                    var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                    if (x_ < x) {
                        // Quick reject
                        continue;
                    }
                    if (nExtrema < 0) {
                        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                        if (extrema[1] < extrema[0] && nExtrema > 1) {
                            this.swapExtrema();
                        }
                        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                        if (nExtrema > 1) {
                            y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                        }
                    }
                    if (nExtrema == 2) {
                        // 分成三段单调函数
                        if (t < extrema[0]) {
                            w += y0_ < y0 ? 1 : -1;
                        } else if (t < extrema[1]) {
                            w += y1_ < y0_ ? 1 : -1;
                        } else {
                            w += y3 < y1_ ? 1 : -1;
                        }
                    } else {
                        // 分成两段单调函数
                        if (t < extrema[0]) {
                            w += y0_ < y0 ? 1 : -1;
                        } else {
                            w += y3 < y0_ ? 1 : -1;
                        }
                    }
                }
                return w;
            }
        }

        /**
         * Method: windingQuadratic
         */

    }, {
        key: 'windingQuadratic',
        value: function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
            var curve = this.curve;
            var roots = this.roots;

            // Quick reject
            if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
                return 0;
            }
            var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
            if (nRoots === 0) {
                return 0;
            } else {
                var t = curve.quadraticExtremum(y0, y1, y2);
                if (t >= 0 && t <= 1) {
                    var w = 0;
                    var y_ = curve.quadraticAt(y0, y1, y2, t);
                    for (var i = 0; i < nRoots; i++) {
                        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                        if (x_ > x) {
                            continue;
                        }
                        if (roots[i] < t) {
                            w += y_ < y0 ? 1 : -1;
                        } else {
                            w += y2 < y_ ? 1 : -1;
                        }
                    }
                    return w;
                } else {
                    var _x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                    if (_x_ > x) {
                        return 0;
                    }
                    return y2 < y0 ? 1 : -1;
                }
            }
        }

        /**
         * Method: windingArc
         *     // TODO   Arc 旋转
         */

    }, {
        key: 'windingArc',
        value: function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
            var roots = this.roots;
            var PI2 = this.PI2;

            y -= cy;
            if (y > r || y < -r) {
                return 0;
            }
            var tmp = Math.sqrt(r * r - y * y);
            roots[0] = -tmp;
            roots[1] = tmp;

            if (Math.abs(startAngle - endAngle) >= PI2) {
                // Is a circle
                startAngle = 0;
                endAngle = PI2;
                var dir = anticlockwise ? 1 : -1;
                if (x >= roots[0] + cx && x <= roots[1] + cx) {
                    return dir;
                } else {
                    return 0;
                }
            }

            if (anticlockwise) {
                var _tmp = startAngle;
                startAngle = this.normalizeRadian(endAngle);
                endAngle = this.normalizeRadian(_tmp);
            } else {
                startAngle = this.normalizeRadian(startAngle);
                endAngle = this.normalizeRadian(endAngle);
            }
            if (startAngle > endAngle) {
                endAngle += PI2;
            }

            var w = 0;
            for (var i = 0; i < 2; i++) {
                var x_ = roots[i];
                if (x_ + cx > x) {
                    var angle = Math.atan2(y, x_);
                    var _dir = anticlockwise ? 1 : -1;
                    if (angle < 0) {
                        angle = PI2 + angle;
                    }
                    if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
                        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                            _dir = -_dir;
                        }
                        w += _dir;
                    }
                }
            }
            return w;
        }

        /**
         * APIMethod: isInsidePath
         * 与 canvas 一样采用 non-zero winding rule
         */

    }, {
        key: 'isInsidePath',
        value: function isInsidePath(pathArray, lineWidth, brushType, x, y) {
            var w = 0;
            var xi = 0;
            var yi = 0;
            var x0 = 0;
            var y0 = 0;
            var beginSubpath = true;
            var firstCmd = true;

            brushType = brushType || 'fill';

            var hasStroke = brushType === 'stroke' || brushType === 'both';
            var hasFill = brushType === 'fill' || brushType === 'both';

            // var roots = [-1, -1, -1];
            for (var i = 0; i < pathArray.length; i++) {
                var seg = pathArray[i];
                var p = seg.points;
                // Begin a new subpath
                if (beginSubpath || seg.command === 'M') {
                    if (i > 0) {
                        // Close previous subpath
                        if (hasFill) {
                            w += this.windingLine(xi, yi, x0, y0, x, y);
                        }
                        if (w !== 0) {
                            return true;
                        }
                    }
                    x0 = p[p.length - 2];
                    y0 = p[p.length - 1];
                    beginSubpath = false;
                    if (firstCmd && seg.command !== 'A') {
                        // 如果第一个命令不是M, 是lineTo, bezierCurveTo
                        // 等绘制命令的话，是会从该绘制的起点开始算的
                        // Arc 会在之后做单独处理所以这里忽略
                        firstCmd = false;
                        xi = x0;
                        yi = y0;
                    }
                }
                switch (seg.command) {
                    case 'M':
                        xi = p[0];
                        yi = p[1];
                        break;
                    case 'L':
                        if (hasStroke) {
                            if (this.isInsideLine(xi, yi, p[0], p[1], lineWidth, x, y)) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += this.windingLine(xi, yi, p[0], p[1], x, y);
                        }
                        xi = p[0];
                        yi = p[1];
                        break;
                    case 'C':
                        if (hasStroke) {
                            if (this.isInsideCubicStroke(xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], lineWidth, x, y)) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += this.windingCubic(xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y);
                        }
                        xi = p[4];
                        yi = p[5];
                        break;
                    case 'Q':
                        if (hasStroke) {
                            if (this.isInsideQuadraticStroke(xi, yi, p[0], p[1], p[2], p[3], lineWidth, x, y)) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += this.windingQuadratic(xi, yi, p[0], p[1], p[2], p[3], x, y);
                        }
                        xi = p[2];
                        yi = p[3];
                        break;
                    case 'A':
                        // TODO Arc 旋转
                        // TODO Arc 判断的开销比较大
                        var cx = p[0];
                        var cy = p[1];
                        var rx = p[2];
                        var ry = p[3];
                        var theta = p[4];
                        var dTheta = p[5];
                        var x1 = Math.cos(theta) * rx + cx;
                        var y1 = Math.sin(theta) * ry + cy;
                        // 不是直接使用 arc 命令
                        if (!firstCmd) {
                            w += this.windingLine(xi, yi, x1, y1);
                        } else {
                            firstCmd = false;
                            // 第一个命令起点还未定义
                            x0 = x1;
                            y0 = y1;
                        }
                        // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
                        var _x = (x - cx) * ry / rx + cx;
                        if (hasStroke) {
                            if (this.isInsideArcStroke(cx, cy, ry, theta, theta + dTheta, 1 - p[7], lineWidth, _x, y)) {
                                return true;
                            }
                        }
                        if (hasFill) {
                            w += this.windingArc(cx, cy, ry, theta, theta + dTheta, 1 - p[7], _x, y);
                        }
                        xi = Math.cos(theta + dTheta) * rx + cx;
                        yi = Math.sin(theta + dTheta) * ry + cy;
                        break;
                    case 'z':
                        if (hasStroke) {
                            if (this.isInsideLine(xi, yi, x0, y0, lineWidth, x, y)) {
                                return true;
                            }
                        }
                        beginSubpath = true;
                        break;
                }
            }
            if (hasFill) {
                w += this.windingLine(xi, yi, x0, y0, x, y);
            }
            return w !== 0;
        }

        /**
         * APIMethod: getTextWidth
         * 测算多行文本宽度
         */

    }, {
        key: 'getTextWidth',
        value: function getTextWidth(text, textFont) {
            var key = text + ':' + textFont;
            if (this._textWidthCache[key]) {
                return this._textWidthCache[key];
            }
            this._ctx = this._ctx || this.util.getContext();
            this._ctx.save();

            if (textFont) {
                this._ctx.font = textFont;
            }

            text = (text + '').split('\n');
            var width = 0;
            for (var i = 0, l = text.length; i < l; i++) {
                width = Math.max(this._ctx.measureText(text[i]).width, width);
            }
            this._ctx.restore();

            this._textWidthCache[key] = width;
            if (++this._textWidthCacheCounter > this.TEXT_CACHE_MAX) {
                // 内存释放
                this._textWidthCacheCounter = 0;
                this._textWidthCache = {};
            }

            return width;
        }

        /**
         * APIMethod: getTextHeight
         * 测算多行文本高度
         */

    }, {
        key: 'getTextHeight',
        value: function getTextHeight(text, textFont) {
            var key = text + ':' + textFont;
            if (this._textHeightCache[key]) {
                return this._textHeightCache[key];
            }

            this._ctx = this._ctx || this.util.getContext();

            this._ctx.save();
            if (textFont) {
                this._ctx.font = textFont;
            }

            text = (text + '').split('\n');
            // 比较粗暴
            //var height = (this._ctx.measureText('国').width + 2) * text.length;  //打包不支持中文，替换掉
            var height = (this._ctx.measureText('ZH').width + 2) * text.length;

            this._ctx.restore();

            this._textHeightCache[key] = height;
            if (++this._textHeightCacheCounter > this.TEXT_CACHE_MAX) {
                // 内存释放
                this._textHeightCacheCounter = 0;
                this._textHeightCache = {};
            }
            return height;
        }
    }]);

    return Area;
}();

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Clip = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Easing = __webpack_require__(267);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Animation.Clip
 * 动画片段
 *
 */
var Clip = exports.Clip = function () {

    /**
     * 动画主控制器
     * @config target
     * @config life(1000)
     * @config delay(0)
     * @config loop(true)
     * @config gap(0)
     * @config onframe
     * @config easing(optional)
     * @config ondestroy(optional)
     * @config onrestart(optional)
     */

    /**
     * Constructor: SuperMap.LevelRenderer.Animation.Clip
     * 构造函数。
     *
     *
     * Parameters:
     * options - {Object} 可选参数：
     *
     * Symbolizer properties:
     * target - {Object} 动画对象，可以是数组，如果是数组的话会批量分发 onframe 等事件。
     * life - {Number} 动画时长，默认值：1000。
     * delay - {Number}  动画延迟时间。默认值：0。
     * loop - {Boolean}  是否循环，默认值：true。
     * gap - {Number}  循环的间隔时间。默认值：0。
     * onframe - {Object}  帧。
     * easing - {Boolean}
     * ondestroy - {Boolean}
     * onrestart - {Boolean}
     *
     */
    function Clip(options) {
        _classCallCheck(this, Clip);

        this._targetPool = options.target || {};
        if (!(this._targetPool instanceof Array)) {
            this._targetPool = [this._targetPool];
        }

        // 生命周期
        this._life = options.life || 1000;
        // 延时
        this._delay = options.delay || 0;
        // 开始时间
        this._startTime = new Date().getTime() + this._delay; // 单位毫秒

        // 结束时间
        this._endTime = this._startTime + this._life * 1000;

        // 是否循环
        this.loop = typeof options.loop == 'undefined' ? false : options.loop;

        this.gap = options.gap || 0;

        this.easing = options.easing || 'Linear';

        this.onframe = options.onframe;
        this.ondestroy = options.ondestroy;
        this.onrestart = options.onrestart;
        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation.Clip";
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Clip, [{
        key: 'destroy',
        value: function destroy() {}
    }, {
        key: 'step',
        value: function step(time) {
            var easing = new _Easing.Easing();
            var percent = (time - this._startTime) / this._life;

            // 还没开始
            if (percent < 0) {
                return;
            }

            percent = Math.min(percent, 1);

            var easingFunc = typeof this.easing == 'string' ? easing[this.easing] : this.easing;
            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;

            this.fire('frame', schedule);

            // 结束
            if (percent == 1) {
                if (this.loop) {
                    this.restart();
                    // 重新开始周期
                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                    return 'restart';
                }

                // 动画完成将这个控制器标识为待删除
                // 在Animation.update中进行批量删除
                this._needsRemove = true;
                return 'destroy';
            }

            return null;
        }
    }, {
        key: 'restart',
        value: function restart() {
            var time = new Date().getTime();
            var remainder = (time - this._startTime) % this._life;
            this._startTime = new Date().getTime() - remainder + this.gap;
        }
    }, {
        key: 'fire',
        value: function fire(eventType, arg) {
            for (var i = 0, len = this._targetPool.length; i < len; i++) {
                if (this['on' + eventType]) {
                    this['on' + eventType](this._targetPool[i], arg);
                }
            }
        }
    }]);

    return Clip;
}();

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ComputeBoundingBox = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Curve = __webpack_require__(79);

var _Vector = __webpack_require__(82);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.ComputeBoundingBox
 * LevelRenderer 工具-图形 Bounds 计算
 *
 */
var ComputeBoundingBox = exports.ComputeBoundingBox = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.ComputeBoundingBox
     * 构造函数。
     *
     */
    function ComputeBoundingBox() {
        _classCallCheck(this, ComputeBoundingBox);

        if (arguments.length === 3) {
            this.computeBoundingBox(arguments);
        }

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.ComputeBoundingBox";
    }

    /**
     * APIMethod: computeBoundingBox
     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中。
     *
     * Parameters:
     * points - {Array{Object}} 顶点数组。
     * min - {Number}
     * max - {Number}
     *
     */


    _createClass(ComputeBoundingBox, [{
        key: 'computeBoundingBox',
        value: function computeBoundingBox(points, min, max) {
            if (points.length === 0) {
                return;
            }
            var left = points[0][0];
            var right = points[0][0];
            var top = points[0][1];
            var bottom = points[0][1];

            for (var i = 1; i < points.length; i++) {
                var p = points[i];
                if (p[0] < left) {
                    left = p[0];
                }
                if (p[0] > right) {
                    right = p[0];
                }
                if (p[1] < top) {
                    top = p[1];
                }
                if (p[1] > bottom) {
                    bottom = p[1];
                }
            }

            min[0] = left;
            min[1] = top;
            max[0] = right;
            max[1] = bottom;
        }

        /**
         * APIMethod: cubeBezier
         * 从三阶贝塞尔曲线(p0 p1 p2 p3)中计算出最小包围盒，写入`min`和`max`中。
         *
         * 原：computeCubeBezierBoundingBox
         *
         * Parameters:
         * p0 - {Array{Number}}
         * p1 - {Array{Number}}
         * p2 - {Array{Number}}
         * p3 - {Array{Number}}
         * min - {Array{Number}}
         * max - {Array{Number}}
         *
         */

    }, {
        key: 'cubeBezier',
        value: function cubeBezier(p0, p1, p2, p3, min, max) {
            var curve = new _Curve.Curve();

            var xDim = [];
            curve.cubicExtrema(p0[0], p1[0], p2[0], p3[0], xDim);
            for (var i = 0; i < xDim.length; i++) {
                xDim[i] = curve.cubicAt(p0[0], p1[0], p2[0], p3[0], xDim[i]);
            }
            var yDim = [];
            curve.cubicExtrema(p0[1], p1[1], p2[1], p3[1], yDim);
            for (var _i = 0; _i < yDim.length; _i++) {
                yDim[_i] = curve.cubicAt(p0[1], p1[1], p2[1], p3[1], yDim[_i]);
            }

            xDim.push(p0[0], p3[0]);
            yDim.push(p0[1], p3[1]);

            var left = Math.min.apply(null, xDim);
            var right = Math.max.apply(null, xDim);
            var top = Math.min.apply(null, yDim);
            var bottom = Math.max.apply(null, yDim);

            min[0] = left;
            min[1] = top;
            max[0] = right;
            max[1] = bottom;
        }

        /**
         * APIMethod: quadraticBezier
         * 从二阶贝塞尔曲线(p0 p1 p2)中计算出最小包围盒，写入`min`和`max`中
         *
         * 原：computeQuadraticBezierBoundingBox
         *
         * Parameters:
         * p0 - {Array{Number}}
         * p1 - {Array{Number}}
         * p2 - {Array{Number}}
         * min - {Array{Number}}
         * max - {Array{Number}}
         *
         */

    }, {
        key: 'quadraticBezier',
        value: function quadraticBezier(p0, p1, p2, min, max) {
            var curve = new _Curve.Curve();

            // Find extremities, where derivative in x dim or y dim is zero
            var t1 = curve.quadraticExtremum(p0[0], p1[0], p2[0]);
            var t2 = curve.quadraticExtremum(p0[1], p1[1], p2[1]);

            t1 = Math.max(Math.min(t1, 1), 0);
            t2 = Math.max(Math.min(t2, 1), 0);

            var ct1 = 1 - t1;
            var ct2 = 1 - t2;

            var x1 = ct1 * ct1 * p0[0] + 2 * ct1 * t1 * p1[0] + t1 * t1 * p2[0];
            var y1 = ct1 * ct1 * p0[1] + 2 * ct1 * t1 * p1[1] + t1 * t1 * p2[1];

            var x2 = ct2 * ct2 * p0[0] + 2 * ct2 * t2 * p1[0] + t2 * t2 * p2[0];
            var y2 = ct2 * ct2 * p0[1] + 2 * ct2 * t2 * p1[1] + t2 * t2 * p2[1];
            min[0] = Math.min(p0[0], p2[0], x1, x2);
            min[1] = Math.min(p0[1], p2[1], y1, y2);
            max[0] = Math.max(p0[0], p2[0], x1, x2);
            max[1] = Math.max(p0[1], p2[1], y1, y2);
        }

        /**
         * APIMethod: arc
         * 从圆弧中计算出最小包围盒，写入`min`和`max`中
         *
         * 原：computeArcBoundingBox
         *
         * Parameters:
         * x - {Number}  圆弧中心点 x
         * y - {Number}  圆弧中心点 y
         * r - {Number}  圆弧半径
         * startAngle - {Number}  圆弧开始角度
         * endAngle - {Number}  圆弧结束角度
         * anticlockwise - {Number}  是否是顺时针
         * min - {Number}
         * max - {Number}
         */

    }, {
        key: 'arc',
        value: function arc(x, y, r, startAngle, endAngle, anticlockwise, min, max) {
            var vec2 = new _Vector.Vector();

            var start = vec2.create();
            var end = vec2.create();
            var extremity = vec2.create();

            start[0] = Math.cos(startAngle) * r + x;
            start[1] = Math.sin(startAngle) * r + y;

            end[0] = Math.cos(endAngle) * r + x;
            end[1] = Math.sin(endAngle) * r + y;

            vec2.min(min, start, end);
            vec2.max(max, start, end);

            // Thresh to [0, Math.PI * 2]
            startAngle = startAngle % (Math.PI * 2);
            if (startAngle < 0) {
                startAngle = startAngle + Math.PI * 2;
            }
            endAngle = endAngle % (Math.PI * 2);
            if (endAngle < 0) {
                endAngle = endAngle + Math.PI * 2;
            }

            if (startAngle > endAngle && !anticlockwise) {
                endAngle += Math.PI * 2;
            } else if (startAngle < endAngle && anticlockwise) {
                startAngle += Math.PI * 2;
            }
            if (anticlockwise) {
                var tmp = endAngle;
                endAngle = startAngle;
                startAngle = tmp;
            }

            // var number = 0;
            // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
            for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
                if (angle > startAngle) {
                    extremity[0] = Math.cos(angle) * r + x;
                    extremity[1] = Math.sin(angle) * r + y;

                    vec2.min(min, extremity, min);
                    vec2.max(max, extremity, max);
                }
            }
        }
    }]);

    return ComputeBoundingBox;
}();

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Animation.easing
 * 缓动
 */
// 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
// http://sole.github.io/tween.js/examples/03_graphs.html
var Easing = exports.Easing = function () {

    /*
     * Constructor: SuperMap.LevelRenderer.Animation.easing
     * 构造函数。
     *
     */
    function Easing() {
        _classCallCheck(this, Easing);

        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation.easing";
    }

    /*
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Easing, [{
        key: "destroy",
        value: function destroy() {}

        // 线性
        /*
         * @param {number} k
         * @return {number} 返回输入值
         */

    }, {
        key: "Linear",
        value: function Linear(k) {
            return k;
        }

        // 二次方的缓动（t^2）
        /*
         * @param {number} k
         * @return {number} 返回二次方的缓动的值
         */

    }, {
        key: "QuadraticIn",
        value: function QuadraticIn(k) {
            return k * k;
        }

        /*
         * @param {number} k
         * @return {number} 返回按二次方缓动退出的值
         */

    }, {
        key: "QuadraticOut",
        value: function QuadraticOut(k) {
            return k * (2 - k);
        }

        /*
         * @param {number} k
         * @return {number} 返回按二次方缓动进入和退出的值
         */

    }, {
        key: "QuadraticInOut",
        value: function QuadraticInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k;
            }
            return -0.5 * (--k * (k - 2) - 1);
        }

        // 三次方的缓动（t^3）
        /*
         * @param {number} k
         * @return {number} 返回按三次方缓动的值
         */

    }, {
        key: "CubicIn",
        value: function CubicIn(k) {
            return k * k * k;
        }

        /*
         * @param {number} k
         * @return {number} 返回按三次方缓动退出的值
         */

    }, {
        key: "CubicOut",
        value: function CubicOut(k) {
            return --k * k * k + 1;
        }

        /*
         * @param {number} k
         * @return {number} 返回按三次方缓动进入退出的值
         */

    }, {
        key: "CubicInOut",
        value: function CubicInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        }

        // 四次方的缓动（t^4）
        /*
         * @param {number} k
         * @return {number} 返回按四次方缓动进入的值
         */

    }, {
        key: "QuarticIn",
        value: function QuarticIn(k) {
            return k * k * k * k;
        }

        /*
         * @param {number} k
         * @return {number} 返回按四次方缓动退出的值
         */

    }, {
        key: "QuarticOut",
        value: function QuarticOut(k) {
            return 1 - --k * k * k * k;
        }

        /*
         * @param {number} k
         * @return {number} 返回按四次方缓动进入退出的值
         */

    }, {
        key: "QuarticInOut",
        value: function QuarticInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k;
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        }

        // 五次方的缓动（t^5）
        /*
         * @param {number} k
         * @return {number} 返回按五次方缓动的值
         */

    }, {
        key: "QuinticIn",
        value: function QuinticIn(k) {
            return k * k * k * k * k;
        }

        /*
         * @param {number} k
         * @return {number} 返回按五次方缓动退出的值
         */

    }, {
        key: "QuinticOut",
        value: function QuinticOut(k) {
            return --k * k * k * k * k + 1;
        }

        /*
         * @param {number} k
         * @return {number} 返回按五次方缓动进入退出的值
         */

    }, {
        key: "QuinticInOut",
        value: function QuinticInOut(k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        }

        // 正弦曲线的缓动（sin(t)）
        /*
         * @param {number} k
         * @return {number} 返回按正弦曲线的缓动进入的值
         */

    }, {
        key: "SinusoidalIn",
        value: function SinusoidalIn(k) {
            return 1 - Math.cos(k * Math.PI / 2);
        }

        /*
         * @param {number} k
         * @return {number} 返回按正弦曲线的缓动退出的值
         */

    }, {
        key: "SinusoidalOut",
        value: function SinusoidalOut(k) {
            return Math.sin(k * Math.PI / 2);
        }

        /*
         * @param {number} k
         * @return {number} 返回按正弦曲线的缓动进入退出的值
         */

    }, {
        key: "SinusoidalInOut",
        value: function SinusoidalInOut(k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        }

        // 指数曲线的缓动（2^t）
        /*
         * @param {number} k
         * @return {number} 返回按指数曲线的缓动进入的值
         */

    }, {
        key: "ExponentialIn",
        value: function ExponentialIn(k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        }

        /*
         * @param {number} k
         * @return {number} 返回按指数曲线的缓动退出的值
         */

    }, {
        key: "ExponentialOut",
        value: function ExponentialOut(k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        }

        /*
         * @param {number} k
         * @return {number} 返回按指数曲线的缓动进入退出的值
         */

    }, {
        key: "ExponentialInOut",
        value: function ExponentialInOut(k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        }

        // 圆形曲线的缓动（sqrt(1-t^2)）
        /*
         * @param {number} k
         * @return {number} 返回按圆形曲线的缓动进入的值
         */

    }, {
        key: "CircularIn",
        value: function CircularIn(k) {
            return 1 - Math.sqrt(1 - k * k);
        }

        /*
         * @param {number} k
         * @return {number} 返回按圆形曲线的缓动退出的值
         */

    }, {
        key: "CircularOut",
        value: function CircularOut(k) {
            return Math.sqrt(1 - --k * k);
        }

        /*
         * @param {number} k
         * @return {number} 返回按圆形曲线的缓动进入退出的值
         */

    }, {
        key: "CircularInOut",
        value: function CircularInOut(k) {
            if ((k *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        }

        // 创建类似于弹簧在停止前来回振荡的动画
        /*
         * @param {number} k
         * @return {number} 返回按类似于弹簧在停止前来回振荡的动画的缓动进入的值
         */

    }, {
        key: "ElasticIn",
        value: function ElasticIn(k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }

        /*
         * @param {number} k
         * @return {number} 返回按类似于弹簧在停止前来回振荡的动画的缓动退出的值
         */

    }, {
        key: "ElasticOut",
        value: function ElasticOut(k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
        }

        /*
         * @param {number} k
         * @return {number} 返回按类似于弹簧在停止前来回振荡的动画的缓动进入退出的值
         */

    }, {
        key: "ElasticInOut",
        value: function ElasticInOut(k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            if ((k *= 2) < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
        }

        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
        /*
         * @param {number} k
         * @return {number} 返回按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动进入的值
         */

    }, {
        key: "BackIn",
        value: function BackIn(k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        }

        /*
         * @param {number} k
         * @return {number} 返回按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动退出的值
         */

    }, {
        key: "BackOut",
        value: function BackOut(k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        }

        /*
         * @param {number} k
         * @return {number} 返回按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动进入退出的值
         */

    }, {
        key: "BackInOut",
        value: function BackInOut(k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        }

        // 创建弹跳效果
        /*
         * @param {number} k
         * @return {number} 返回按弹跳效果的缓动进入的值
         */

    }, {
        key: "BounceIn",
        value: function BounceIn(k) {
            return 1 - this.BounceOut(1 - k);
        }

        /*
         * @param {number} k
         * @return {number} 返回按弹跳效果的缓动退出的值
         */

    }, {
        key: "BounceOut",
        value: function BounceOut(k) {
            if (k < 1 / 2.75) {
                return 7.5625 * k * k;
            } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
        }

        /*
         * @param {number} k
         * @return {number} 返回按弹跳效果的缓动进入退出的值
         */

    }, {
        key: "BounceInOut",
        value: function BounceInOut(k) {
            if (k < 0.5) {
                return this.BounceIn(k * 2) * 0.5;
            }
            return this.BounceOut(k * 2 - 1) * 0.5 + 0.5;
        }
    }]);

    return Easing;
}();

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Env
 * 环境识别
 *
 */
var Env = exports.Env = function Env() {
    _classCallCheck(this, Env);

    // Zepto.js
    // (c) 2010-2013 Thomas Fuchs
    // Zepto.js may be freely distributed under the MIT license.
    this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Env";
    var me = this;
    function detect(ua) {
        var os = me.os = {};
        var browser = me.browser = {};
        var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
        var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
        var touchpad = webos && ua.match(/TouchPad/);
        var kindle = ua.match(/Kindle\/([\d.]+)/);
        var silk = ua.match(/Silk\/([\d._]+)/);
        var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
        var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
        var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
        var playbook = ua.match(/PlayBook/);
        var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
        var firefox = ua.match(/Firefox\/([\d.]+)/);
        var ie = ua.match(/MSIE ([\d.]+)/);
        var safari = webkit && ua.match(/Mobile\//) && !chrome;
        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

        // Todo: clean this up with a better OS/browser seperation:
        // - discern (more) between multiple browsers on android
        // - decide if kindle fire in silk mode is android or not
        // - Firefox on Android doesn't specify the Android version
        // - possibly devide in os, device and browser hashes

        /*eslint-disable*/
        if (browser.webkit = !!webkit) {
            browser.version = webkit[1];
        }

        if (android) {
            os.android = true, os.version = android[2];
        }
        if (iphone && !ipod) {
            os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
        }
        if (ipad) {
            os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
        }
        if (ipod) {
            os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        }
        if (webos) {
            os.webos = true, os.version = webos[2];
        }
        if (touchpad) {
            os.touchpad = true;
        }
        if (blackberry) {
            os.blackberry = true, os.version = blackberry[2];
        }
        if (bb10) {
            os.bb10 = true, os.version = bb10[2];
        }
        if (rimtabletos) {
            os.rimtabletos = true, os.version = rimtabletos[2];
        }
        if (playbook) {
            browser.playbook = true;
        }
        if (kindle) {
            os.kindle = true, os.version = kindle[1];
        }
        if (silk) {
            browser.silk = true, browser.version = silk[1];
        }
        if (!silk && os.android && ua.match(/Kindle Fire/)) {
            browser.silk = true;
        }
        if (chrome) {
            browser.chrome = true, browser.version = chrome[1];
        }
        if (firefox) {
            browser.firefox = true, browser.version = firefox[1];
        }
        if (ie) {
            browser.ie = true, browser.version = ie[1];
        }
        if (safari && (ua.match(/Safari/) || !!os.ios)) {
            browser.safari = true;
        }
        if (webview) {
            browser.webview = true;
        }
        if (ie) {
            browser.ie = true, browser.version = ie[1];
        }

        os.tablet = !!(ipad || playbook || android && !ua.match(/Mobile/) || firefox && ua.match(/Tablet/) || ie && !ua.match(/Phone/) && ua.match(/Touch/));
        os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 || chrome && ua.match(/Android/) || chrome && ua.match(/CriOS\/([\d.]+)/) || firefox && ua.match(/Mobile/) || ie && ua.match(/Touch/)));

        return {
            browser: browser,
            os: os,
            // 原生canvas支持
            canvasSupported: document.createElement('canvas').getContext ? true : false
        };
    }

    return detect(navigator.userAgent);
};

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Event
 * LevelRenderer 工具-事件辅助类
 *
 */
var Event = exports.Event = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Event
     * 构造函数。
     *
     */
    function Event() {
        _classCallCheck(this, Event);

        /**
         * Property: stop
         * {Function} 停止冒泡和阻止默认行为
         */
        this.stop = typeof window.addEventListener === 'function' ? function (e) {
            e.preventDefault();
            e.stopPropagation();
            e.cancelBubble = true;
        } : function (e) {
            e.returnValue = false;
            e.cancelBubble = true;
        };

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Event";
    }

    /**
     * APIMethod: getX
     * 提取鼠标（手指）x坐标。
     *
     * Parameters:
     * e - {Event} 事件。
     *
     * Returns:
     * {Number} 鼠标（手指）x坐标。
     */


    _createClass(Event, [{
        key: 'getX',
        value: function getX(e) {
            return typeof e.zrenderX != 'undefined' && e.zrenderX || typeof e.offsetX != 'undefined' && e.offsetX || typeof e.layerX != 'undefined' && e.layerX || typeof e.clientX != 'undefined' && e.clientX;
        }

        /**
         * APIMethod: getY
         * 提取鼠标y坐标。
         *
         * Parameters:
         * e - {Event} 事件。
         *
         * Returns:
         * {Number} 鼠标（手指）y坐标。
         */

    }, {
        key: 'getY',
        value: function getY(e) {
            return typeof e.zrenderY != 'undefined' && e.zrenderY || typeof e.offsetY != 'undefined' && e.offsetY || typeof e.layerY != 'undefined' && e.layerY || typeof e.clientY != 'undefined' && e.clientY;
        }

        /**
         * APIMethod: getDelta
         * 提取鼠标滚轮变化。
         *
         * Parameters:
         * e - {Event} 事件。
         *
         * Returns:
         * {Number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动。
         */

    }, {
        key: 'getDelta',
        value: function getDelta(e) {
            return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta || typeof e.wheelDelta != 'undefined' && e.wheelDelta || typeof e.detail != 'undefined' && -e.detail;
        }
    }]);

    return Event;
}();

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Group = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Eventful = __webpack_require__(53);

var _Transformable = __webpack_require__(81);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Group
 * Group 是一个容器，可以插入子节点，Group 的变换也会被应用到子节点上。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Transformable>
 *
 * (code)
 *     var g = new SuperMap.LevelRenderer.Group();
 *     var Circle = new SuperMap.LevelRenderer.Shape.Circle();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.addChild(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *             brushType: 'fill'
 *         }
 *     }));
 *     LR.addGroup(g);
 * (end)
 */

var Group = exports.Group = function (_SuperMap$mixin) {
    _inherits(Group, _SuperMap$mixin);

    /**
     * Constructor: SuperMap.LevelRenderer.Group
     * 构造函数。
     *
     * Parameters:
     * options - {Array} Group 的配置（options）项，可以是 Group 的自有属性，也可以是自定义的属性。
     *
     */
    function Group(options) {
        _classCallCheck(this, Group);

        var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, options));

        options = options || {};
        /**
         * APIProperty: id
         * {String} Group 的唯一标识。
         */
        _this.id = null;

        /**
         * APIProperty: type
         * {Readonly{String}} 类型，默认值：'group'。
         */
        _this.type = 'group';

        //http://www.w3.org/TR/2dcontext/#clipping-region
        /**
         * APIProperty: clipShape
         * {String} 用于裁剪的图形(shape)，所有 Group 内的图形在绘制时都会被这个图形裁剪，该图形会继承 Group 的变换。
         *
         */
        _this.clipShape = null;

        /**
         * Property: _children
         * {Array}
         *
         */
        _this._children = [];

        /**
         * Property: _storage
         * {Array}
         *
         */
        _this._storage = null;

        /**
         * Property: __dirty
         * {Boolean} 默认值：true。
         *
         */
        _this.__dirty = true;

        /**
         * APIProperty: ignore
         * {Boolean} 是否忽略该 Group 及其所有子节点。默认值：false。
         *
         */
        _this.ignore = false;
        _Util.Util.extend(_this, options);
        _this.id = _this.id || _Util.Util.createUniqueID("smShapeGroup_");
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Group";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Group, [{
        key: 'destroy',
        value: function destroy() {
            this.id = null;
            this.type = null;
            this.clipShape = null;
            this._children = null;
            this._storage = null;
            this.__dirty = null;
            this.ignore = null;

            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'destroy', this).call(this);
        }

        /**
         * Method: children
         * 复制并返回一份新的包含所有儿子节点的数组。
         *
         * Returns:
         * {Array<SuperMap.LevelRenderer.Shape>} 图形数组。
         */

    }, {
        key: 'children',
        value: function children() {
            return this._children.slice();
        }

        /**
         * APIMethod: childAt
         * 获取指定 index 的儿子节点。
         *
         * Parameters:
         * idx - {Number} 节点索引。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Shape>} 图形。
         */

    }, {
        key: 'childAt',
        value: function childAt(idx) {
            return this._children[idx];
        }

        /**
         * APIMethod: addChild
         * 添加子节点，可以是 Shape 或者 Group。
         *
         * Parameters:
         * child - {<SuperMap.LevelRenderer.Shape>/<SuperMap.LevelRenderer.Group>} 节点图形。
         *
         */
        // TODO Type Check

    }, {
        key: 'addChild',
        value: function addChild(child) {
            if (child == this) {
                return;
            }

            if (child.parent == this) {
                return;
            }
            if (child.parent) {
                child.parent.removeChild(child);
            }

            this._children.push(child);
            child.parent = this;

            if (this._storage && this._storage !== child._storage) {

                this._storage.addToMap(child);

                if (child instanceof Group) {
                    child.addChildrenToStorage(this._storage);
                }
            }
        }

        /**
         * APIMethod: removeChild
         * 移除子节点。
         *
         * Parameters:
         * child - {<SuperMap.LevelRenderer.Shape>} 需要移除的子节点图形。
         *
         */

    }, {
        key: 'removeChild',
        value: function removeChild(child) {
            var idx = _Util.Util.indexOf(this._children, child);

            this._children.splice(idx, 1);
            child.parent = null;

            if (this._storage) {

                this._storage.delFromMap(child.id);

                if (child instanceof Group) {
                    child.delChildrenFromStorage(this._storage);
                }
            }
        }

        /**
         * APIMethod: eachChild
         * 遍历所有子节点。
         *
         * Parameters:
         * cb - {Function} 回调函数。
         * context - {Object} 上下文。
         *
         */

    }, {
        key: 'eachChild',
        value: function eachChild(cb, context) {
            var haveContext = !!context;
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (haveContext) {
                    cb.call(context, child);
                } else {
                    cb(child);
                }
            }
        }

        /**
         * APIMethod: traverse
         * 深度优先遍历所有子孙节点。
         *
         * Parameters:
         * cb - {Function} 回调函数。
         * context - {Object} 上下文。
         *
         */

    }, {
        key: 'traverse',
        value: function traverse(cb, context) {
            var haveContext = !!context;
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                if (haveContext) {
                    cb.call(context, child);
                } else {
                    cb(child);
                }

                if (child.type === 'group') {
                    child.traverse(cb, context);
                }
            }
        }

        /**
         * Method: addChildrenToStorage
         * 把子图形添加到仓库。
         *
         * Parameters:
         * storage - {<SuperMap.LevelRenderer.Storage>} 图形仓库。
         *
         */

    }, {
        key: 'addChildrenToStorage',
        value: function addChildrenToStorage(storage) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                storage.addToMap(child);
                if (child.type === 'group') {
                    child.addChildrenToStorage(storage);
                }
            }
        }

        /**
         * Method: delChildrenFromStorage
         * 从仓库把子图形删除。
         *
         * Parameters:
         * storage - {<SuperMap.LevelRenderer.Storage>} 图形仓库。
         *
         */

    }, {
        key: 'delChildrenFromStorage',
        value: function delChildrenFromStorage(storage) {
            for (var i = 0; i < this._children.length; i++) {
                var child = this._children[i];
                storage.delFromMap(child.id);
                if (child.type === 'group') {
                    child.delChildrenFromStorage(storage);
                }
            }
        }

        /**
         * Method: modSelf。
         * 是否  修改。
         *
         */

    }, {
        key: 'modSelf',
        value: function modSelf() {
            this.__dirty = true;
        }
    }]);

    return Group;
}(_SuperMap.SuperMap.mixin(_Eventful.Eventful, _Transformable.Transformable));

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Handler = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Eventful2 = __webpack_require__(53);

var _Config = __webpack_require__(78);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Handler
 * Handler 控制模块。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Eventful>
 */
var Handler = exports.Handler = function (_Eventful) {
    _inherits(Handler, _Eventful);

    /**
     * Constructor: SuperMap.LevelRenderer.Handler
     * 构造函数。
     *
     * Parameters:
     * root - {HTMLElement} 绘图区域。
     * storage - {<SuperMap.LevelRenderer.Storage>} Storage 实例。
     * painter - {<SuperMap.LevelRenderer.Painter>} Painter 实例。
     *
     */
    function Handler(root, storage, painter) {
        _classCallCheck(this, Handler);

        /**
         * Property: root
         * {HTMLElement} 绘图区域。
         *
         */
        var _this = _possibleConstructorReturn(this, (Handler.__proto__ || Object.getPrototypeOf(Handler)).call(this, root, storage, painter));

        _this.root = root;

        /**
         * Property: storage
         * {<SuperMap.LevelRenderer.Storage>} Storage 实例。
         *
         */
        _this.storage = storage;

        /**
         * Property: painter
         * {<SuperMap.LevelRenderer.Painter>} Painter 实例。
         *
         */
        _this.painter = painter;

        /**
         * Property: _lastX
         * {Number} 默认值：0。
         *
         */
        _this._lastX = 0;

        /**
         * Property: _lastY
         * {Number} 默认值：0。
         *
         */
        _this._lastY = 0;

        /**
         * Property: _mouseX
         * {Number} 默认值：0。
         *
         */
        _this._mouseX = 0;

        /**
         * Property: _mouseY
         * {Number} 默认值：0。
         *
         */
        _this._mouseY = 0;

        /**
         * Property: _findHover
         * {Function} 查找 Hover 图形。
         *
         */
        _this._findHover = null;

        /**
         * Property: _domHover
         * {Object} 高亮 DOM。
         *
         */
        _this._domHover = null;

        // 各种事件标识的私有变量
        // this._hasfound = false;              // 是否找到 hover 图形元素
        // this._lastHover = null;              // 最后一个 hover 图形元素
        // this._mouseDownTarget = null;
        // this._draggingTarget = null;         // 当前被拖拽的图形元素
        // this._isMouseDown = false;
        // this._isDragging = false;
        // this._lastMouseDownMoment;
        // this._lastTouchMoment;
        // this._lastDownButton;

        _this._findHover = bind3Arg(findHover, _this);
        _this._domHover = painter.getDomHover();

        _this.CLASS_NAME = "SuperMap.LevelRenderer.Handler";
        var domHandlers = {
            /**
             * Method: resize
             * 窗口大小改变响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            resize: function resize(event) {
                event = event || window.event;
                this._lastHover = null;
                this._isMouseDown = 0;

                // 分发SuperMap.LevelRenderer.Config.EVENT.RESIZE事件，global
                this.dispatch(_Config.Config.EVENT.RESIZE, event);
            },

            /**
             * Method: click
             * 点击响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            click: function click(event) {
                event = this._zrenderEventFixed(event);

                // 分发SuperMap.LevelRenderer.Config.EVENT.CLICK事件
                var _lastHover = this._lastHover;
                if (_lastHover && _lastHover.clickable || !_lastHover) {

                    // 判断没有发生拖拽才触发click事件
                    if (this._clickThreshold < 10) {
                        this._dispatchAgency(_lastHover, _Config.Config.EVENT.CLICK, event);
                    }
                }

                this._mousemoveHandler(event);
            },

            /**
             * Method: dblclick
             * 双击响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            dblclick: function dblclick(event) {
                event = event || window.event;
                event = this._zrenderEventFixed(event);

                // 分发SuperMap.LevelRenderer.Config.EVENT.DBLCLICK事件
                var _lastHover = this._lastHover;
                if (_lastHover && _lastHover.clickable || !_lastHover) {

                    // 判断没有发生拖拽才触发dblclick事件
                    if (this._clickThreshold < 5) {
                        this._dispatchAgency(_lastHover, _Config.Config.EVENT.DBLCLICK, event);
                    }
                }

                this._mousemoveHandler(event);
            },

            /**
             * Method: mousewheel
             * 鼠标滚轮响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mousewheel: function mousewheel(event) {
                event = this._zrenderEventFixed(event);

                // http://www.sitepoint.com/html5-javascript-mouse-wheel/
                // https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/mousewheel
                var delta = event.wheelDelta // Webkit
                || -event.detail; // Firefox
                var scale = delta > 0 ? 1.1 : 1 / 1.1;

                var layers = this.painter.getLayers();

                var needsRefresh = false;
                for (var z in layers) {
                    if (z !== 'hover') {
                        var layer = layers[z];
                        var pos = layer.position;
                        if (layer.zoomable) {
                            layer.__zoom = layer.__zoom || 1;
                            var newZoom = layer.__zoom;
                            newZoom *= scale;
                            newZoom = Math.max(Math.min(layer.maxZoom, newZoom), layer.minZoom);
                            scale = newZoom / layer.__zoom;
                            layer.__zoom = newZoom;
                            // Keep the mouse center when scaling
                            pos[0] -= (this._mouseX - pos[0]) * (scale - 1);
                            pos[1] -= (this._mouseY - pos[1]) * (scale - 1);
                            layer.scale[0] *= scale;
                            layer.scale[1] *= scale;
                            layer.dirty = true;
                            needsRefresh = true;
                        }
                    }
                }
                if (needsRefresh) {
                    this.painter.refresh();
                }

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEWHEEL事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.MOUSEWHEEL, event);
                this._mousemoveHandler(event);
            },

            /**
             * Method: mousemove
             * 鼠标（手指）移动响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mousemove: function mousemove(event) {
                // 拖拽不触发click事件
                this._clickThreshold++;

                event = this._zrenderEventFixed(event);
                this._lastX = this._mouseX;
                this._lastY = this._mouseY;
                this._mouseX = _SUtil.SUtil.Util_event.getX(event);
                this._mouseY = _SUtil.SUtil.Util_event.getY(event);
                var dx = this._mouseX - this._lastX;
                var dy = this._mouseY - this._lastY;

                // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGSTART事件
                // 避免手抖点击误认为拖拽
                // if (this._mouseX - this._lastX > 1 || this._mouseY - this._lastY > 1) {
                this._processDragStart(event);
                // }
                this._hasfound = 0;
                this._event = event;

                this._iterateAndFindHover();

                // 找到的在迭代函数里做了处理，没找到得在迭代完后处理
                if (!this._hasfound) {
                    // 过滤首次拖拽产生的mouseout和dragLeave
                    if (!this._draggingTarget || this._lastHover && this._lastHover != this._draggingTarget) {
                        // 可能出现SuperMap.LevelRenderer.Config.EVENT.MOUSEOUT事件
                        this._processOutShape(event);

                        // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGLEAVE事件
                        this._processDragLeave(event);
                    }

                    this._lastHover = null;
                    this.storage.delHover();
                    this.painter.clearHover();
                }

                // set cursor for root element
                var cursor = '';

                // 如果存在拖拽中元素，被拖拽的图形元素最后addHover
                if (this._draggingTarget) {
                    this.storage.drift(this._draggingTarget.id, dx, dy);
                    this._draggingTarget.modSelf();
                    this.storage.addHover(this._draggingTarget);
                } else if (this._isMouseDown) {
                    // Layer dragging
                    var layers = this.painter.getLayers();

                    var needsRefresh = false;
                    for (var z in layers) {
                        if (z !== 'hover') {
                            var layer = layers[z];
                            if (layer.panable) {
                                // PENDING
                                cursor = 'move';
                                // Keep the mouse center when scaling
                                layer.position[0] += dx;
                                layer.position[1] += dy;
                                needsRefresh = true;
                                layer.dirty = true;
                            }
                        }
                    }
                    if (needsRefresh) {
                        this.painter.refresh();
                    }
                }

                if (this._draggingTarget || this._hasfound && this._lastHover.draggable) {
                    cursor = 'move';
                } else if (this._hasfound && this._lastHover.clickable) {
                    cursor = 'pointer';
                }
                this.root.style.cursor = cursor;

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEMOVE事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.MOUSEMOVE, event);

                if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                    this.painter.refreshHover();
                }
            },

            /**
             * Method: mouseout
             * 鼠标（手指）离开响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mouseout: function mouseout(event) {
                event = this._zrenderEventFixed(event);

                var element = event.toElement || event.relatedTarget;
                if (element != this.root) {
                    while (element && element.nodeType != 9) {
                        // 忽略包含在root中的dom引起的mouseOut
                        if (element == this.root) {
                            this._mousemoveHandler(event);
                            return;
                        }

                        element = element.parentNode;
                    }
                }

                event.zrenderX = this._lastX;
                event.zrenderY = this._lastY;
                this.root.style.cursor = '';
                this._isMouseDown = 0;

                this._processOutShape(event);
                this._processDrop(event);
                this._processDragEnd(event);

                this.painter.refreshHover();

                this.dispatch(_Config.Config.EVENT.GLOBALOUT, event);
            },

            /**
             * Method: mousedown
             * 鼠标（手指）按下响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mousedown: function mousedown(event) {
                // 重置 clickThreshold
                this._clickThreshold = 0;

                if (this._lastDownButton == 2) {
                    this._lastDownButton = event.button;
                    this._mouseDownTarget = null;
                    // 仅作为关闭右键菜单使用
                    return;
                }

                this._lastMouseDownMoment = new Date();
                event = this._zrenderEventFixed(event);
                this._isMouseDown = 1;

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEDOWN事件
                this._mouseDownTarget = this._lastHover;
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.MOUSEDOWN, event);
                this._lastDownButton = event.button;
            },

            /**
             * Method: mouseup
             * 鼠标（手指）抬起响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mouseup: function mouseup(event) {
                event = this._zrenderEventFixed(event);
                this.root.style.cursor = '';
                this._isMouseDown = 0;
                this._mouseDownTarget = null;

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEUP事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.MOUSEUP, event);
                this._processDrop(event);
                this._processDragEnd(event);
            },

            /**
             * Method: touchstart
             * Touch 开始响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            touchstart: function touchstart(event) {
                // SUtil.Util_event.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._lastTouchMoment = new Date();

                // 平板补充一次findHover
                this._mobildFindFixed(event);
                this._mousedownHandler(event);
            },

            /**
             * Method: touchmove
             * Touch 移动响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            touchmove: function touchmove(event) {
                event = this._zrenderEventFixed(event, true);
                this._mousemoveHandler(event);
                if (this._isDragging) {
                    _SUtil.SUtil.Util_event.stop(event); // 阻止浏览器默认事件，重要
                }
            },

            /**
             * Method: touchend
             * Touch 结束响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            touchend: function touchend(event) {
                // SUtil.Util_event.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._mouseupHandler(event);

                var now = new Date();
                if (now - this._lastTouchMoment < _Config.Config.EVENT.touchClickDelay) {
                    this._mobildFindFixed(event);
                    this._clickHandler(event);
                    if (now - this._lastClickMoment < _Config.Config.EVENT.touchClickDelay / 2) {
                        this._dblclickHandler(event);
                        if (this._lastHover && this._lastHover.clickable) {
                            _SUtil.SUtil.Util_event.stop(event); // 阻止浏览器默认事件，重要
                        }
                    }
                    this._lastClickMoment = now;
                }
                this.painter.clearHover();
            }
        };

        initDomHandler(_this);

        // 初始化，事件绑定，支持的所有事件都由如下原生事件计算得来
        if (window.addEventListener) {
            window.addEventListener('resize', _this._resizeHandler);

            if (_SUtil.SUtil.Util_env.os.tablet || _SUtil.SUtil.Util_env.os.phone) {
                // mobile支持
                root.addEventListener('touchstart', _this._touchstartHandler);
                root.addEventListener('touchmove', _this._touchmoveHandler);
                root.addEventListener('touchend', _this._touchendHandler);
            } else {
                // mobile的click/move/up/down自己模拟
                root.addEventListener('click', _this._clickHandler);
                root.addEventListener('dblclick', _this._dblclickHandler);
                root.addEventListener('mousewheel', _this._mousewheelHandler);
                root.addEventListener('mousemove', _this._mousemoveHandler);
                root.addEventListener('mousedown', _this._mousedownHandler);
                root.addEventListener('mouseup', _this._mouseupHandler);
            }
            root.addEventListener('DOMMouseScroll', _this._mousewheelHandler);
            root.addEventListener('mouseout', _this._mouseoutHandler);
        } else {
            window.attachEvent('onresize', _this._resizeHandler);

            root.attachEvent('onclick', _this._clickHandler);
            //root.attachEvent('ondblclick ', this._dblclickHandler);
            root.ondblclick = _this._dblclickHandler;
            root.attachEvent('onmousewheel', _this._mousewheelHandler);
            root.attachEvent('onmousemove', _this._mousemoveHandler);
            root.attachEvent('onmouseout', _this._mouseoutHandler);
            root.attachEvent('onmousedown', _this._mousedownHandler);
            root.attachEvent('onmouseup', _this._mouseupHandler);
        }

        // 辅助函数 start
        /**
         * Method: bind1Arg
         * bind 一个参数的 function。
         *
         * Parameters:
         * handler - {Function} 要 bind 的 function。
         * context - {Object} 运行时 this 环境。
         *
         * Returns:
         * {Function}
         */
        function bind1Arg(handler, context) {
            return function (e) {
                return handler.call(context, e);
            };
        }

        /*
         // bind 两个参数的 function
         function bind2Arg(handler, context) {
         return function (arg1, arg2) {
         return handler.call(context, arg1, arg2);
         };
         }
         */

        // bind 三个参数的 function
        function bind3Arg(handler, context) {
            return function (arg1, arg2, arg3) {
                return handler.call(context, arg1, arg2, arg3);
            };
        }

        /**
         * Method: initDomHandler
         * 为控制类实例初始化 dom 事件处理函数。
         *
         * Parameters:
         * instance - {<SuperMap.LevelRenderer.Handler>} 控制类实例 。
         *
         * Returns:
         * {Function}
         */
        function initDomHandler(instance) {
            var domHandlerNames = ['resize', 'click', 'dblclick', 'mousewheel', 'mousemove', 'mouseout', 'mouseup', 'mousedown', 'touchstart', 'touchend', 'touchmove'];

            var len = domHandlerNames.length;
            while (len--) {
                var name = domHandlerNames[len];
                instance['_' + name + 'Handler'] = bind1Arg(domHandlers[name], instance);
            }
        }

        /**
         * Method: findHover
         * 迭代函数，查找 hover 到的图形元素并即时做些事件分发。
         *
         * Parameters:
         * shape - {Object} 图形。
         * x - {Number} 鼠标 x。
         * y - {Number} 鼠标 y。
         *
         * Returns:
         * {Boolean} 是否找到图形。
         *
         */
        function findHover(shape, x, y) {
            var me = this;
            if (me._draggingTarget && me._draggingTarget.id == shape.id || // 迭代到当前拖拽的图形上
            shape.isSilent() // 打酱油的路过，啥都不响应的shape~
            ) {
                    return false;
                }

            var event = me._event;
            if (shape.isCover(x, y)) {
                if (shape.hoverable) {
                    // SMIC-修改 - start
                    if (shape.isHoverByRefDataID && shape.isHoverByRefDataID === true) {
                        if (shape.refDataID) {
                            var fid = shape.refDataID;
                            //me.painter.clearHover();
                            //me.storage.delHover();

                            var hoverGroup = null;
                            if (shape.refDataHoverGroup) {
                                hoverGroup = shape.refDataHoverGroup;
                            }

                            //查找同一个用户数据 feature 的所有图形
                            var shapeList = me.storage._shapeList;
                            for (var i = 0, len = shapeList.length; i < len; i++) {
                                var si = shapeList[i];
                                if (si.refDataID && fid === si.refDataID) {
                                    if (hoverGroup) {
                                        if (si.refDataHoverGroup && hoverGroup === si.refDataHoverGroup) {
                                            me.storage.addHover(si);
                                        }
                                    } else {
                                        me.storage.addHover(si);
                                    }
                                }
                            }
                        }
                    } else {
                        me.storage.addHover(shape);
                    }
                    //初始代码：
                    //  me.storage.addHover(shape);
                    // SMIC-修改 - end
                }
                // 查找是否在 clipShape 中
                var p = shape.parent;
                while (p) {
                    if (p.clipShape && !p.clipShape.isCover(me._mouseX, me._mouseY)) {
                        // 已经被祖先 clip 掉了
                        return false;
                    }
                    p = p.parent;
                }

                if (me._lastHover != shape) {
                    me._processOutShape(event);

                    // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGLEAVE事件
                    me._processDragLeave(event);

                    me._lastHover = shape;

                    // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGENTER事件
                    me._processDragEnter(event);
                }

                me._processOverShape(event);

                // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGOVER
                me._processDragOver(event);

                me._hasfound = 1;

                return true; // 找到则中断迭代查找
            }

            return false;
        }

        // 辅助函数 end
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Handler, [{
        key: 'destroy',
        value: function destroy() {
            this.dispose();
            this._lastX = null;
            this._lastY = null;
            this._mouseX = null;
            this._mouseY = null;
            this._findHover = null;

            _Eventful2.Eventful.prototype.destroy.apply(this, arguments);
        }

        /**
         * APIMethod: on
         * 自定义事件绑定。
         *
         * Parameters:
         * eventName - {string} 事件名称，resize、hover、drag 等。
         * handler - {Function} 响应函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Handler>} this。
         */

    }, {
        key: 'on',
        value: function on(eventName, handler) {
            this.bind(eventName, handler);
            return this;
        }

        /**
         * APIMethod: un
         * 自定义事件解除绑定。
         *
         * Parameters:
         * eventName - {string} 事件名称，resize、hover、drag 等。
         * handler - {Function} 响应函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Handler>} this。
         */

    }, {
        key: 'un',
        value: function un(eventName, handler) {
            this.unbind(eventName, handler);
            return this;
        }

        /**
         * APIMethod: trigger
         * 事件触发。
         *
         * Parameters:
         * eventName - {string} 事件名称，resize、hover、drag 等。
         * eventArgs - {event} dom事件对象。
         *
         */

    }, {
        key: 'trigger',
        value: function trigger(eventName, eventArgs) {
            var EVENT = _Config.Config.EVENT;
            switch (eventName) {
                case EVENT.RESIZE:
                case EVENT.CLICK:
                case EVENT.DBLCLICK:
                case EVENT.MOUSEWHEEL:
                case EVENT.MOUSEMOVE:
                case EVENT.MOUSEDOWN:
                case EVENT.MOUSEUP:
                case EVENT.MOUSEOUT:
                    this['_' + eventName + 'Handler'](eventArgs);
                    break;
            }
        }

        /**
         * APIMethod: dispose
         * 释放，解绑所有事件。
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            var root = this.root;

            if (window.removeEventListener) {
                window.removeEventListener('resize', this._resizeHandler);

                if (_SUtil.SUtil.Util_env.os.tablet || _SUtil.SUtil.Util_env.os.phone) {
                    // mobile支持
                    root.removeEventListener('touchstart', this._touchstartHandler);
                    root.removeEventListener('touchmove', this._touchmoveHandler);
                    root.removeEventListener('touchend', this._touchendHandler);
                } else {
                    // mobile的click自己模拟
                    root.removeEventListener('click', this._clickHandler);
                    root.removeEventListener('dblclick', this._dblclickHandler);
                    root.removeEventListener('mousewheel', this._mousewheelHandler);
                    root.removeEventListener('mousemove', this._mousemoveHandler);
                    root.removeEventListener('mousedown', this._mousedownHandler);
                    root.removeEventListener('mouseup', this._mouseupHandler);
                }
                root.removeEventListener('DOMMouseScroll', this._mousewheelHandler);
                root.removeEventListener('mouseout', this._mouseoutHandler);
            } else {
                window.detachEvent('onresize', this._resizeHandler);

                root.detachEvent('onclick', this._clickHandler);
                root.detachEvent('dblclick', this._dblclickHandler);
                root.detachEvent('onmousewheel', this._mousewheelHandler);
                root.detachEvent('onmousemove', this._mousemoveHandler);
                root.detachEvent('onmouseout', this._mouseoutHandler);
                root.detachEvent('onmousedown', this._mousedownHandler);
                root.detachEvent('onmouseup', this._mouseupHandler);
            }

            this.root = null;
            this._domHover = null;
            this.storage = null;
            this.painter = null;

            this.un();
        }

        /**
         * Method: _processDragStart
         * 拖拽开始。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processDragStart',
        value: function _processDragStart(event) {
            var _lastHover = this._lastHover;

            if (this._isMouseDown && _lastHover && _lastHover.draggable && !this._draggingTarget && this._mouseDownTarget == _lastHover) {
                // 拖拽点击生效时长阀门，某些场景需要降低拖拽敏感度
                if (_lastHover.dragEnableTime && new Date() - this._lastMouseDownMoment < _lastHover.dragEnableTime) {
                    return;
                }

                var _draggingTarget = _lastHover;
                this._draggingTarget = _draggingTarget;
                this._isDragging = 1;

                _draggingTarget.invisible = true;
                this.storage.mod(_draggingTarget.id);

                // 分发 Config.EVENT.DRAGSTART事件
                this._dispatchAgency(_draggingTarget, _Config.Config.EVENT.DRAGSTART, event);
                this.painter.refresh();
            }
        }

        /**
         * Method: _processDragEnter
         * 拖拽进入目标元素。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processDragEnter',
        value: function _processDragEnter(event) {
            if (this._draggingTarget) {
                // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGENTER事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.DRAGENTER, event, this._draggingTarget);
            }
        }

        /**
         * Method: _processDragOver
         * 拖拽在目标元素上移动。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processDragOver',
        value: function _processDragOver(event) {
            if (this._draggingTarget) {
                // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGOVER事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.DRAGOVER, event, this._draggingTarget);
            }
        }

        /**
         * Method: _processDragLeave
         * 拖拽离开目标元素。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processDragLeave',
        value: function _processDragLeave(event) {
            if (this._draggingTarget) {
                // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGLEAVE事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.DRAGLEAVE, event, this._draggingTarget);
            }
        }

        /**
         * Method: _processDrop
         * 拖拽在目标元素上完成。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processDrop',
        value: function _processDrop(event) {
            if (this._draggingTarget) {
                this._draggingTarget.invisible = false;
                this.storage.mod(this._draggingTarget.id);
                this.painter.refresh();

                // 分发SuperMap.LevelRenderer.Config.EVENT.DROP事件
                this._dispatchAgency(this._lastHover, _Config.Config.EVENT.DROP, event, this._draggingTarget);
            }
        }

        /**
         * Method: _processDragEnd
         * 拖拽结束。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processDragEnd',
        value: function _processDragEnd(event) {
            if (this._draggingTarget) {
                // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGEND事件
                this._dispatchAgency(this._draggingTarget, _Config.Config.EVENT.DRAGEND, event);

                this._lastHover = null;
            }

            this._isDragging = 0;
            this._draggingTarget = null;
        }

        /**
         * Method: _processOverShape
         * 鼠标在某个图形元素上移动。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processOverShape',
        value: function _processOverShape(event) {
            // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEOVER事件
            this._dispatchAgency(this._lastHover, _Config.Config.EVENT.MOUSEOVER, event);
        }

        /**
         * Method: _processOutShape
         * 鼠标离开某个图形元素。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_processOutShape',
        value: function _processOutShape(event) {
            // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEOUT事件
            this._dispatchAgency(this._lastHover, _Config.Config.EVENT.MOUSEOUT, event);
        }

        /**
         * Method: _dispatchAgency
         * 鼠标离开某个图形元素。
         *
         * Parameters:
         * targetShape - {Object} 目标图形元素。
         * eventName - {Object} 事件名称。
         * event - {Object} 事件对象。
         * draggedShape - {Object} 拖拽事件特有，当前被拖拽图形元素。
         *
         */

    }, {
        key: '_dispatchAgency',
        value: function _dispatchAgency(targetShape, eventName, event, draggedShape) {
            var eventHandler = 'on' + eventName;
            var eventPacket = {
                type: eventName,
                event: event,
                target: targetShape,
                cancelBubble: false
            };

            var el = targetShape;

            if (draggedShape) {
                eventPacket.dragged = draggedShape;
            }

            while (el) {
                el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler](eventPacket));
                el.dispatch(eventName, eventPacket);

                el = el.parent;

                if (eventPacket.cancelBubble) {
                    break;
                }
            }

            if (targetShape) {
                // 冒泡到顶级 zrender 对象
                if (!eventPacket.cancelBubble) {
                    this.dispatch(eventName, eventPacket);
                }
            } else if (!draggedShape) {
                // 无hover目标，无拖拽对象，原生事件分发
                this.dispatch(eventName, {
                    type: eventName,
                    event: event
                });
            }
        }

        /**
         * Method: _iterateAndFindHover
         * 迭代寻找 hover shape。
         *
         */

    }, {
        key: '_iterateAndFindHover',
        value: function _iterateAndFindHover() {
            var invTransform = _SUtil.SUtil.Util_matrix.create();

            var list = this.storage.getShapeList();
            var currentZLevel;
            var currentLayer;
            var tmp = [0, 0];
            for (var i = list.length - 1; i >= 0; i--) {
                var shape = list[i];

                if (currentZLevel !== shape.zlevel) {
                    currentLayer = this.painter.getLayer(shape.zlevel, currentLayer);
                    tmp[0] = this._mouseX;
                    tmp[1] = this._mouseY;

                    if (currentLayer.needTransform) {
                        _SUtil.SUtil.Util_matrix.invert(invTransform, currentLayer.transform);
                        _SUtil.SUtil.Util_vector.applyTransform(tmp, tmp, invTransform);
                    }
                }

                if (this._findHover(shape, tmp[0], tmp[1])) {
                    break;
                }
            }
        }

        /**
         * Method: _mobildFindFixed
         * touch 有指尖错觉，四向尝试，让touch上的点击更好触发事件。
         *
         * Parameters:
         * event - {Object} 事件对象。
         *
         */

    }, {
        key: '_mobildFindFixed',
        value: function _mobildFindFixed(event) {
            // touch指尖错觉的尝试偏移量配置
            var MOBILE_TOUCH_OFFSETS = [{ x: 10 }, { x: -20 }, { x: 10, y: 10 }, { y: -20 }];

            this._lastHover = null;
            this._mouseX = event.zrenderX;
            this._mouseY = event.zrenderY;

            this._event = event;

            this._iterateAndFindHover();

            for (var i = 0; !this._lastHover && i < MOBILE_TOUCH_OFFSETS.length; i++) {
                var offset = MOBILE_TOUCH_OFFSETS[i];
                offset.x && (this._mouseX += offset.x);
                offset.y && (this._mouseX += offset.y);

                this._iterateAndFindHover();
            }

            if (this._lastHover) {
                event.zrenderX = this._mouseX;
                event.zrenderY = this._mouseY;
            }
        }

        /**
         * Method: _zrenderEventFixed
         * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标 。
         *
         * Parameters:
         * event - {Object} 事件。
         * isTouch - {Boolean} 是否触摸。
         *
         */

    }, {
        key: '_zrenderEventFixed',
        value: function _zrenderEventFixed(event, isTouch) {
            if (event.zrenderFixed) {
                return event;
            }

            if (!isTouch) {
                event = event || window.event;
                // 进入对象优先~
                var target = event.toElement || event.relatedTarget || event.srcElement || event.target;

                if (target && target != this._domHover) {
                    event.zrenderX = (typeof event.offsetX != 'undefined' ? event.offsetX : event.layerX) + target.offsetLeft;
                    event.zrenderY = (typeof event.offsetY != 'undefined' ? event.offsetY : event.layerY) + target.offsetTop;
                }
            } else {
                var touch = event.type != 'touchend' ? event.targetTouches[0] : event.changedTouches[0];
                if (touch) {
                    var rBounding = this.root.getBoundingClientRect();
                    // touch事件坐标是全屏的~
                    event.zrenderX = touch.clientX - rBounding.left;
                    event.zrenderY = touch.clientY - rBounding.top;
                }
            }

            event.zrenderFixed = 1;
            return event;
        }

        // SMIC-方法扩展 - start
        /**
         * Method: getLastHoverOne
         * 获取单个高亮图形。
         *
         */

    }, {
        key: 'getLastHoverOne',
        value: function getLastHoverOne() {
            if (this._lastHover) {
                return this._lastHover;
            }
            return null;
        }

        // SMIC-方法扩展 - end

    }]);

    return Handler;
}(_Eventful2.Eventful);

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Http
 * LevelRenderer 工具-Http
 *
 */
var Http = exports.Http = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Http
     * 构造函数。
     *
     */
    function Http() {
        _classCallCheck(this, Http);

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Http";
    }

    /**
     * Method: get
     * get请求。
     *
     * Parameters:
     * url - {string|IHTTPGetOption}
     * onsuccess - {Function}
     * onerror - {Function}
     * opts - {Object} 额外参数
     *
     * Returns:
     * {Number} cos 值。
     */


    _createClass(Http, [{
        key: 'get',
        value: function get(url, onsuccess, onerror) {
            if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object') {
                var obj = url;
                url = obj.url;
                onsuccess = obj.onsuccess;
                onerror = obj.onerror;
            }
            var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP');
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function () {
                if (xhr.readyState == 4) {
                    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                        onsuccess && onsuccess(xhr.responseText);
                    } else {
                        onerror && onerror();
                    }
                    xhr.onreadystatechange = new Function();
                    xhr = null;
                }
            };

            xhr.send(null);
        }
    }]);

    return Http;
}();

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Log = undefined;

var _Config = __webpack_require__(78);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Log
 * LevelRenderer 工具-日志
 *
 */
var Log =

/**
 * Constructor: SuperMap.LevelRenderer.Tool.Log
 * 构造函数。
 *
 */
exports.Log = function Log() {
    _classCallCheck(this, Log);

    this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Log";
    return function () {
        if (_Config.Config.debugMode === 0) {
            return;
        } else if (_Config.Config.debugMode == 1) {
            for (var k in arguments) {
                throw new Error(arguments[k]);
            }
        } else if (_Config.Config.debugMode > 1) {
            for (var _k in arguments) {
                console.log(arguments[_k]);
            }
        }
    };

    /* for debug
     return function(mes) {
     document.getElementById('wrong-message').innerHTML =
     mes + ' ' + (new Date() - 0)
     + '<br/>'
     + document.getElementById('wrong-message').innerHTML;
     };
     */
};

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Math
 * LevelRenderer 工具-数学辅助类
 *
 */
var Math = exports.Math = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Math
     * 构造函数。
     *
     */
    function Math() {
        _classCallCheck(this, Math);

        /**
         * Property: _radians
         * {Number} 角度与弧度转化参数
         */
        this._radians = window.Math.PI / 180;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Math";
    }

    /**
     * APIMethod: sin
     * 正弦函数。
     *
     * Parameters:
     * angle - {Number} 弧度（角度）参数。
     * isDegrees - {Boolean} angle参数是否为角度计算，默认为false，angle为以弧度计量的角度。
     *
     * Returns:
     * {Number} sin 值。
     */


    _createClass(Math, [{
        key: "sin",
        value: function sin(angle, isDegrees) {
            return window.Math.sin(isDegrees ? angle * this._radians : angle);
        }

        /**
         * APIMethod: cos
         * 正弦函数。
         *
         * Parameters:
         * angle - {Number} 弧度（角度）参数。
         * isDegrees - {Boolean} angle参数是否为角度计算，默认为false，angle为以弧度计量的角度。
         *
         * Returns:
         * {Number} cos 值。
         */

    }, {
        key: "cos",
        value: function cos(angle, isDegrees) {
            return window.Math.cos(isDegrees ? angle * this._radians : angle);
        }

        /**
         * APIMethod: degreeToRadian
         * 角度转弧度。
         *
         * Parameters:
         * angle - {Number} 角度参数。
         *
         * Returns:
         * {Number} 弧度值。
         */

    }, {
        key: "degreeToRadian",
        value: function degreeToRadian(angle) {
            return angle * this._radians;
        }

        /**
         * APIMethod: radianToDegree
         * 弧度转角度。
         *
         * Parameters:
         * angle - {Number} 弧度参数。
         *
         * Returns:
         * {Number} 角度。
         */

    }, {
        key: "radianToDegree",
        value: function radianToDegree(angle) {
            return angle / this._radians;
        }
    }]);

    return Math;
}();

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Tool.Matrix
 * LevelRenderer 工具-3x2矩阵操作类
 *
 */
var Matrix = exports.Matrix = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Tool.Matrix
     * 构造函数。
     *
     */
    function Matrix() {
        _classCallCheck(this, Matrix);

        /**
         * Property: ArrayCtor
         * {Object} 数组类型控制
         */
        this.ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Matrix";
    }

    /**
     * APIMethod: create
     * 创建一个单位矩阵。
     *
     * Returns:
     * {Float32Array|Array.<Number>} 单位矩阵。
     */


    _createClass(Matrix, [{
        key: "create",
        value: function create() {
            var ArrayCtor = this.ArrayCtor;

            var out = new ArrayCtor(6);
            this.identity(out);

            return out;
        }

        /**
         * APIMethod: identity
         * 设置矩阵为单位矩阵。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 单位矩阵。
         */

    }, {
        key: "identity",
        value: function identity(out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            out[4] = 0;
            out[5] = 0;
            return out;
        }

        /**
         * APIMethod: copy
         * 复制矩阵。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * m - {Float32Array|Array.<Number>} 原始矩阵。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 克隆矩阵。
         */

    }, {
        key: "copy",
        value: function copy(out, m) {
            out[0] = m[0];
            out[1] = m[1];
            out[2] = m[2];
            out[3] = m[3];
            out[4] = m[4];
            out[5] = m[5];
            return out;
        }

        /**
         * APIMethod: mul
         * 矩阵相乘。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * m1 - {Float32Array|Array.<Number>} 矩阵m1。
         * m2- {Float32Array|Array.<Number>} 矩阵m2。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 结果矩阵。
         */

    }, {
        key: "mul",
        value: function mul(out, m1, m2) {
            out[0] = m1[0] * m2[0] + m1[2] * m2[1];
            out[1] = m1[1] * m2[0] + m1[3] * m2[1];
            out[2] = m1[0] * m2[2] + m1[2] * m2[3];
            out[3] = m1[1] * m2[2] + m1[3] * m2[3];
            out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
            out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
            return out;
        }

        /**
         * APIMethod: translate
         * 平移变换。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * a - {Float32Array|Array.<Number>} 矩阵。
         * v- {Float32Array|Array.<Number>} 平移参数。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 结果矩阵。
         */

    }, {
        key: "translate",
        value: function translate(out, a, v) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4] + v[0];
            out[5] = a[5] + v[1];
            return out;
        }

        /**
         * APIMethod: rotate
         * 旋转变换。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * a - {Float32Array|Array.<Number>} 矩阵。
         * rad- {Float32Array|Array.<Number>} 旋转参数。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 结果矩阵。
         */

    }, {
        key: "rotate",
        value: function rotate(out, a, rad) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            var st = Math.sin(rad);
            var ct = Math.cos(rad);

            out[0] = aa * ct + ab * st;
            out[1] = -aa * st + ab * ct;
            out[2] = ac * ct + ad * st;
            out[3] = -ac * st + ct * ad;
            out[4] = ct * atx + st * aty;
            out[5] = ct * aty - st * atx;
            return out;
        }

        /**
         * APIMethod: scale
         * 缩放变换。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * a - {Float32Array|Array.<Number>} 矩阵。
         * v- {Float32Array|Array.<Number>} 缩放参数。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 结果矩阵。
         */

    }, {
        key: "scale",
        value: function scale(out, a, v) {
            var vx = v[0];
            var vy = v[1];
            out[0] = a[0] * vx;
            out[1] = a[1] * vy;
            out[2] = a[2] * vx;
            out[3] = a[3] * vy;
            out[4] = a[4] * vx;
            out[5] = a[5] * vy;
            return out;
        }

        /**
         * APIMethod: invert
         * 求逆矩阵。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * a - {Float32Array|Array.<Number>} 矩阵。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 结果矩阵。
         */

    }, {
        key: "invert",
        value: function invert(out, a) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];

            var det = aa * ad - ab * ac;
            if (!det) {
                return null;
            }
            det = 1.0 / det;

            out[0] = ad * det;
            out[1] = -ab * det;
            out[2] = -ac * det;
            out[3] = aa * det;
            out[4] = (ac * aty - ad * atx) * det;
            out[5] = (ab * atx - aa * aty) * det;
            return out;
        }

        /**
         * APIMethod: mulVector
         * 矩阵左乘向量。
         *
         * Parameters:
         * out - {Float32Array|Array.<Number>} 单位矩阵。
         * a - {Float32Array|Array.<Number>} 矩阵。
         * v- {Float32Array|Array.<Number>} 缩放参数。
         *
         * Returns:
         * {Float32Array|Array.<Number>} 结果矩阵。
         */

    }, {
        key: "mulVector",
        value: function mulVector(out, a, v) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];

            out[0] = v[0] * aa + v[1] * ac + atx;
            out[1] = v[0] * ab + v[1] * ad + aty;

            return out;
        }
    }]);

    return Matrix;
}();

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PaintLayer = exports.Painter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Transformable2 = __webpack_require__(81);

var _SmicImage = __webpack_require__(107);

var _Util = __webpack_require__(1);

var _Util2 = __webpack_require__(29);

var _Config = __webpack_require__(78);

var _SUtil = __webpack_require__(12);

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Painter
 * Painter 绘图模块。
 */
var Painter = exports.Painter = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Painter
     * 构造函数。
     *
     * Parameters:
     * root - {HTMLElement} 绘图区域（DIV）。
     * storage - {<SuperMap.LevelRenderer.Storage>} Storage 实例。
     *
     */
    function Painter(root, storage) {
        _classCallCheck(this, Painter);

        /**
         * APIProperty: root
         * {HTMLElement} 绘图容器。
         *
         */
        this.root = root;

        /**
         * APIProperty: storage
         * {Array} 图形仓库。
         *
         */
        this.storage = storage;

        /**
         * Property: _domRoot
         * {HTMLElement} 容器根 dom 对象。
         *
         */
        this._domRoot = null;

        /**
         * Property: _layers
         * {Object} 绘制层对象。
         *
         */
        this._layers = {};

        /**
         * Property: _zlevelList
         * {Array} 层列表。
         *
         */
        this._zlevelList = [];

        /**
         * Property: _layerConfig
         * {Object} 绘制层配置对象。
         *
         */
        this._layerConfig = {};

        /**
         * Property: _bgDom
         * {Object} 背景层 Canvas （Dom）。
         *
         */
        this._bgDom = null;

        /**
         * Property: shapeToImage
         * {Function} 形状转图像函数。
         *
         */
        this.shapeToImage = null;
        // retina 屏幕优化
        Painter.devicePixelRatio = Math.max(window.devicePixelRatio || 1, 1);

        this.CLASS_NAME = "SuperMap.LevelRenderer.Painter";
        this.root.innerHTML = '';
        this._width = this._getWidth(); // 宽，缓存记录
        this._height = this._getHeight(); // 高，缓存记录

        var domRoot = document.createElement('div');
        this._domRoot = domRoot;

        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
        domRoot.style.position = 'relative';
        domRoot.style.overflow = 'hidden';
        domRoot.style.width = this._width + 'px';
        domRoot.style.height = this._height + 'px';
        this.root.appendChild(domRoot);

        this.shapeToImage = this._createShapeToImageProcessor();

        // 创建各层canvas
        // 背景
        //this._bgDom = Painter.createDom('bg', 'div', this);
        this._bgDom = Painter.createDom(_Util.Util.createUniqueID("SuperMap.Theme_background_"), 'div', this);
        domRoot.appendChild(this._bgDom);
        this._bgDom.onselectstart = returnFalse;
        this._bgDom.style['-webkit-user-select'] = 'none';
        this._bgDom.style['user-select'] = 'none';
        this._bgDom.style['-webkit-touch-callout'] = 'none';

        // 高亮
        //var hoverLayer = new PaintLayer('_hoverLayer_', this);
        var hoverLayer = new PaintLayer(_Util.Util.createUniqueID("_highLightLayer_"), this);
        this._layers['hover'] = hoverLayer;
        domRoot.appendChild(hoverLayer.dom);
        hoverLayer.initContext();

        hoverLayer.dom.onselectstart = returnFalse;
        hoverLayer.dom.style['-webkit-user-select'] = 'none';
        hoverLayer.dom.style['user-select'] = 'none';
        hoverLayer.dom.style['-webkit-touch-callout'] = 'none';

        var me = this;
        this.updatePainter = function (shapeList, callback) {
            me.refreshShapes(shapeList, callback);
        };

        // 返回false的方法，用于避免页面被选中
        function returnFalse() {
            return false;
        }

        /* eslint-disable */
        // 什么都不干的空方法
        function doNothing() {} //NOSONAR

        /* eslint-enable */
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Painter, [{
        key: 'destroy',
        value: function destroy() {
            this.dispose();
            this._zlevelList = null;
            this._layerConfig = null;
            this._bgDom = null;
            this.shapeToImage = null;
        }

        /**
         * APIMethod: render
         * 渲染。
         *
         * 首次绘图，创建各种 dom 和 context。
         *
         * Parameters:
         * callback - {Function} 绘画结束后的回调函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'render',
        value: function render(callback) {
            // TODO
            this.refresh(callback, true);

            return this;
        }

        /**
         * APIMethod: refresh
         * 刷新。
         *
         * Parameters:
         * callback - {Function} 刷新结束后的回调函数。
         * paintAll - {Boolean} 强制绘制所有 shape。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'refresh',
        value: function refresh(callback, paintAll) {
            var list = this.storage.getShapeList(true);
            this._paintList(list, paintAll);

            if (typeof callback == 'function') {
                callback();
            }

            return this;
        }

        /**
         * Method: _paintList
         * 按列表绘制图形。
         */

    }, {
        key: '_paintList',
        value: function _paintList(list, paintAll) {
            if (typeof paintAll == 'undefined') {
                paintAll = false;
            }

            this._updateLayerStatus(list);

            var currentLayer;
            var currentZLevel;
            var ctx;

            for (var id in this._layers) {
                if (id !== 'hover') {
                    this._layers[id].unusedCount++;
                    this._layers[id].updateTransform();
                }
            }

            var invTransform = [];

            for (var i = 0, l = list.length; i < l; i++) {
                var shape = list[i];

                if (currentZLevel !== shape.zlevel) {
                    if (currentLayer && currentLayer.needTransform) {
                        ctx.restore();
                    }

                    currentLayer = this.getLayer(shape.zlevel);
                    ctx = currentLayer.ctx;
                    currentZLevel = shape.zlevel;

                    // Reset the count
                    currentLayer.unusedCount = 0;

                    if (currentLayer.dirty || paintAll) {
                        currentLayer.clear();
                    }

                    if (currentLayer.needTransform) {
                        ctx.save();
                        currentLayer.setTransform(ctx);
                    }
                }

                // Start group clipping
                if (ctx && shape.__startClip) {
                    var clipShape = shape.__startClip;
                    ctx.save();
                    // Set transform
                    if (clipShape.needTransform) {
                        var m = clipShape.transform;
                        _SUtil.SUtil.Util_matrix.invert(invTransform, m);
                        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }

                    ctx.beginPath();
                    clipShape.buildPath(ctx, clipShape.style);
                    ctx.clip();

                    // Transform back
                    if (clipShape.needTransform) {
                        var _m = invTransform;
                        ctx.transform(_m[0], _m[1], _m[2], _m[3], _m[4], _m[5]);
                    }
                }

                if ((currentLayer && currentLayer.dirty || paintAll) && !shape.invisible) {
                    if (!shape.onbrush || shape.onbrush && !shape.onbrush(ctx, false)) {
                        if (_Config.Config.catchBrushException) {
                            try {
                                shape.brush(ctx, false, this.updatePainter);
                            } catch (error) {
                                _SUtil.SUtil.Util_log(error, 'brush error of ' + shape.type, shape);
                            }
                        } else {
                            shape.brush(ctx, false, this.updatePainter);
                        }
                    }
                }

                // Stop group clipping
                if (ctx && shape.__stopClip) {
                    ctx.restore();
                }

                shape.__dirty = false;
            }

            if (ctx && currentLayer && currentLayer.needTransform) {
                ctx.restore();
            }

            for (var _id in this._layers) {
                if (_id !== 'hover') {
                    var layer = this._layers[_id];
                    layer.dirty = false;
                    // 删除过期的层
                    // PENDING
                    // if (layer.unusedCount >= 500) {
                    //     this.delLayer(id);
                    // }
                    if (layer.unusedCount == 1) {
                        layer.clear();
                    }
                }
            }
        }

        /**
         * APIMethod: getLayer
         * 获取 zlevel 所在层，如果不存在则会创建一个新的层。
         *
         * Parameters:
         * zlevel - {Number} zlevel。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'getLayer',
        value: function getLayer(zlevel) {
            // Change draw layer
            var currentLayer = this._layers[zlevel];
            if (!currentLayer) {
                var len = this._zlevelList.length;
                var prevLayer = null;
                var i = -1;
                if (len > 0 && zlevel > this._zlevelList[0]) {
                    for (i = 0; i < len - 1; i++) {
                        if (this._zlevelList[i] < zlevel && this._zlevelList[i + 1] > zlevel) {
                            break;
                        }
                    }
                    prevLayer = this._layers[this._zlevelList[i]];
                }
                this._zlevelList.splice(i + 1, 0, zlevel);

                // Create a new layer
                //currentLayer = new PaintLayer(zlevel, this);
                currentLayer = new PaintLayer(_Util.Util.createUniqueID("_levelLayer_" + zlevel), this);
                var prevDom = prevLayer ? prevLayer.dom : this._bgDom;
                if (prevDom.nextSibling) {
                    prevDom.parentNode.insertBefore(currentLayer.dom, prevDom.nextSibling);
                } else {
                    prevDom.parentNode.appendChild(currentLayer.dom);
                }
                currentLayer.initContext();

                this._layers[zlevel] = currentLayer;

                if (this._layerConfig[zlevel]) {
                    new _Util2.Util().merge(currentLayer, this._layerConfig[zlevel], true);
                }

                currentLayer.updateTransform();
            }

            return currentLayer;
        }

        /**
         * Method: getLayers
         * 获取所有已创建的层。
         *
         * Returns:
         * {Array{<Painter.Layer>}} 已创建的层
         */

    }, {
        key: 'getLayers',
        value: function getLayers() {
            return this._layers;
        }

        /**
         * Method: _updateLayerStatus
         * 更新绘制层状态。
         */

    }, {
        key: '_updateLayerStatus',
        value: function _updateLayerStatus(list) {
            var layers = this._layers;

            var elCounts = {};
            for (var z in layers) {
                if (z !== 'hover') {
                    elCounts[z] = layers[z].elCount;
                    layers[z].elCount = 0;
                }
            }

            for (var i = 0; i < list.length; i++) {
                var shape = list[i];
                var zlevel = shape.zlevel;
                var layer = layers[zlevel];
                if (layer) {
                    layer.elCount++;
                    // 已经被标记为需要刷新
                    if (layer.dirty) {
                        continue;
                    }
                    layer.dirty = shape.__dirty;
                }
            }

            // 层中的元素数量有发生变化
            for (var _z in layers) {
                if (_z !== 'hover') {
                    if (elCounts[_z] !== layers[_z].elCount) {
                        layers[_z].dirty = true;
                    }
                }
            }
        }

        /**
         * APIMethod: refreshShapes
         * 更新的图形元素列表。
         *
         * Parameters:
         * shapeList - {Number} 需要更新的图形元素列表。
         * callback - {Number} 视图更新后回调函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'refreshShapes',
        value: function refreshShapes(shapeList, callback) {
            for (var i = 0, l = shapeList.length; i < l; i++) {
                var shape = shapeList[i];
                this.storage.mod(shape.id);
            }

            this.refresh(callback);
            return this;
        }

        /**
         * APIMethod: clear
         * 清除 hover 层外所有内容。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'clear',
        value: function clear() {
            for (var k in this._layers) {
                if (k == 'hover') {
                    continue;
                }
                this._layers[k].clear();
            }

            return this;
        }

        /**
         * APIMethod: modLayer
         * 修改指定 zlevel 的绘制参数。
         *
         * Parameters:
         * zlevel - {String} zlevel。
         * config - {Object} 配置对象。可用属性如下：
         *
         * Symbolizer properties:
         * clearColor - {String} 每次清空画布的颜色。默认值：0。
         * motionBlur - {Boolean} 是否开启动态模糊。默认值：false。
         * lastFrameAlpha - {Number}  在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显。默认值：0.7。
         * position - {Array{Number}}  层的平移。
         * rotation - {Array{Number}}  层的旋转。
         * scale - {Array{Number}}  层的缩放。
         * zoomable - {Boolean} 层是否支持鼠标缩放操作。默认值：false。
         * panable - {Boolean} 层是否支持鼠标平移操作。默认值：false。
         *
         */

    }, {
        key: 'modLayer',
        value: function modLayer(zlevel, config) {
            if (config) {
                if (!this._layerConfig[zlevel]) {
                    this._layerConfig[zlevel] = config;
                } else {
                    new _Util2.Util().merge(this._layerConfig[zlevel], config, true);
                }

                var layer = this._layers[zlevel];

                if (layer) {
                    new _Util2.Util().merge(layer, this._layerConfig[zlevel], true);
                }
            }
        }

        /**
         * APIMethod: delLayer
         * 删除指定层。
         *
         * Parameters:
         * zlevel - {Ntring} 层所在的 zlevel。
         *
         */

    }, {
        key: 'delLayer',
        value: function delLayer(zlevel) {
            var layer = this._layers[zlevel];
            if (!layer) {
                return;
            }
            // Save config
            this.modLayer(zlevel, {
                position: layer.position,
                rotation: layer.rotation,
                scale: layer.scale
            });
            layer.dom.parentNode.removeChild(layer.dom);
            delete this._layers[zlevel];

            this._zlevelList.splice(new _Util2.Util().indexOf(this._zlevelList, zlevel), 1);
        }

        /**
         * APIMethod: refreshHover
         * 刷新 hover 层。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'refreshHover',
        value: function refreshHover() {
            this.clearHover();
            var list = this.storage.getHoverShapes(true);
            for (var i = 0, l = list.length; i < l; i++) {
                this._brushHover(list[i]);
            }
            this.storage.delHover();

            return this;
        }

        /**
         * APIMethod: clearHover
         * 清除 hover 层所有内容。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'clearHover',
        value: function clearHover() {
            var hover = this._layers.hover;
            hover && hover.clear();

            return this;
        }

        /**
         * APIMethod: resize
         * 区域大小变化后重绘。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Painter>} this。
         */

    }, {
        key: 'resize',
        value: function resize() {
            var domRoot = this._domRoot;
            domRoot.style.display = 'none';

            var width = this._getWidth();
            var height = this._getHeight();

            domRoot.style.display = '';

            // 优化没有实际改变的resize
            if (this._width != width || height != this._height) {
                this._width = width;
                this._height = height;

                domRoot.style.width = width + 'px';
                domRoot.style.height = height + 'px';

                for (var id in this._layers) {

                    this._layers[id].resize(width, height);
                }

                this.refresh(null, true);
            }

            return this;
        }

        /**
         * APIMethod: clearLayer
         * 清除指定的一个层。
         *
         * Parameters:
         * zLevel - {Number} 层。
         */

    }, {
        key: 'clearLayer',
        value: function clearLayer(zLevel) {
            var layer = this._layers[zLevel];
            if (layer) {
                layer.clear();
            }
        }

        /**
         * APIMethod: dispose
         * 释放。
         *
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this.root.innerHTML = '';

            this.root = null;
            this.storage = null;
            this._domRoot = null;
            this._layers = null;
        }

        /**
         * Method: getDomHover
         * 获取 Hover 层的 Dom。
         *
         */

    }, {
        key: 'getDomHover',
        value: function getDomHover() {
            return this._layers.hover.dom;
        }

        /**
         * APIMethod: toDataURL
         * 图像导出。
         *
         * Parameters:
         * type - {String} 图片类型。
         * backgroundColor - {String} 背景色。默认值：'#fff'。
         * args - {Object}。
         *
         * Returns:
         * {String} 图片的Base64 url。
         */

    }, {
        key: 'toDataURL',
        value: function toDataURL(type, backgroundColor, args) {
            //var imageDom = Painter.createDom('image', 'canvas', this);
            var imageDom = Painter.createDom(_Util.Util.createUniqueID("SuperMap.Theme.image_"), 'canvas', this);
            this._bgDom.appendChild(imageDom);
            var ctx = imageDom.getContext('2d');
            Painter.devicePixelRatio != 1 && ctx.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);

            ctx.fillStyle = backgroundColor || '#fff';
            ctx.rect(0, 0, this._width * Painter.devicePixelRatio, this._height * Painter.devicePixelRatio);
            ctx.fill();

            var self = this;
            // 升序遍历，shape上的zlevel指定绘画图层的z轴层叠

            this.storage.iterShape(function (shape) {
                if (!shape.invisible) {
                    if (!shape.onbrush // 没有onbrush
                    // 有onbrush并且调用执行返回false或undefined则继续粉刷
                    || shape.onbrush && !shape.onbrush(ctx, false)) {
                        if (_Config.Config.catchBrushException) {
                            try {
                                shape.brush(ctx, false, self.updatePainter);
                            } catch (error) {
                                _SUtil.SUtil.Util_log(error, 'brush error of ' + shape.type, shape);
                            }
                        } else {
                            shape.brush(ctx, false, self.updatePainter);
                        }
                    }
                }
            }, { normal: 'up', update: true });
            var image = imageDom.toDataURL(type, args);
            ctx = null;
            this._bgDom.removeChild(imageDom);
            return image;
        }

        /**
         * APIMethod: getWidth
         * 获取绘图区域宽度。
         *
         * Returns:
         * {Number} 绘图区域宽度。
         */

    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this._width;
        }

        /**
         * APIMethod: getHeight
         * 获取绘图区域高度。
         *
         * Returns:
         * {Number} 绘图区域高度。
         */

    }, {
        key: 'getHeight',
        value: function getHeight() {
            return this._height;
        }

        /**
         * Method: _getWidth
         *
         */

    }, {
        key: '_getWidth',
        value: function _getWidth() {
            var root = this.root;
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);

            return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) // 请原谅我这比较粗暴
            - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
        }

        /**
         * Method: _getHeight
         *
         */

    }, {
        key: '_getHeight',
        value: function _getHeight() {
            var root = this.root;
            var stl = root.currentStyle || document.defaultView.getComputedStyle(root);

            return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) // 请原谅我这比较粗暴
            - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
        }

        /**
         * Method: _brushHover
         *
         */

    }, {
        key: '_brushHover',
        value: function _brushHover(shape) {
            var ctx = this._layers.hover.ctx;

            if (!shape.onbrush // 没有onbrush
            // 有onbrush并且调用执行返回false或undefined则继续粉刷
            || shape.onbrush && !shape.onbrush(ctx, true)) {
                var layer = this.getLayer(shape.zlevel);
                if (layer.needTransform) {
                    ctx.save();
                    layer.setTransform(ctx);
                }
                // Retina 优化
                if (_Config.Config.catchBrushException) {
                    try {
                        shape.brush(ctx, true, this.updatePainter);
                    } catch (error) {
                        _SUtil.SUtil.Util_log(error, 'hoverBrush error of ' + shape.type, shape);
                    }
                } else {
                    shape.brush(ctx, true, this.updatePainter);
                }
                if (layer.needTransform) {
                    ctx.restore();
                }
            }
        }

        /**
         * Method: _shapeToImage
         *
         */

    }, {
        key: '_shapeToImage',
        value: function _shapeToImage(id, shape, width, height, devicePixelRatio) {
            var canvas = document.createElement('canvas');
            var ctx = canvas.getContext('2d');
            var _devicePixelRatio = devicePixelRatio || window.devicePixelRatio || 1;

            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            canvas.setAttribute('width', width * _devicePixelRatio);
            canvas.setAttribute('height', height * _devicePixelRatio);

            ctx.clearRect(0, 0, width * _devicePixelRatio, height * _devicePixelRatio);

            var shapeTransform = {
                position: shape.position,
                rotation: shape.rotation,
                scale: shape.scale
            };
            shape.position = [0, 0, 0];
            shape.rotation = 0;
            shape.scale = [1, 1];
            if (shape) {
                shape.brush(ctx, false);
            }

            var imgShape = new _SmicImage.SmicImage({
                id: id,
                style: {
                    x: 0,
                    y: 0,
                    image: canvas
                }
            });

            if (shapeTransform.position != null) {
                imgShape.position = shape.position = shapeTransform.position;
            }

            if (shapeTransform.rotation != null) {
                imgShape.rotation = shape.rotation = shapeTransform.rotation;
            }

            if (shapeTransform.scale != null) {
                imgShape.scale = shape.scale = shapeTransform.scale;
            }

            return imgShape;
        }

        /**
         * Method: _createShapeToImageProcessor
         *
         */

    }, {
        key: '_createShapeToImageProcessor',
        value: function _createShapeToImageProcessor() {
            var me = this;

            return function (id, e, width, height) {
                return me._shapeToImage(id, e, width, height, Painter.devicePixelRatio);
            };
        }

        // SMIC-方法扩展 - start
        /**
         * APIMethod: updateHoverLayer
         * 更新设置显示高亮图层。
         *
         * Parameters:
         * shapes - {Array} 图形数组。
         */

    }, {
        key: 'updateHoverLayer',
        value: function updateHoverLayer(shapes) {
            if (!(shapes instanceof Array)) {
                return this;
            }

            //清除高亮
            this.clearHover();
            this.storage.delHover();

            for (var i = 0; i < shapes.length; i++) {
                this.storage.addHover(shapes[i]);
                this._brushHover(shapes[i]);
            }
        }

        /**
         * Method: createDom
         * 创建 Dom。
         *
         * Parameters:
         * id - {String} Dom id
         * type - {String} Dom type
         * painter - {<SuperMap.LevelRenderer.Painter>} Painter 实例。
         *
         * Returns:
         * {Object} Dom
         */

    }], [{
        key: 'createDom',
        value: function createDom(id, type, painter) {
            var newDom = document.createElement(type);
            var width = painter._width;
            var height = painter._height;

            // 没append呢，请原谅我这样写，清晰~
            newDom.style.position = 'absolute';
            newDom.style.left = 0;
            newDom.style.top = 0;
            newDom.style.width = width + 'px';
            newDom.style.height = height + 'px';
            newDom.setAttribute('width', width * Painter.devicePixelRatio);
            newDom.setAttribute('height', height * Painter.devicePixelRatio);

            // id不作为索引用，避免可能造成的重名，定义为私有属性
            //newDom.setAttribute('data-zr-dom-id', id);
            newDom.setAttribute('id', id);
            return newDom;
        }
    }]);

    return Painter;
}();

/**
 * @private
 * @class Painter.Layer
 * 绘制层类。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Transformable>
 */


var PaintLayer = exports.PaintLayer = function (_Transformable) {
    _inherits(PaintLayer, _Transformable);

    /**
     * Constructor: Painter.Layer
     * 构造函数。
     *
     * Parameters:
     * id - {String} id。
     * painter - {<SuperMap.LevelRenderer.Painter>} Painter 实例。
     *
     */
    function PaintLayer(id, painter) {
        _classCallCheck(this, PaintLayer);

        /**
         * Property: dom
         * {Object} dom。
         */
        var _this = _possibleConstructorReturn(this, (PaintLayer.__proto__ || Object.getPrototypeOf(PaintLayer)).call(this, id, painter));

        _this.dom = null;

        /**
         * Property: domBack
         * {Object} domBack。
         */
        _this.domBack = null;

        /**
         * Property: ctxBack
         * {Object} ctxBack。
         */
        _this.ctxBack = null;

        /**
         * Property: painter
         * {<SuperMap.LevelRenderer.Painter>} painter。
         */
        _this.painter = painter;

        /**
         * Property: unusedCount
         * {Number} unusedCount。
         */
        _this.unusedCount = 0;

        /**
         * Property: config
         * {Object} config。
         */
        _this.config = null;

        /**
         * Property: dirty
         * {Boolean} dirty。
         */
        _this.dirty = true;

        /**
         * Property: elCount
         * {Number} elCount。
         */
        _this.elCount = 0;

        // Configs
        /**
         * Property: clearColor
         * {String} 每次清空画布的颜色。默认值：0；
         */
        _this.clearColor = 0;

        /**
         * Property: motionBlur
         * {Boolean} 是否开启动态模糊。默认值：false；
         */
        _this.motionBlur = false;

        /**
         * Property: lastFrameAlpha
         * {Number} 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
         */
        _this.lastFrameAlpha = 0.7;

        /**
         * Property: zoomable
         * {Boolean} 层是否支持鼠标平移操作。默认值：false；
         */
        _this.zoomable = false;

        /**
         * Property: panable
         * {Boolean} 层是否支持鼠标缩放操作。默认值：false；
         */
        _this.panable = false;

        /**
         * Property: maxZoom
         * {Number} maxZoom。默认值：Infinity。
         */
        _this.maxZoom = Infinity;

        /**
         * Property: minZoom
         * {Number} minZoom。默认值：0。
         */
        _this.minZoom = 0;

        /**
         * Property: ctx
         * {Object} Cavans 上下文。
         */
        _this.ctx = null;
        _this.dom = Painter.createDom(_Util.Util.createUniqueID("SuperMap.Theme" + id), 'canvas', painter);
        _this.dom.onselectstart = returnFalse; // 避免页面选中的尴尬
        _this.dom.style['-webkit-user-select'] = 'none';
        _this.dom.style['user-select'] = 'none';
        _this.dom.style['-webkit-touch-callout'] = 'none';
        // Function
        // 返回false的方法，用于避免页面被选中
        function returnFalse() {
            return false;
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Painter.Layer";
        return _this;
    }

    /**
     * Method: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(PaintLayer, [{
        key: 'destroy',
        value: function destroy() {
            this.dom = null;
            this.domBack = null;
            this.ctxBack = null;
            this.painter = null;
            this.unusedCount = null;
            this.config = null;
            this.dirty = null;
            this.elCount = null;
            this.clearColor = null;
            this.motionBlur = null;
            this.lastFrameAlpha = null;
            this.zoomable = null;
            this.panable = null;
            this.maxZoom = null;
            this.minZoom = null;
            this.ctx = null;

            _Transformable2.Transformable.destroy.apply(this, arguments);
        }

        /**
         * Method: initContext
         * 初始化 Canvan 2D 上下文。
         */

    }, {
        key: 'initContext',
        value: function initContext() {
            this.ctx = this.dom.getContext('2d');
            if (Painter.devicePixelRatio != 1) {
                this.ctx.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
            }
        }

        /**
         * Method: createBackBuffer
         * 创建备份缓冲。
         */

    }, {
        key: 'createBackBuffer',
        value: function createBackBuffer() {
            this.domBack = Painter.createDom(_Util.Util.createUniqueID("SuperMap.Theme.back-" + this.id), 'canvas', this.painter);
            this.ctxBack = this.domBack.getContext('2d');

            if (Painter.devicePixelRatio != 1) {
                this.ctxBack.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
            }
        }

        /**
         * Method: resize
         * 改变大小。
         *
         * Parameters:
         * width - {Number} 宽。
         * height - {Number} 高。
         */

    }, {
        key: 'resize',
        value: function resize(width, height) {
            this.dom.style.width = width + 'px';
            this.dom.style.height = height + 'px';

            this.dom.setAttribute('width', width * Painter.devicePixelRatio);
            this.dom.setAttribute('height', height * Painter.devicePixelRatio);

            if (Painter.devicePixelRatio != 1) {
                this.ctx.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
            }

            if (this.domBack) {
                this.domBack.setAttribute('width', width * Painter.devicePixelRatio);
                this.domBack.setAttribute('height', height * Painter.devicePixelRatio);

                if (Painter.devicePixelRatio != 1) {
                    this.ctxBack.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
                }
            }
        }

        /**
         * Method: clear
         * 清空该层画布。
         */

    }, {
        key: 'clear',
        value: function clear() {
            var dom = this.dom;
            var ctx = this.ctx;
            var width = dom.width;
            var height = dom.height;

            var haveClearColor = this.clearColor;
            var haveMotionBLur = this.motionBlur;
            var lastFrameAlpha = this.lastFrameAlpha;

            if (haveMotionBLur) {
                if (!this.domBack) {
                    this.createBackBuffer();
                }

                this.ctxBack.globalCompositeOperation = 'copy';
                this.ctxBack.drawImage(dom, 0, 0, width / Painter.devicePixelRatio, height / Painter.devicePixelRatio);
            }

            if (haveClearColor) {
                ctx.save();
                ctx.fillStyle = this.config.clearColor;
                ctx.fillRect(0, 0, width / Painter.devicePixelRatio, height / Painter.devicePixelRatio);
                ctx.restore();
            } else {
                ctx.clearRect(0, 0, width / Painter.devicePixelRatio, height / Painter.devicePixelRatio);
            }

            if (haveMotionBLur) {
                var domBack = this.domBack;
                ctx.save();
                ctx.globalAlpha = lastFrameAlpha;
                ctx.drawImage(domBack, 0, 0, width / Painter.devicePixelRatio, height / Painter.devicePixelRatio);
                ctx.restore();
            }
        }
    }]);

    return PaintLayer;
}(_Transformable2.Transformable);

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Render = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @private
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @class SuperMap.LevelRenderer.Render
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Render 接口类，对外可用的所有接口都在这里。内部使用
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 非 get 接口统一返回 this 对象，支持链式调用。
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


var _Util = __webpack_require__(29);

var _Util2 = __webpack_require__(1);

var _Storage = __webpack_require__(280);

var _Painter = __webpack_require__(276);

var _Handler = __webpack_require__(271);

var _Animation = __webpack_require__(263);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Render = exports.Render = function () {

    /*
     * Constructor: SuperMap.LevelRenderer.Render
     * 构造函数。
     *
     * Parameters:
     * id - {String} 唯一标识。
     * dom - {HTMLElement} Dom 对象。
     */
    function Render(id, dom) {
        _classCallCheck(this, Render);

        /**
         * Property: id
         * {String}  唯一标识。
         *
         */
        this.id = id;

        /**
         * Property: storage
         * {<SuperMap.LevelRenderer.Storage>} 图形仓库对象。
         *
         */
        this.storage = new _Storage.Storage();

        /**
         * Property: painter
         * {<SuperMap.LevelRenderer.Painter>} 绘制器对象。
         *
         */
        this.painter = new _Painter.Painter(dom, this.storage);

        /**
         * Property: handler
         * {<SuperMap.LevelRenderer.Handler>} 事件处理对象。
         *
         */
        this.handler = new _Handler.Handler(dom, this.storage, this.painter);

        /**
         * Property: animatingElements
         * {Array} 动画控制数组。
         *
         */
        this.animatingElements = [];

        /**
         * Property: animation
         * {<SuperMap.LevelRenderer.animation.Animation>} 动画对象。
         *
         */
        this.animation = new _Animation.Animation({
            stage: {
                update: Render.getFrameCallback(this)
            }
        });

        /**
         * Property: _needsRefreshNextFrame
         * {Boolean} 是否需要刷新下一帧。
         *
         */
        this._needsRefreshNextFrame = false;
        this.animation.start();
        this.CLASS_NAME = "SuperMap.LevelRenderer.Render";
    }

    /**
     * Method: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Render, [{
        key: 'destroy',
        value: function destroy() {
            this.id = null;
            this.storage = null;
            this.painter = null;
            this.handler = null;
            this.animatingElements = null;
            this.animation = null;
            this._needsRefreshNextFrame = null;
        }

        /**
         * APIMethod: getId
         * 获取实例唯一标识。
         *
         * Returns:
         * {String} 实例唯一标识。
         */

    }, {
        key: 'getId',
        value: function getId() {
            return this.id;
        }

        /**
         * APIMethod: addShape
         * 添加图形形状到根节点。
         *
         * Parameters:
         * shape - {<SuperMap.LevelRenderer.Shape>} 图形对象，可用属性全集，详见各 shape。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'addShape',
        value: function addShape(shape) {
            this.storage.addRoot(shape);
            return this;
        }

        /**
         * APIMethod: addGroup
         * 添加组到根节点。
         *
         * (code)
         * //添加组到根节点例子
         * var render = new SuperMap.LevelRenderer.Render("Render"document.getElementById('lRendertest'));
         * render.clear();
         * var g = new SuperMap.LevelRenderer.Group();
         * g.addChild(new SuperMap.LevelRenderer.Shape.Circle({
         *     style: {
         *         x: 100
         *         y: 100
         *         r: 20
         *         brushType: 'fill'
         *     }
         * }));
         * render.addGroup(g);
         * render.render();
         * (end)
         *
         * Parameters:
         * group - {<SuperMap.LevelRenderer.Group>} 组对象。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'addGroup',
        value: function addGroup(group) {
            this.storage.addRoot(group);
            return this;
        }

        /**
         * APIMethod: delShape
         * 从根节点删除图形形状。
         *
         * Parameters:
         * shapeId - {String} 图形对象唯一标识。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'delShape',
        value: function delShape(shapeId) {
            this.storage.delRoot(shapeId);
            return this;
        }

        /**
         * APIMethod: delGroup
         * 从根节点删除组。
         *
         * Parameters:
         * groupId - {String} 组对象唯一标识。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'delGroup',
        value: function delGroup(groupId) {
            this.storage.delRoot(groupId);
            return this;
        }

        /**
         * Method: modShape
         * 修改图形形状。
         *
         * Parameters:
         * shapeId - {String} 图形对象唯一标识。
         * shape - {<SuperMap.LevelRenderer.Shape>} 图形对象。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'modShape',
        value: function modShape(shapeId, shape) {
            this.storage.mod(shapeId, shape);
            return this;
        }

        /**
         * Method: modGroup
         * 修改组。
         *
         * Parameters:
         * groupId - {String} 组对象唯一标识。
         * group - {<SuperMap.LevelRenderer.Group>} 组对象。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'modGroup',
        value: function modGroup(groupId, group) {
            this.storage.mod(groupId, group);
            return this;
        }

        /**
         * Method: modLayer
         * 修改指定 zlevel 的绘制配置项。
         *
         * Parameters:
         * zLevel - {String} 组对象唯一标识。
         * config - {Object} 配置对象。可用属性如下：
         *
         * Symbolizer properties:
         * clearColor - {String} 每次清空画布的颜色。默认值：0。
         * motionBlur - {Boolean} 是否开启动态模糊。默认值：false。
         * lastFrameAlpha - {Number}  在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显。默认值：0.7。
         * position - {Array{Number}}  层的平移。
         * rotation - {Array{Number}}  层的旋转。
         * scale - {Array{Number}}  层的缩放。
         * zoomable - {Boolean} 层是否支持鼠标缩放操作。默认值：false。
         * panable - {Boolean} 层是否支持鼠标平移操作。默认值：false。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'modLayer',
        value: function modLayer(zLevel, config) {
            this.painter.modLayer(zLevel, config);
            return this;
        }

        /**
         * APIMethod: addHoverShape
         * 添加额外高亮层显示，仅提供添加方法，每次刷新后高亮层图形均被清空。
         *
         * Parameters:
         * shape - {<SuperMap.LevelRenderer.Shape>} 图形对象。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'addHoverShape',
        value: function addHoverShape(shape) {
            this.storage.addHover(shape);
            return this;
        }

        /**
         * APIMethod: render
         * 渲染。
         *
         * Parameters:
         * callback - {Function} 渲染结束后回调函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'render',
        value: function render(callback) {
            this.painter.render(callback);
            this._needsRefreshNextFrame = false;
            return this;
        }

        /**
         * APIMethod: refresh
         * 视图更新。
         *
         * Parameters:
         * callback - {Function} 视图更新后回调函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'refresh',
        value: function refresh(callback) {
            this.painter.refresh(callback);
            this._needsRefreshNextFrame = false;
            return this;
        }

        /**
         * APIMethod: refreshNextFrame
         * 标记视图在浏览器下一帧需要绘制。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'refreshNextFrame',
        value: function refreshNextFrame() {
            this._needsRefreshNextFrame = true;
            return this;
        }

        /**
         * APIMethod: refreshHover
         * 绘制（视图更新）高亮层。
         *
         * Parameters:
         * callback - {Function} 视图更新后回调函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'refreshHover',
        value: function refreshHover(callback) {
            this.painter.refreshHover(callback);
            return this;
        }

        /**
         * APIMethod: refreshShapes
         * 视图更新。
         *
         * Parameters:
         * shapeList - {Array<SuperMap.LevelRenderer.Shape>} 需要更新的图形列表。
         * callback - {Function} 视图更新后回调函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'refreshShapes',
        value: function refreshShapes(shapeList, callback) {
            this.painter.refreshShapes(shapeList, callback);
            return this;
        }

        /**
         * APIMethod: resize
         * 调整视图大小。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'resize',
        value: function resize() {
            this.painter.resize();
            return this;
        }

        /**
         * APIMethod: animate
         * 动画。
         *
         * (code)
         *     zr.animate(circle.id 'style' false)
         *         .when(1000 {x: 10} )
         *         .done(function(){ // Animation done })
         *         .start()
         * (end)
         *
         * Parameters:
         * el - {Array{<SuperMap.LevelRenderer.Shape>/<SuperMap.LevelRenderer.Group>}} 动画对象。
         * path - {String} 需要添加动画的属性获取路径，可以通过 a.b.c 来获取深层的属性。若传入对象为<SuperMap.LevelRenderer.Group>path需为空字符串。
         * loop - {Function} 动画是否循环。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.animation.Animator>} Animator。
         */

    }, {
        key: 'animate',
        value: function animate(el, path, loop) {
            if (typeof el === 'string') {
                el = this.storage.get(el);
            }
            if (el) {
                var target;
                if (path) {
                    var pathSplitted = path.split('.');
                    var prop = el;
                    for (var i = 0, l = pathSplitted.length; i < l; i++) {
                        if (!prop) {
                            continue;
                        }
                        prop = prop[pathSplitted[i]];
                    }
                    if (prop) {
                        target = prop;
                    }
                } else {
                    target = el;
                }

                if (!target) {
                    _SUtil.SUtil.Util_log('Property "' + path + '" is not existed in element ' + el.id);
                    return;
                }

                var animatingElements = this.animatingElements;
                if (typeof el.__aniCount === 'undefined') {
                    // 正在进行的动画记数
                    el.__aniCount = 0;
                }
                if (el.__aniCount === 0) {
                    animatingElements.push(el);
                }
                el.__aniCount++;

                return this.animation.animate(target, { loop: loop }).done(function () {
                    el.__aniCount--;
                    if (el.__aniCount === 0) {
                        // 从animatingElements里移除
                        var idx = new _Util.Util().indexOf(animatingElements, el);
                        animatingElements.splice(idx, 1);
                    }
                });
            } else {
                _SUtil.SUtil.Util_log('Element not existed');
            }
        }

        /**
         * APIMethod: clearAnimation
         * 停止所有动画。
         *
         */

    }, {
        key: 'clearAnimation',
        value: function clearAnimation() {
            this.animation.clear();
        }

        /**
         * APIMethod: getWidth
         * 获取视图宽度。
         *
         * Returns:
         * {Number} 视图宽度。
         */

    }, {
        key: 'getWidth',
        value: function getWidth() {
            return this.painter.getWidth();
        }

        /**
         * APIMethod: getHeight
         * 获取视图高度。
         *
         * Returns:
         * {Number} 视图高度。
         */

    }, {
        key: 'getHeight',
        value: function getHeight() {
            return this.painter.getHeight();
        }

        /**
         * APIMethod: toDataURL
         * 图像导出。
         *
         * Parameters:
         * type - {string} 类型。
         * backgroundColor - {string} 背景色，默认值："#FFFFFF"。
         * args - {string} 参数。
         *
         * Returns:
         * {String} 图片的 Base64 url。
         */

    }, {
        key: 'toDataURL',
        value: function toDataURL(type, backgroundColor, args) {
            return this.painter.toDataURL(type, backgroundColor, args);
        }

        /**
         * APIMethod: shapeToImage
         * 将常规 shape 转成 image shape。
         *
         * Parameters:
         * e - {<SuperMap.LevelRenderer.Shape>} 图形。
         * width - {Number} 宽度。
         * height - {Number} 高度。
         *
         * Returns:
         * {Object} image shape。
         */

    }, {
        key: 'shapeToImage',
        value: function shapeToImage(e, width, height) {
            var id = _Util2.Util.createUniqueID("SuperMap.LevelRenderer.ToImage_");
            return this.painter.shapeToImage(id, e, width, height);
        }

        /**
         * APIMethod: on
         * 事件绑定。
         *
         * Parameters:
         * eventName - {String} 事件名称。
         * eventHandler - {Function} 响应函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'on',
        value: function on(eventName, eventHandler) {
            this.handler.on(eventName, eventHandler);
            return this;
        }

        /**
         * APIMethod: un
         * 事件解绑定，参数为空则解绑所有自定义事件。
         *
         * Parameters:
         * eventName - {String} 事件名称。
         * eventHandler - {Function} 响应函数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'un',
        value: function un(eventName, eventHandler) {
            this.handler.un(eventName, eventHandler);
            return this;
        }

        /**
         * APIMethod: trigger
         * 事件触发。
         *
         * Parameters:
         * eventName - {String} 事件名称，resize，hover，drag，etc。
         * event - {event} event dom事件对象。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'trigger',
        value: function trigger(eventName, event) {
            this.handler.trigger(eventName, event);
            return this;
        }

        /**
         * APIMethod: clear
         * 清除当前 Render 下所有类图的数据和显示，clear 后 MVC 和已绑定事件均还存在在，Render 可用。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'clear',
        value: function clear() {
            this.storage.delRoot();
            this.painter.clear();
            return this;
        }

        /**
         * APIMethod: dispose
         * 释放当前 Render 实例（删除包括 dom，数据、显示和事件绑定），dispose后 Render 不可用。
         *
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this.animation.stop();

            this.clear();
            this.storage.dispose();
            this.painter.dispose();
            this.handler.dispose();

            this.animation = null;
            this.animatingElements = null;
            this.storage = null;
            this.painter = null;
            this.handler = null;

            // 释放后告诉全局删除对自己的索引，没想到啥好方法
            // zrender.delInstance(this.id);
        }

        // SMIC-方法扩展 - start
        /**
         * APIMethod: updateHoverShapes
         * 更新设置显示高亮图层。
         *
         * Parameters:
         * shapes - {Array<SuperMap.LevelRenderer.Shape>} 图形数组。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'updateHoverShapes',
        value: function updateHoverShapes(shapes) {
            this.painter.updateHoverLayer(shapes);
            return this;
        }

        /**
         * APIMethod: getAllShapes
         * 获取所有图形。
         *
         * Returns:
         * {Array<SuperMap.LevelRenderer.Shape>} 图形数组。
         */

    }, {
        key: 'getAllShapes',
        value: function getAllShapes() {
            return this.storage._shapeList;
        }

        /**
         * APIMethod: clearAll
         *  清除高亮和图形图层。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} this。
         */

    }, {
        key: 'clearAll',
        value: function clearAll() {
            this.clear();
            this.painter.clearHover();
            return this;
        }

        /**
         * APIMethod: getHoverOne
         * 获取单个高亮图形，当前鼠标对应。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Shape>} 高亮图形。
         */

    }, {
        key: 'getHoverOne',
        value: function getHoverOne() {
            return this.handler.getLastHoverOne();
        }
    }], [{
        key: 'getFrameCallback',
        value: function getFrameCallback(renderInstance) {
            return function () {
                var animatingElements = renderInstance.animatingElements;

                //animatingElements instanceof Array 临时解决 destory 报错
                if (animatingElements instanceof Array) {
                    for (var i = 0, l = animatingElements.length; i < l; i++) {
                        renderInstance.storage.mod(animatingElements[i].id);
                    }

                    if (animatingElements.length || renderInstance._needsRefreshNextFrame) {
                        renderInstance.refresh();
                    }
                }
            };
        }

        // SMIC-方法扩展 - end


    }]);

    return Render;
}();

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicCircle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicCircle
 * 圆形
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicCircle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 60,
 *             brushType: "both",
 *             color: "blue",
 *             strokeColor: "red",
 *             lineWidth: 3,
 *             text: "Circle"
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicCircle = exports.SmicCircle = function (_Shape) {
    _inherits(SmicCircle, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {number} 圆心x坐标,必设参数
     * y - {number} 圆心y坐标，必设参数
     * r - {number} 半径，必设参数
     * brushType - {string} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {string} 填充颜色,默认值"#000000"
     * strokeColor - {string} 描边颜色,默认值为'#000000'
     * lineCape — {string} 线帽样式，可以是 butt, round, square，默认是butt
     * lineWidth - {number} 描边宽度、默认是1
     * opacity - {number} 绘制透明度、默认是1，不透明
     * shadowBlur - {number} 阴影模糊度，大于0有效，默认是0
     * shadowColor - {string} 阴影颜色，默认是'#000000'
     * shadowOffsetX - {number} 阴影横向偏移，默认是0
     * shadowOffsetY - {number} 阴影纵向偏移，默认是0
     * text - {string} 图形中的附加文本，默认是0
     * textColor - {string} 文本颜色，默认是'#000000'
     * textFont - {string} 附加文本样式，eg:'bold 18px verdana'
     * textPosition - {string} 附加文本位置, 可以是 inside, left, right, top, bottom
     * textAlign - {string} 默认根据textPosition自动设置，附加文本水平对齐。可以是start, end, left, right, center
     * textBaseline {string} 默认根据textPosition自动设置，附加文本垂直对齐。可以是top, bottom, middle, alphabetic, hanging, ideographic
     */
    //打开接口 style


    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicCircle
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicCircle(options) {
        _classCallCheck(this, SmicCircle);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicCircle.__proto__ || Object.getPrototypeOf(SmicCircle)).call(this, options));

        _this.type = 'smiccircle';

        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicCircle";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicCircle, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicCircle.prototype.__proto__ || Object.getPrototypeOf(SmicCircle.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建图形路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var x = style.x + __OP[0]; // 圆心x
            var y = style.y + __OP[1]; // 圆心y

            ctx.moveTo(x + style.r, y);
            ctx.arc(x, y, style.r, 0, Math.PI * 2, true);

            return true;
        }

        /**
         * APIMethod: getRect
         * 返回圆形包围盒矩形
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var x = style.x + __OP[0]; // 圆心x
            var y = style.y + __OP[1]; // 圆心y
            var r = style.r; // 圆r

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(x - r - lineWidth / 2),
                y: Math.round(y - r - lineWidth / 2),
                width: r * 2 + lineWidth,
                height: r * 2 + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicCircle;
}(_Shape2.Shape);

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicSector = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicSector
 * 扇形。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicSector({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 60,
 *             r0: 30,
 *             startAngle: 0,
 *             endEngle: 180
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicSector = exports.SmicSector = function (_Shape) {
    _inherits(SmicSector, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 圆心 x 坐标，必设参数。
     * y - {Number} 圆心 y 坐标，必设参数。
     * r - {Number} 外圆半径，必设参数。
     * r0 - {Number} 内圆半径，指定后将出现内弧，同时扇边长度为`r - r0`。取值范围[0, r)，默认值：0。
     * startAngle - {Number} 起始角度，必设参数。取值范围[0, 360)。
     * endAngle - {Number} 结束角度，必设参数。取值范围(0, 360。
     * clockWise - {Boolean} 是否是顺时针。默认值：false。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style


    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicSector
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicSector(options) {
        _classCallCheck(this, SmicSector);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicSector.__proto__ || Object.getPrototypeOf(SmicSector)).call(this, options));

        _this.type = 'smicsector';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicSector";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicSector, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicSector.prototype.__proto__ || Object.getPrototypeOf(SmicSector.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建扇形路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var x = style.x + __OP[0]; // 圆心x
            var y = style.y + __OP[1]; // 圆心y
            var r0 = style.r0 || 0; // 形内半径[0,r)
            var r = style.r; // 扇形外半径(0,r]
            var startAngle = style.startAngle; // 起始角度[0,360)
            var endAngle = style.endAngle; // 结束角度(0,360]
            var clockWise = style.clockWise || false;

            startAngle = _SUtil.SUtil.Util_math.degreeToRadian(startAngle);
            endAngle = _SUtil.SUtil.Util_math.degreeToRadian(endAngle);

            if (!clockWise) {
                // 扇形默认是逆时针方向，Y轴向上
                // 这个跟arc的标准不一样，为了兼容echarts
                startAngle = -startAngle;
                endAngle = -endAngle;
            }

            var unitX = _SUtil.SUtil.Util_math.cos(startAngle);
            var unitY = _SUtil.SUtil.Util_math.sin(startAngle);
            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);

            ctx.lineTo(unitX * r + x, unitY * r + y);

            ctx.arc(x, y, r, startAngle, endAngle, !clockWise);

            ctx.lineTo(_SUtil.SUtil.Util_math.cos(endAngle) * r0 + x, _SUtil.SUtil.Util_math.sin(endAngle) * r0 + y);

            if (r0 !== 0) {
                ctx.arc(x, y, r0, endAngle, startAngle, clockWise);
            }

            ctx.closePath();

            return;
        }

        /**
         * APIMethod: getRect
         * 返回扇形包围盒矩形
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var min0 = _SUtil.SUtil.Util_vector.create();
            var min1 = _SUtil.SUtil.Util_vector.create();
            var max0 = _SUtil.SUtil.Util_vector.create();
            var max1 = _SUtil.SUtil.Util_vector.create();

            var x = style.x + __OP[0]; // 圆心x
            var y = style.y + __OP[1]; // 圆心y
            var r0 = style.r0 || 0; // 形内半径[0,r)
            var r = style.r; // 扇形外半径(0,r]
            var startAngle = _SUtil.SUtil.Util_math.degreeToRadian(style.startAngle);
            var endAngle = _SUtil.SUtil.Util_math.degreeToRadian(style.endAngle);
            var clockWise = style.clockWise;

            if (!clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }

            if (r0 > 1) {
                _SUtil.SUtil.Util_computeBoundingBox.arc(x, y, r0, startAngle, endAngle, !clockWise, min0, max0);
            } else {
                min0[0] = max0[0] = x;
                min0[1] = max0[1] = y;
            }
            _SUtil.SUtil.Util_computeBoundingBox.arc(x, y, r, startAngle, endAngle, !clockWise, min1, max1);

            _SUtil.SUtil.Util_vector.min(min0, min0, min1);
            _SUtil.SUtil.Util_vector.max(max0, max0, max1);
            style.__rect = {
                x: min0[0],
                y: min0[1],
                width: max0[0] - min0[0],
                height: max0[1] - min0[1]
            };
            return style.__rect;
        }
    }]);

    return SmicSector;
}(_Shape2.Shape);

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Storage = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(29);

var _Group = __webpack_require__(270);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Storage
 * 内容（图像）仓库 (M) 。
 */
var Storage = exports.Storage = function () {

    /**
     * Constructor: SuperMap.LevelRenderer.Storage
     * 构造函数。
     */
    function Storage() {
        _classCallCheck(this, Storage);

        /**
         * Property: _elements
         * {Object} 所有常规形状，id 索引的 map。
         *
         */
        this._elements = {};

        /**
         * Property: _hoverElements
         * {Array} 高亮层形状，不稳定，动态增删，数组位置也是 z 轴方向，靠前显示在下方。
         *
         */
        this._hoverElements = [];

        /**
         * Property: _roots
         * {Array} _roots。
         *
         */
        this._roots = [];

        /**
         * Property: _shapeList
         * {Array}  _shapeList。
         *
         */
        this._shapeList = [];

        /**
         * Property: _shapeListOffset
         * {Number}  _shapeListOffset。默认值：0。
         *
         */
        this._shapeListOffset = 0;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Storage";
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(Storage, [{
        key: 'destroy',
        value: function destroy() {
            this.dispose();
            this._shapeList = null;
            this._shapeListOffset = null;
        }

        /**
         * APIMethod: iterShape
         * 遍历迭代器。
         *
         * Parameters:
         * fun - {Function} 迭代回调函数，return true终止迭代。
         * option - {Object} 迭代参数，缺省为仅降序遍历普通层图形。可设属性如下：
         *
         * Symbolizer properties:
         * hover - {Boolean} 是否是高亮层图形。默认值：true。
         * normal - {String} 是否是普通层图形，迭代时是否指定及z轴顺序。可设值：'down' ，'up'；默认值："down"。
         * update - {Boolean} 是否在迭代前更新形状列表。默认值：false。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'iterShape',
        value: function iterShape(fun, option) {
            if (!option) {
                var defaultIterateOption = {
                    hover: false,
                    normal: 'down',
                    update: false
                };
                option = defaultIterateOption;
            }

            if (option.hover) {
                // 高亮层数据遍历
                for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                    var el = this._hoverElements[i];
                    el.updateTransform();
                    if (fun(el)) {
                        return this;
                    }
                }
            }

            if (option.update) {
                this.updateShapeList();
            }

            // 遍历: 'down' | 'up'
            switch (option.normal) {
                case 'down':
                    {
                        // 降序遍历，高层优先
                        var _l = this._shapeList.length;
                        while (_l--) {
                            if (fun(this._shapeList[_l])) {
                                return this;
                            }
                        }
                        break;
                    }
                // case 'up':
                default:
                    {
                        // 升序遍历，底层优先
                        for (var _i = 0, _l2 = this._shapeList.length; _i < _l2; _i++) {
                            if (fun(this._shapeList[_i])) {
                                return this;
                            }
                        }
                        break;
                    }
            }

            return this;
        }

        /**
         * APIMethod: getHoverShapes
         * 返回 hover 层的形状数组。
         *
         * Parameters:
         * update - {Boolean} 是否在返回前更新图形的变换。默认值：false。
         *
         * Returns:
         * {Array<SuperMap.LevelRenderer.Shape>} 图形数组。
         */

    }, {
        key: 'getHoverShapes',
        value: function getHoverShapes(update) {
            // hoverConnect
            var hoverElements = [],
                len = this._hoverElements.length;
            for (var i = 0; i < len; i++) {
                hoverElements.push(this._hoverElements[i]);
                var target = this._hoverElements[i].hoverConnect;
                if (target) {
                    var shape;
                    target = target instanceof Array ? target : [target];
                    for (var j = 0, k = target.length; j < k; j++) {
                        shape = target[j].id ? target[j] : this.get(target[j]);
                        if (shape) {
                            hoverElements.push(shape);
                        }
                    }
                }
            }
            hoverElements.sort(Storage.shapeCompareFunc);
            if (update) {
                for (var _i2 = 0, l = hoverElements.length; _i2 < l; _i2++) {
                    hoverElements[_i2].updateTransform();
                }
            }
            return hoverElements;
        }

        /**
         * APIMethod: getShapeList
         * 返回所有图形的绘制队列。
         *
         * Parameters:
         * update - {Boolean} 是否在返回前更新该数组。默认值：false。  详见：<SuperMap.LevelRenderer.Shape> updateShapeList。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Shape>} 图形。
         */

    }, {
        key: 'getShapeList',
        value: function getShapeList(update) {
            if (update) {
                this.updateShapeList();
            }
            return this._shapeList;
        }

        /**
         * APIMethod: updateShapeList
         * 更新图形的绘制队列。
         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列。
         */

    }, {
        key: 'updateShapeList',
        value: function updateShapeList() {
            this._shapeListOffset = 0;
            var rootsLen = this._roots.length;
            for (var i = 0; i < rootsLen; i++) {
                var root = this._roots[i];
                this._updateAndAddShape(root);
            }
            this._shapeList.length = this._shapeListOffset;

            var shapeListLen = this._shapeList.length;
            for (var _i3 = 0; _i3 < shapeListLen; _i3++) {
                this._shapeList[_i3].__renderidx = _i3;
            }

            this._shapeList.sort(Storage.shapeCompareFunc);
        }

        /**
         * Method: _updateAndAddShape
         * 跟新并添加图形。
         */

    }, {
        key: '_updateAndAddShape',
        value: function _updateAndAddShape(el, clipShapes) {
            if (el.ignore) {
                return;
            }

            el.updateTransform();

            if (el.type == 'group') {

                if (el.clipShape) {
                    // clipShape 的变换是基于 group 的变换
                    el.clipShape.parent = el;
                    el.clipShape.updateTransform();

                    // PENDING 效率影响
                    if (clipShapes) {
                        clipShapes = clipShapes.slice();
                        clipShapes.push(el.clipShape);
                    } else {
                        clipShapes = [el.clipShape];
                    }
                }

                for (var i = 0; i < el._children.length; i++) {
                    var child = el._children[i];

                    // Force to mark as dirty if group is dirty
                    child.__dirty = el.__dirty || child.__dirty;

                    this._updateAndAddShape(child, clipShapes);
                }

                // Mark group clean here
                el.__dirty = false;
            } else {
                el.__clipShapes = clipShapes;

                this._shapeList[this._shapeListOffset++] = el;
            }
        }

        /**
         * APIMethod: mod
         * 修改图形(Shape)或者组(Group)。
         *
         * Parameters:
         * elId - {String} 唯一标识。
         * params - {Object} 参数。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'mod',
        value: function mod(elId, params) {
            var el = this._elements[elId];
            if (el) {

                el.modSelf();

                if (params) {
                    // 如果第二个参数直接使用 shape
                    // parent, _storage, __startClip 三个属性会有循环引用
                    // 主要为了向 1.x 版本兼容，2.x 版本不建议使用第二个参数
                    if (params.parent || params._storage || params.__startClip) {
                        var target = {};
                        for (var name in params) {
                            if (name == 'parent' || name == '_storage' || name == '__startClip') {
                                continue;
                            }
                            if (params.hasOwnProperty(name)) {
                                target[name] = params[name];
                            }
                        }
                        new _Util.Util().merge(el, target, true);
                    } else {
                        new _Util.Util().merge(el, params, true);
                    }
                }
            }

            return this;
        }

        /**
         * APIMethod: drift
         * 移动指定的图形(Shape)的位置。
         *
         * Parameters:
         * shapeId - {String} 唯一标识。
         * dx - {Number}
         * dy - {Number}
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'drift',
        value: function drift(shapeId, dx, dy) {
            var shape = this._elements[shapeId];
            if (shape) {
                shape.needTransform = true;
                if (shape.draggable === 'horizontal') {
                    dy = 0;
                } else if (shape.draggable === 'vertical') {
                    dx = 0;
                }
                if (!shape.ondrift // ondrift
                // 有onbrush并且调用执行返回false或undefined则继续
                || shape.ondrift && !shape.ondrift(dx, dy)) {
                    shape.drift(dx, dy);
                }
            }

            return this;
        }

        /**
         * APIMethod: addHover
         * 添加高亮层数据。
         *
         * Parameters:
         * shape - {<SuperMap.LevelRenderer.Shape>} 图形。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'addHover',
        value: function addHover(shape) {
            shape.updateNeedTransform();
            this._hoverElements.push(shape);
            return this;
        }

        /**
         * APIMethod: delHover
         * 清空高亮层数据。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'delHover',
        value: function delHover() {
            this._hoverElements = [];
            return this;
        }

        /**
         * APIMethod: hasHoverShape
         * 是否有图形在高亮层里。
         *
         * Returns:
         * {Boolean} 是否有图形在高亮层里。
         */

    }, {
        key: 'hasHoverShape',
        value: function hasHoverShape() {
            return this._hoverElements.length > 0;
        }

        /**
         * APIMethod: addRoot
         * 添加图形(Shape)或者组(Group)到根节点。
         *
         * Parameters:
         * el - {<SuperMap.LevelRenderer.Shape>/<SuperMap.LevelRenderer.Group>} 图形。
         *
         */

    }, {
        key: 'addRoot',
        value: function addRoot(el) {
            if (el instanceof _Group.Group) {
                el.addChildrenToStorage(this);
            }

            this.addToMap(el);
            this._roots.push(el);
        }

        /**
         * APIMethod: delRoot
         * 删除指定的图形(Shape)或者组(Group)。
         *
         * Parameters:
         * elId - {Array{String}} 删除图形(Shape)或者组(Group)的 id 数组。如果为空清空整个Storage。
         *
         */

    }, {
        key: 'delRoot',
        value: function delRoot(elId) {
            if (typeof elId == 'undefined') {
                // 不指定elId清空
                for (var i = 0; i < this._roots.length; i++) {
                    var root = this._roots[i];

                    if (root instanceof _Group.Group) {
                        root.delChildrenFromStorage(this);
                    }
                }

                this._elements = {};
                this._hoverElements = [];
                this._roots = [];

                return;
            }

            if (elId instanceof Array) {
                var elIdLen = elId.length;
                for (var _i4 = 0; _i4 < elIdLen; _i4++) {
                    this.delRoot(elId[_i4]);
                }
                return;
            }

            var el;
            if (typeof elId == 'string') {
                el = this._elements[elId];
            } else {
                el = elId;
            }

            var idx = new _Util.Util().indexOf(this._roots, el);
            if (idx >= 0) {
                this.delFromMap(el.id);
                this._roots.splice(idx, 1);
                if (el instanceof _Group.Group) {
                    el.delChildrenFromStorage(this);
                }
            }
        }

        /**
         * APIMethod: addToMap
         * 添加图形到 map。
         *
         * Parameters:
         * el - {<SuperMap.LevelRenderer.Shape>} 图形。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'addToMap',
        value: function addToMap(el) {
            if (el instanceof _Group.Group) {
                el._storage = this;
            }
            el.modSelf();

            this._elements[el.id] = el;

            return this;
        }

        /**
         * APIMethod: get
         * 获取指定图形。
         *
         * Parameters:
         * elId - {String} 图形 id。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Shape>} 图形。
         */

    }, {
        key: 'get',
        value: function get(elId) {
            return this._elements[elId];
        }

        /**
         * APIMethod: delFromMap
         * 从 map 中删除指定图形。
         *
         * Parameters:
         * elId - {String} 图形id。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Storage>} this。
         */

    }, {
        key: 'delFromMap',
        value: function delFromMap(elId) {
            var el = this._elements[elId];
            if (el) {
                delete this._elements[elId];

                if (el instanceof _Group.Group) {
                    el._storage = null;
                }
            }

            return this;
        }

        /**
         * APIMethod: dispose
         * 清空并且释放 Storage。
         */

    }, {
        key: 'dispose',
        value: function dispose() {
            this._elements = null;
            // this._renderList = null;
            this._roots = null;
            this._hoverElements = null;
        }
    }], [{
        key: 'shapeCompareFunc',
        value: function shapeCompareFunc(a, b) {
            if (a.zlevel == b.zlevel) {
                if (a.z == b.z) {
                    return a.__renderidx - b.__renderidx;
                }
                return a.z - b.z;
            }
            return a.zlevel - b.zlevel;
        }
    }]);

    return Storage;
}();

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nonEarthCRS = exports.NonEarthCRS = exports.nonProjection = exports.NonProjection = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_leaflet2["default"].Projection = {};

/**
 * @private
 * @class L.Projection.NonProjection
 * @classdesc 平面无投影对象
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param bounds - {L.bounds} 坐标范围
 */
var NonProjection = exports.NonProjection = _leaflet2["default"].Class.extend({

    initialize: function initialize(bounds) {
        this.bounds = bounds;
    },

    project: function project(latlng) {
        return new _leaflet2["default"].Point(latlng.lng, latlng.lat);
    },

    unproject: function unproject(point) {
        return new _leaflet2["default"].LatLng(point.y, point.x);
    }
});

var nonProjection = exports.nonProjection = function nonProjection(bounds) {
    return new NonProjection(bounds);
};

/**
 * @class L.CRS.NonEarthCRS
 * @classdesc 平面无投影坐标类
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param options - {Object} 构建平面无投影坐标对象参数<br>
 *        origin - {Object} 原点<br>
 *        bounds - {[L.bounds]{@linkdoc-leaflet/#bounds}|Array<number>} 范围<br>
 *        resolutions - {Array<number>} 分辨率
 */
var NonEarthCRS = exports.NonEarthCRS = _leaflet2["default"].Class.extend({

    /*
     * @member L.CRS.NonEarthCRS.prototype.includes -{Object}
     * @description 包含的坐标对象，默认为：L.CRS。
     */
    includes: _leaflet2["default"].CRS,

    initialize: function initialize(options) {
        if (options.origin) {
            this.transformation = new _leaflet2["default"].Transformation(1, -options.origin.x, -1, options.origin.y);
        }
        this.projection = _leaflet2["default"].Projection.NonProjection(options.bounds);
        this.bounds = options.bounds;
        this.origin = options.origin;
        this.resolutions = options.resolutions;
    },

    /**
     * @function L.CRS.NonEarthCRS.prototype.scale
     * @description 通过缩放级别计算比例尺
     * @param zoom - {number}缩放级别
     * @return {number} 得到的比例尺
     */
    scale: function scale(zoom) {
        if (!this.resolutions || this.resolutions.length === 0) {
            var width = Math.max(this.bounds.getSize().x, this.bounds.getSize().y);
            var defaultScale = 1 / (width / 256);
            return defaultScale * Math.pow(2, zoom);
        }
        return 1 / this.resolutions[zoom];
    },

    /**
     * @function L.CRS.NonEarthCRS.prototype.zoom
     * @description 通过比例尺计算范围
     * @param scale - {number}比例尺
     * @return {number} 返回空间范围值
     */
    zoom: function zoom(scale) {
        if (!this.resolutions || this.resolutions.length === 0) {
            var width = Math.max(this.bounds.getSize().x, this.bounds.getSize().y);
            var defaultScale = 1 / (width / 256);
            return scale / defaultScale;
        }
        for (var i = 0; i < this.resolutions.length; i++) {
            if (1 / this.resolutions == scale) {
                return i;
            }
        }
        return -1;
    },

    /**
     * @function L.CRS.NonEarthCRS.prototype.distance
     * @description 通过两个坐标点计算之间的距离
     * @param latlng1 - {L.latLng} 坐标点1
     * @param latlng2 - {L.latLng} 坐标点2
     * @return {number} 返回距离长度
     */
    distance: function distance(latlng1, latlng2) {
        var dx = latlng2.lng - latlng1.lng,
            dy = latlng2.lat - latlng1.lat;

        return Math.sqrt(dx * dx + dy * dy);
    },

    infinite: true
});
var nonEarthCRS = exports.nonEarthCRS = function nonEarthCRS(options) {
    return new NonEarthCRS(options);
};
_leaflet2["default"].Projection.NonProjection = nonProjection;

_leaflet2["default"].CRS.NonEarthCRS = nonEarthCRS;

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VectorTileFormat = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @constant L.supermap.VectorTileFormat
 * @classdesc 矢量瓦片格式
 */
var VectorTileFormat = exports.VectorTileFormat = {
  JSON: "JSON",
  MVT: "MVT",
  PBF: "PBF"
};

_leaflet2["default"].supermap.VectorTileFormat = VectorTileFormat;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CartoCSSToLeaflet = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

var _CartoDefaultStyle = __webpack_require__(446);

var _CartoStyleMap = __webpack_require__(447);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class L.supermap.CartoCSSToLeaflet
 * @classdesc CartoCSS样式转Leaflet样式类
 * @param url - {String} 地图服务地址
 * @private
 */
var CartoCSSToLeaflet = exports.CartoCSSToLeaflet = function () {
    function CartoCSSToLeaflet(url) {
        _classCallCheck(this, CartoCSSToLeaflet);

        /**
         * @member L.supermap.CartoCSSToLeaflet.prototype.cartoCSS
         * @description CartoCSS样式
         */
        this.cartoCSS = null;

        /**
         * @member L.supermap.CartoCSSToLeaflet.prototype.mapUrl
         * @description 地图服务地址
         */
        this.mapUrl = url;
    }

    /**
     * @function L.supermap.CartoCSSToLeaflet.prototype.pretreatedCartoCSS
     * @description CartoCSS样式预处理
     * @param cartoStr - {string} Carto信息
     * @param processCharacters - {Object} 需要处理的特征对象
     */


    _createClass(CartoCSSToLeaflet, [{
        key: "pretreatedCartoCSS",
        value: function pretreatedCartoCSS(cartoStr, processCharacters) {
            if (processCharacters) {
                cartoStr = this.processCharacters(cartoStr);
            }
            this.cartoCSS = this.cartoCSS || {};
            var shaders = new _iclientCommon.CartoCSS(cartoStr).getShaders();
            if (!shaders) {
                return;
            }
            for (var i = 0; i < shaders.length; i++) {
                var element = shaders[i].elements[0];
                var attachment = shaders[i].attachment;
                this.cartoCSS[element.clean] = this.cartoCSS[element.clean] || {};
                this.cartoCSS[element.clean][attachment] = this.cartoCSS[element.clean][attachment] || [];
                this.cartoCSS[element.clean][attachment].push(shaders[i]);
            }
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.processCharacters
         * @description 替换一些关键符号
         * @param cartoCSSStr - {string} cartoCSSS信息
         */

    }, {
        key: "processCharacters",
        value: function processCharacters(cartoCSSStr) {
            var style = cartoCSSStr;
            if (!style) {
                return;
            }
            var me = this;
            style = style.replace(/[@]/gi, "___");
            style = style.replace(/\\#/gi, "___");
            for (var attr in me.layersInfo) {
                var newAttr = attr.replace(/[@#\s]/gi, "___");
                style = style.replace(attr.replace(/[#]/gi, "\\#"), newAttr);
            }
            style = style.replace(/[#]/gi, "\n#");
            //将zoom转化为scale，以免引起混淆
            style = style.replace(/\[zoom/gi, "[scale");
            return style;
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.pickShader
         * @description 拾取着色对象
         * @param layerName - {string} 图层名称
         */

    }, {
        key: "pickShader",
        value: function pickShader(layerName) {
            if (!this.cartoCSS) {
                return null;
            }
            var name = layerName.replace(/[@#\s]/gi, "___");
            return this.cartoCSS[name];
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.getDefaultStyle
         * @description 获取默认风格
         * @param type - {string} 默认风格类型
         */

    }, {
        key: "getDefaultStyle",
        value: function getDefaultStyle(type) {
            var style = {};
            //设置默认值
            var expandStyle = _CartoDefaultStyle.DefaultStyle[type];
            for (var prop in expandStyle) {
                var val = expandStyle[prop];
                style[prop] = val;
            }
            return style;
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.getStyleFromiPortalMarker
         * @description 从iPortalMarker中获取样式
         * @param icon - {string} iPortal图标
         */

    }, {
        key: "getStyleFromiPortalMarker",
        value: function getStyleFromiPortalMarker(icon) {
            if (icon.indexOf("./") == 0) {
                return null;
            }
            //兼容iportal示例的问题
            if (icon.indexOf("http://support.supermap.com.cn:8092/static/portal") == 0) {
                icon = icon.replace("http://support.supermap.com.cn:8092/static/portal", "http://support.supermap.com.cn:8092/apps/viewer/static");
            }
            return _leaflet2["default"].icon({
                iconUrl: icon,
                iconSize: _leaflet2["default"].point(48, 43),
                iconAnchor: _leaflet2["default"].point(24, 43),
                popupAnchor: _leaflet2["default"].point(0, -43)
            });
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.getStyleFromiPortalStyle
         * @description 从iPortal的风格中获取样式
         * @param iPortalStyle - {Object} iPortal的样式对象
         * @param type - {string} 样式类型
         * @param fStyle -{Object} 图标参数
         */

    }, {
        key: "getStyleFromiPortalStyle",
        value: function getStyleFromiPortalStyle(iPortalStyle, type, fStyle) {
            var featureStyle = fStyle ? JSON.parse(fStyle) : null;
            var style = {};
            if (type === 'Point' || type === 'MultiPoint') {
                var pointStyle = featureStyle || iPortalStyle.pointStyle;
                if (pointStyle.externalGraphic) {
                    if (pointStyle.externalGraphic.indexOf("./") == 0) {
                        return null;
                    }
                    //兼容iportal示例的问题
                    if (pointStyle.externalGraphic.indexOf("http://support.supermap.com.cn:8092/static/portal") == 0) {
                        pointStyle.externalGraphic = pointStyle.externalGraphic.replace("http://support.supermap.com.cn:8092/static/portal", "http://support.supermap.com.cn:8092/apps/viewer/static");
                    }
                    return _leaflet2["default"].icon({
                        iconUrl: pointStyle.externalGraphic,
                        iconSize: _leaflet2["default"].point(pointStyle.graphicWidth, pointStyle.graphicHeight),
                        iconAnchor: _leaflet2["default"].point(-pointStyle.graphicXOffset, -pointStyle.graphicYOffset),
                        popupAnchor: _leaflet2["default"].point(0, -pointStyle.graphicHeight)
                    });
                }
                style.radius = pointStyle.pointRadius;
                style.color = pointStyle.strokeColor;
                style.opacity = pointStyle.strokeOpacity;
                style.lineCap = pointStyle.strokeLineCap;
                style.weight = pointStyle.strokeWidth;
                style.fillColor = pointStyle.fillColor;
                style.fillOpacity = pointStyle.fillOpacity;
                style.dashArray = this.dashStyle(pointStyle, 1);
                return style;
            }
            if (type === 'LineString' || type === 'MultiLineString' || type === 'Box') {
                var lineStyle = featureStyle || iPortalStyle.lineStyle;
                style.color = lineStyle.strokeColor;
                style.opacity = lineStyle.strokeOpacity;
                style.fillOpacity = lineStyle.fillOpacity;
                style.lineCap = lineStyle.strokeLineCap;
                style.weight = lineStyle.strokeWidth;
                style.dashArray = this.dashStyle(lineStyle, 1);
                return style;
            }
            if (type === 'Polygon' || type === 'MultiPolygon') {
                var polygonStyle = featureStyle || iPortalStyle.polygonStyle;
                style.color = polygonStyle.strokeColor;
                style.opacity = polygonStyle.strokeOpacity;
                style.lineCap = polygonStyle.strokeLineCap;
                style.weight = polygonStyle.strokeWidth;
                style.fillColor = polygonStyle.fillColor;
                style.fillOpacity = polygonStyle.fillOpacity;
                style.dashArray = this.dashStyle(polygonStyle, 1);
                return style;
            }
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.dashStyle
         * @description 符号样式
         * @param style -{Object} 样式参数
         * @param widthFactor -{number}宽度系数
         */

    }, {
        key: "dashStyle",
        value: function dashStyle(style, widthFactor) {
            if (!style) {
                return [];
            }
            var w = style.strokeWidth * widthFactor;
            var str = style.strokeDashstyle;
            switch (str) {
                case 'solid':
                    return [];
                case 'dot':
                    return [1, 4 * w];
                case 'dash':
                    return [4 * w, 4 * w];
                case 'dashdot':
                    return [4 * w, 4 * w, 1, 4 * w];
                case 'longdash':
                    return [8 * w, 4 * w];
                case 'longdashdot':
                    return [8 * w, 4 * w, 1, 4 * w];
                default:
                    if (!str) {
                        return [];
                    }
                    if (_iclientCommon.CommonUtil.isArray(str)) {
                        return str;
                    }
                    str = _iclientCommon.StringExt.trim(str).replace(/\s+/g, ",");
                    return str.replace(/\[|\]/gi, "").split(",");
            }
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.getValidStyleFromCarto
         * @description 从Carto中获取有效的样式
         * @param zoom - {number}缩放级别
         * @param scale - {number}比例尺
         * @param shader - {Array<Object>} 渲染器对象数组
         * @param feature - {L.feature} 要素
         * @param fromServer - {string} 服务源
         */

    }, {
        key: "getValidStyleFromCarto",
        value: function getValidStyleFromCarto(zoom, scale, shader, feature, fromServer) {
            if (!shader) {
                return null;
            }
            var type = feature.type,
                attributes = feature.properties.attributes || {},
                style = this.getDefaultStyle(type);
            fromServer = fromServer === undefined ? true : fromServer;

            attributes.FEATUREID = feature.properties.id;
            attributes.SCALE = scale;

            var cartoStyleMap = _CartoStyleMap.CartoStyleMap[type];

            var fontSize, fontName;
            for (var i = 0, len = shader.length; i < len; i++) {
                var _shader = shader[i];
                var prop = cartoStyleMap[_shader.property];
                var value = _shader.getValue(attributes, zoom, true);
                if (value !== null && prop) {
                    if (prop === "fontSize") {
                        value = fromServer ? value *= 0.8 : value;
                        fontSize = value + "px";
                        style.fontSize = fontSize;
                    } else if (prop === "fontName") {
                        fontName = value;
                        style.fontName = fontName;
                    } else {
                        if (prop === "globalCompositeOperation") {
                            value = _CartoStyleMap.CompOpMap[value];
                            if (!value || value === "") {
                                continue;
                            }
                        } else if (fromServer && prop === 'iconUrl') {
                            value = this.mapUrl + '/tileFeature/symbols/' + value.replace(/(___)/gi, '@');
                            value = value.replace(/(__0__0__)/gi, '__8__8__');
                            style["iconUrl"] = value;
                            continue;
                        }
                        if (prop === 'weight' && value < 1) {
                            value = Math.ceil(value);
                        }
                        style[prop] = value;
                    }
                }
            }
            return style;
        }

        /**
         * @function L.supermap.CartoCSSToLeaflet.prototype.getValidStyleFromLayerInfo
         * @description 通过图层信息获取有效的样式
         * @param feature - {SuperMap.Feature} 要素
         * @param layerInfo - {Object} 图层信息
         */

    }, {
        key: "getValidStyleFromLayerInfo",
        value: function getValidStyleFromLayerInfo(feature, layerInfo) {
            var type = feature.type,
                style = this.getDefaultStyle(type),
                shader = layerInfo && layerInfo.layerStyle;
            if (!shader) {
                return style;
            }
            if (type === "POINT") {
                var size = Math.ceil(shader.markerSize * _iclientCommon.SuperMap.DOTS_PER_INCH * _iclientCommon.SuperMap.INCHES_PER_UNIT["mm"]) || 8;
                var symbolParameters = {
                    "transparent": true,
                    "resourceType": "SYMBOLMARKER",
                    "picWidth": size,
                    "picHeight": size,
                    "style": JSON.stringify(shader)
                };
                style.iconUrl = _iclientCommon.CommonUtil.urlAppend(this.mapUrl + "/symbol.png", _iclientCommon.CommonUtil.getParameterString(symbolParameters));
                style.iconSize = [size, size];
                return style;
            }
            if (type === "TEXT") {
                shader = feature.properties.textStyle || layerInfo.layerStyle;
                //设置文本是否使用粗体
                style.fontWeight = shader.bold ? shader.fontWeight : "normal";
                //设置文本的尺寸（对应fontHeight属性）和行高，行高iserver不支持，默认5像素
                //固定大小的时候单位是毫米
                if (shader.fontHeight) {
                    var text_h = shader.fontHeight * _iclientCommon.SuperMap.DOTS_PER_INCH * _iclientCommon.SuperMap.INCHES_PER_UNIT["mm"] * 0.85; //毫米转像素,服务端的字体貌似要稍微小一点
                    style.fontSize = text_h + "px";
                    style.textHeight = text_h;
                }

                //设置文本字体类型
                //在桌面字体钱加@时为了解决对联那种形式，但是在canvas不支持，并且添加了@会导致
                //字体大小被固定，这里需要去掉
                if (shader.fontName) {
                    style.fontFamily = shader.fontName.indexOf("@") ? shader.fontName.replace(/@/g, "") : shader.fontName;
                }

                //设置对齐方式
                if (shader.align) {
                    var alignStr = shader.align.replace(/TOP|MIDDLE|BASELINE|BOTTOM/, "");
                    style.textAlign = alignStr.toLowerCase();
                }
                style.weight = shader.outline ? shader.outlineWidth : 0;
                if (shader.backColor) {
                    style.color = "rgba(" + shader.backColor.red + "," + shader.backColor.green + "," + shader.backColor.blue + ",1)";
                }
                if (shader.foreColor) {
                    style.fillColor = "rgba(" + shader.foreColor.red + "," + shader.foreColor.green + "," + shader.foreColor.blue + ",1)";
                }
                style.rotation = shader.rotation || 0;
                return style;
            }
            //目前只实现桌面系统默认的几种symbolID，非系统默认的面用颜色填充替代，线则用实线来替代
            var fillSymbolID = shader["fillSymbolID"] > 7 ? 0 : shader["fillSymbolID"];
            var lineSymbolID = shader["lineSymbolID"] > 5 ? 0 : shader["lineSymbolID"];
            for (var attr in shader) {
                var obj = _CartoStyleMap.ServerStyleMap[attr];
                if (!obj) {
                    continue;
                }
                var leafletStyle = obj.leafletStyle;
                switch (obj.type) {
                    case "number":
                        {
                            var value = shader[attr];
                            if (obj.unit) {
                                value = value * _iclientCommon.SuperMap.DOTS_PER_INCH * _iclientCommon.SuperMap.INCHES_PER_UNIT[obj.unit] * 2.5;
                            }
                            style[leafletStyle] = value;
                            break;
                        }

                    case "color":
                        {
                            var color = shader[attr];
                            var _value = void 0,
                                alpha = 1;
                            if (leafletStyle === "fillColor") {
                                if (fillSymbolID === 0 || fillSymbolID === 1) {
                                    //当fillSymbolID为0时，用颜色填充，为1是无填充，即为透明填充，alpha通道为0
                                    alpha = 1 - fillSymbolID;
                                    _value = "rgba(" + color.red + "," + color.green + "," + color.blue + "," + alpha + ")";
                                }
                            } else if (leafletStyle === "color") {
                                if (lineSymbolID === 0 || lineSymbolID === 5) {
                                    //对于lineSymbolID为0时，线为实线，为lineSymbolID为5时，为无线模式，即线为透明，即alpha通道为0
                                    alpha = lineSymbolID === 0 ? 1 : 0;
                                } else {
                                    //以下几种linePattern分别模拟了桌面的SymbolID为1~4几种符号的linePattern
                                    var linePattern = [1, 0];
                                    switch (lineSymbolID) {
                                        case 1:
                                            linePattern = [9.7, 3.7];
                                            break;
                                        case 2:
                                            linePattern = [3.7, 3.7];
                                            break;
                                        case 3:
                                            linePattern = [9.7, 3.7, 2.3, 3.7];
                                            break;
                                        case 4:
                                            linePattern = [9.7, 3.7, 2.3, 3.7, 2.3, 3.7];
                                            break;
                                        default:
                                            break;
                                    }
                                    style.lineDasharray = linePattern;
                                }
                                _value = "rgba(" + color.red + "," + color.green + "," + color.blue + "," + alpha + ")";
                            }
                            style[leafletStyle] = _value;
                            break;
                        }
                    default:
                        break;
                }
            }

            //处理标签文本的情况
            if (layerInfo && layerInfo.textField) {
                style.textAlign = "LEFT";
            }
            return style;
        }
    }]);

    return CartoCSSToLeaflet;
}();

_leaflet2["default"].supermap.CartoCSSToLeaflet = CartoCSSToLeaflet;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.ThemeLayer
 * @classdesc 专题图层基类，调用建议使用其子类实现类。
 * @private
 * @extends L.Layer{@linkdoc-leaflet/#layer}
 * @param name - {string} 专题图层名称
 * @param options -{Object} 待设置得参数。
 */
var ThemeLayer = exports.ThemeLayer = _leaflet2["default"].Layer.extend({

    options: {
        name: null,
        opacity: 1,
        // {Array} 专题要素事件临时存储，临时保存图层未添加到 map 前用户添加的事件监听，待图层添加到 map 后把这些事件监听添加到图层上，清空此图层。
        //这是一个二维数组，组成二维数组的每个一维数组长度为 2，分别是 event, callback。
        TFEvents: null,
        attribution: "Map Data <span>© <a href='http://support.supermap.com.cn/product/iServer.aspx' target='_blank'>SuperMap iServer</a></span> with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(name, options) {
        _leaflet2["default"].Util.setOptions(this, options);
        this.options.name = name;
        this.features = [];
        this.TFEvents = options && options.TFEvents ? options.TFEvents : [];
        this.levelRenderer = new _iclientCommon.LevelRenderer();
        this.movingOffset = [0, 0];
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.getEvents
     * @description 获取图层事件
     * @return {Object} 返回图层支持的事件
     */
    getEvents: function getEvents() {
        var me = this;
        var events = {
            zoomend: me._reset,
            moveend: me._reset,
            resize: me._resize
        };
        if (this._map._zoomAnimated) {
            events.zoomanim = me._zoomAnim;
        }
        return events;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.onRemove
     * @description 删除某个地图
     * @param map - {L.map} 要删除的地图
     */
    onRemove: function onRemove(map) {
        var me = this;
        _leaflet2["default"].DomUtil.remove(me.container);
        map.off("mousemove", me.mouseMoveHandler);
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.onAdd
     * @description 添加专题图
     * @param map - {L.map} 要添加的地图
     */
    onAdd: function onAdd(map) {
        var me = this;

        me.map = me._map = map;
        me._initContainer();
        if (!me.levelRenderer) {
            map.removeLayer(me);
            return;
        }
        //初始化渲染器
        var size = map.getSize();
        me.container.style.width = size.x + "px";
        me.container.style.height = size.y + "px";
        me._updateOpacity();

        me.renderer = me.levelRenderer.init(me.container);
        me.renderer.clear();
        if (me.features && me.features.length > 0) {
            me._reset();
        }

        //处理用户预先（在图层添加到 map 前）监听的事件
        me.addTFEvents();
        me.mouseMoveHandler = function (e) {
            var xy = e.layerPoint;
            me.currentMousePosition = _leaflet2["default"].point(xy.x + me.movingOffset[0], xy.y + me.movingOffset[1]);
        };
        map.on("mousemove", me.mouseMoveHandler);

        me.update();
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.addFeatures
     * @description 向专题图图层中添加数据, 支持的feature类型为:iServer返回的feature json对象 或L.supermap.themeFeature类型
     * @param features - {SuperMap.Feature.Vector} 要添加的要素
     */
    addFeatures: function addFeatures(features) {// eslint-disable-line no-unused-vars
        //子类实现此方法
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.redrawThematicFeatures
     * @description 抽象方法，可实例化子类必须实现此方法。
     * @param bounds - {L.bounds} 重绘专题要素范围。
     */
    redrawThematicFeatures: function redrawThematicFeatures(bounds) {// eslint-disable-line no-unused-vars
        //子类必须实现此方法
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.destroyFeatures
     * @description 销毁某个要素
     * @param features - {SuperMap.Feature.Vector} 将被销毁的要素
     */
    destroyFeatures: function destroyFeatures(features) {
        if (features === undefined) {
            features = this.features;
        }
        if (!features) {
            return;
        }
        this.removeFeatures(features);
        for (var i = features.length - 1; i >= 0; i--) {
            features[i].destroy();
        }
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.removeFeatures
     * @description 从专题图中删除 feature。这个函数删除所有传递进来的矢量要素。
     * @param features - {L.feature} 将被删除得要素
     */
    removeFeatures: function removeFeatures(features) {
        var me = this;
        if (!features || features.length === 0) {
            return;
        }
        if (features === me.features) {
            return me.removeAllFeatures();
        }
        if (!_leaflet2["default"].Util.isArray(features)) {
            features = [features];
        }

        var featuresFailRemoved = [];

        for (var i = features.length - 1; i >= 0; i--) {
            var feature = features[i];

            //如果我们传入的feature在features数组中没有的话，则不进行删除，
            //并将其放入未删除的数组中。
            var findex = _leaflet2["default"].Util.indexOf(me.features, feature);

            if (findex === -1) {
                featuresFailRemoved.push(feature);
                continue;
            }
            me.features.splice(findex, 1);
        }

        var drawFeatures = [];
        for (var hex = 0, len = me.features.length; hex < len; hex++) {
            feature = me.features[hex];
            drawFeatures.push(feature);
        }
        me.features = [];
        me.addFeatures(drawFeatures);
        //绘制专题要素
        if (me.renderer) {
            if (me._map) {
                me.redrawThematicFeatures(me._map.getBounds());
            } else {
                me.redrawThematicFeatures();
            }
        }

        var succeed = featuresFailRemoved.length == 0;
        me.fire("featuresremoved", { features: featuresFailRemoved, succeed: succeed });
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.removeAllFeatures
     * @description 清除当前图层所有的矢量要素。
     */
    removeAllFeatures: function removeAllFeatures() {
        var me = this;
        if (me.renderer) {
            me.renderer.clear();
        }
        me.features = [];
        me.fire("featuresremoved", { features: [], succeed: true });
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.getFeatures
     * @description 查看当前图层中的有效数据。
     * @return {Array} 返回图层中的有效数据。
     */
    getFeatures: function getFeatures() {
        var me = this;
        var len = me.features.length;
        var clonedFeatures = new Array(len);
        for (var i = 0; i < len; ++i) {
            clonedFeatures[i] = me.features[i];
        }
        return clonedFeatures;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.getFeatureBy
     * @description 在专题图的要素数组 features 里面遍历每一个 feature，当 feature[property] === value 时，返回此 feature（并且只返回第一个）。
     * @param property - {string} 要素得某个属性名
     * @param value - {string} 对应属性名得值
     */
    getFeatureBy: function getFeatureBy(property, value) {
        var me = this;
        var feature = null;
        for (var id in me.features) {
            if (me.features[id][property] !== value) {
                continue;
            }
            feature = me.features[id];
            break;
        }
        return feature;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.getFeatureById
     * @description 通过给定一个 id，返回对应的矢量要素,如果不存在则返回 null
     * @param featureId - {number}要素id
     */
    getFeatureById: function getFeatureById(featureId) {
        return this.getFeatureBy('id', featureId);
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.getFeaturesByAttribute
     * @description 通过给定一个属性的 key 值和 value 值，返回所有匹配的要素数组。
     * @param attrName - {string} key 值
     * @param attrValue - {string} value 值
     * @return {Array} 返回所有匹配的要素数组。
     */
    getFeaturesByAttribute: function getFeaturesByAttribute(attrName, attrValue) {
        var me = this,
            feature,
            foundFeatures = [];
        for (var id in me.features) {
            feature = me.features[id];
            if (feature && feature.attributes && feature.attributes[attrName] === attrValue) {
                foundFeatures.push(feature);
            }
        }
        return foundFeatures;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.update
     * @description 更新图层
     * @param bounds - {L.bounds} 图层范围
     */
    update: function update(bounds) {
        var me = this;
        var offsetLeft = parseInt(me._map.getContainer().style.left, 10);
        offsetLeft = -Math.round(offsetLeft);
        var offsetTop = parseInt(me._map.getContainer().style.top, 10);
        offsetTop = -Math.round(offsetTop);
        me.container.style.left = offsetLeft + 'px';
        me.container.style.top = offsetTop + 'px';

        //绘制专题要素
        if (me.renderer) {
            me.redrawThematicFeatures(bounds);
        }

        if (me.currentMousePosition) {
            me.currentMousePosition = _leaflet2["default"].point(me.currentMousePosition.x - me.movingOffset[0], me.currentMousePosition.y - me.movingOffset[1]);
        }
        me.movingOffset = [0, 0];
        me._zoom = me._map.getZoom();
        me._center = me._map.getCenter();
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.setOpacity
     * @description 设置图层的不透明度,取值[0-1]之间。
     * @param opacity - {number}不透明度
     */
    setOpacity: function setOpacity(opacity) {
        var me = this;
        if (opacity === me.options.opacity) {
            return;
        }
        if (opacity) {
            me.options.opacity = opacity;
        }
        me._updateOpacity();
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.redraw
     * @description 重绘该图层
     * @return {boolean} 返回是否重绘成功
     */
    redraw: function redraw() {
        var me = this;
        if (!me.renderer) {
            return false;
        }
        if (me._map) {
            me.redrawThematicFeatures(me._map.getBounds());
        } else {
            me.redrawThematicFeatures();
        }
        return true;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.on
     * @description 添加专题要素事件监听。添加专题要素事件监听。
     * @param event - {Event} 监听事件
     * @param callback - {function} 回调函数
     * @param context - {string} 信息
     */
    on: function on(event, callback, context) {
        // eslint-disable-line no-unused-vars
        if (this.renderer) {
            this.renderer.on(event, callback);
        } else {
            _leaflet2["default"].Layer.prototype.on.call(this, event, callback);
        }
        return this;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.off
     * @description 移除专题要素事件监听。
     * @param event - {Event} 监听事件
     * @param callback - {function} 回调函数
     * @param context - {string} 信息
     */
    off: function off(event, callback, context) {
        // eslint-disable-line no-unused-vars
        var me = this;
        if (me.renderer) {
            me.renderer.un(event, callback);
        } else {
            _leaflet2["default"].Layer.prototype.off.call(this, event, callback);
        }
        return this;
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.addTFEvents
     * @description 将图层添加到地图上之前用户要求添加的事件监听添加到图层。
     */
    addTFEvents: function addTFEvents() {
        var me = this;
        var tfEs = me.TFEvents;
        var len = tfEs.length;

        for (var i = 0; i < len; i++) {
            me.renderer.on(tfEs[i][0], tfEs[i][1]);
        }
    },

    /**
     * @function L.supermap.ThemeLayer.prototype.getLocalXY
     * @description 地理坐标转为像素坐标
     * @param coordinate - {array}
     */
    getLocalXY: function getLocalXY(coordinate) {
        if (!this._map) {
            return coordinate;
        }
        var coor = coordinate;
        if (_leaflet2["default"].Util.isArray(coordinate)) {
            coor = _leaflet2["default"].point(coordinate[0], coordinate[1]);
        } else if (!(coordinate instanceof _leaflet2["default"].Point)) {
            if (coordinate instanceof _iclientCommon.GeometryPoint || coordinate instanceof _iclientCommon.GeoText) {
                coor = _leaflet2["default"].point(coordinate.x, coordinate.y);
            } else {
                coor = _leaflet2["default"].point(coordinate.lon, coordinate.lat);
            }
        }
        var point = this._map.latLngToContainerPoint(this._map.options.crs.unproject(coor));
        return [point.x, point.y];
    },

    _initContainer: function _initContainer() {
        var parentContainer = this.getPane();
        var animated = this._map.options.zoomAnimation && _leaflet2["default"].Browser.any3d;
        var className = this.options.name || "themeLayer";
        className += ' leaflet-layer leaflet-zoom-' + (animated ? 'animated' : 'hide');
        this.container = _leaflet2["default"].DomUtil.create("div", className, parentContainer);

        var originProp = _leaflet2["default"].DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
        this.container.style[originProp] = '50% 50%';

        this.container.style.position = "absolute";
        this.container.style.zIndex = 200;
    },

    _zoomAnim: function _zoomAnim(evt) {
        var zoom = evt.zoom,
            center = evt.center;
        var scale = this._map.getZoomScale(zoom),
            offset = this._map._getCenterOffset(center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

        if (_leaflet2["default"].DomUtil.setTransform) {
            _leaflet2["default"].DomUtil.setTransform(this.container, offset, scale);
        } else {
            this.container.style[_leaflet2["default"].DomUtil.TRANSFORM] = _leaflet2["default"].DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
        }
    },

    _updateOpacity: function _updateOpacity() {
        var me = this;
        _iclientCommon.CommonUtil.modifyDOMElement(me.container, null, null, null, null, null, null, me.options.opacity);
        if (me._map !== null) {
            me._map.fire("changelayer", { layer: me, property: "opacity" });
        }
    },

    //缩放移动重绘
    _reset: function _reset() {
        var me = this;
        var latLngBounds = me._map.getBounds();
        me.update(latLngBounds);

        var topLeft = me._map.containerPointToLayerPoint([0, 0]);
        _leaflet2["default"].DomUtil.setPosition(me.container, topLeft);
        var size = me._map.getSize();
        if (parseFloat(me.container.width) !== parseFloat(size.x)) {
            me.container.width = size.x + 'px';
        }
        if (parseFloat(me.container.height) !== parseFloat(size.y)) {
            me.container.height = size.y + 'px';
        }
        me.redraw();
    },

    //通知渲染器的尺寸变化
    _resize: function _resize() {
        var me = this;
        var newSize = me._map.getSize();
        me.container.style.width = newSize.x + "px";
        me.container.style.height = newSize.y + "px";
        me.renderer.resize();
    }
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CanvasRenderer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.CanvasRenderer
 * @private
 * @classdesc 画布渲染器
 * @extends L.Canvas{@linkdoc-leaflet/#canvas}
 * @param tileCoord - {Object} 切片坐标系
 * @param tileSize - {number}切片大小
 * @param options - {Object} 渲染器参数
 */
var CanvasRenderer = exports.CanvasRenderer = _leaflet2["default"].Canvas.extend({

    initialize: function initialize(tileCoord, tileSize, options) {
        _leaflet2["default"].Canvas.prototype.initialize.call(this, options);
        this._tileCoord = tileCoord;
        this._size = tileSize;

        this._initContainer();
        this._container.setAttribute('width', this._size.x);
        this._container.setAttribute('height', this._size.y);
        this._layers = {};
        this._drawnLayers = {};
        this._drawing = true;

        if (options.interactive) {
            this._container.style.pointerEvents = 'auto';
        }
    },

    /**
     * @function L.supermap.CanvasRenderer.prototype.getCoord
     * @description 获取坐标
     */
    getCoord: function getCoord() {
        return this._tileCoord;
    },

    /**
     * @function L.supermap.CanvasRenderer.prototype.getContainer
     * @description 获取容器
     */
    getContainer: function getContainer() {
        return this._container;
    },

    /**
     * @function L.supermap.CanvasRenderer.prototype.getOffset
     * @description 停止渲染
     */
    getOffset: function getOffset() {
        return this._tileCoord.scaleBy(this._size).subtract(this._map.getPixelOrigin());
    },

    onAdd: _leaflet2["default"].Util.falseFn,

    /**
     * @function L.supermap.CanvasRenderer.prototype.addTo
     * @description 添加到切片地图
     * @param map - {L.map} 切片地图
     */
    addTo: function addTo(map) {
        this._map = map;
    },

    /**
     * @function L.supermap.CanvasRenderer.prototype.removeFrom
     * @description 删除切片地图
     * @param map - {L.map} 切片地图
     */
    removeFrom: function removeFrom(map) {
        // eslint-disable-line no-unused-vars
        delete this._map;
    },

    _updateDashArray: function _updateDashArray(layer) {
        var array = layer.options.dashArray;
        if (array && typeof array === "string") {
            var parts = array.split(','),
                dashArray = [],
                i;
            for (i = 0; i < parts.length; i++) {
                dashArray.push(Number(parts[i]));
            }
            layer.options._dashArray = dashArray;
        } else {
            layer.options._dashArray = array;
        }
    },

    _onClick: function _onClick(e) {
        var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset()),
            layer,
            clickedLayer;

        for (var id in this._layers) {
            layer = this._layers[id];
            if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
                clickedLayer = layer;
            }
        }
        if (clickedLayer) {
            _leaflet2["default"].DomEvent.stop(e);
            this._fireEvent([clickedLayer], e);
        }
    },

    _onMouseMove: function _onMouseMove(e) {
        if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) {
            return;
        }

        var point = this._map.mouseEventToLayerPoint(e).subtract(this.getOffset());
        this._handleMouseHover(e, point);
    },

    _updateIcon: function _updateIcon(layer) {
        if (!this._drawing) {
            return;
        }

        var options = layer.options,
            ctx = this._ctx,
            img = layer._getImage();
        if (options.iconSize && img.complete) {
            var size = _leaflet2["default"].point(options.iconSize),
                anchor = size && size.divideBy(2, true),
                p = layer._point.subtract(anchor);
            ctx.drawImage(img, p.x, p.y, size.x, size.y);
        } else {
            _leaflet2["default"].DomEvent.on(img, 'load', function () {
                var size = _leaflet2["default"].point([img.width, img.height]),
                    anchor = size && size.divideBy(2, true),
                    p = layer._point.subtract(anchor);
                ctx.drawImage(img, p.x, p.y, size.x, size.y);
            });
        }

        this._drawnLayers[layer._leaflet_id] = layer;
    }
});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SVGRenderer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.SVGRenderer
 * @classdesc 矢量图层缩放渲染器类
 * @private
 * @extends L.SVG{@linkdoc-leaflet/#svg}
 * @param tileCoord - {Object} 切片坐标系
 * @param tileSize - {number}切片大小
 * @param options - {Object} 渲染参数
 */
var SVGRenderer = exports.SVGRenderer = _leaflet2["default"].SVG.extend({

    initialize: function initialize(tileCoord, tileSize, options) {
        _leaflet2["default"].SVG.prototype.initialize.call(this, options);
        this._tileCoord = tileCoord;
        this._size = tileSize;

        this._initContainer();
        this._container.setAttribute('width', this._size.x);
        this._container.setAttribute('height', this._size.y);
        this._container.setAttribute('viewBox', [0, 0, this._size.x, this._size.y].join(' '));

        this._layers = {};
    },

    /**
     * @function L.supermap.SVGRenderer.prototype.getCoord
     * @description 获取坐标
     */
    getCoord: function getCoord() {
        return this._tileCoord;
    },

    /**
     * @function L.supermap.SVGRenderer.prototype.getContainer
     * @description 获取容器
     */
    getContainer: function getContainer() {
        return this._container;
    },

    onAdd: _leaflet2["default"].Util.falseFn,

    /**
     * @function L.supermap.SVGRenderer.prototype.addTo
     * @description 添加到切片地图
     * @param map - {L.map} 切片地图
     */
    addTo: function addTo(map) {
        this._map = map;
        if (this.options.interactive) {
            for (var i in this._layers) {
                var layer = this._layers[i];
                layer._path.style.pointerEvents = 'auto';
                this._map._targets[_leaflet2["default"].stamp(layer._path)] = layer;
            }
        }
    },

    /**
     * @function L.supermap.SVGRenderer.prototype.removeFrom
     * @description 删除切片地图
     * @param map - {L.map} 切片地图
     */
    removeFrom: function removeFrom(map) {
        var _map = map || this._map;
        if (this.options.interactive) {
            for (var i in this._layers) {
                var layer = this._layers[i];
                delete _map._targets[_leaflet2["default"].stamp(layer._path)];
            }
        }
        delete this._map;
    },

    _initContainer: function _initContainer() {
        _leaflet2["default"].SVG.prototype._initContainer.call(this);
        // var rect = L.SVG.create('rect');
    },

    _addPath: function _addPath(layer) {
        this._rootGroup.appendChild(layer._path);
        this._layers[_leaflet2["default"].stamp(layer)] = layer;
    },

    _updateIcon: function _updateIcon(layer) {
        var path = layer._path = _leaflet2["default"].SVG.create('image'),
            options = layer.options,
            iconUrl = options.iconUrl;
        if (options.iconSize) {
            var size = _leaflet2["default"].point(options.iconSize),
                anchor = size && size.divideBy(2, true),
                p = layer._point.subtract(anchor);
            path.setAttribute('x', p.x);
            path.setAttribute('y', p.y);
            path.setAttribute('width', size.x + 'px');
            path.setAttribute('height', size.y + 'px');
        } else {
            var img = new Image();
            img.src = iconUrl;
            _leaflet2["default"].DomEvent.on(img, 'load', function () {
                var size = _leaflet2["default"].point([img.width, img.height]),
                    anchor = size && size.divideBy(2, true),
                    p = layer._point.subtract(anchor);
                path.setAttribute('x', p.x);
                path.setAttribute('y', p.y);
                path.setAttribute('width', size.x + 'px');
                path.setAttribute('height', size.y + 'px');
            });
        }
        path.setAttribute('href', iconUrl);
    }
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PolyBase = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.PolyBase
 * @classdesc 多边形基类
 * @private
 */
//@type {{_makeFeatureParts: PolyBase._makeFeatureParts, makeInteractive: PolyBase.makeInteractive}}
var PolyBase = exports.PolyBase = {
    _makeFeatureParts: function _makeFeatureParts(feat, pxPerExtent) {
        pxPerExtent = pxPerExtent || { x: 1, y: 1 };
        var rings = feat.geometry;
        var coord;

        this._parts = [];
        for (var i = 0; i < rings.length; i++) {
            var ring = rings[i];
            var part = [];
            for (var j = 0; j < ring.length; j++) {
                coord = ring[j];
                part.push(_leaflet2["default"].point(coord).scaleBy(pxPerExtent));
            }
            this._parts.push(part);
        }
    },

    /**
         * @function L.supermap.PolyBase.prototype.makeInteractive
         * @description 设置交互
         */
    makeInteractive: function makeInteractive() {
        this._pxBounds = this._getPixelBounds();
    }
};

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextSymbolizer = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _Symbolizer = __webpack_require__(83);

var _CanvasRenderer = __webpack_require__(285);

var _SVGRenderer = __webpack_require__(286);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.TextSymbolizer
 * @classdesc 文本符号类
 * @private
 * @extends L.Path{@linkdoc-leaflet/#path}
 * @param feature - {L.feature} 要素
 * @param pxPerExtent - {number}文本符号大小
 */
var TextSymbolizer = exports.TextSymbolizer = _leaflet2["default"].Path.extend({

    /**
     * @member L.supermap.TextSymbolizer.prototype.includes
     * @description 包含符号
     */
    includes: _Symbolizer.Symbolizer.prototype,

    options: {
        color: 'white',
        fillColor: 'black',
        fill: true,
        fillOpacity: 1,
        opacity: 0.6,
        weight: 1,
        rotation: 0.0,
        stroke: true,
        fontFamily: "Arial Unicode MS Regular",
        fontSize: 14,
        fontWeight: 'bold',
        textAlign: 'center',
        offsetX: 1,
        offsetY: 1
    },

    initialize: function initialize(feature, pxPerExtent) {
        _Symbolizer.Symbolizer.prototype.initialize.call(this, feature);
        this._makeFeatureParts(feature, pxPerExtent);
        this.options.offsetX = pxPerExtent || 1;
        this.options.offsetY = pxPerExtent || 1;
    },

    /**
     * @function L.supermap.TextSymbolizer.prototype.render
     * @description 绘制点符号
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    render: function render(renderer, style) {
        //原本类型就是text的情况
        if (this.properties.texts) {
            this._text = this.properties.texts[0];
        }
        //类型是label的情况
        if (!this._text) {
            var attributes = this.properties.attributes;
            this._text = attributes && this.properties.textField ? attributes[this.properties.textField] || "" : "";
        }
        var options = this.options;
        this._pxBounds = _leaflet2["default"].bounds(this._point, this._point);
        _Symbolizer.Symbolizer.prototype.render.apply(this, [renderer, style]);
        this.options = _leaflet2["default"].Util.extend(options, style);
        this._updatePath();
    },

    _makeFeatureParts: function _makeFeatureParts(feat, pxPerExtent) {
        pxPerExtent = pxPerExtent || { x: 1, y: 1 };
        var coord = feat.geometry[0];
        if (_typeof(coord[0]) === 'object' && 'x' in coord[0]) {
            this._point = _leaflet2["default"].point(coord[0]).scaleBy(pxPerExtent);
            this._empty = _leaflet2["default"].Util.falseFn;
        } else {
            this._point = _leaflet2["default"].point(coord).scaleBy(pxPerExtent);
            this._empty = _leaflet2["default"].Util.falseFn;
        }
    },

    /**
     * @function L.supermap.TextSymbolizer.prototype.makeInteractive
     * @description 设置交互
     */
    makeInteractive: function makeInteractive() {
        this._updateBounds();
    },

    /**
     * @function L.supermap.TextSymbolizer.prototype.updateStyle
     * @description 更新替换符号样式
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    updateStyle: function updateStyle(renderer, style) {
        this._updateBounds();
        return _Symbolizer.Symbolizer.prototype.updateStyle.call(this, renderer, style);
    },

    _updateBounds: function _updateBounds() {
        var w = this._renderer._getTextWidth(this);
        var p = [w / 2, w / 2];
        this._pxBounds = _leaflet2["default"].bounds(this._point.subtract(p), this._point.add(p));
    },

    _updatePath: function _updatePath() {
        this._renderer._updateText(this);
    },
    _containsPoint: function _containsPoint(point) {
        // eslint-disable-line no-unused-vars
        return false;
    }
});

_CanvasRenderer.CanvasRenderer.include({
    _getTextWidth: function _getTextWidth(layer) {
        return this._ctx.measureText(layer._text).width;
    },
    _updateText: function _updateText(layer) {
        if (!this._drawing || layer._empty()) {
            return;
        }
        var container = this.getContainer();
        var size = this._map.getSize();
        container.width = size.x;
        container.height = size.y;
        container.style.width = size.x + 'px';
        container.style.height = size.y + 'px';
        var ctx = this._ctx,
            options = layer.options,
            offsetX = options.offsetX || 1,
            offsetY = options.offsetY || 1,
            p = layer._point.subtract(_leaflet2["default"].point(offsetX, offsetY));
        if (!options.fill) {
            return;
        }

        this._drawnLayers[layer._leaflet_id] = layer;

        ctx.fillRect(0, 0, size.x, size.y);
        ctx.font = [options.fontWeight ? options.fontWeight : "bold", options.fontSize ? options.fontSize : "14px", options.fontFamily ? options.fontFamily : "Arial Unicode MS Regular,Microsoft Yahei"].join(" ");
        ctx.textAlign = options.textAlign;
        ctx.lineWidth = options.weight;
        ctx.fillStyle = options.fillColor;
        ctx.fillText(layer._text, p.x, p.y);
        ctx.strokeStyle = options.color;
        ctx.strokeText(layer._text, p.x, p.y);
        ctx.rotate(options.rotation);
    }
});

_SVGRenderer.SVGRenderer.include({
    _getTextWidth: function _getTextWidth(layer) {
        return layer._path.getComputedTextLength() || 0;
    },

    _initPath: function _initPath(layer) {
        var path;

        if (TextSymbolizer && layer instanceof TextSymbolizer) {
            path = layer._path = _leaflet2["default"].SVG.create("text");
            path.textContent = layer._text;
        } else {
            path = layer._path = _leaflet2["default"].SVG.create("path");
        }

        if (layer.options.className) {
            _leaflet2["default"].DomUtil.addClass(path, layer.options.className);
        }

        if (layer.options.interactive) {
            _leaflet2["default"].DomUtil.addClass(path, 'leaflet-interactive');
        }

        this._updateStyle(layer);
        this._layers[_leaflet2["default"].stamp(layer)] = layer;
    },

    _updateText: function _updateText(layer) {
        var path = layer._path,
            options = layer.options,
            offsetX = options.offsetX || 1,
            offsetY = options.offsetY || 1,
            p = layer._point.subtract(_leaflet2["default"].point(offsetX, offsetY));
        path.setAttribute('x', p.x);
        path.setAttribute('y', p.y);
        options.rotation = options.rotation || 0;
        path.setAttribute('transform', 'rotate(' + options.rotation / Math.PI * 180 + ' ' + p.x + ' ' + p.y + ')');
        path.setAttribute('text-anchor', options.textAlign === 'center' ? 'middle' : options.textAlign);
        path.style.fontSize = options.fontSize;
        path.style.fontFamily = options.fontFamily;
        path.style.fontWeight = options.fontWeight || "bold";
        path.style.glyphOrientationVertical = options.rotation;
        if (options.stroke) {
            path.setAttribute('stroke', options.color);
            path.setAttribute('stroke-linecap', 'round');
            path.setAttribute('stroke-linejoin', 'round');
            path.setAttribute('stroke-opacity', options.opacity);
            path.setAttribute('stroke-width', options.weight > 1 ? options.weight / 10 : options.weight);
        } else {
            path.setAttribute('stroke', 'none');
        }
        if (options.fill) {
            path.setAttribute('fill', options.fillColor || options.color);
            path.setAttribute('fill-opacity', options.fillOpacity);
        } else {
            path.setAttribute('fill', 'none');
        }
    }

});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(30);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(296)))

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(85),
    isObject = __webpack_require__(294);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z

/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
exports.forward = function (ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
exports.inverse = function (mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

exports.toPoint = function (mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return deg * (Math.PI / 180.0);
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return 180.0 * (rad / Math.PI);
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    } else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    } else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    } else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = eccSquared / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));

  var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;

  var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = eccSquared / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  } else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if (84 >= lat && lat >= 72) {
    LetterDesignator = 'X';
  } else if (72 > lat && lat >= 64) {
    LetterDesignator = 'W';
  } else if (64 > lat && lat >= 56) {
    LetterDesignator = 'V';
  } else if (56 > lat && lat >= 48) {
    LetterDesignator = 'U';
  } else if (48 > lat && lat >= 40) {
    LetterDesignator = 'T';
  } else if (40 > lat && lat >= 32) {
    LetterDesignator = 'S';
  } else if (32 > lat && lat >= 24) {
    LetterDesignator = 'R';
  } else if (24 > lat && lat >= 16) {
    LetterDesignator = 'Q';
  } else if (16 > lat && lat >= 8) {
    LetterDesignator = 'P';
  } else if (8 > lat && lat >= 0) {
    LetterDesignator = 'N';
  } else if (0 > lat && lat >= -8) {
    LetterDesignator = 'M';
  } else if (-8 > lat && lat >= -16) {
    LetterDesignator = 'L';
  } else if (-16 > lat && lat >= -24) {
    LetterDesignator = 'K';
  } else if (-24 > lat && lat >= -32) {
    LetterDesignator = 'J';
  } else if (-32 > lat && lat >= -40) {
    LetterDesignator = 'H';
  } else if (-40 > lat && lat >= -48) {
    LetterDesignator = 'G';
  } else if (-48 > lat && lat >= -56) {
    LetterDesignator = 'F';
  } else if (-56 > lat && lat >= -64) {
    LetterDesignator = 'E';
  } else if (-64 > lat && lat >= -72) {
    LetterDesignator = 'D';
  } else if (-72 > lat && lat >= -80) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
    colInt++;
  }

  if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  } else {
    rollover = false;
  }

  if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
    rowInt++;
  }

  if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw "MGRSPoint coverting from nothing";
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!/[A-Z]/.test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw "MGRSPoint bad conversion from: " + mgrsString;
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw "Bad character: " + e;
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw "MGRSPoint given invalid Northing " + n;
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) {
        // making sure that this loop ends
        throw "Bad character: " + n;
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;
    case 'D':
      northing = 2000000.0;
      break;
    case 'E':
      northing = 2800000.0;
      break;
    case 'F':
      northing = 3700000.0;
      break;
    case 'G':
      northing = 4600000.0;
      break;
    case 'H':
      northing = 5500000.0;
      break;
    case 'J':
      northing = 6400000.0;
      break;
    case 'K':
      northing = 7300000.0;
      break;
    case 'L':
      northing = 8200000.0;
      break;
    case 'M':
      northing = 9100000.0;
      break;
    case 'N':
      northing = 0.0;
      break;
    case 'P':
      northing = 800000.0;
      break;
    case 'Q':
      northing = 1700000.0;
      break;
    case 'R':
      northing = 2600000.0;
      break;
    case 'S':
      northing = 3500000.0;
      break;
    case 'T':
      northing = 4400000.0;
      break;
    case 'U':
      northing = 5300000.0;
      break;
    case 'V':
      northing = 6200000.0;
      break;
    case 'W':
      northing = 7000000.0;
      break;
    case 'X':
      northing = 7900000.0;
      break;
    default:
      northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  } else {
    throw "Invalid zone letter: " + zoneLetter;
  }
}

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 298 */
/***/ (function(module, exports) {

module.exports = function(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
};

/***/ }),
/* 299 */
/***/ (function(module, exports) {

module.exports = function (array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
};

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

var globals = __webpack_require__(516);
var parseProj = __webpack_require__(302);
var wkt = __webpack_require__(305);

function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = parseProj(arguments[1]);
      }
      else {
        defs[name] = wkt(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
globals(defs);
module.exports = defs;


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

var proj4 = __webpack_require__(512);
proj4.defaultDatum = 'WGS84'; //default datum
proj4.Proj = __webpack_require__(114);
proj4.WGS84 = new proj4.Proj('WGS84');
proj4.Point = __webpack_require__(502);
proj4.toPoint = __webpack_require__(299);
proj4.defs = __webpack_require__(300);
proj4.transform = __webpack_require__(304);
proj4.mgrs = __webpack_require__(295);
proj4.version = __webpack_require__(545).version;
__webpack_require__(517)(proj4);
module.exports = proj4;

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var PrimeMeridian = __webpack_require__(510);
var units = __webpack_require__(511);

module.exports = function(defData) {
  var self = {};
  var paramObj = {};
  defData.split("+").map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).forEach(function(a) {
    var split = a.split("=");
    split.push(true);
    paramObj[split[0].toLowerCase()] = split[1];
  });
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self.long0 = v * D2R;
    },
    lon_1: function(v) {
      self.long1 = v * D2R;
    },
    lon_2: function(v) {
      self.long2 = v * D2R;
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    lonc: function(v) {
      self.longc = v * D2R;
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      if (units[v]) {
        self.to_meter = units[v].to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function(v) {
      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
};


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var e0fn = __webpack_require__(56);
var e1fn = __webpack_require__(57);
var e2fn = __webpack_require__(58);
var e3fn = __webpack_require__(59);
var mlfn = __webpack_require__(60);
var adjust_lon = __webpack_require__(7);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var sign = __webpack_require__(61);
var asinz = __webpack_require__(44);

exports.init = function() {
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
};

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (this.sphere) {
    var b = cos_phi * Math.sin(delta_lon);
    if ((Math.abs(Math.abs(b) - 1)) < 0.0000000001) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));
      con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));
      if (lat < 0) {
        con = -con;
      }
      y = this.a * this.k0 * (con - this.lat0);
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var tq = Math.tan(lat);
    var t = Math.pow(tq, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    var n = this.a / Math.sqrt(con);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);

    x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;
    y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;

  }
  p.x = x;
  p.y = y;
  return p;
};

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
exports.inverse = function(p) {
  var con, phi;
  var delta_phi;
  var i;
  var max_iter = 6;
  var lat, lon;

  if (this.sphere) {
    var f = Math.exp(p.x / (this.a * this.k0));
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + p.y / (this.a * this.k0);
    var h = Math.cos(temp);
    con = Math.sqrt((1 - h * h) / (1 + g * g));
    lat = asinz(con);
    if (temp < 0) {
      lat = -lat;
    }
    if ((g === 0) && (h === 0)) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    var x = p.x - this.x0;
    var y = p.y - this.y0;

    con = (this.ml0 + y / this.k0) / this.a;
    phi = con;
    for (i = 0; true; i++) {
      delta_phi = ((con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0) - phi;
      phi += delta_phi;
      if (Math.abs(delta_phi) <= EPSLN) {
        break;
      }
      if (i >= max_iter) {
        return (95);
      }
    } // for()
    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.tan(phi);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var n = this.a / Math.sqrt(con);
      var r = n * (1 - this.es) / con;
      var d = x / (n * this.k0);
      var ds = Math.pow(d, 2);
      lat = phi - (n * tan_phi * ds / r) * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));
      lon = adjust_lon(this.long0 + (d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi));
    }
    else {
      lat = HALF_PI * sign(y);
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var datum_transform = __webpack_require__(514);
var adjust_axis = __webpack_require__(503);
var proj = __webpack_require__(114);
var toPoint = __webpack_require__(299);
module.exports = function transform(source, dest, point) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  }
  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84");
  }

  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {
    wgs84 = new proj('WGS84');
    transform(source, wgs84, point);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (source.axis !== "enu") {
    adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === "longlat") {
    point.x *= D2R; // convert degrees to radians
    point.y *= D2R;
  }
  else {
    if (source.to_meter) {
      point.x *= source.to_meter;
      point.y *= source.to_meter;
    }
    source.inverse(point); // Convert Cartesian to longlat
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point.x -= dest.from_greenwich;
  }

  if (dest.projName === "longlat") {
    // convert radians to decimal degrees
    point.x *= R2D;
    point.y *= R2D;
  }
  else { // else project
    dest.forward(point);
    if (dest.to_meter) {
      point.x /= dest.to_meter;
      point.y /= dest.to_meter;
    }
  }

  // DGR, 2010/11/12
  if (dest.axis !== "enu") {
    adjust_axis(dest, true, point);
  }

  return point;
};

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var extend = __webpack_require__(118);

function mapit(obj, key, v) {
  obj[key] = v.map(function(aa) {
    var o = {};
    sExpr(aa, o);
    return o;
  }).reduce(function(a, b) {
    return extend(a, b);
  }, {});
}

function sExpr(v, obj) {
  var key;
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  else {
    key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
      }
      else {
        obj[key] = v[0];
      }
    }
    else if (!v.length) {
      obj[key] = true;
    }
    else if (key === 'TOWGS84') {
      obj[key] = v;
    }
    else {
      obj[key] = {};
      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          obj[key].auth = v[2];
        }
      }
      else if (key === 'SPHEROID') {
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          obj[key].auth = v[3];
        }
      }
      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
      }
      else if (v.every(function(aa) {
        return Array.isArray(aa);
      })) {
        mapit(obj, key, v);
      }
      else {
        sExpr(v, obj[key]);
      }
    }
  }
}

function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  }
  else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  }
  else {
    if (typeof wkt.PROJECTION === "object") {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    }
    else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = parseFloat(wkt.UNIT.convert, 10)*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);
      }
    }
  }

  if (wkt.GEOGCS) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (wkt.GEOGCS.DATUM) {
      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();
    }
    else {
      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === "wgs_1984") {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = "rnb72";
    }
    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {
      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === "international") {
        wkt.ellps = 'intl';
      }

      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = "osgb36";
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return parseFloat(input, 10) * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['false_easting', 'False_Easting'],
    ['false_northing', 'False_Northing'],
    ['central_meridian', 'Central_Meridian'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === "Lambert_Azimuthal_Equal_Area")) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  }
}
module.exports = function(wkt, self) {
  var lisp = JSON.parse(("," + wkt).replace(/\s*\,\s*([A-Z_0-9]+?)(\[)/g, ',["$1",').slice(1).replace(/\s*\,\s*([A-Z_0-9]+?)\]/g, ',"$1"]').replace(/,\["VERTCS".+/,''));
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  lisp.unshift('output');
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj.output);
  return extend(self, obj.output);
};


/***/ }),
/* 306 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 307 */
/***/ (function(module, exports) {

module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF4AAAAdCAYAAAAjHtusAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozYWZlOGIwMi01MWE3LTRiZjYtYWVkYS05MGQ2ZTQ4YjZiMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODg0NkFBQUE3RjEzMTFFNzhFRjJFQkY4RjcxQjc1NjIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODg0NkFBQTk3RjEzMTFFNzhFRjJFQkY4RjcxQjc1NjIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4MWI3NzdhNC1lZmEyLTQ1MzUtOGQzNi03MmRjNDkyODMzN2UiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpjYTYzODVjMi1jNDQ1LTExN2EtYTc0ZC1lM2I5MzJlMGE4Y2QiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5q1HM0AAAF/ElEQVR42tSabYhUVRjHZ7W01C1uaCRW4F3oi9SXCUnwQ9gsGUFvOEtQH1bLu5VS9sbYh5KicjYt29qiGQwVg2xWWKgocob91AvC+CWsoJqB3qHMSdTMpZyeU/+Df07n3pk7997Z6cBv99z7nHvOvf/z/pxJNZvNVI/jCKXmv6EquAmVkxPSlvtp2GItr0/96fFQForChJAWDiVYTkMYMu4XBFcYjLOwWS3sNwmn8NGzZ0h4Flv/zwIdchAnh/slCGmmKUNIBzYPaXOUr0vPuEjD71JAPh7l61embzinhV3V8nnCGmGT8LwlzSL8/yUh4Tfjo9T/CgnCIYNKycA2Qq21AcHU/VHE80Idoo3Qs0W6p0UtUnkZvEMDeVcCyqxEafF7hL8Qf0oYsIj+lfC9cH1CwhchWAGCtZO+AooQOkdC1Km1VtCb63StW73uFSzgKFUkNwBbmZGGmqowhvg8ZNpH9oXChcIcYRdeNomgxLkaH+S1SGubAxyIpFv+Zp+0DYjrAS00j/dem2VGEl6FJ4Qa4quEu8j2hTCJ+GJhe4JjfQMf6JCYPPbysMPxBlp0BUKOogEF9Rg9/heNvNKYfM0KsZUZaYxX4STGrzJa+zbhPeFH2DcK10KItcI+pI0rVElwXl1ULaKnIJhDw0oRQpTQc1zcbwRU8ATy4DR6yMlTzwkqMziEWHvubJ4Nk4ZtHdnqwvwY17xq3Z4FjrG+z2Kdrdf2ZSGD+xlLPh6t1R0jP9fI22ZzKI92yvQl7EbmBxI4S7Y+vIAOL87QZqsc5uNnssxZIcfYjXT9snCR7jjobidp+FkxA2v+Cq1QervMDmp4P7Xs3YZtE9kOC3P/By6JGaETl8ElwueYTNTDq4UDsKnd7YfCNbT239LF1udS72xYJt1UWxNfN4IIP4bWuTpEja01JtMFZFsm/AHbtHBlDE6yasA4moYTrUbvdBTXHqUrAH4uSadbyzF+vbBM2IsNkS3MNa5305JxqfA02T4TnkX8XOH1mPw8ruVejpxbI9hZD2Cz1U7LdrrUvjP/WfZinNZhr6V27hP+FPZh9aLvLxVO4DllX0G2OcKnlO/DCblxaz6uXBtmi+8mBaP3/SP8IuEIiTRoPPQm2TaEmEyXo0JU+F0YiPFD0hhOsiE/vqeEVwyTgF8L51OilcIZ2I4Ll5NttvAJPfukUeB2sk0ZPSbKIUUJpCII7+DasWy08uhNNazT0wGHI7mAtB7KqMKm38HhDdAUibTVKGicbB8YAqrJ9DRsp43JdB4qUof1HQrPE6XTQWu3Ce/inVzjXhXpMiTwUYugNVQ+p80jrUsV5EH0POKeuXO9QjhFq5GryNYvfEMCDhsftYVsB9ETtG0V9ZjfhCURhbcJFpfwVZ9jvhxsLHwTYtp2svlWQw3vXL8UnqHVSIG8l8ex+tHhBXgjddgqHEZ8ufAA2aaEnYgrF/KrPXrEmMUqZ9THLW06xhoBaVueQpkug+ewOUphE3Qv2Q5gGamXYa+QbVq4O+DQ5FHyZqrjxNt7UHh9uuRa0F7HjCF8o9PCTOGnscM7g2u1Hl9C9oeEnxC/1ajZg8JLiM9Hj9GHJseMShwL2DO0G5yEWn3Zh1QUods5CPkIoqlwAZxhXMsb6HrcEPBxchhdJ6wj29vCW4hfLOzo8J3rltYX50nXQAATSf/K4DEaGlTLvplsk/QCpoD60EQ7gLYZc8H9wq+I3yncEOEcNhuz6HWf3XEiwU/4Y8YEqVp2P10rt+8REvBGw026i4aDcbL9jF8r8Blmf4fCOzhViiscskygXRdehf3CO4hfigmTBXyQrl8TFtD1IzQX3CbcQrY3hPcRv4z8OmHPXwchVNln2MmE7BX6VwIFi/he6uxvb6JM3m0fdqvx/ATidxg2JeC7VDErAw5NzGfvwRJVheEIQ8Mg/pdwIM+UOmi9Q8ivCsrIy0tF+wVbEcLrd3Pb2XisEb4Tdlhsi4WP4RBbaLGrHfC3PrvMIezy9rTpGm5lz9LOMG15xvFxD/j5gjzjjDbMOzk+9zzt3v5bgAEAibzFeFHVgYkAAAAASUVORK5CYII="

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.changeTileVersion = exports.ChangeTileVersion = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

__webpack_require__(544);

var _MapService = __webpack_require__(136);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.control.changeTileVersion
 * @classdesc 版本切换控件,支持IE10及以上
 * @extends L.Control{@linkdoc-leaflet/#control}
 * @example
 * L.supermap.control.changeTileVersion({
 *      layer: baseLayer,
 *      position: "topleft",
 *      orientation: "horizontal"
 *  }).addTo(map);
 * @param options -{Object} logo控件配置项</br>
 *        layer - {[L.Layer]{@linkdoc-leaflet/#layer}} 绑定的底图图层</br>
 *        position - {string} 控件位置 继承自leaflet control</br>
 *        title - {string} 鼠标滑过时提示</br>
 *        tooltip - {string} tooltip提示显示位置 top | right | bottom | left</br>
 *        collapsed - {boolean} 是否折叠。<br>
 *        nextText - {string} 下一个版本的按钮布局</br>
 *        lastText - {string} 上一个版本的按钮布局</br>
 *        ico - {string} 控件显示的logo</br>
 *        orientation - {string} 方向horizontal|vertical</br>
 *        switch - {boolean} 是否显示上/下一个版本切换控件
 */
var ChangeTileVersion = exports.ChangeTileVersion = _leaflet2["default"].Control.extend({

    options: {
        //绑定的底图图层
        layer: null,
        //控件位置 继承自leaflet control
        position: 'topleft',
        //鼠标滑过时提示
        title: '切换缓存版本',
        //tooltip提示显示位置 top | right | bottom | left
        tooltip: "top",
        //是否折叠
        collapsed: true,
        //下一个版本的按钮布局
        nextText: "+",
        //上一个版本的按钮布局
        lastText: "-",
        //控件显示的logo
        ico: 'V',
        //方向horizontal|vertical
        orientation: 'horizontal',
        //是否显示上/下一个版本切换控件
        "switch": true
    },

    /**
     * @private
     * @function L.supermap.control.changeTileVersion.prototype.onAdd
     * @description 添加控件
     */
    onAdd: function onAdd() {
        if (this.options.orientation !== 'vertical') {
            this.options.orientation = 'horizontal';
        }
        var layout = this._initLayout();
        if (this.options.layer) {
            this.setLayer(this.options.layer);
        }
        return layout;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.setContent
     * @description 设置版本相关信息
     * @param version - {Object} 版本信息
     */
    setContent: function setContent(version) {
        var content = _leaflet2["default"].Util.extend({}, version);
        this.setVersionName(content.desc).setToolTip(content.desc);
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.setVersionName
     * @description  设置版本号
     * @param content - {string} 版本信息
     * @return {this} this
     */
    setVersionName: function setVersionName(content) {
        var value = content;
        if (!content) {
            value = this.getValue();
        }
        this._sliderValue.innerHTML = value;
        return this;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.setToolTip
     * @description 设置提示信息
     * @param tooltip - {HTMLElement|String} 要需要设置的提示信息
     * @return {this} this
     */
    setToolTip: function setToolTip(tooltip) {
        this.tooltip.innerHTML = tooltip;
        return this;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.updateLength
     * @description 更新进度条长度
     * @param length - {number}进度长度参数
     */
    updateLength: function updateLength(length) {
        if (length > 0) {
            this.length = length;
            this.slider.setAttribute("max", this.length - 1);
        }
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.setLayer
     * @description 绑定图层
     * @param layer - {L.supermap.tiledMapLayer} 绑定的图层
     */
    setLayer: function setLayer(layer) {
        if (layer) {
            this.options.layer = layer;
        }
        var me = this;
        var tileLayer = me.options.layer;
        tileLayer.on("tilesetsinfoloaded", function (result) {
            var tileVersions = result && result.tileVersions;
            me.update(tileVersions);
        });
        tileLayer.on("tileversionschanged", function (result) {
            var tileVersions = result && result.tileVersion;
            me.setContent(tileVersions);
        });
        me.getTileSetsInfo();
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.update
     * @description 更新缓存切片集及进度条长度
     * @param tileVersions - {number}待更新的切片版本号
     */
    update: function update(tileVersions) {
        this.tileVersions = tileVersions;
        this.updateLength(this.tileVersions.length);
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.getTileSetsInfo
     * @description 请求获取切片集信息
     */
    getTileSetsInfo: function getTileSetsInfo() {
        var me = this;
        if (me.options.layer) {
            new _MapService.MapService(me.options.layer._url).getTilesets(function getTilesInfoSucceed(info) {
                me.options.layer.setTileSetsInfo(info.result);
            });
        }
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.removeLayer
     * @description 移除绑定的地图图层
     */
    removeLayer: function removeLayer() {
        this.options.layer = null;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.nextTilesVersion
     * @description 下一个版本,第一次不进行加减，是无版本的状态
     * @return {this} this
     */
    nextTilesVersion: function nextTilesVersion() {
        if (this.firstLoad) {
            this.options.layer.nextTilesVersion();
            this.firstLoad = !!0;
            return this;
        }
        this.slider.value = this.slider.value + 1;
        this.options.layer.nextTilesVersion();
        return this;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.lastTilesVersion
     * @description 上一个版本
     */
    lastTilesVersion: function lastTilesVersion() {
        this.slider.value = this.slider.value - 1;
        this.options.layer.lastTilesVersion();
        return this;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.tilesVersion
     * @description 根据指定版本号请求版本
     * @param version - {string} 版本号参数
     */
    tilesVersion: function tilesVersion(version) {
        var layer = this.options.layer,
            tileVersions = this.tileVersions;
        var len = tileVersions.length;
        for (var i = 0; i < len; i++) {
            if (tileVersions[i].name == version) {
                layer.updateCurrentTileSetsIndex(i);
                layer.changeTilesVersion();
                break;
            }
        }
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.getValue
     * @description 获取进度条的值。注：(进度条的值并不是版本号)
     */
    getValue: function getValue() {
        return this.slider.value;
    },

    /**
     * @function L.supermap.control.changeTileVersion.prototype.getVersion
     * @description 获取当前进度条值对应的版本号
     */
    getVersion: function getVersion() {
        var version = this.tileVersions[this.getValue()];
        return version && version.name;
    },

    _initLayout: function _initLayout() {
        var className = 'leaflet-control-ctv';
        this._container = _leaflet2["default"].DomUtil.create('div', className + ' ' + className + '-' + this.options.orientation);
        //正常情况下显示btn
        this._sliderBtn = _leaflet2["default"].DomUtil.create('a', className + '-toggle', this._container);
        this._sliderBtn.setAttribute("title", this.options.title);
        this._sliderBtn.innerHTML = this.options.ico;

        //滑块拖动时值显示区域
        this._sliderValue = _leaflet2["default"].DomUtil.create('p', className + '-value', this._container);
        this._sliderValue.innerHTML = this.options.ico;

        var sliderClassName = "leaflet-ctv-slider";
        this._sliderContent = _leaflet2["default"].DomUtil.create('div', sliderClassName + "-main" + "  tooltip", this._container);

        //tooltip提示框
        this.tooltip = _leaflet2["default"].DomUtil.create("span", "tooltip-text" + "  " + "tooltip-" + this.options.tooltip, this._sliderContent);
        this.tooltip.innerHTML = this.options.ico;

        //加控件
        if (this.options["switch"]) {
            this._next = _leaflet2["default"].DomUtil.create('a', sliderClassName + "-incdec" + " " + sliderClassName + '-next', this._sliderContent);
            this._next.innerHTML = this.options.nextText;
            _leaflet2["default"].DomEvent.on(this._next, 'click', this.nextTilesVersion, this);
            _leaflet2["default"].DomUtil.addClass(this._container, className + '-incdec');
        }

        //滑块
        this._sliderContainer = _leaflet2["default"].DomUtil.create('div', sliderClassName + '-container', this._sliderContent);
        this.slider = _leaflet2["default"].DomUtil.create('input', sliderClassName, this._sliderContainer);

        this.slider.setAttribute("title", this.options.title);
        this.slider.setAttribute("id", "slider");
        this.slider.setAttribute("type", "range");
        this.slider.setAttribute("min", 0);
        this.slider.setAttribute("max", 0);
        this.slider.setAttribute("step", 1);
        this.slider.setAttribute("value", 0);

        //判断浏览器是否支持Range滑动条
        if (this.slider.type == "text") {
            console.error("抱歉，您的浏览器不支持HTML5 range滑动条，请使用高版本浏览器");
        }
        this.firstLoad = true;
        if ('oninput' in this.slider || 'onchange' in this.slider) {
            _leaflet2["default"].DomEvent.on(this.slider, "change", this._tilesVersion, this);
        } else {
            this.slider.onpropertychange = this._tilesVersion;
        }

        //减控件
        if (this.options["switch"]) {
            this._last = _leaflet2["default"].DomUtil.create('a', sliderClassName + "-incdec" + " " + sliderClassName + '-last', this._sliderContent);
            this._last.innerHTML = this.options.lastText;
            _leaflet2["default"].DomEvent.on(this._last, 'click', this.lastTilesVersion, this);
        }

        if (window.matchMedia("screen and (-webkit-min-device-pixel-ratio:0)").matches && this.options.orientation == 'vertical') {
            this.slider.style.width = 170 + 'px';
            this._sliderContainer.style.height = 170 + 'px';
        } else if (this.options.orientation == 'vertical') {
            this._sliderContainer.style.height = 170 + 'px';
        } else {
            this._sliderContainer.style.width = 150 + 'px';
        }

        _leaflet2["default"].DomEvent.disableClickPropagation(this._container);

        if (this.options.collapsed) {
            if (!_leaflet2["default"].Browser.android) {
                _leaflet2["default"].DomEvent.on(this._container, 'mouseenter', this._expand, this).on(this._container, 'mouseleave', this._collapse, this);
            }

            if (_leaflet2["default"].Browser.touch) {
                _leaflet2["default"].DomEvent.on(this._sliderBtn, 'click', _leaflet2["default"].DomEvent.stop).on(this._sliderBtn, 'click', this._expand, this);
            } else {
                _leaflet2["default"].DomEvent.on(this._sliderBtn, 'focus', this._expand, this);
            }
        } else {
            this._expand();
        }
        return this._container;
    },

    _expand: function _expand() {
        _leaflet2["default"].DomUtil.addClass(this._container, 'leaflet-control-ctv-expanded');
    },

    _collapse: function _collapse() {
        _leaflet2["default"].DomUtil.removeClass(this._container, 'leaflet-control-ctv-expanded');
    },

    _tilesVersion: function _tilesVersion() {
        var version = this.getVersion();
        this.tilesVersion(version);
    }

});

_leaflet2["default"].Map.mergeOptions({
    changeTileVersionControl: false
});

_leaflet2["default"].Map.addInitHook(function () {
    if (this.options.changeTileVersionControl) {
        this.changeTileVersionControl = new ChangeTileVersion();
        this.addControl(this.changeTileVersionControl);
    }
});

var changeTileVersion = exports.changeTileVersion = function changeTileVersion(options) {
    return new ChangeTileVersion(options);
};

_leaflet2["default"].supermap.control.changeTileVersion = changeTileVersion;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.logo = exports.Logo = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iClient = __webpack_require__(307);

var _iClient2 = _interopRequireDefault(_iClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.control.logo
 * @classdesc Logo控件。
 * @description map初始化的配置项为logoControl，如果为true，则显示控件；否则不显示该控件。目前默认显示。
 * @extends L.Control{@linkdoc-leaflet/#control}
 * @example
 *  L.supermap.control.Logo({
 *      imageUrl: xxx,//非必填项
 *  }).addTo(map);
 * @param options -{Object} logo控件配置项</br>
 *        imageUrl - {string} logo图片地址</br>
 *        width - {string} logo图片宽</br>
 *        height - {string} logo图片高</br>
 *        link - {string} 跳转链接</br>
 *        alt - {string} logo图片失效时显示文本
 */
var Logo = exports.Logo = _leaflet2["default"].Control.extend({

    options: {
        position: 'bottomright',
        //logo图片地址
        imageUrl: null,
        //跳转链接
        link: null,
        //logo图片宽
        width: null,
        //logo图片高
        height: null,
        //logo图片失效时显示文本
        alt: "SuperMap iClient"
    },

    /**
     * @private
     * @function L.supermap.control.logo.prototype.onAdd
     * @override
     * @description 添加一个logo
     * @return {div} 返回创建logo的div
     */
    onAdd: function onAdd() {
        var div = _leaflet2["default"].DomUtil.create('div', 'iclient-leaflet-logo');
        div.style.marginTop = 0;
        div.style.marginBottom = 0;
        div.style.marginLeft = 0;
        div.style.marginRight = 0;

        var imgSrc = _iClient2["default"];
        if (this.options.imageUrl) {
            imgSrc = this.options.imageUrl;
        }
        var alt = this.options.alt;

        var imageWidth = "94px";
        var imageHeight = "29px";
        var styleSize = "width:" + imageWidth + ";height:" + imageHeight + ";";
        if (this.options.imageUrl) {
            imageWidth = this.options.width;
            imageHeight = this.options.height;
            styleSize = "width:" + imageWidth + ";height:" + imageHeight + ";";
            if (!imageWidth || !imageHeight) {
                styleSize = "";
            }
        }
        var link = this.options.link || "http://iclient.supermap.io";
        div.innerHTML = "<a href='" + link + "' target='_blank' style='border: none;display: block;'>" + "<img src=" + imgSrc + " alt='" + alt + "' style='border: none;" + styleSize + "margin-right:5px;margin-bottom:2px;white-space: nowrap'></a>";
        return div;
    }
});
//map默认开启logoControl
_leaflet2["default"].Map.mergeOptions({
    logoControl: true
});
//map默认开启logoControl
_leaflet2["default"].Map.addInitHook(function () {
    if (!this._logoAdded && this.options.logoControl) {
        if (this.options.logoControl === true) {
            this.logoControl = new Logo();
        } else if (this.options.logoControl instanceof _leaflet2["default"].Control) {
            this.logoControl = this.options.logoControl;
        }
        if (this.logoControl) {
            this.addControl(this.logoControl);
            this._logoAdded = true;
        }
    }
});
var logo = exports.logo = function logo(options) {
    return new Logo(options);
};

_leaflet2["default"].supermap.control.logo = logo;

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.imageMapLayer = exports.ImageMapLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.imageMapLayer
 * @classdesc SuperMap iServer 的 REST 地图服务的图层(SuperMap iServer Java 6R 及以上分块动态 REST 图层)。使用Image资源出图
 * @extends L.TileLayer{@linkdoc-leaflet/#tilelayer}
 * @example
 *      L.superMap.imageMapLayer(url).addTo(map);
 * @param url -{string} 影像图层地址
 * @param options -{Object} 影像图层可选参数。如：<br>
 *        layersID - {number}图层ID，如果有layersID，则是在使用专题图。<br>
 *        redirect - {boolean} 是否从定向，如果为 true，则将请求重定向到图片的真实地址；如果为 false，则响应体中是图片的字节流。<br>
 *        transparent - {number}设置透明度。<br>
 *        cacheEnabled - {boolean} 是否启用缓存。<br>
 *        clipRegionEnabled - {boolean} 是否启用地图裁剪。<br>
 *        prjCoordSys - {Object} 请求的地图的坐标参考系统。 如：prjCoordSys={"epsgCode":3857}。<br>
 *        overlapDisplayed - {boolean} 地图对象在同一范围内时，是否重叠显示。<br>
 *        overlapDisplayedOptions - {string} 避免地图对象压盖显示的过滤选项。<br>
 *        tileversion - {string} 切片版本名称，cacheEnabled 为 true 时有效。<br>
 *        crs - {{@link L.Proj.CRS}} 坐标系统类。<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        attribution - {string} 版权信息。
 */
var ImageMapLayer = exports.ImageMapLayer = _leaflet2["default"].TileLayer.extend({

    options: {
        //如果有layersID，则是在使用专题图
        layersID: null,
        //如果为 true，则将请求重定向到图片的真实地址；如果为 false，则响应体中是图片的字节流
        redirect: false,
        transparent: null,
        cacheEnabled: null,
        clipRegionEnabled: false,
        //请求的地图的坐标参考系统。 如：prjCoordSys= {"epsgCode":3857}。
        prjCoordSys: null,
        //地图对象在同一范围内时，是否重叠显示
        overlapDisplayed: true,
        //避免地图对象压盖显示的过滤选项
        overlapDisplayedOptions: null,
        //切片版本名称，cacheEnabled 为 true 时有效。
        tileversion: null,

        crs: null,
        serverType: _iclientCommon.ServerType.ISERVER,

        attribution: "Map Data <span>© <a href='http://support.supermap.com.cn/product/iServer.aspx' target='_blank'>SuperMap iServer</a></span> with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(url, options) {
        this.url = this._url = url;
        _leaflet2["default"].TileLayer.prototype.initialize.apply(this, arguments);
        _leaflet2["default"].setOptions(this, options);
        _leaflet2["default"].stamp(this);
    },

    /**
     * @private
     * @function L.supermap.imageMapLayer.prototype.onAdd
     * @description 添加影像地图。
     * @param map - {L.map} 待添加的影像地图参数
     */
    onAdd: function onAdd(map) {
        this._crs = this.options.crs || map.options.crs;
        this._initLayerUrl();
        _leaflet2["default"].TileLayer.prototype.onAdd.call(this, map);
    },

    /**
     * @function L.supermap.imageMapLayer.prototype.getTileUrl
     * @description 根据行列号获取切片地址
     * @param coords - {Object} 行列号
     * @return {String} 切片地址
     */
    getTileUrl: function getTileUrl(coords) {
        //使用ViewBounds出图
        var tileBounds = this._tileCoordsToBounds(coords),
            nw = this._crs.project(tileBounds.getNorthWest()),
            se = this._crs.project(tileBounds.getSouthEast());
        var tileUrl = this._layerUrl + "&viewBounds=" + "{\"leftBottom\" : {\"x\":" + nw.x + ",\"y\":" + se.y + "},\"rightTop\" : {\"x\":" + se.x + ",\"y\":" + nw.y + "}}";
        return encodeURI(tileUrl);
    },

    _initLayerUrl: function _initLayerUrl() {
        var me = this;
        var layerUrl = me.url + "/image.png?";
        layerUrl += me._initAllRequestParams().join('&');
        layerUrl = this._appendCredential(layerUrl);
        this._layerUrl = layerUrl;
    },

    _initAllRequestParams: function _initAllRequestParams() {
        var me = this,
            options = me.options || {},
            params = [];

        var tileSize = this.options.tileSize;
        if (!(tileSize instanceof _leaflet2["default"].Point)) {
            tileSize = _leaflet2["default"].point(tileSize, tileSize);
        }
        params.push("width=" + tileSize.x);
        params.push("height=" + tileSize.y);

        var redirect = options.redirect === true ? options.redirect : false;
        params.push("redirect=" + redirect);

        var transparent = options.transparent === true ? options.transparent : false;
        params.push("transparent=" + transparent);

        var cacheEnabled = options.cacheEnabled === false ? options.cacheEnabled : true;
        params.push("cacheEnabled=" + cacheEnabled);

        if (options.prjCoordSys) {
            params.push("prjCoordSys=" + JSON.stringify(options.prjCoordSys));
        }

        if (options.layersID) {
            params.push("layersID=" + options.layersID);
        }

        if (options.clipRegionEnabled && options.clipRegion instanceof _leaflet2["default"].Path) {
            options.clipRegion = _leaflet2["default"].Util.toSuperMapGeometry(options.clipRegion.toGeoJSON());
            options.clipRegion = _iclientCommon.CommonUtil.toJSON(_iclientCommon.ServerGeometry.fromGeometry(options.clipRegion));
            params.push("clipRegionEnabled=" + options.clipRegionEnabled);
            params.push("clipRegion=" + JSON.stringify(options.clipRegion));
        }

        if (options.overlapDisplayed === false) {
            params.push("overlapDisplayed=false");
            if (options.overlapDisplayedOptions) {
                params.push("overlapDisplayedOptions=" + me.overlapDisplayedOptions.toString());
            }
        } else {
            params.push("overlapDisplayed=true");
        }

        if (options.cacheEnabled === true && options.tileversion) {
            params.push("tileversion=" + options.tileversion);
        }

        return params;
    },

    //追加token或key
    _appendCredential: function _appendCredential(url) {
        var newUrl = url,
            credential,
            value;
        switch (this.options.serverType) {
            case _iclientCommon.ServerType.IPORTAL:
                value = _iclientCommon.SecurityManager.getToken(url);
                credential = value ? new _iclientCommon.Credential(value, "token") : null;
                if (!credential) {
                    value = _iclientCommon.SecurityManager.getKey(url);
                    credential = value ? new _iclientCommon.Credential(value, "key") : null;
                }
                break;
            case _iclientCommon.ServerType.ONLINE:
                value = _iclientCommon.SecurityManager.getKey(url);
                credential = value ? new _iclientCommon.Credential(value, "key") : null;
                break;
            default:
                //iserver or others
                value = _iclientCommon.SecurityManager.getToken(url);
                credential = value ? new _iclientCommon.Credential(value, "token") : null;
                break;
        }
        if (credential) {
            newUrl += "&" + credential.getUrlParameters();
        }
        return newUrl;
    }
});

var imageMapLayer = exports.imageMapLayer = function imageMapLayer(url, options) {
    return new ImageMapLayer(url, options);
};

_leaflet2["default"].supermap.imageMapLayer = imageMapLayer;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.webMap = exports.WebMap = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _jsonsql = __webpack_require__(458);

var _jsonsql2 = _interopRequireDefault(_jsonsql);

var _proj = __webpack_require__(301);

var _proj2 = _interopRequireDefault(_proj);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

var _CartoCSSToLeaflet = __webpack_require__(283);

var _NonEarthCRS = __webpack_require__(281);

var _Graphic = __webpack_require__(133);

var _BaiduTileLayer = __webpack_require__(124);

var _TileLayer = __webpack_require__(88);

var _CloudTileLayer = __webpack_require__(125);

var _TiledMapLayer = __webpack_require__(127);

var _UniqueThemeLayer = __webpack_require__(132);

var _RangeThemeLayer = __webpack_require__(130);

var _LabelThemeLayer = __webpack_require__(129);

var _FeatureService = __webpack_require__(135);

var _ThemeFeature = __webpack_require__(112);

var _UnicodeMarker = __webpack_require__(131);

var _TiandituTileLayer = __webpack_require__(126);

__webpack_require__(306);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.webmap
 * @classdesc 对接iPortal/Online地图类。
 * @extends L.LayerGroup{@linkdoc-leaflet/#layergroup}
 * @param id - {number}iPortal/Online地图id。
 * @param options - {Object} 可选参数。如：<br>
 *        map - {string} 地图容器id。<br>
 *        server - {string} iPortal/Online服务地址。默认为 http://www.supermapol.com <br>
 *        featureLayerPopupEnable - {boolean} 是否启动要素图层提示框。<br>
 *        featureLayerPopup - {string} 提示框提示信息。<br>
 *        credentialValue - {string} 证书值。<br>
 *        credentialKey - {string} 证书密钥。<br>
 *        attribution - {string} 版权信息。
 */
var WebMap = exports.WebMap = _leaflet2["default"].LayerGroup.extend({

    options: {
        map: 'map',
        server: 'http://www.supermapol.com',
        featureLayerPopupEnable: true,
        featureLayerPopup: null,
        credentialValue: null,
        credentialKey: 'key',
        attribution: "Map Data <span>© <a href='http://www.supermapol.com'>SuperMap Online</a></span> with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.defaultFeatureLayerPopup
     * @description 默认图层弹出框
     * @param layer -{L.Layer} 指定图层
     * @return {string} 图层弹出框内容
     */
    defaultFeatureLayerPopup: function defaultFeatureLayerPopup(layer) {
        return layer.feature.properties.attributes.title + ":" + layer.feature.properties.attributes.description;
    },

    initialize: function initialize(id, options) {
        this._layers = {};
        _leaflet2["default"].setOptions(this, options);
        this.id = id;
        this.load();
        this.cartoCSSToLeaflet = new _CartoCSSToLeaflet.CartoCSSToLeaflet();
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.load
     * @description 登陆后添加地图图层
     */
    load: function load() {
        if (this.options.server.indexOf('http://') < 0 && this.options.server.indexOf('https://') < 0) {
            this.options.server = "http://" + this.options.server;
        }
        var mapUrl = this.options.server + '/web/maps/' + this.id + '.json';
        if (this.options.credentialValue) {
            mapUrl += '?' + this.options.credentialKey + '=' + this.options.credentialValue;
        }
        var me = this;
        _iclientCommon.FetchRequest.get(mapUrl).then(function (response) {
            return response.json();
        }).then(function (jsonObj) {
            if (!jsonObj) {
                return;
            }
            var layers = jsonObj.layers;
            me.mapInfo = jsonObj;
            me.createLayersByJson(layers);
        });
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.addLayerWrapper
     * @description 添加图层容器
     * @param layer - {L.Layer} 待添加的图层
     * @param isBaseLayer -{boolean} 是否为底图层cre
     * @param options - {Object} 创建地图的可选参数
     * @return {this} this
     */
    addLayerWrapper: function addLayerWrapper(layer, isBaseLayer, options) {
        if (isBaseLayer) {
            this.createMap(options);
        }
        this.addLayer(layer);
        if (layer.labelLayer) {
            this.addLayer(layer.labelLayer);
        }
        return this;
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.createLayersByJson
     * @description 通过json创建图层
     * @param layersJson - {JSON} 图层的json信息
     */
    createLayersByJson: function createLayersByJson(layersJson) {
        if (!_leaflet2["default"].Util.isArray(layersJson)) {
            return;
        }
        if (layersJson.length === 0) {
            return;
        }
        this.layers = [];
        var layerQueue = [];
        for (var i = 0; i < layersJson.length; i++) {
            var layerJson = layersJson[i];
            layerJson["_originIndex"] = i;
            var layerJsonType = layerJson.layerType = layerJson.layerType || "BASE_LAYER";
            if (layerJsonType !== "BASE_LAYER") {
                //如果图层不是底图，则先加到图层队列里面等待底图完成后再处理
                layerQueue.unshift(layerJson);
                continue;
            } else {
                layerJson.isBaseLayer = true;
                this.createLayer(layerJson.type, layerJson);
            }
        }
        //底图加载完成后开始处理图层队列里的图层
        while (layerQueue.length > 0) {
            var layerInfo = layerQueue.pop();
            var type = layerInfo.type;
            var layerType = layerInfo.layerType = layerInfo.layerType || "BASE_LAYER";
            if (layerType !== "OVERLAY_LAYER") {
                type = layerType;
            }
            this.createLayer(type, layerInfo);
        }
        this.fire('mapLoaded', { map: this._map });
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.createCRS
     * @description 创建坐标对象
     * @param epsgCode - {mnumber} epsg编码
     * @param type - {string} 坐标类型
     * @param resolutions - {number}分辨率
     * @param origin - {SuperMap.Point} 起始点
     * @param bounds -{SuperMap.Bounds} 指定坐标范围
     */
    createCRS: function createCRS(epsgCode, type, resolutions, origin, bounds) {
        if (epsgCode < 0) {
            return new _NonEarthCRS.NonEarthCRS({
                bounds: bounds,
                origin: origin,
                resolutions: resolutions
            });
        }

        if (epsgCode === 910112 || epsgCode === 910102) {
            return _leaflet2["default"].CRS.BaiduCRS;
        }
        if (epsgCode === 910111) {
            epsgCode = 3857;
            //todo 火星mercator
        }
        if (epsgCode === 910101) {
            epsgCode = 4326;
            //todo 火星
        }
        return _leaflet2["default"].Proj.CRS("EPSG:" + epsgCode, {
            origin: origin,
            resolutions: resolutions,
            bounds: bounds
        });
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.createMap
     * @description 创建地图
     * @param options - {Object} 创建地图所需参数
     */
    createMap: function createMap(options) {
        var crs = options.crs || _leaflet2["default"].CRS.EPSG3857;
        var bounds = _leaflet2["default"].latLngBounds(crs.unproject(options.bounds.min), crs.unproject(options.bounds.max));
        this._map = _leaflet2["default"].map(this.options.map, {
            center: bounds.getCenter(),
            maxZoom: options.maxZoom || 22,
            minZoom: options.minZoom || 0,
            zoom: options.zoom || 0,
            crs: crs,
            renderer: _leaflet2["default"].canvas()
        });
        if (crs instanceof _NonEarthCRS.NonEarthCRS) {
            this._map.setZoom(options.zoom ? options.zoom + 2 : 2, { maxZoom: options.maxZoom || 22 });
        } else {
            this._map.fitBounds(bounds, { maxZoom: options.maxZoom || 22 });
        }
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.getResolutionsFromScales
     * @description 通过比例尺获取分辨率
     * @param scales - {Array<number>} 排序比例尺数组
     * @param dpi - {number}屏幕分辨率
     * @param units - {string} 地图的单位
     * @param datum - {SuperMap.Datum} 大地参照系类
     * @return {Array<number>} 返回给定比例尺所对应的分辨率
     */
    getResolutionsFromScales: function getResolutionsFromScales(scales, dpi, units, datum) {
        var resolutions = [];
        for (var i = 0; i < scales.length; i++) {
            resolutions.push(_leaflet2["default"].Util.GetResolutionFromScaleDpi(scales[i], dpi, units, datum));
        }
        return resolutions;
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.createLayer
     * @description 创建图层
     * @param type - {string} 图层类型
     * @param layerInfo - {Object} 图层信息
     */
    createLayer: function createLayer(type, layerInfo) {
        var prjCoordSys = layerInfo.prjCoordSys,
            epsgCode = prjCoordSys && prjCoordSys.epsgCode || this.mapInfo.epsgCode,
            center = this.mapInfo.center || layerInfo.center,
            level = this.mapInfo.level || layerInfo.level,
            bounds = this.mapInfo.extent || layerInfo.bounds,
            scales = layerInfo.scales,
            isBaseLayer = layerInfo.isBaseLayer,
            opacity = layerInfo.opacity;
        var mapBounds = _leaflet2["default"].bounds([bounds.leftBottom.x, bounds.leftBottom.y], [bounds.rightTop.x, bounds.rightTop.y]);
        var layerBounds = layerInfo.bounds ? _leaflet2["default"].bounds([layerInfo.bounds.leftBottom.x, layerInfo.bounds.leftBottom.y], [layerInfo.bounds.rightTop.x, layerInfo.bounds.rightTop.y]) : null;
        var origin = layerBounds ? _leaflet2["default"].point(layerBounds.min.x, layerBounds.max.y) : _leaflet2["default"].point(mapBounds.min.x, mapBounds.max.y);
        var resolutions = !scales ? null : this.getResolutionsFromScales(scales, 96, layerInfo.units);
        var crs = this.createCRS(epsgCode, prjCoordSys ? prjCoordSys.type : '', resolutions, origin, layerBounds || mapBounds);
        var mapOptions = {
            bounds: mapBounds,
            center: _leaflet2["default"].point(center.x, center.y),
            crs: crs,
            zoom: level
        };
        var layer;
        switch (type) {
            case "SUPERMAP_REST":
                layer = (0, _TiledMapLayer.tiledMapLayer)(layerInfo.url, {
                    transparent: true,
                    opacity: opacity
                });
                break;
            case "SUPERMAP_REST_VECTOR":
                //ToDO
                break;
            case "TIANDITU_VEC":
            case "TIANDITU_IMG":
            case "TIANDITU_TER":
                mapOptions.crs = epsgCode === 4326 ? _leaflet2["default"].CRS.TianDiTu_WGS84 : _leaflet2["default"].CRS.TianDiTu_Mercator;
                mapOptions.minZoom = 1;
                mapOptions.zoom = 1 + mapOptions.zoom;
                layer = this.createTiandituLayer(layerInfo);
                break;
            case "BAIDU":
                mapOptions.crs = _leaflet2["default"].CRS.BaiduCRS;
                mapOptions.zoom = 3 + mapOptions.zoom;
                mapOptions.minZoom = 3;
                layer = (0, _BaiduTileLayer.baiduTileLayer)();
                break;
            case 'BING':
                //todo
                break;
            case "WMS":
                layer = this.createWmsLayer(layerInfo);
                break;
            case "WMTS":
                mapOptions.resolutions = this.getResolutionsFromScales(scales, 90.71446714322, layerInfo.units);
                var identifier = layerInfo.identifier;
                var layerName = identifier.substring(identifier.indexOf("_") + 1);
                layer = (0, _TileLayer.wmtsLayer)(layerInfo.url, {
                    layer: layerName,
                    style: "default",
                    tilematrixSet: identifier,
                    format: "image/png"
                });
                break;
            case "CLOUD":
                mapOptions.crs = _leaflet2["default"].CRS.EPSG3857;
                mapOptions.zoom = 3 + mapOptions.zoom;
                mapOptions.minZoom = 3;
                layer = (0, _CloudTileLayer.cloudTileLayer)(layerInfo.url, { opacity: opacity });
                break;
            case "MARKER_LAYER":
                layer = this.createMarkersLayer(layerInfo, crs);
                break;
            case "FEATURE_LAYER":
                if (layerInfo.identifier == "ANIMATORVECTOR") {
                    //todo
                } else if (layerInfo.identifier == "THEME") {
                    layer = this.createThemeLayer(layerInfo);
                } else {
                    layer = this.createVectorLayer(layerInfo, crs);
                }
                break;
            default:
                throw new Error('unSupported Layer Type');
        }
        if (layer && layerInfo.isVisible) {
            this.addLayerWrapper(layer, isBaseLayer, mapOptions);
        }
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.createTiandituLayer
     * @description 创建天地图图层
     * @param layerInfo - {Object} 图层信息
     * @return {L.supermap.tiandituTileLayer} 返回天地图图层对象
     */
    createTiandituLayer: function createTiandituLayer(layerInfo) {
        var type = layerInfo.type.split('_')[1].toLowerCase();
        var isLabel = layerInfo.layerType === 'OVERLAY_LAYER';
        var layer = new _TiandituTileLayer.TiandituTileLayer({
            layerType: type,
            isLabel: isLabel
        });
        return layer;
    },

    /**
     * @private
     * @function L.supermap.webmap.prototype.createMarkersLayer
     * @description 创建图标图层
     * @param layerInfo - {Object} 图层信息
     * @param crs - {Object} 坐标对象
     * @return {L.Layer} 返回marker图层
     */
    createMarkersLayer: function createMarkersLayer(layerInfo, crs) {
        var that = this;
        var markers = layerInfo.markers || [];
        //style = layerInfo.style,
        //opacity = layerInfo.opacity,
        //marker, point, size, offset, icon, that = this;
        //todo offset
        var coordsToLatLng = function coordsToLatLng(coords) {
            var ll = crs.unproject(_leaflet2["default"].point(coords[0], coords[1]));
            return new _leaflet2["default"].LatLng(ll.lat, ll.lng, coords[2]);
        };

        var layer = _leaflet2["default"].geoJSON(_leaflet2["default"].Util.toGeoJSON(markers), {
            pointToLayer: function pointToLayer(geojson, latlng) {
                var m = new _leaflet2["default"].Marker(latlng);
                m.setStyle = function (style) {
                    if (style) {
                        m.setIcon(style);
                    }
                };
                return m;
            },
            coordsToLatLng: coordsToLatLng, style: function style(geoJsonFeature) {
                return that.cartoCSSToLeaflet.getStyleFromiPortalMarker(geoJsonFeature.properties.icon);
            }
        });
        if (this.options.featureLayerPopupEnable) {
            layer.bindPopup(this.options.featureLayerPopup || this.defaultFeatureLayerPopup);
        }
        return layer;
    },
    /**
     * @private
     * @function L.supermap.webmap.prototype.createWmsLayer
     * @description 创建Wms图层
     * @param layerInfo - {Object} 图层信息
     */
    createWmsLayer: function createWmsLayer(layerInfo) {
        var url = layerInfo.url,
            opacity = layerInfo.opacity,
            subLayers = layerInfo.subLayers;

        if (!subLayers || subLayers === "undefined" || subLayers === "null") {
            subLayers = "0";
        }
        return _leaflet2["default"].tileLayer.wms(url, {
            layers: subLayers,
            format: 'image/png',
            transparent: true,
            noWrap: true,
            opacity: opacity
        });
    },
    /**
     * @private
     * @function L.supermap.webmap.prototype.createVectorLayer
     * @description 创建矢量要素图层
     * @param layerInfo - {Object} 图层信息
     * @param crs - {Object} 坐标对象
     * @return {L.Layer} 返回矢量要素图层对象
     */
    createVectorLayer: function createVectorLayer(layerInfo, crs) {
        var _this = this;

        var _style = layerInfo.style,
            opacity = layerInfo.opacity,
            me = this;
        //todo readonly = layerInfo.readonly;
        var coordsToLatLng = function coordsToLatLng(coords) {
            var ll = crs.unproject(_leaflet2["default"].point(coords[0], coords[1]));
            return new _leaflet2["default"].LatLng(ll.lat, ll.lng, coords[2]);
        };
        if (!layerInfo.url) {
            var layer = _leaflet2["default"].geoJSON(_leaflet2["default"].Util.toGeoJSON(layerInfo.features), {
                pointToLayer: function pointToLayer(geojson, latlng) {
                    var m = new _leaflet2["default"].Marker(latlng);
                    m.setStyle = function (style) {
                        if (style) {
                            m.setIcon(style);
                        }
                    };
                    return m;
                },
                coordsToLatLng: coordsToLatLng, style: function style(geoJsonFeature) {
                    var lStyle = me.cartoCSSToLeaflet.getStyleFromiPortalStyle(_style ? _style : {}, geoJsonFeature.geometry.type, geoJsonFeature.properties.style);
                    if (lStyle.dashArray && lStyle.dashArray.length == 0) {
                        lStyle.dashArray = null;
                    }
                    return lStyle;
                },
                opacity: opacity
            });
            if (this.options.featureLayerPopupEnable) {
                layer.bindPopup(this.options.featureLayerPopup || this.defaultFeatureLayerPopup);
            }
            return layer;
        } else {
            var url = layerInfo.url,
                datasourceName = layerInfo.name,
                datasets = layerInfo.features;
            for (var setNameIndex = 0; setNameIndex < datasets.length; setNameIndex++) {
                var dataset = datasets[setNameIndex];
                if (dataset.visible) {
                    this.getFeaturesBySQL(url, datasourceName, dataset.name, "", _iclientCommon.DataFormat.GEOJSON, function (serviceResult) {
                        var layer = _leaflet2["default"].geoJSON(serviceResult.result, {
                            pointToLayer: function pointToLayer(geojson, latlng) {
                                var m = new _leaflet2["default"].Marker(latlng);
                                m.setStyle = function (style) {
                                    if (style) {
                                        m.setIcon(style);
                                    }
                                };
                                return m;
                            },
                            coordsToLatLng: coordsToLatLng,
                            style: function style(geoJsonFeature) {
                                return this.cartoCSSToLeaflet.getStyleFromiPortalStyle(_style ? _style : {}, geoJsonFeature.geometry.type, geoJsonFeature.properties.style);
                            },
                            opacity: opacity
                        });
                        if (_this.options.featureLayerPopupEnable) {
                            layer.bindPopup(me.options.featureLayerPopup || me.defaultFeatureLayerPopup);
                        }
                        _this.addLayer(layer);
                    });
                }
            }
        }
    },
    getFeaturesBySQL: function getFeaturesBySQL(url, datasourceName, datasetName, filter, format, callback) {
        filter = filter || "SMID > 0";
        var sqlParam = new _iclientCommon.GetFeaturesBySQLParameters({
            queryParameter: {
                name: datasetName + "@" + datasourceName,
                attributeFilter: filter
            },
            datasetNames: [datasourceName + ":" + datasetName]
        });
        (0, _FeatureService.featureService)(url).getFeaturesBySQL(sqlParam, callback, format);
    },
    /**
     * @private
     * @function L.supermap.webmap.prototype.createThemeLayer
     * @description 创建专题图图层
     * @param layerInfo - {Object} 图层信息
     * @return {L.Layer} 返回专题图图层对象
     */
    createThemeLayer: function createThemeLayer(layerInfo) {
        var _this2 = this;

        var themeSettings = layerInfo.themeSettings && JSON.parse(layerInfo.themeSettings);

        var layer;
        var type = themeSettings.type;
        layerInfo.themeSettings = themeSettings;
        if (type === "HEAT") {
            layer = this.createHeatLayer(layerInfo, themeSettings);
        } else if (type === "UNIQUE") {
            layer = this.createUniqueLayer(layerInfo, themeSettings);
        } else if (type === "RANGE") {
            layer = this.createRangeLayer(layerInfo, themeSettings);
        } else {
            layer = this.createBaseThemeLayer(layerInfo, themeSettings);
        }
        if (layer) {
            this.addFeature2ThemeLayer(layerInfo, layer);
            layer.on('add', function (e) {
                _this2.registerThemeEvent(e.target);
            });
        }
        if (themeSettings && themeSettings.labelField) {
            var labelLayer = this.createLabelLayer(layerInfo, themeSettings);
            labelLayer.on('add', function (e) {
                _this2.registerThemeEvent(e.target);
            });
            layer.labelLayer = labelLayer;
        }
        return layer;
    },
    createBaseThemeLayer: function createBaseThemeLayer(layerInfo, themeSettings) {
        var _this3 = this;

        var style = layerInfo.style,
            opacity = layerInfo.opacity,
            vectorType = themeSettings.vectorType,
            featureStyle = style.pointStyle;
        if (vectorType === "LINE") {
            featureStyle.fill = false;
        } else {
            featureStyle.fill = true;
        }
        var coordsToLatLng = function coordsToLatLng(coords) {
            var ll = _this3._map.options.crs.unproject(_leaflet2["default"].point(coords[0], coords[1]));
            return new _leaflet2["default"].LatLng(ll.lat, ll.lng, coords[2]);
        };
        var pointStyle = {};
        pointStyle.radius = featureStyle.pointRadius;
        pointStyle.color = featureStyle.strokeColor;
        pointStyle.opacity = featureStyle.strokeOpacity;
        pointStyle.lineCap = featureStyle.strokeLineCap;
        pointStyle.weight = featureStyle.strokeWidth;
        pointStyle.fillColor = featureStyle.fillColor;
        pointStyle.fillOpacity = featureStyle.fillOpacity;
        var pointToLayer = function pointToLayer(geojson, latlng) {
            return _leaflet2["default"].circleMarker(latlng, pointStyle);
        };
        if (featureStyle.unicode) {
            pointToLayer = function pointToLayer(geojson, latlng) {
                return new _UnicodeMarker.UnicodeMarker(latlng, featureStyle);
            };
        }
        return _leaflet2["default"].geoJSON({ type: "GeometryCollection", geometries: [] }, {
            pointToLayer: pointToLayer,
            coordsToLatLng: coordsToLatLng,
            opacity: opacity
        });
        //this.registerVectorEvent(vector);
    },
    createUniqueLayer: function createUniqueLayer(layerInfo, themeSettings) {
        var title = layerInfo.title;
        var themeField = themeSettings.field,
            styleGroups = [],
            settings = themeSettings.settings,
            isVisible = layerInfo.isVisible,
            opacity = layerInfo.opacity,
            vectorType = themeSettings.vectorType;
        //组成styleGroup
        for (var i = 0; i < settings.length; i++) {
            var object = {};
            object.value = settings[i].value;
            object.style = settings[i].style;
            styleGroups.push(object);
        }
        var unique = new _UniqueThemeLayer.UniqueThemeLayer(title, {
            opacity: opacity,
            visibility: isVisible
        });
        this.registerThemeEvent(unique);
        unique.style = layerInfo.style.pointStyle;
        if (vectorType === "LINE") {
            unique.style.fill = false;
        }
        unique.style.stroke = true;
        unique.themeField = themeField;
        unique.styleGroups = styleGroups;
        var that = this;
        unique.on('click', function (event) {
            if (event.target && event.target.refDataID) {
                var currenFeature = unique.getFeatureById(event.target.refDataID);
                that.events.triggerEvent("uniquefeatureclicked", currenFeature, unique);
            }
        });
        return unique;
    },
    createRangeLayer: function createRangeLayer(layerInfo, themeSettings) {
        var title = layerInfo.title;
        var themeField = themeSettings.field,
            styleGroups = [],
            settings = themeSettings.settings,
            isVisible = layerInfo.isVisible,
            opacity = layerInfo.opacity,
            vectorType = themeSettings.vectorType,
            featureStyle = layerInfo.style.pointStyle;
        if (vectorType === "LINE") {
            featureStyle.fill = false;
        } else {
            featureStyle.fill = true;
        }
        //组成styleGroup
        for (var i = 0; i < settings.length; i++) {
            var object = {};
            object.start = settings[i].start;
            object.end = settings[i].end;
            object.style = settings[i].style;
            styleGroups.push(object);
        }
        var range = new _RangeThemeLayer.RangeThemeLayer(title, {
            visibility: isVisible,
            opacity: opacity
        });
        this.registerThemeEvent(range);
        range.style = layerInfo.style.pointStyle;
        range.style.stroke = true;
        range.themeField = themeField;
        range.styleGroups = styleGroups;
        return range;
    },
    createLabelLayer: function createLabelLayer(layerInfo, themeSettings) {
        var title = layerInfo.title;
        var labelField = themeSettings.labelField,
            settings = themeSettings.settings,
            isVisible = layerInfo.isVisible;

        //目前只是同一样式
        var style;
        if (!settings || settings.length > 0) {
            style = {
                "fillColor": "#ffffff"
            };
        } else {
            style = settings[0].style;
        }
        var layerStyle = _leaflet2["default"].Util.extend(new _iclientCommon.ThemeStyle(), style);
        layerStyle.fontWeight = "bold";
        layerStyle.fontSize = "14px";
        //默认显示标签边框背景
        layerStyle.labelRect = true;
        layerStyle.strokeColor = layerStyle.fillColor;
        layerStyle.fontColor = themeSettings.labelColor;
        if (themeSettings.labelFont) {
            layerStyle.fontFamily = themeSettings.labelFont;
        }

        var label = new _LabelThemeLayer.LabelThemeLayer(title, {
            visibility: isVisible,
            opacity: 0.7
        });
        this.registerThemeEvent(label);
        label.style = layerStyle;

        label.themeField = labelField;
        //styleGroup, 目前只是同一样式
        label.styleGroups = [];
        return label;
    },
    createHeatLayer: function createHeatLayer(layerInfo, themeSettings) {
        var colors = themeSettings.colors || ['blue', 'cyan', 'lime', 'yellow', 'red'];
        var gradient = {},
            featureWeight = void 0;
        for (var i = 0, len = colors.length, index = 1; i < len; i++) {
            gradient[index / len] = colors[i];
            index++;
        }
        var radius = themeSettings.settings[0].radius;
        //判断单位
        if (themeSettings.heatUnit === "千米" || themeSettings.heatUnit === "km") {
            radius = themeSettings.heatRadius * 1000;
        }
        //权重
        if (themeSettings.settings[0] && themeSettings.settings[0].featureWeight) {
            featureWeight = themeSettings.settings[0].featureWeight;
        }
        return _leaflet2["default"].heatLayer([], {
            radius: radius / 2,
            minOpacity: layerInfo.opacity,
            gradient: gradient,
            blur: radius / 2,
            featureWeight: featureWeight
        });
    },
    addFeature2ThemeLayer: function addFeature2ThemeLayer(layerInfo, layer) {
        var _this4 = this;

        if (layerInfo.layerType !== "FEATURE_LAYER" || layerInfo.identifier !== "THEME") {
            return;
        }
        var me = this;
        var isRestData = !!layerInfo.datasourceName;
        var cartoCSS = layerInfo.cartoCSS;
        if (cartoCSS) {
            var needTransform = this.getCartoCSS2Obj(cartoCSS).needTransform;
            var isAddFile = this.getCartoCSS2Obj(cartoCSS).isAddFile;
        }

        var url = layerInfo.url,
            subLayers,
            subLayer,
            layerName,
            credential = layerInfo.credential,
            themeSettings = layerInfo.themeSettings,
            filter = themeSettings.filter;

        if (isAddFile) {
            var position = JSON.parse(layerInfo.datasourceName);
            var sql = this.getSQLFromFilter(filter);
            if (url) {
                this.getFeatureFromFileAdded(layerInfo, function (data) {
                    var sFeaturesArr = [],
                        features,
                        result;
                    if (data.type === 'EXCEL' || data.type === 'CSV') {
                        features = me.parseFeatureFromEXCEL.apply(me, [data.content.rows, data.content.colTitles, false, position]);
                        for (var x = 0, len = features.length; x < len; x++) {
                            result = (0, _jsonsql2["default"])({ attr: features[x].attributes }, sql);
                            if (result.length > 0) {
                                sFeaturesArr.push(features[x]);
                            }
                        }
                    } else {
                        features = me.parseFeatureFromJson(data.content);
                        for (var i = 0, length = features.length; i < length; i++) {
                            result = (0, _jsonsql2["default"])({ attr: features[i].attributes }, sql);
                            if (result.length > 0) {
                                sFeaturesArr.push(features[i]);
                            }
                        }
                    }
                    var newEpsgCode = me.mapInfo && me.mapInfo.epsgCode,
                        oldEpsgCode = layerInfo.prjCoordSys && layerInfo.prjCoordSys.epsgCode;
                    if (needTransform) {
                        me.changeFeatureLayerEpsgCode(oldEpsgCode, newEpsgCode, layer, sFeaturesArr, function (features) {
                            addFeatures(features);
                        });
                    } else {
                        addFeatures(sFeaturesArr);
                    }
                }, function () {});
            } else {
                var newFeautures = [],
                    features = layerInfo.features;
                for (var i = 0, len = features.length; i < len; i++) {
                    var feature = features[i];
                    var sqlResult = (0, _jsonsql2["default"])({ attr: feature.attributes }, sql);
                    if (sqlResult.length > 0) {
                        var lon = feature.geometry.points[0].x,
                            lat = feature.geometry.points[0].y;
                        var point = new _iclientCommon.GeometryPoint(lon, lat);
                        var vector = new _iclientCommon.GeometryVector(point, feature.attributes, feature.style);
                        newFeautures.push(vector);
                    }
                }
                addFeatures(newFeautures);
            }
        } else if (isRestData) {
            var dataSourceName = layerInfo.datasourceName;
            subLayers = layerInfo.subLayers && JSON.parse(layerInfo.subLayers);
            if (subLayers.length && subLayers.length > 0) {
                subLayer = subLayers[0];
            } else {
                subLayer = subLayers;
            }
            layerName = subLayer && subLayer.name;
            this.getFeaturesBySQL(layerInfo.url, dataSourceName, layerName, themeSettings.filter, _iclientCommon.DataFormat.ISERVER, function (getFeaturesEventArgs) {
                var features,
                    feature,
                    result = getFeaturesEventArgs.result,
                    addedFeatures = [];
                if (result && result.features) {
                    features = result.features;
                    for (var fi = 0, felen = features.length; fi < felen; fi++) {
                        feature = new _iclientCommon.ServerFeature.fromJson(features[fi]).toFeature();
                        addedFeatures.push(feature);
                    }
                    var newEpsgCode = me.mapInfo && me.mapInfo.epsgCode,
                        oldEpsgCode = layerInfo.prjCoordSys && layerInfo.prjCoordSys.epsgCode;

                    if (needTransform) {
                        _this4.changeFeatureLayerEpsgCode(oldEpsgCode, newEpsgCode, layer, addedFeatures, function (features) {
                            addFeatures(features);
                        });
                    } else {
                        addFeatures(features);
                    }
                }
            });
        } else {
            subLayers = layerInfo.subLayers && JSON.parse(layerInfo.subLayers);
            if (subLayers.length && subLayers.length > 0) {
                subLayer = subLayers[0];
            } else {
                subLayer = subLayers;
            }
            layerName = subLayer && subLayer.name;
            var oldEpsgCode = layerInfo.prjCoordSys && layerInfo.prjCoordSys.epsgCode;
            this.getFeaturesBySQL(url, credential, layerName, filter, _iclientCommon.DataFormat.ISERVER, function (features) {
                var newEpsgCode = me.mapInfo && me.mapInfo.epsgCode;
                if (needTransform) {
                    me.changeFeatureLayerEpsgCode(oldEpsgCode, newEpsgCode, layer, features, function (features) {
                        addFeatures(features);
                    });
                } else {
                    addFeatures(features);
                }
            });
        }

        function addFeatures(features) {
            if (layer && layer.labelLayer instanceof _LabelThemeLayer.LabelThemeLayer) {
                me.addFeature2LabelLayer(layer.labelLayer, features, layerInfo);
            }
            if (_leaflet2["default"].HeatLayer && layer instanceof _leaflet2["default"].HeatLayer) {
                var heatPoints = [];
                for (var _i = 0, _len = features.length; _i < _len; _i++) {
                    var geometry = features[_i].geometry;
                    heatPoints[_i] = me._map.options.crs.unproject(_leaflet2["default"].point(geometry.x, geometry.y));
                    if (layer.options.featureWeight) {
                        heatPoints[_i] = [heatPoints[_i].lat, heatPoints[_i].lng, parseFloat(features[_i].attributes[layer.options.featureWeight])];
                    }
                }
                layer.setLatLngs(heatPoints);
            } else if (layer instanceof _leaflet2["default"].GeoJSON) {
                layer.addData(JSON.parse(new _iclientCommon.GeoJSON().write(features)));
            } else {
                layer.addFeatures(features);
            }
        }
    },

    addFeature2LabelLayer: function addFeature2LabelLayer(layer, features, layerInfo) {
        if (!features) {
            return;
        }

        var feature, geoTextFeature;
        var themeSettings = layerInfo.themeSettings;
        themeSettings = typeof themeSettings === "string" ? JSON.parse(layerInfo.themeSettings) : layerInfo.themeSettings;
        var themeField = themeSettings.labelField;

        var style = layer.style;
        var labelFeatures = [],
            lngLat;
        var styleInfo = layerInfo.styleString && JSON.parse(layerInfo.styleString);
        for (var i = 0; i < features.length; i++) {
            lngLat = this.getLabelLngLat(themeSettings.vectorType, features[i]);
            //设置标签的偏移量
            this.setLabelOffset(themeSettings.vectorType, styleInfo, features[i], style);
            feature = features[i];
            var attributes = feature.attributes;
            geoTextFeature = new _ThemeFeature.ThemeFeature([lngLat.lat, lngLat.lng, attributes[themeField]], attributes);
            labelFeatures.push(geoTextFeature);
        }
        layer.style = style;
        layer.addFeatures(labelFeatures);
    },
    setLabelOffset: function setLabelOffset(vectorType, styleInfo, feature, layerStyle) {
        if (vectorType === 'POINT') {
            var pointRadius = styleInfo.pointStyle.pointRadius || 0;
            var strokeWidth = styleInfo.pointStyle.strokeWidth || 0;
            var fontSize = parseInt(styleInfo.pointStyle.fontSize) || 0;
            layerStyle.labelXOffset = 0;
            layerStyle.labelYOffset = styleInfo.pointStyle.unicode ? 20 + fontSize : 25 + (pointRadius + strokeWidth);
        } else {
            return;
        }
    },
    getLabelLngLat: function getLabelLngLat(vectorType, feature) {
        var lngLat = {};
        if (vectorType === 'POINT') {
            var geometry = feature.geometry;
            lngLat.lng = geometry.x;
            lngLat.lat = geometry.y;
        } else if (vectorType === 'LINE') {
            //一条线所有顶点的数量
            var length, index;
            var components = feature.geometry.components;
            if (components[0].x) {
                //说明是lineString类型
                length = components.length;
                //线取中间点下一个显示标签
                index = parseInt(length / 2);
                lngLat.lng = components[index].x;
                lngLat.lat = components[index].y;
            } else {
                //说明是MultiLineString类型,取第一条线
                var lineOne = components[0].components;
                length = lineOne.length;
                index = parseInt(length / 2);
                lngLat.lng = lineOne[index].x;
                lngLat.lat = lineOne[index].y;
            }
        } else {
            var centroid = feature.geometry.getCentroid();
            lngLat.lng = centroid.x;
            lngLat.lat = centroid.y;
        }
        return lngLat;
    },
    changeFeatureLayerEpsgCode: function changeFeatureLayerEpsgCode(oldEpsgCode, newEpsgCode, layer, features, success) {
        var me = this,
            i,
            len;
        var points = [];
        if (!oldEpsgCode || !newEpsgCode) {
            return;
        }
        if (features && features.length > 0) {
            for (i = 0, len = features.length; i < len; i++) {
                var feature = features[i];
                var geometry = feature.geometry;
                var vertices = geometry.getVertices();
                points = points.concat(vertices);
            }
            oldEpsgCode = 'EPSG:' + oldEpsgCode, newEpsgCode = 'EPSG:' + newEpsgCode;
            me.coordsTransform(oldEpsgCode, newEpsgCode, points, function (layer, features) {
                return function (newCoors) {
                    var start = 0,
                        len = newCoors.length;
                    for (i = start; i < len; i++) {
                        var point = points[i],
                            coor = newCoors[i];
                        point.x = coor.x;
                        point.y = coor.y;
                        point.calculateBounds();
                    }
                    for (i = 0, len = features.length; i < len; i++) {
                        var feature = features[i];
                        var geometry = feature.geometry;
                        if (geometry.components) {
                            me.calculateComponents(geometry.components);
                        }
                        geometry.calculateBounds();
                    }
                    success && success.call(me, features);
                };
            }(layer, features));
        }
        return true;
    },
    calculateComponents: function calculateComponents(components) {
        if (components) {
            if (components.components) {
                this.calculateComponents(components.components);
            } else {
                for (var i = 0, len = components.length; i < len; i++) {
                    var component = components[i];
                    if (component.components) {
                        this.calculateComponents(component.components);
                    }
                    component.calculateBounds();
                }
            }
        }
    },
    coordsTransform: function coordsTransform(fromEpsg, toEpsg, point, success) {
        var newCoord;
        var from = this.SERVER_TYPE_MAP[fromEpsg],
            to = this.SERVER_TYPE_MAP[toEpsg];
        if (fromEpsg === toEpsg || !from || !to) {
            if (point && point.length !== undefined) {
                newCoord = [];
                for (var i = 0, len = point.length; i < len; i++) {
                    var coor = { x: point[i].x, y: point[i].y };
                    newCoord.push(coor);
                }
            } else {
                newCoord = { x: point.x, y: point.y };
            }
            if (success) {
                success.call(this, newCoord);
            }
        } else {
            var mercator = this.SERVER_TYPE_MAP['EPSG:3857'],
                wgs84 = this.SERVER_TYPE_MAP['EPSG:4326'];
            if ((from === mercator || from === wgs84) && (to === mercator || to === wgs84)) {
                this.projTransform(fromEpsg, toEpsg, point, success);
            } else {
                var convertType = from + '_' + to;
                this.postTransform(convertType, point, success);
            }
        }
    },
    projTransform: function projTransform(fromEpsg, toEpsg, point, success) {
        var newCoor,
            me = this;
        if (!_proj2["default"]) {
            return;
        }
        if (point && point.length !== undefined) {
            newCoor = [];
            for (var i = 0, len = point.length; i < len; i++) {
                var coor = (0, _proj2["default"])(fromEpsg, toEpsg, [point[i].x, point[i].y]);
                newCoor.push({ x: coor[0], y: coor[1] });
            }
        } else {
            newCoor = (0, _proj2["default"])(fromEpsg, toEpsg, [point.x, point.y]);
            newCoor = { x: newCoor[0], y: newCoor[1] };
        }
        if (success) {
            me.fire('coordconvertsuccess', { newCoor: newCoor });
            success.call(me, newCoor);
        }
    },
    postTransform: function postTransform(convertType, point, success) {
        var me = this,
            epsgArray = [];
        if (!convertType) {
            return success.call(me, null);
        }
        if (point && point.length !== undefined) {
            for (var i = 0, len = point.length; i < len; i++) {
                epsgArray.push({ x: point[i].x, y: point[i].y });
            }
        } else {
            epsgArray = [{ x: point.x, y: point.y }];
        }
        if (epsgArray.length === 0) {
            return success.call(me, null);
        }
        var postData = {
            "convertType": convertType,
            "points": epsgArray
        };
        var url = this.url + "coordconvert.json";
        postData = JSON.stringify(postData);
        var options = {
            url: url,
            isInTheSameDomain: true,
            data: postData,
            method: "POST",
            success: function (success) {
                return function (res) {
                    if (success) {
                        var newCoors = JSON.parse(res.responseText);
                        if (!point && point.length !== undefined) {
                            newCoors = newCoors[0];
                        }
                        me.fire('coordconvertsuccess', { newCoors: newCoors });
                        success.call(me, newCoors);
                    }
                };
            }(success),
            failure: function failure(err) {
                if (!me.actived) {
                    return;
                }
                me.fire('coordconvertfailed', { err: err });
            },
            scope: this
        };
        if (!_iclientCommon.CommonUtil.isInTheSameDomain(url) && this.proxy) {
            options.proxy = this.proxy;
        }
        _iclientCommon.CommonUtil.committer(options);
    },
    getSQLFromFilter: function getSQLFromFilter(filter) {

        if (!filter) {
            return ' * where (1==1||1>=0)';
        } else {
            filter = filter.replace(/=/g, '==').replace(/and|AND/g, '&&').replace(/or|OR/g, '||').replace(/>==/g, '>=').replace(/<==/g, '<=');
            return ' *  where (' + filter + ')';
        }
    },
    getAttributesObjFromTable: function getAttributesObjFromTable(cols, colTitles) {
        if (cols.length < 0 || colTitles.length < 0) {
            return;
        }
        var attrArr = [];
        for (var i = 0; i < cols.length; i++) {
            var obj = {};
            for (var j = 0; j < colTitles.length; j++) {
                obj[colTitles[j]] = cols[i][j];
            }
            attrArr.push(obj);
        }
        return attrArr;
    },
    parseFeatureFromEXCEL: function parseFeatureFromEXCEL(rows, colTitles, isGraphic, position) {
        var attrArr = this.getAttributesObjFromTable(rows, colTitles);
        var features = [];
        for (var i = 0, len = attrArr.length; i < len; i++) {
            var lon = attrArr[i][position["lon"]];
            var lat = attrArr[i][position["lat"]];
            if (!lon || !lat) {
                continue;
            }
            lon = parseFloat(lon);
            lat = parseFloat(lat);
            var geometry = new _iclientCommon.GeometryPoint(lon, lat);
            var pointGraphic;
            if (isGraphic) {
                pointGraphic = new _Graphic.Graphic(geometry, attrArr[i], null);
            } else {
                pointGraphic = new _iclientCommon.GeometryVector(geometry, attrArr[i], null);
            }
            features.push(pointGraphic);
        }
        return features;
    },
    parseFeatureFromJson: function parseFeatureFromJson(feature) {
        var format = new _iclientCommon.GeoJSON();
        var features = format.read(feature);
        //兼容insights数据格式
        if (features == null) {
            var content = JSON.parse(feature.replace(/'/, '"'));
            if (content.isAnalyseResult) {
                content = content.data.recordsets[0].features;
            }
            format = new _iclientCommon.GeoJSON();
            features = format.read(content);
        }
        for (var i = 0, len = features.length; i < len; i++) {
            features[i].attributes = features[i].attributes.properties || features[i].attributes;
        }
        return features;
    },
    getFeatureFromFileAdded: function getFeatureFromFileAdded(layerInfo, success, failed, isGraphic) {
        var url = isGraphic ? layerInfo.url + '?currentPage=1&&pageSize=9999999' : layerInfo.url;
        _iclientCommon.FetchRequest.get(url).then(function (response) {
            return response.json();
        }).then(function (data) {
            success && success(data);
        })["catch"](function (err) {
            return failed && failed(err);
        });
    },
    getCartoCSS2Obj: function getCartoCSS2Obj(cartoCSS) {
        var isAddFile,
            needTransform = false;
        if (cartoCSS.indexOf('}') > -1) {
            cartoCSS = JSON.parse(cartoCSS);
            needTransform = cartoCSS.needTransform;
            isAddFile = cartoCSS.isAddFile;
        } else {
            if (cartoCSS === 'needTransform') {
                needTransform = true;
                //layerInfo.needTransform = true;
                isAddFile = false;
            } else {
                isAddFile = cartoCSS === 'true';
            }
        }
        return {
            isAddFile: isAddFile,
            needTransform: needTransform
        };
    },
    registerThemeEvent: function registerThemeEvent(themeLayer) {
        var _this5 = this;

        themeLayer.on('click', function (evt) {
            if (!themeLayer.map) {
                return;
            }
            if (_this5.selectedFeature) {
                _this5.fire('featureUnSelected', { feature: _this5.selectedFeature });
                _this5.selectedFeature = null;
            }
            var feature = void 0;
            if (evt.target && evt.target.refDataID) {
                feature = themeLayer.getFeatureById(evt.target.refDataID);
            }
            if (feature) {
                _this5.selectedFeature = feature;
                _this5.fire('featureSelected', { feature: feature });
            }
        });
        themeLayer.on('mousemove', function (evt) {
            if (!themeLayer.map) {
                return;
            }
            if (evt.target && evt.target.refDataID) {
                var feature = void 0;
                if (evt.target && evt.target.refDataID) {
                    feature = themeLayer.getFeatureById(evt.target.refDataID);
                }
                if (feature) {
                    _this5.fire('featureMousemove', { feature: feature });
                }
            }
        });
    },
    SERVER_TYPE_MAP: {
        "EPSG:4326": "WGS84",
        "EPSG:3857": "MERCATOR",
        "EPSG:900913": "MERCATOR",
        "EPSG:102113": "MERCATOR",
        "EPSG:910101": "GCJ02",
        "EPSG:910111": "GCJ02MERCATOR",
        "EPSG:910102": "BD",
        "EPSG:910112": "BDMERCATOR"
    }
});
var webMap = exports.webMap = function webMap(id, options) {
    return new WebMap(id, options);
};

_leaflet2["default"].supermap.webmap = webMap;

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.dataFlowLayer = exports.DataFlowLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _DataFlowService = __webpack_require__(134);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.dataFlowLayer
 * @classdesc 实时数据图层源
 * @extends L.GeoJSON{@linkdoc-leaflet/#geojson}
 * @param url - {string} 实时数据图层服务地址
 * @param options - {Object} 设置图层参数。如：<br>
 *        geometry - {Object} GeoJSON几何对象<br>
 *        prjCoordSys - {Object} 投影坐标对象。<br>
 *        excludeField - {string} 排除字段。<br>
 *        idField - {string} id字段。
 */
var DataFlowLayer = exports.DataFlowLayer = _leaflet2["default"].GeoJSON.extend({

    options: {
        geometry: null,
        prjCoordSys: null,
        excludeField: null,
        idField: "id"
    },

    initialize: function initialize(url, options) {
        options = options || {};
        var me = this;
        if (options.style && !options.pointToLayer) {
            options.pointToLayer = function (geojson, latlng) {
                return _leaflet2["default"].circleMarker(latlng, options.style());
            };
        }
        _leaflet2["default"].Util.setOptions(me, options);
        me._layers = {};
        _leaflet2["default"].stamp(me);
        me.url = url;
        this.idCache = {};
    },

    /**
     * @private
     * @function L.supermap.dataFlowLayer.prototype.onAdd
     * @description 添加地图
     * @param map - {L.map} 待添加的地图
     */
    onAdd: function onAdd(map) {
        // eslint-disable-line no-unused-vars
        var me = this;
        me.dataService = new _DataFlowService.DataFlowService(this.url, {
            geometry: this.options.geometry,
            prjCoordSys: this.options.prjCoordSys,
            excludeField: this.options.excludeField
        }).initSubscribe();
        me.dataService.on('subscribeSocketConnected', function (e) {
            me.fire("subscribeSuccessed", e);
        });
        me.dataService.on('messageSuccessed', function (msg) {
            me._onMessageSuccessed(msg);
        });
        me.dataService.on('setFilterParamSuccessed', function (msg) {
            me.fire("setFilterParamSuccessed", msg);
        });
    },

    /**
     * @private
     * @function L.supermap.dataFlowLayer.prototype.onRemove
     * @description 删除指定地图
     * @param map - {L.map} 待删除的地图
     */
    onRemove: function onRemove(map) {
        // eslint-disable-line no-unused-vars
        this.dataService.unSubscribe();
    },

    /**
     * @function L.supermap.dataFlowLayer.prototype.setExcludeField
     * @description 设置唯一字段
     * @param excludeField - {string} 唯一字段
     */
    setExcludeField: function setExcludeField(excludeField) {
        this.dataService.setExcludeField(excludeField);
        this.options.excludeField = excludeField;
        return this;
    },

    /**
     * @function L.supermap.dataFlowLayer.prototype.setGeometry
     * @description 设置集合要素
     * @param geometry - {Object} 待设置的GeoJSON几何要素对象
     */
    setGeometry: function setGeometry(geometry) {
        this.dataService.setGeometry(geometry);
        this.options.geometry = geometry;
        return this;
    },

    _onMessageSuccessed: function _onMessageSuccessed(msg) {
        var geojson = msg.featureResult;
        var geoID = msg.featureResult.properties[this.options.idField];
        var layer = null;
        if (geoID !== undefined && this.idCache[geoID]) {
            layer = this.getLayer(this.idCache[geoID]);
            this._updateLayerData(layer, geojson);
        } else {
            layer = _leaflet2["default"].GeoJSON.geometryToLayer(geojson, this.options);
            layer.feature = _leaflet2["default"].GeoJSON.asFeature(geojson);
            this.addLayer(layer);
            if (geoID !== undefined) {
                this.idCache[geoID] = this.getLayerId(layer);
            }
        }
        if (this.options.onEachFeature) {
            this.options.onEachFeature(geojson, layer);
        }
        this.fire("dataUpdated", { layer: this, updateLayer: layer, data: msg.featureResult });
    },
    _updateLayerData: function _updateLayerData(layer, geojson) {
        if (geojson.properties) {
            layer.feature.properties = geojson.properties;
        }
        var latlngs = [];
        switch (geojson.geometry.type) {
            case 'Point':
                latlngs = _leaflet2["default"].GeoJSON.coordsToLatLng(geojson.geometry.coordinates);
                layer.setLatLng(latlngs);
                break;
            case 'LineString':
                latlngs = _leaflet2["default"].GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 0);
                layer.setLatLngs(latlngs);
                break;
            case 'MultiLineString':
            case 'Polygon':
                latlngs = _leaflet2["default"].GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 1);
                layer.setLatLngs(latlngs);
                break;
            case 'MultiPolygon':
                latlngs = _leaflet2["default"].GeoJSON.coordsToLatLngs(geojson.geometry.coordinates, 2);
                layer.setLatLngs(latlngs);
                break;
        }
    }
});
var dataFlowLayer = exports.dataFlowLayer = function dataFlowLayer(url, options) {
    return new DataFlowLayer(url, options);
};

_leaflet2["default"].supermap.dataFlowLayer = dataFlowLayer;

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.echartsLayer = exports.EchartsLayer = undefined;
exports.LeafletMapCoordSys = LeafletMapCoordSys;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _echarts = __webpack_require__(546);

var _echarts2 = _interopRequireDefault(_echarts);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.echartsLayer
 * @classdesc 百度ECharts图层类。
 * @extends L.Layer{@linkdoc-leaflet/#layer}
 * @param echartsOptions - {Object} 图表参数
 * @param options - {Object} 可选图层参数。<br>
 *        attribution - {string} 版权信息。<br>
 *        loadWhileAnimating - {boolean} 是否在启动时加载。
 */
var EchartsLayer = exports.EchartsLayer = _leaflet2["default"].Layer.extend({

    includes: [],
    _echartsContainer: null,
    _map: null,
    _ec: null,
    _echartsOptions: null,

    options: {
        attribution: "© 2017 百度 ECharts with <span>© <a href='http://iclient.supermap.io/' target='_blank'>SuperMap iClient</a></span>",
        loadWhileAnimating: true
    },

    initialize: function initialize(echartsOptions, options) {
        if (echartsOptions) {
            echartsOptions.LeafletMap = {
                roam: true
            };
        }
        this._echartsOptions = echartsOptions;
        _leaflet2["default"].Util.setOptions(this, options);
    },

    /**
     * @function L.supermap.echartsLayer.prototype.setOption
     * @description 设置图表地图参数
     * @param echartsOptions - {Object} 图表参数
     * @param notMerge - {boolean} 是否合并参数
     * @param lazyUpdate - {string} 后台自动更新
     */
    setOption: function setOption(echartsOptions, notMerge, lazyUpdate) {
        if (echartsOptions) {
            echartsOptions.LeafletMap = {
                roam: true
            };
        }
        this._echartsOptions = echartsOptions;
        this._ec.setOption(echartsOptions, notMerge, lazyUpdate);
    },

    _disableEchartsContainer: function _disableEchartsContainer() {
        this._echartsContainer.style.visibility = "hidden";
    },
    _enableEchartsContainer: function _enableEchartsContainer() {
        this._echartsContainer.style.visibility = "visible";
    },

    /**
     * @private
     * @function L.supermap.echartsLayer.prototype.onAdd
     * @description 添加地图
     * @param map - {L.map} 待添加的地图
     */
    onAdd: function onAdd(map) {
        this._map = map;
        this._initEchartsContainer();
        this._ec = _echarts2["default"].init(this._echartsContainer);
        _echarts2["default"].leafletMap = map;
        var me = this;
        map.on("zoomstart", function () {
            me._disableEchartsContainer();
        });
        _echarts2["default"].registerAction({
            type: 'LeafletMapLayout',
            event: 'LeafletMapLayout',
            update: 'updateLayout'
        }, function (payload, ecModel) {// eslint-disable-line no-unused-vars

        });
        _echarts2["default"].registerCoordinateSystem('leaflet', LeafletMapCoordSys);
        _echarts2["default"].extendComponentModel({
            type: 'LeafletMap',
            getBMap: function getBMap() {
                return this.__LeafletMap;
            },
            defaultOption: {
                roam: false
            }
        });
        _echarts2["default"].extendComponentView({
            type: 'LeafletMap',
            render: function render(LeafletMapModel, ecModel, api) {
                var rendering = true;
                var leafletMap = _echarts2["default"].leafletMap;
                var viewportRoot = api.getZr().painter.getViewportRoot();
                var coordSys = LeafletMapModel.coordinateSystem;
                var moveHandler = function moveHandler() {
                    if (rendering) {
                        return;
                    }
                    var bounds = map.getBounds();
                    var topLeft = map.latLngToLayerPoint(bounds.getNorthWest());
                    var mapOffset = [parseInt(topLeft.x, 10) || 0, parseInt(topLeft.y, 10) || 0];
                    viewportRoot.style.left = mapOffset[0] + 'px';
                    viewportRoot.style.top = mapOffset[1] + 'px';
                    coordSys.setMapOffset(mapOffset);
                    LeafletMapModel.__mapOffset = mapOffset;
                    api.dispatchAction({
                        type: 'LeafletMapLayout'
                    });
                };

                function zoomEndHandler() {
                    if (rendering) {
                        return;
                    }

                    api.dispatchAction({
                        type: 'LeafletMapLayout'
                    });
                    me._enableEchartsContainer();
                }

                if (me.options.loadWhileAnimating) {
                    leafletMap.off('move', this._oldMoveHandler);
                } else {
                    leafletMap.off('moveend', this._oldMoveHandler);
                }
                leafletMap.off('zoomend', this._oldZoomEndHandler);
                if (me.options.loadWhileAnimating) {
                    leafletMap.on('move', moveHandler);
                } else {
                    leafletMap.on('moveend', moveHandler);
                }
                leafletMap.on('zoomend', zoomEndHandler);
                this._oldMoveHandler = moveHandler;
                this._oldZoomEndHandler = zoomEndHandler;
                rendering = false;
            }
        });
        this._ec.setOption(this._echartsOptions);
    },

    onRemove: function onRemove() {
        // 销毁echarts实例
        this._ec.dispose();
    },

    _initEchartsContainer: function _initEchartsContainer() {
        var size = this._map.getSize();
        var _div = document.createElement('div');
        _div.style.position = 'absolute';
        _div.style.height = size.y + 'px';
        _div.style.width = size.x + 'px';
        _div.style.zIndex = 10;
        this._echartsContainer = _div;
        this._map.getPanes().overlayPane.appendChild(this._echartsContainer);
        var me = this;
        this._map.on('resize', function (e) {
            var size = e.newSize;
            me._echartsContainer.style.width = size.x + 'px';
            me._echartsContainer.style.height = size.y + 'px';
            me._ec.resize();
        });
    }

});

/**
 * @class L.supermap.LeafletMapCoordSys
 * @private
 * @classdesc 地图坐标系统类
 * @param LeafletMap - {L.map} 地图
 * @param api - {Object} 接口
 */
function LeafletMapCoordSys(LeafletMap, api) {
    this._LeafletMap = LeafletMap;
    this.dimensions = ['lng', 'lat'];
    this._mapOffset = [0, 0];
    this._api = api;
}

LeafletMapCoordSys.prototype.dimensions = ['lng', 'lat'];

LeafletMapCoordSys.prototype.setMapOffset = function (mapOffset) {
    this._mapOffset = mapOffset;
};

LeafletMapCoordSys.prototype.getBMap = function () {
    return this._LeafletMap;
};

LeafletMapCoordSys.prototype.prepareCustoms = function () {
    var zrUtil = _echarts2["default"].util;

    var rect = this.getViewRect();
    return {
        coordSys: {
            // The name exposed to user is always 'cartesian2d' but not 'grid'.
            type: 'leaflet',
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
        },
        api: {
            coord: zrUtil.bind(this.dataToPoint, this),
            size: zrUtil.bind(dataToCoordSize, this)
        }
    };

    function dataToCoordSize(dataSize, dataItem) {
        dataItem = dataItem || [0, 0];
        return zrUtil.map([0, 1], function (dimIdx) {
            var val = dataItem[dimIdx];
            var halfSize = dataSize[dimIdx] / 2;
            var p1 = [];
            var p2 = [];
            p1[dimIdx] = val - halfSize;
            p2[dimIdx] = val + halfSize;
            p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
            return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
        }, this);
    }
};

LeafletMapCoordSys.prototype.dataToPoint = function (data) {
    //处理数据中的null值
    if (data[1] === null) {
        data[1] = 85.4;
    }

    data[1] = this.fixLat(data[1]);

    var point = new _leaflet2["default"].latLng(data[1], data[0]);
    var px = this._LeafletMap.latLngToLayerPoint(point);
    var mapOffset = this._mapOffset;
    return [px.x - mapOffset[0], px.y - mapOffset[1]];
};

LeafletMapCoordSys.prototype.fixLat = function (lat) {
    if (lat >= 90) {
        return 89.99999999999999;
    }
    if (lat <= -90) {
        return -89.99999999999999;
    }
    return lat;
};

LeafletMapCoordSys.prototype.pointToData = function (pt) {
    var mapOffset = this._mapOffset;
    var point = this._LeafletMap.layerPointToLatLng([pt[0] + mapOffset[0], pt[1] + mapOffset[1]]);
    return [point.lng, point.lat];
};

LeafletMapCoordSys.prototype.getViewRect = function () {
    var api = this._api;
    return new _echarts2["default"].graphic.BoundingRect(0, 0, api.getWidth(), api.getHeight());
};

LeafletMapCoordSys.prototype.getRoamTransform = function () {
    return _echarts2["default"].matrix.create();
};
LeafletMapCoordSys.dimensions = LeafletMapCoordSys.prototype.dimensions;

LeafletMapCoordSys.create = function (ecModel, api) {
    var coordSys;

    ecModel.eachComponent('LeafletMap', function (LeafletMapModel) {
        var leafletMap = _echarts2["default"].leafletMap;
        coordSys = new LeafletMapCoordSys(leafletMap, api);
        coordSys.setMapOffset(LeafletMapModel.__mapOffset || [0, 0]);
        LeafletMapModel.coordinateSystem = coordSys;
    });
    ecModel.eachSeries(function (seriesModel) {
        if (seriesModel.get('coordinateSystem') === 'leaflet') {
            seriesModel.coordinateSystem = coordSys;
        }
    });
};

var echartsLayer = exports.echartsLayer = function echartsLayer(echartsOptions, options) {
    return new EchartsLayer(echartsOptions, options);
};

_leaflet2["default"].supermap.echartsLayer = echartsLayer;

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.graphicLayer = exports.GraphicLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.graphicLayer
 * @classdesc 高效率点图层类。
 * @extends L.Path{@linkdoc-leaflet/#path}
 * @param graphics - {Object} 图形对象
 * @param options - {Object} 可选参数。如：<br>
 *        stroke - {boolean} <br>
 *        color - {string} 颜色<br>
 *        weight - {number} 线宽<br>
 *        opacity - {number}透明度 <br>
 *        lineCap - {string} 线帽形状<br>
 *        lineJoin - {string} 线条交汇边角形状<br>
 *        fill - {boolean} 是否填充<br>
 *        fillColor - {string} 填充色<br>
 *        fillOpacity - {number}填充透明度<br>
 *        fillRule - {string} 填充规则<br>
 *        radius - {number}半径
 */
var GraphicLayer = exports.GraphicLayer = _leaflet2["default"].Path.extend({

    initialize: function initialize(graphics, options) {
        options = options || {};
        _leaflet2["default"].setOptions(this, options);
        this.graphics = graphics;
    },

    /**
     * @private
     * @function L.supermap.graphicLayer.prototype.getEvents
     * @description 获取事件
     * @return {Object} 返回该图层支持的事件对象
     */
    getEvents: function getEvents() {
        var events = {
            click: this._handleClick
        };
        return events;
    },

    /**
     * @private
     * @function L.supermap.graphicLayer.prototype.onAdd
     * @description 添加图形
     */
    onAdd: function onAdd() {
        this._canvas = document.createElement('canvas');
        var width = this._map.getPixelBounds().getSize().x;
        var height = this._map.getPixelBounds().getSize().y;
        this._canvas.width = width;
        this._canvas.height = height;
        this._ctx = this._canvas.getContext('2d');
        _leaflet2["default"].Path.prototype.onAdd.call(this);
    },

    _update: function _update() {
        if (this._map) {
            this._updatePath();
        }
    },

    _updatePath: function _updatePath() {
        this._renderer._drawGraphics(this._getGraphicsInBounds());
    },

    _project: function _project() {
        var me = this;
        me._getGraphicsInBounds().map(function (graphic) {
            var point = me._map.latLngToLayerPoint(graphic.getLatLng());
            var w = me._clickTolerance();
            var p = [graphic._anchor + w, graphic._anchor + w];
            graphic._pxBounds = new _leaflet2["default"].Bounds(point.subtract(p), point.add(p));
            return graphic;
        });
        me._pxBounds = _leaflet2["default"].bounds(_leaflet2["default"].point(0, 0), _leaflet2["default"].point(this._canvas.width, this._canvas.height));
    },

    _getGraphicsInBounds: function _getGraphicsInBounds() {
        var me = this;
        var graphicsInBounds = [];
        var viewBounds = me._map.getBounds();
        this.graphics.map(function (graphic) {
            if (viewBounds.contains(graphic.getLatLng())) {
                graphicsInBounds.push(graphic);
            }
            return graphic;
        });
        return graphicsInBounds;
    },

    _containsPoint: function _containsPoint() {
        return false;
    },

    _handleClick: function _handleClick(evt) {
        var me = this;
        var graphics = me._getGraphicsInBounds();
        for (var i = 0; i < graphics.length; i++) {
            var center = me._map.latLngToLayerPoint(graphics[i].getLatLng());
            var canvas = graphics[i].getCanvas();
            var p1 = _leaflet2["default"].point(center.x - canvas.width / 2, center.y - canvas.height / 2),
                p2 = _leaflet2["default"].point(center.x + canvas.width / 2, center.y + canvas.height / 2),
                bounds = _leaflet2["default"].bounds(p1, p2);
            if (bounds.contains(me._map.latLngToLayerPoint(evt.latlng))) {
                return me.options.handleClick.call(me, graphics[i]);
            }
        }
    }
});

_leaflet2["default"].Canvas.include({
    _drawGraphics: function _drawGraphics(graphics) {
        var me = this;
        me._ctx.clearRect(0, 0, me._ctx.canvas.width, me._ctx.canvas.height);
        graphics.map(function (graphic) {
            var canvas = graphic.getCanvas();
            var pt = me._map.latLngToLayerPoint(graphic.getLatLng());
            var p0 = pt.x - canvas.width / 2;
            var p1 = pt.y - canvas.height / 2;
            me._ctx.drawImage(canvas, p0, p1);
            return graphic;
        });
    }
});

var graphicLayer = exports.graphicLayer = function graphicLayer(graphics, options) {
    return new GraphicLayer(graphics, options);
};

_leaflet2["default"].supermap.graphicLayer = graphicLayer;

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.mapVLayer = exports.MapVLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _MapVRenderer = __webpack_require__(448);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.mapVLayer
 * @classdesc MapV图层
 * @extends L.Layer{@linkdoc-leaflet/#layer}
 * @param dataSet - {mapv.DataSet} MapV图层数据集
 * @param mapVOptions - {Object} MapV图层参数
 * @param options - {Object} 可选参数。如：<br>
 *        attributionPrefix - {string} 版权信息前缀。<br>
 *        attribution - {string} 版权信息。
 */
var MapVLayer = exports.MapVLayer = _leaflet2["default"].Layer.extend({

    options: {
        attributionPrefix: null,
        attribution: " © 2017 百度 MapV with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(dataSet, mapVOptions, options) {
        options = options || {};
        this.dataSet = dataSet || {};
        this.mapVOptions = mapVOptions || {};
        this.render = this.render.bind(this);
        _leaflet2["default"].Util.setOptions(this, options);
        if (this.options.attributionPrefix) {
            this.options.attribution = this.options.attributionPrefix + this.options.attribution;
        }

        this.canvas = this._createCanvas();
        _leaflet2["default"].stamp(this);
    },

    /**
     * @private
     * @function L.supermap.mapVLayer.prototype.onAdd
     * @description 添加地图图层
     * @param map - {L.map} 要添加的地图
     */
    onAdd: function onAdd(map) {
        this._map = map;
        var overlayPane = this.getPane();
        var container = this.container = _leaflet2["default"].DomUtil.create("div", "leaflet-layer leaflet-zoom-animated", overlayPane);
        container.appendChild(this.canvas);
        var size = map.getSize();
        container.style.width = size.x + "px";
        container.style.height = size.y + "px";
        this.renderer = new _MapVRenderer.MapVRenderer(map, this, this.dataSet, this.mapVOptions);
        this.draw();
        this.fire("loaded");
    },

    // _hide: function () {
    //     this.canvas.style.display = 'none';
    // },

    // _show: function () {
    //     this.canvas.style.display = 'block';
    // },

    /**
     * @private
     * @function L.supermap.mapVLayer.prototype.onRemove
     * @description 删除地图图层
     */
    onRemove: function onRemove() {
        _leaflet2["default"].DomUtil.remove(this.container);
        this.renderer.unbindEvent();
    },

    /**
     * @function L.supermap.mapVLayer.prototype.addData
     * @description 追加数据
     * @param data - {Object} 要追加的数据
     * @param options -{Object} 要追加的值
     */
    addData: function addData(data, options) {
        this.renderer.addData(data, options);
    },

    /**
     * @function L.supermap.mapVLayer.prototype.update
     * @description 更新图层
     * @param opt - {Object} 待更新的数据<br>
     *        data -{Object} mapv数据集<br>
     *        options -{Object} mapv绘制参数<br>
     */
    update: function update(opt) {
        this.renderer.update(opt);
    },

    /**
     * @function L.supermap.mapVLayer.prototype.getData
     * @description 获取数据
     * @return {mapv.DataSet} mapv数据集
     */
    getData: function getData() {
        if (this.renderer) {
            this.dataSet = this.renderer.getData();
        }
        return this.dataSet;
    },

    /**
     * @function L.supermap.mapVLayer.prototype.removeData
     * @description 删除符合过滤条件的数据
     * @param filter - {function} 过滤条件。条件参数为数据项，返回值为true,表示删除该元素；否则表示不删除
     * @example
     *  filter=function(data){
     *    if(data.id=="1"){
     *      return true
     *    }
     *    return false;
     *  }
     */
    removeData: function removeData(filter) {
        this.renderer && this.renderer.removeData(filter);
    },

    /**
     * @function L.supermap.mapVLayer.prototype.clearData
     * @description 清除数据
     */
    clearData: function clearData() {
        this.renderer.clearData();
    },

    /**
     * @function L.supermap.mapVLayer.prototype.draw
     * @description 绘制图层
     */
    draw: function draw() {
        return this._reset();
    },

    /**
     * @function L.supermap.mapVLayer.prototype.setZIndex
     * @description 设置canvas层级
     * @param zIndex - {number} canvas层级
     */
    setZIndex: function setZIndex(zIndex) {
        this.canvas.style.zIndex = zIndex;
    },

    /**
     * @function L.supermap.mapVLayer.prototype.render
     * @description 渲染
     */
    render: function render() {
        this.renderer._canvasUpdate();
    },

    /**
     * @function L.supermap.mapVLayer.prototype.getCanvas
     * @description 获取canvas
     * @return {HTMLElement} 返回mapV图层包含的canvas对象
     */
    getCanvas: function getCanvas() {
        return this.canvas;
    },

    /**
     * @function L.supermap.mapVLayer.prototype.getContainer
     * @description 获取容器
     * @return {HTMLElement} 返回包含mapV图层的dom对象
     */
    getContainer: function getContainer() {
        return this.container;
    },

    /**
     * @function L.supermap.mapVLayer.prototype.getTopLeft
     * @description 获取左上角坐标
     * @return {L.Bounds} 返回左上角坐标
     */
    getTopLeft: function getTopLeft() {
        var map = this._map;
        var topLeft;
        if (map) {
            var bounds = map.getBounds();
            topLeft = bounds.getNorthWest();
        }
        return topLeft;
    },

    _createCanvas: function _createCanvas() {
        var canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.top = 0 + "px";
        canvas.style.left = 0 + "px";
        canvas.style.pointerEvents = "none";
        canvas.style.zIndex = this.options.zIndex || 600;
        var global$2 = typeof window === 'undefined' ? {} : window;
        var devicePixelRatio = this.devicePixelRatio = global$2.devicePixelRatio;
        if (this.mapVOptions.context == '2d') {
            canvas.getContext(this.mapVOptions.context).scale(devicePixelRatio, devicePixelRatio);
        }
        return canvas;
    },

    _resize: function _resize() {
        var canvas = this.canvas;
        if (!canvas) {
            return;
        }

        var map = this._map;
        var size = map.getSize();
        canvas.width = size.x;
        canvas.height = size.y;
        canvas.style.width = size.x + 'px';
        canvas.style.height = size.y + 'px';
        var bounds = map.getBounds();
        var topLeft = map.latLngToLayerPoint(bounds.getNorthWest());
        _leaflet2["default"].DomUtil.setPosition(canvas, topLeft);
    },

    _reset: function _reset() {
        this._resize();
        this._render();
    },
    redraw: function redraw() {
        this._resize();
        this._render();
    },
    _render: function _render() {
        this.render();
    }

});

var mapVLayer = exports.mapVLayer = function mapVLayer(dataSet, mapVOptions, options) {
    return new MapVLayer(dataSet, mapVOptions, options);
};

_leaflet2["default"].Map.include({
    /*
     * 获取精确的像素坐标.
     * 当需要绘制比较平滑的曲线的时候可调用此方法代替latLngToContainerPoint
     * @param latlng
     */
    latLngToAccurateContainerPoint: function latLngToAccurateContainerPoint(latlng) {
        var projectedPoint = this.project(_leaflet2["default"].latLng(latlng));
        var layerPoint = projectedPoint._subtract(this.getPixelOrigin());
        return _leaflet2["default"].point(layerPoint).add(this._getMapPanePos());
    }
});

_leaflet2["default"].supermap.mapVLayer = mapVLayer;

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.rankSymbolThemeLayer = exports.RankSymbolThemeLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

var _GraphThemeLayer = __webpack_require__(128);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.rankSymbolThemeLayer
 * @classdesc 符号专题图图层。
 * @description 符号专题图通过为每个要素绘制符号大小来反映其对应的专题值的大小；它只能表示单个个字段属性信息。
 *            符号专题图多用于具有相关数量特征的地图上，比如表示不同地区粮食产量、GDP、人口等。
 *            即通过制作一个符号专题图，就可以清晰展示各个区域相关Value的分布差异等。
 *           目前提供的符号图形有：圆形（后续进行扩展 心形 五角星 多角心 图片等）
 * @extends L.supermap.GraphThemeLayer
 * @param name - {string} 专题图层名
 * @param symbolType - {SuperMap.ChartType} 必设参数，目前支持："Circle"。
 * @param options - {Object} 可选参数<br>
 *          symbolType<SuperMap.ChartType>，必设参数，目前支持："Circle"。<br>
 *          symbolSetting:各类型图表的 symbolSetting 对象可设属性请参考图表模型类的注释中对 symbolSetting 对象可设属性的描述。
 *              所有图表类型的 symbolSetting 对象通常都具有以下 5 个基础可设属性：
 *  * codomain - {Array{number}} 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。
 *  * XOffset - {number}  专题要素（图形）在 X 方向上的偏移值，单位像素。
 *  * YOffset - {number}  专题要素（图形）在 Y 方向上的偏移值，单位像素。
 *  * dataViewBoxParameter - {Array{number}} 数据视图框 dataViewBox 参数，
 *  它是指图形框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值，长度为 4 的一维数组。
 *  * decimalNumber - {number}数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。
 */
var RankSymbolThemeLayer = exports.RankSymbolThemeLayer = _GraphThemeLayer.GraphThemeLayer.extend({

    initialize: function initialize(name, symbolType, options) {
        // eslint-disable-line no-unused-vars
        _GraphThemeLayer.GraphThemeLayer.prototype.initialize.apply(this, arguments);
        this.symbolType = symbolType;
        this.symbolSetting = {};
    },

    /**
     * @function L.supermap.rankSymbolThemeLayer.prototype.setSymbolType
     * @description 设置符号类型，此函数可动态改变图表类型。在调用此函数前请通过 symbolSetting 为新类型的图表做相关配置。
     * @param symbolType - {SuperMap.ChartType} 目前支持："Circle"。 //todo 这里怎么又是supermap的类型
     */
    setSymbolType: function setSymbolType(symbolType) {
        this.symbolType = symbolType;
        this.redraw();
    },

    /**
     * @function L.supermap.rankSymbolThemeLayer.prototype.createThematicFeature
     * @description 创建专题要素（图形）
     * @param feature  - {SuperMap.Feature.Vector} 要创建的专题图形要素
     * @return {SuperMap.Feature.Theme} 专题图形
     */
    createThematicFeature: function createThematicFeature(feature) {
        var me = this;
        var thematicFeature;
        // 检查图形创建条件并创建图形
        if (_iclientCommon.FeatureTheme[me.symbolType] && me.themeField && me.symbolSetting) {
            thematicFeature = new _iclientCommon.FeatureTheme[me.symbolType](feature, me, [me.themeField], me.symbolSetting);
        }

        // thematicFeature 是否创建成功
        if (!thematicFeature) {
            return false;
        }

        // 对专题要素执行图形装载
        thematicFeature.assembleShapes();

        return thematicFeature;
    }

});

var rankSymbolThemeLayer = exports.rankSymbolThemeLayer = function rankSymbolThemeLayer(name, symbolType, options) {
    return new RankSymbolThemeLayer(name, symbolType, options);
};

_leaflet2["default"].supermap.rankSymbolThemeLayer = rankSymbolThemeLayer;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tiledVectorLayer = exports.TileVectorLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _VectorGrid = __webpack_require__(452);

var _CartoCSSToLeaflet = __webpack_require__(283);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.tiledVectorLayer
 * @classdesc SuperMap iServer的矢量瓦片图层
 * @extends L.supermap.VectorGrid
 * @example
 *      L.supermap.tiledVectorLayer(url).addTo(map);
 * @param url - {string} 图层数据服务地址
 * @param options - {Object} 图层可选参数
 */
var TileVectorLayer = exports.TileVectorLayer = _VectorGrid.VectorGrid.extend({

    options: {
        //服务器类型<SuperMap.ServerType>iServer|iPortal|Online
        serverType: null,
        crs: null,
        cartoCSS: null,
        // 指定图层的名称列表。支持的类型为矢量图层
        layerNames: null,
        //获取进行切片的地图图层 ID
        layersID: null,
        //是否服务端CartoCSS样式，默认使用
        serverCartoCSSStyle: true,

        returnAttributes: false,

        /*各图层扩展的像素值。
         *例如：
         * 0_15:0_5,1_10：表示顶级0图层的0、1子图层扩展的像素分别为5、10像素；顶级0图层下，除0、1图层外的子图层的扩展像素都为15像素。
         * 0:0_5,1_10：表示顶级0图层的0、1子图层扩展的像素分别为5、10像素；顶级0图层下，其他除0、1图层外的子图层的扩展像素为根据该图层默认样式计算得出的默认值。
         */
        expands: null,
        cacheEnabled: false,
        //瓦片模板，如果设置了此参数，则按此模板出图，url无效（对接第三方瓦片）
        tileTemplate: null,
        subdomains: 'abc',

        timeout: 10000,
        attribution: " with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(url, options) {
        options = options || {};
        options.noWrap = options.noWrap == null ? true : options.noWrap;
        _leaflet2["default"].setOptions(this, options);
        _VectorGrid.VectorGrid.prototype.initialize.call(this, options);
        _leaflet2["default"].stamp(this);
        var me = this;

        if (!url || url === "" || url.indexOf("http") < 0) {
            url = "";
            return this;
        }

        me.url = url;
        if (url && url.indexOf("/") === url.length - 1) {
            url = url.substr(0, url.length - 1);
            me.url = url;
        }
        this.cartoCSSToLeaflet = new _CartoCSSToLeaflet.CartoCSSToLeaflet(me.url);
        me.initLayersInfo();
        if (!me.options.serverCartoCSSStyle && me.options) {
            me.setClientCartoCSS(me.options.cartoCSS);
        }
    },

    /**
     * @private
     * @function L.supermap.tiledVectorLayer.prototype.onAdd
     * @description 添加地图
     * @param map - {L.map} 待添加的地图
     */
    onAdd: function onAdd(map) {
        this._crs = this.options.crs || map.options.crs;
        this._map = map;
        this._initLayerUrl();
        if (this.options.tileTemplate || !this.options.serverCartoCSSStyle) {
            this._initGrid();
        }
    },

    /**
     * @private
     * @function L.supermap.tiledVectorLayer.prototype.initLayersInfo
     * @description 获取服务器layers资源下的风格信息(当CartoCSS中不存在相应图层渲染信息时使用)
     */
    initLayersInfo: function initLayersInfo() {
        var me = this;
        var layersUrl = me.url + "/layers.json";
        _iclientCommon.FetchRequest.get(layersUrl, null, {
            timeout: me.options.timeout
        }).then(function (response) {
            return response.json();
        }).then(function (json) {
            me.layersInfoInitialized = true;
            me.layersInfo = json;
            if (!me.layersInfo) {
                return;
            }
            var layersInfo = {};
            for (var i = 0, len = me.layersInfo.length; i < len; i++) {
                var layers = me.layersInfo[i].subLayers.layers;
                for (var j = 0, len1 = layers.length; j < len1; j++) {
                    layers[j].layerIndex = len1 - j;
                    layersInfo[layers[j].name] = layers[j];
                }
            }
            me.layersInfo = layersInfo;
            if (me.options.serverCartoCSSStyle) {
                me.getVectorStylesFromServer();
            }
        })["catch"](function (ex) {
            console.error('error', ex);
        });
    },

    /**
     * @function L.supermap.tiledVectorLayer.prototype.getLayerStyleInfo
     * @description 获取图层样式信息
     * @param layerName - {string} 图层名称
     */
    getLayerStyleInfo: function getLayerStyleInfo(layerName) {
        var me = this,
            layerInfo_simple;
        me.layersStyles = me.layersStyles || {};

        layerInfo_simple = me.layersStyles[layerName];
        if (layerInfo_simple) {
            return layerInfo_simple;
        }

        if (!me.layersInfo) {
            return {};
        }
        var layerInfo = me.layersInfo[layerName];
        if (!layerInfo) {
            return null;
        }
        layerInfo_simple = { layerIndex: layerInfo.layerIndex, ugcLayerType: layerInfo.ugcLayerType };
        switch (layerInfo.ugcLayerType) {
            case "VECTOR":
                layerInfo_simple.layerStyle = layerInfo.style ? layerInfo.style : null;
                break;
            case "THEME":
                var theme = layerInfo.theme;
                //标注图层特别标明
                layerInfo_simple.layerStyle = theme ? theme.defaultStyle : null;
                if (theme && theme.type === "LABEL") {
                    layerInfo_simple.type = theme.type;
                    layerInfo_simple.textField = theme.labelExpression;
                }
                break;
            default:
                //SVTile发布出来的地图没有ugcLayerType属性
                if (layerInfo.style) {
                    layerInfo_simple.layerStyle = layerInfo.style;
                }
                break;
        }
        me.layersStyles[layerName] = layerInfo_simple;
        return layerInfo_simple;
    },

    /*
     * @function L.supermap.tiledVectorLayer.prototype.getVectorStylesFromServer
     * @description 等待服务器的carto返回之后拼接本地配置的cartoCSS,并调用onAdd出图
     */
    getVectorStylesFromServer: function getVectorStylesFromServer() {
        var me = this;
        var vectorStyleUrl = me.url + "/tileFeature/vectorstyles.json";
        _iclientCommon.FetchRequest.get(vectorStyleUrl, null, {
            timeout: me.options.timeout
        }).then(function (response) {
            return response.json();
        }).then(function (styles) {
            if (!styles || !styles.style) {
                return null;
            }
            if (styles.style && styles.type === 'cartoCSS') {
                me.setServerCartoCSS(styles.style);
            }
            if (me.options) {
                me.setClientCartoCSS(me.options.cartoCSS);
            }
            me._initGrid();
        })["catch"](function (ex) {
            console.error('error', ex);
        });
    },

    /**
     * @private
     * @function L.supermap.tiledVectorLayer.prototype.setServerCartoCSS
     * @description 设置服务端获取到的cartoCSS样式,cartoCSS请求回来之后自动调用
     */
    setServerCartoCSS: function setServerCartoCSS(cartoCSSStr) {
        this.cartoCSSToLeaflet.pretreatedCartoCSS(cartoCSSStr, true);
    },
    /**
     * @function L.supermap.tiledVectorLayer.prototype.setClientCartoCSS
     * @description 客户端设置cartoCSS样式
     */
    setClientCartoCSS: function setClientCartoCSS(cartoCSSStr) {
        this.cartoCSSToLeaflet.pretreatedCartoCSS(cartoCSSStr, false);
    },

    /**
     * @private
     * @function L.supermap.tiledVectorLayer.prototype.getVectorTileLayerStyle
     * @description 获取图层风格信息，当CartoCSS中包含有对该图层的渲染信息时，优先获取,否则获取layers资源下layerSytle的渲染信息
     * @param coords - {Object} 图层坐标参数对象
     * @param feature - {L.feature} 要获取的要是
     */
    getVectorTileLayerStyle: function getVectorTileLayerStyle(coords, feature) {
        if (!feature) {
            return null;
        }
        var me = this,
            layerName = feature.layerName,
            layerStyleInfo = me.getLayerStyleInfo(layerName);

        //处理标签图层
        if (layerStyleInfo.textField) {
            var textField = layerStyleInfo.textField;
            if (textField && textField.indexOf('.')) {
                var arr = textField.split('.');
                textField = arr && arr.length > 0 && arr[arr.length - 1];
            }
            feature.properties.textField = textField;
        }

        me.vectorTileLayerStyles = me.vectorTileLayerStyles || {};

        var style = me.vectorTileLayerStyles[layerName];
        if (style) {
            feature = this._mergeFeatureTextField(feature, style);
            return style;
        }

        // SuperMap.CartoCSSToLeaflet内部做了客户端配置的cartoCSS和服务端cartoCSS的拼接处理
        // 客户端配置的cartoCSS会覆盖相应图层的服务端cartoCSS
        if (!style) {
            var scale = this.getScaleFromCoords(coords);
            var shaders = this.cartoCSSToLeaflet.pickShader(layerName) || [];
            style = [];
            for (var itemKey in shaders) {
                var shader = shaders[itemKey];
                for (var j = 0; j < shader.length; j++) {
                    var serverStyle = this.cartoCSSToLeaflet.getValidStyleFromCarto(coords.z, scale, shader[j], feature);
                    if (serverStyle) {
                        style.push(serverStyle);
                    }
                }
            }
        }

        feature = this._mergeFeatureTextField(feature, style);

        //次优先级是layers资源的默认的样式，最低优先级是CartoDefaultStyle的样式
        if (feature.type === "TEXT" || !style || style.length < 1) {
            style = this.cartoCSSToLeaflet.getValidStyleFromLayerInfo(feature, layerStyleInfo);
            if (feature.type === "TEXT") {
                style.textName = "[" + feature.properties.textField + "]";
            }
        }

        me.vectorTileLayerStyles[layerName] = style;
        return style;
    },

    /**
     * @function L.supermap.tiledVectorLayer.prototype.getScale
     * @description 通过缩放级别获取比例尺
     * @param zoom - {number}缩放级别
     * @return {number} 比例尺
     */
    getScale: function getScale(zoom) {
        var me = this;
        //返回当前比例尺
        var z = zoom || me._map.getZoom();
        return me.scales[z];
    },

    /**
     * @function L.supermap.tiledVectorLayer.prototype.getScaleFromCoords
     * @description 通过行列号获取比例尺
     * @param coords - {Object} 行列号
     * @return {number} 比例尺
     */
    getScaleFromCoords: function getScaleFromCoords(coords) {
        var me = this,
            scale;
        if (me.scales && me.scales[coords.z]) {
            return me.scales[coords.z];
        }
        me.scales = me.scales || {};
        scale = me.getDefaultScale(coords);
        me.scales[coords.z] = scale;
        return scale;
    },

    /**
     * @private
     * @function L.supermap.tiledVectorLayer.prototype.getDefaultScale
     * @description 根据行列号获取默认比例尺
     * @param coords - {Object} 行列号
     * @return {number} 默认比例尺
     */
    getDefaultScale: function getDefaultScale(coords) {
        var me = this,
            crs = me._crs;
        var resolution;
        if (crs.options && crs.options.resolutions) {
            resolution = crs.options.resolutions[coords.z];
        } else {
            var tileBounds = me._tileCoordsToBounds(coords);
            var ne = crs.project(tileBounds.getNorthEast());
            var sw = crs.project(tileBounds.getSouthWest());
            var tileSize = me.options.tileSize;
            resolution = Math.max(Math.abs(ne.x - sw.x) / tileSize, Math.abs(ne.y - sw.y) / tileSize);
        }

        var mapUnit = _iclientCommon.Unit.METER;
        if (crs.code && crs.code.indexOf("4326") > -1) {
            mapUnit = _iclientCommon.Unit.DEGREE;
        }
        return _leaflet2["default"].Util.resolutionToScale(resolution, 96, mapUnit);
    },

    _mergeFeatureTextField: function _mergeFeatureTextField(feature, style) {
        //如果设置了使用服务端cartocss样式，则文本专题图图层优先从carto中读取文本字段的key
        if (!this.options.serverCartoCSSStyle || !style || feature.type !== "TEXT") {
            return feature;
        }

        var tempStyle = style;
        if (!_leaflet2["default"].Util.isArray(style)) {
            tempStyle = [style];
        }
        for (var i = 0; i < tempStyle.length; i++) {
            var textName = tempStyle[i].textName;
            if (textName && feature.properties) {
                feature.properties.textField = textName.substring(1, textName.length - 1);
            }
        }

        return feature;
    },

    _getTileUrl: function _getTileUrl(coords) {
        var me = this,
            tileTemplate = me.options.tileTemplate;
        if (!tileTemplate) {
            return me._getDefaultTileUrl(coords);
        }
        return me._getTileTemplateUrl(coords);
    },

    _getTileTemplateUrl: function _getTileTemplateUrl(coords) {
        var me = this,
            tileTemplate = me.options.tileTemplate;
        var data = {
            s: me._getSubdomain(coords),
            x: coords.x,
            y: coords.y,
            z: coords.z
        };
        if (me._map && !me._map.options.crs.infinite) {
            var invertedY = me._globalTileRange.max.y - coords.y;
            if (me.options.tms) {
                data['y'] = invertedY;
            }
            data['-y'] = invertedY;
        }

        var tileUrl = _leaflet2["default"].Util.template(tileTemplate, _leaflet2["default"].extend(data, me.options));
        return tileUrl;
    },

    _initGrid: function _initGrid() {
        _VectorGrid.VectorGrid.prototype.onAdd.call(this, this._map);
    },

    _getSubdomain: _leaflet2["default"].TileLayer.prototype._getSubdomain,
    _getDefaultTileUrl: function _getDefaultTileUrl(coords) {
        var x = coords.x,
            y = coords.y;
        var tileUrl = this._tileUrl + "&x=" + x + "&y=" + y;
        var scale = this.getScaleFromCoords(coords);
        tileUrl += "&scale=" + scale;
        return tileUrl;
    },

    _initLayerUrl: function _initLayerUrl() {
        var options = this.options;
        if (!this.url) {
            return;
        }
        var format = options.format.toString().toLowerCase();
        this._tileUrl = this.url + "/tileFeature." + format + "?";
        this._tileUrl += this._createURLParam(options);
    },

    _createURLParam: function _createURLParam(options) {
        var params = [];

        //添加安全认证信息
        var credential = this._getCredential();
        if (credential) {
            params.push(credential);
        }
        if (options.layersID) {
            params.push("layersID=" + options.layersID);
        }
        if (options.layerNames) {
            if (!_leaflet2["default"].Util.isArray(options.layerNames)) {
                options.layerNames = [options.layerNames];
            }
            var layerNamesString = '[' + options.layerNames.join(',') + ']';
            params.push("layerNames=" + layerNamesString);
        }
        //切片的起始参考点，默认为地图范围的左上角。
        var crs = this._crs;
        if (crs.options && crs.options.origin) {
            params.push("origin=" + JSON.stringify({ x: crs.options.origin[0], y: crs.options.origin[1] }));
        } else if (crs.projection && crs.projection.bounds) {
            var bounds = crs.projection.bounds;
            var tileOrigin = _leaflet2["default"].point(bounds.min.x, bounds.max.y);
            params.push("origin=" + JSON.stringify({ x: tileOrigin.x, y: tileOrigin.y }));
        }
        if (options.expands) {
            params.push("expands=" + options.expands);
        }

        params.push("returnAttributes=" + options.returnAttributes);

        params.push("cacheEnabled=" + options.cacheEnabled);

        var tileSize = this.options.tileSize;
        params.push("width=" + tileSize);
        params.push("height=" + tileSize);
        return params.join("&");
    },

    //获取token或key表达式
    _getCredential: function _getCredential(url) {
        var credential, value;
        switch (this.options.serverType) {
            case _iclientCommon.ServerType.IPORTAL:
                value = _iclientCommon.SecurityManager.getToken(url);
                credential = value ? new _iclientCommon.Credential(value, "token") : null;
                if (!credential) {
                    value = _iclientCommon.SecurityManager.getKey(url);
                    credential = value ? new _iclientCommon.Credential(value, "key") : null;
                }
                break;
            case _iclientCommon.ServerType.ONLINE:
                value = _iclientCommon.SecurityManager.getKey(url);
                credential = value ? new _iclientCommon.Credential(value, "key") : null;
                break;
            default:
                //iserver or others
                value = _iclientCommon.SecurityManager.getToken(url);
                credential = value ? new _iclientCommon.Credential(value, "token") : null;
                break;
        }
        if (credential) {
            return credential.getUrlParameters();
        }
        return null;
    }
});

var tiledVectorLayer = exports.tiledVectorLayer = function tiledVectorLayer(url, options) {
    return new TileVectorLayer(url, options);
};

_leaflet2["default"].supermap.tiledVectorLayer = tiledVectorLayer;

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.turfLayer = exports.TurfLayer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _turf = __webpack_require__(549);

var _turf2 = _interopRequireDefault(_turf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.turfLayer
 * @classdesc Turf图层
 * @extends L.Layer{@linkdoc-leaflet/#geojson}
 * @param options - {Object} 可选参数。如：<br>
 *        attribution - {string} 版权信息。
 */
var TurfLayer = exports.TurfLayer = _leaflet2["default"].GeoJSON.extend({

    turfMap: {
        "Measurement.along": ["line", "distance", "units"],
        "Measurement.area": ["geojson"],
        "Measurement.bbox": ["geojson"],
        "Measurement.bboxPolygon": ["bbox"],
        "Measurement.bearing": ["start", "end", "final"],
        "Measurement.center": ["geojson", "properties"],
        "Measurement.centerOfMass": ["geojson", "properties"],
        "Measurement.centroid": ["geojson", "properties"],
        "Measurement.destination": ["origin", "distance", "bearing", "units"],
        "Measurement.distance": ["from", "to", "units"],
        "Measurement.envelope": ["geojson"],
        "Measurement.lineDistance": ["geojson", "units"],
        "Measurement.midpoint": ["point1", "point2"],
        "Measurement.pointOnSurface": ["fc"],
        "Measurement.polygonTangents": ["point", "polygon"],
        "Measurement.rhumbBearing": ["start", "end", "final"],
        "Measurement.rhumbDestination": ["origin", "distance", "bearing", "units"],
        "Measurement.rhumbDistance": ["from", "to", "units"],
        "Measurement.square": ["bbox"],
        "Measurement.greatCircle": ["start", "end", "properties", "npoints", "offset"],
        "CoordinateMutation.flip": ["geojson", "mutate"],
        "CoordinateMutation.rewind": ["geojson", "reverse", "mutate"],
        "CoordinateMutation.round": ["num", "precision"],
        "CoordinateMutation.truncate": ["geojson", "precision", "coordinates", "mutate"],
        "Transformation.bboxClip": ["feature", "bbox"],
        "Transformation.bezier": ["line", "resolution", "sharpness"],
        "Transformation.buffer": ["geojson", "radius", "units", "steps"],
        "Transformation.circle": ["center", "radius", "steps", "units", "properties"],
        "Transformation.clone": ["geojson", "cloneAll"],
        "Transformation.concave": ["points", "maxEdge", "units"],
        "Transformation.convex": ["feature"],
        "Transformation.difference": ["polygon1", "polygon2"],
        "Transformation.dissolve": ["featureCollection", "propertyName"],
        "Transformation.intersect": ["poly1", "poly2"],
        "Transformation.lineOffset": ["geojson", "distance", "units"],
        "Transformation.simplify": ["feature", "tolerance", "highQuality"],
        "Transformation.tesselate": ["poly"],
        "Transformation.transformRotate": ["geojson", "angle", "pivot", "mutate"],
        "Transformation.transformTranslate": ["geojson", "distance", "direction", "units", "zTranslation", "mutate"],
        "Transformation.transformScale": ["geojson", "factor", "origin", "mutate"],
        "Transformation.union": ["A"],
        "featureConversion.combine": ["fc"],
        "featureConversion.explode": ["geojson"],
        "featureConversion.flatten": ["geojson"],
        "featureConversion.lineStringToPolygon": ["lines", "properties", "autoComplete", "orderCoords"],
        "featureConversion.polygonize": ["geojson"],
        "featureConversion.polygonToLineString": ["polygon", "properties"],
        "Misc.kinks": ["featureIn"],
        "Misc.lineArc": ["center", "radius", "bearing1", "bearing2", "steps", "units"],
        "Misc.lineChunk": ["geojson", "segmentLength", "units", "reverse"],
        "Misc.lineIntersect": ["line1", "line2"],
        "Misc.lineOverlap": ["line1", "line2"],
        "Misc.lineSegment": ["geojson"],
        "Misc.lineSlice": ["startPt", "stopPt", "line"],
        "Misc.lineSliceAlong": ["line", "startDist", "stopDist", "units"],
        "Misc.lineSplit": ["line", "splitter"],
        "Misc.mask": ["polygon", "mask"],
        "Misc.pointOnLine": ["lines", "pt", "units"],
        "Misc.sector": ["center", "radius", "bearing1", "bearing2", "steps", "units"],
        "Misc.unkinkPolygon": ["geojson"],
        "Helper.featureCollection": ["features"],
        "Helper.feature": ["geometry", "properties"],
        "Helper.geometryCollection": ["geometries", "properties"],
        "Helper.lineString": ["coordinates", "properties"],
        "Helper.multiLineString": ["coordinates", "properties"],
        "Helper.multiPoint": ["coordinates", "properties"],
        "Helper.multiPolygon": ["coordinates", "properties"],
        "Helper.point": ["coordinates", "properties"],
        "Helper.polygon": ["coordinates", "properties"],
        "Data.random": ["type", "count", "options"],
        "Data.sample": ["featurecollection", "num"],
        "Interpolation.interpolate": ["points", "cellSize", "gridType", "property", "units", "weight"],
        "Interpolation.isobands": ["pointGrid", "breaks", "zProperty", "options"],
        "Interpolation.isolines": ["pointGrid", "breaks", "zProperty", "propertiesToAllIsolines", "propertiesPerIsoline"],
        "Interpolation.planepoint": ["point", "triangle"],
        "Interpolation.tin": ["points", "z"],
        "Interpolation.idw": ["controlPoints", "valueField", "weight", "cellWidth", "units"],
        "Joins.inside": ["point", "polygon", "ignoreBoundary"],
        "Joins.within": ["points", "polygons"],
        "Joins.tag": ["points", "polygons", "field", "outField"],
        "Grids.hexGrid": ["bbox", "cellDiameter", "units", "triangles"],
        "Grids.pointGrid": ["bbox", "cellSide", "units", "centered", "bboxIsMask"],
        "Grids.squareGrid": ["bbox", "cellSize", "units", "completelyWithin"],
        "Grids.triangleGrid": ["bbox", "cellSize", "units"],
        "Classification.nearest": ["targetPoint", "points"],
        "Aggregation.collect": ["polygons", "points", "inProperty", "outProperty"],
        "Aggregation.clustersDbscan": ["points", "maxDistance", "units", "minPoints"],
        "Aggregation.clustersKmeans": ["points", "numberOfClusters", "mutate"],
        "Meta.coordAll": ["geojson"],
        "Meta.coordEach": ["geojson", "callback", "excludeWrapCoord"],
        "Meta.coordReduce": ["geojson", "callback", "initialValue", "excludeWrapCoord"],
        "Meta.featureEach": ["geojson", "callback"],
        "Meta.featureReduce": ["geojson", "callback", "initialValue"],
        "Meta.flattenEach": ["geojson", "callback"],
        "Meta.flattenReduce": ["geojson", "callback", "initialValue"],
        "Meta.getCoord": ["obj"],
        "Meta.getCoords": ["obj"],
        "Meta.getGeom": ["obj"],
        "Meta.getGeomType": ["obj"],
        "Meta.geomEach": ["geojson", "callback"],
        "Meta.geomReduce": ["geojson", "callback", "initialValue"],
        "Meta.propEach": ["geojson", "callback"],
        "Meta.propReduce": ["geojson", "callback", "initialValue"],
        "Meta.segmentEach": ["geojson", "callback"],
        "Meta.segmentReduce": ["geojson", "callback", "initialValue"],
        "Meta.getCluster": ["geojson", "filter"],
        "Meta.clusterEach": ["geojson", "property", "callback"],
        "Meta.clusterReduce": ["geojson", "property", "callback", "initialValue"],
        "Assertions.collectionOf": ["featureCollection", "type", "name"],
        "Assertions.containsNumber": ["coordinates"],
        "Assertions.geojsonType": ["value", "type", "name"],
        "Assertions.featureOf": ["feature", "type", "name"],
        "Booleans.booleanClockwise": ["line"],
        "Booleans.booleanContains": ["feature1", "feature2"],
        "Booleans.booleanCrosses": ["feature1", "feature2"],
        "Booleans.booleanDisjoint": ["feature1", "feature2"],
        "Booleans.booleanOverlap": ["feature1", "feature2"],
        "Booleans.booleanPointOnLine": ["point", "linestring", "ignoreEndVertices"],
        "UnitConversion.bearingToAngle": ["bearing"],
        "UnitConversion.convertArea": ["area", "originalUnit", "finalUnit"],
        "UnitConversion.convertDistance": ["distance", "originalUnit", "finalUnit"],
        "UnitConversion.degrees2radians": ["degrees"],
        "UnitConversion.distanceToRadians": ["distance", "units"],
        "UnitConversion.distanceToDegrees": ["distance", "units"],
        "UnitConversion.radiansToDistance": ["radians", "units"],
        "UnitConversion.radians2degrees": ["radians"]
    },

    options: {
        attribution: "<span>© <a href='http://turfjs.org/' target='_blank'>turfjs</a></span> with <span>© <a href='http://iclient.supermap.io' target='_blank'>SuperMap iClient</a></span>"
    },

    initialize: function initialize(options) {
        options = options || {};
        _leaflet2["default"].Util.setOptions(this, options);
        _leaflet2["default"].stamp(this);
        this._layers = {};
    },

    /**
     * @function L.supermap.turfLayer.prototype.process
     * @description 执行Turf.js提供的相关空间分析方法
     * @param type -{string} Turf.js提供的空间分析方法名
     * @param args -{Object} Turf.js提供的空间分析方法对应的参数对象
     * @param callback -{function} 空间分析完成执行的回调函数，返回执行的结果
     * @param addFeaturesToMap -{boolean} 是否添加到map
     */
    process: function process(type, args, callback, addFeaturesToMap) {
        var result = _turf2["default"][type.split('.')[1]].apply(this, this.parse(type, args));
        addFeaturesToMap = addFeaturesToMap == null ? true : addFeaturesToMap;
        if (addFeaturesToMap) {
            this.addData([result]);
        }
        if (callback) {
            callback(result);
        }
    },

    parse: function parse(type, args) {
        if (type === 'Transformation.union') {
            return args['A'];
        }
        var result = [];
        var tempArgs = this.turfMap[type];
        if (tempArgs) {
            tempArgs.map(function (key) {
                result.push(args[key]);
                return args[key];
            });
        }
        return result;
    }
});

var turfLayer = exports.turfLayer = function turfLayer(options) {
    return new TurfLayer(options);
};

_leaflet2["default"].supermap.turfLayer = turfLayer;

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.circleStyle = exports.CircleStyle = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.circleStyle
 * @classdesc 圆形要素风格
 * @private
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param options - {Object} 圆形要素风格参数。如：<br>
 *        stroke - {boolean}
 *        color - {string} 颜色
 *        weight - {number}宽带
 *        opacity - {number}透明度
 *        lineCap - {string} 线帽形状
 *        lineJoin - {string} 线条交汇边角形状
 *        fill - {boolean} 是否填充
 *        fillColor - {string} 填充色
 *        fillOpacity - {number}填充透明度
 *        fillRule - {string} 填充形状
 *        radius - {number}半径
 */
var CircleStyle = exports.CircleStyle = _leaflet2["default"].Class.extend({

    options: {
        stroke: true,
        color: '#3388ff',
        weight: 1,
        opacity: 1,
        lineCap: 'round',
        lineJoin: 'round',
        fill: false,
        fillColor: null,
        fillOpacity: 0.2,
        fillRule: 'evenodd',
        radius: 3
    },

    initialize: function initialize(options) {
        options = options || {};
        _leaflet2["default"].Util.setOptions(this, options);
        this._canvas = document.createElement('canvas');
        this._canvas.width = 2 * (this.options.radius + this.options.weight);
        this._canvas.height = 2 * (this.options.radius + this.options.weight);
        this._ctx = this._canvas.getContext('2d');
        this._initStyle();
    },

    /**
     * @function L.supermap.circleStyle.prototype.getCanvas
     * @description 获取画布
     */
    getCanvas: function getCanvas() {
        return this._canvas;
    },

    _initStyle: function _initStyle() {
        this._ctx.beginPath();
        this._ctx.arc(this._canvas.width / 2, this._canvas.height / 2, this.options.radius, 0, Math.PI * 2);
        this._fillStroke();
    },

    _fillStroke: function _fillStroke() {
        var options = this.options;
        if (options.fill) {
            this._ctx.globalAlpha = options.fillOpacity;
            this._ctx.fillStyle = options.fillColor || options.color;
            this._ctx.fill(options.fillRule || 'evenodd');
        }
        if (options.stroke && options.weight !== 0) {
            this._ctx.globalAlpha = options.opacity;
            this._ctx.lineWidth = options.weight;
            this._ctx.strokeStyle = options.color;
            this._ctx.lineCap = options.lineCap;
            this._ctx.lineJoin = options.lineJoin;
            this._ctx.stroke();
        }
    }

});

var circleStyle = exports.circleStyle = function circleStyle(options) {
    return new CircleStyle(options);
};

_leaflet2["default"].supermap.circleStyle = circleStyle;

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addressMatchService = exports.AddressMatchService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _ServiceBase = __webpack_require__(8);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.addressMatchService
 * @constructs L.supermap.addressMatchService
 * @classdesc 地址匹配服务
 * @extends L.supermap.ServiceBase
 * @example
 *      L.supermap.addressMatchService(url,options)
 *      .code(function(result){
 *          //doSomething
 *      })
 * @param url - {string} 地址匹配服务地址
 * @param options {Object} 地址匹配服务可选参数。如：data - {number}
 *
 */
var AddressMatchService = exports.AddressMatchService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.addressMatchService.prototype.code
     * @description 获取正向地址匹配结果。
     * @param params - {Object} 正向匹配参数。
     * @param callback - {function} 请求结果的回调函数。
     */
    code: function code(params, callback) {
        var me = this;
        var addressMatchService = new _iclientCommon.AddressMatchService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        addressMatchService.code(me.url + '/geocoding', params);
    },

    /**
     * @function L.supermap.addressMatchService.prototype.decode
     * @description 获取反向地址匹配结果。
     * @param params -{Object} 反向匹配参数。
     * @param callback -{function} 请求结果的回调函数。
     */
    decode: function decode(params, callback) {
        var me = this;
        var addressMatchService = new _iclientCommon.AddressMatchService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        addressMatchService.decode(me.url + '/geodecoding', params);
    }

});

var addressMatchService = exports.addressMatchService = function addressMatchService(url, options) {
    return new AddressMatchService(url, options);
};

_leaflet2["default"].supermap.addressMatchService = addressMatchService;

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.chartService = exports.ChartService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

var _ServiceBase = __webpack_require__(8);

var _CommontypesConversion = __webpack_require__(36);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.chartService
 * @classdesc 海图服务。
 * @extends L.supermap.ServiceBase
 * @example
 *      L.supermap.chartService(url)
 *      .queryChart(param,function(result){
 *          //doSomething
 *      })
 * @param url - {string} 与客户端交互的海图服务地址。
 * @param options -{Object} 可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 */
var ChartService = exports.ChartService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.chartService.prototype.queryChart
     * @description 查询海图
     * @param params -{SuperMap.ChartQueryParameters} 海图查询所需参数类。
     * @param callback -{function} 回调函数。
     * @param resultFormat -{SuperMap.DataFormat} 返回的结果格式类型。
     */
    queryChart: function queryChart(params, callback, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var chartQueryService = new _iclientCommon.ChartQueryService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });

        chartQueryService.processAsync(param);
    },

    /**
     * @function L.supermap.chartService.prototype.getChartFeatureInfo
     * @description 获取海图物标信息
     * @param callback -{function} 回调函数
     */
    getChartFeatureInfo: function getChartFeatureInfo(callback) {
        var me = this,
            url = me.url.concat();
        url += "/chartFeatureInfoSpecs";
        var chartFeatureInfoSpecsService = new _iclientCommon.ChartFeatureInfoSpecsService(url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        chartFeatureInfoSpecsService.processAsync();
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }
        params.returnContent = params.returnContent == null ? true : params.returnContent;
        if (params.chartQueryFilterParameters && !_leaflet2["default"].Util.isArray(params.chartQueryFilterParameters)) {
            params.chartQueryFilterParameters = [params.chartQueryFilterParameters];
        }

        if (params.bounds) {
            params.bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(params.bounds);
        }
    },
    _processFormat: function _processFormat(resultFormat) {
        return resultFormat ? resultFormat : _iclientCommon.DataFormat.GEOJSON;
    }
});

var chartService = exports.chartService = function chartService(url, options) {
    return new ChartService(url, options);
};

_leaflet2["default"].supermap.chartService = chartService;

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fieldService = exports.FieldService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class  L.supermap.fieldService
 * @classdesc 字段服务类
 * @extends L.supermap.ServiceBase
 * @example
 *   L.supermap.fieldService(url).getFields(function(result){
 *     //doSomething
 *   });
 * @param url - {string} 字段服务地址
 * @param options - {Object} 字段服务类可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        dataSourceName - {string} 数据资源名称 <br>
 *        dataSetName - {string} 数据集名称
 */
var FieldService = exports.FieldService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url);
    },

    /**
     * @function L.supermap.fieldService.prototype.getFields
     * @description 字段查询服务
     * @param params {SuperMap.FieldParameters} 字段信息查询参数类
     * @param callback - {function} 回调函数
     */
    getFields: function getFields(params, callback) {
        var me = this;
        var getFieldsService = new _iclientCommon.GetFieldsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            datasource: params.datasource,
            dataset: params.dataset
        });
        getFieldsService.processAsync();
    },

    /**
     * @function L.supermap.fieldService.prototype.getFieldStatisticsInfo
     * @description 字段统计服务
     * @param params {SuperMap.FieldStatisticsParameters} 字段统计信息查询参数类
     * @param callback - {function} 回调函数
     */
    getFieldStatisticsInfo: function getFieldStatisticsInfo(params, callback) {
        if (!(params instanceof _iclientCommon.FieldStatisticsParameters)) {
            return;
        }
        var me = this,
            fieldName = params.fieldName,
            modes = params.statisticMode;
        if (modes && !_leaflet2["default"].Util.isArray(modes)) {
            modes = [modes];
        }
        me.currentStatisticResult = { fieldName: fieldName };
        me._statisticsCallback = callback;
        //针对每种统计方式分别进行请求
        for (var mode in modes) {
            me.currentStatisticResult[modes[mode]] = null;
            me._fieldStatisticRequest(params.datasource, params.dataset, fieldName, modes[mode]);
        }
    },

    _fieldStatisticRequest: function _fieldStatisticRequest(dataSourceName, dataSetName, fieldName, statisticMode) {
        var me = this;
        var statisticService = new _iclientCommon.FieldStatisticService(me.url, {
            eventListeners: {
                scope: me,
                processCompleted: me._processCompleted,
                processFailed: me._statisticsCallback
            },
            datasource: dataSourceName,
            dataset: dataSetName,
            field: fieldName,
            statisticMode: statisticMode
        });
        statisticService.processAsync();
    },

    _processCompleted: function _processCompleted(fieldStatisticResult) {
        var me = this;
        var getAll = true,
            result = fieldStatisticResult.result;
        if (this.currentStatisticResult) {
            if (null == me.currentStatisticResult[result.mode]) {
                this.currentStatisticResult[result.mode] = result.result;
            }
        }
        for (var mode in me.currentStatisticResult) {
            if (null == me.currentStatisticResult[mode]) {
                getAll = false;
                break;
            }
        }
        if (getAll) {
            me._statisticsCallback({ result: me.currentStatisticResult });
        }
    }
});
var fieldService = exports.fieldService = function fieldService(url, options) {
    return new FieldService(url, options);
};

_leaflet2["default"].supermap.fieldService = fieldService;

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.gridCellInfosService = exports.GridCellInfosService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _ServiceBase = __webpack_require__(8);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.gridCellInfosService
 * @classdesc 数据栅格查询服务
 * @extends L.supermap.ServiceBase
 * @example
 *      L.supermap.gridCellInfosService(url)
 *      .getGridCellInfos(param,function(result){
 *           //doSomething
 *      })
 * @param url - {string} 数据栅格查询服务地址
 * @param options - {Object} 数据栅格查询服务类可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 */
var GridCellInfosService = exports.GridCellInfosService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.gridCellInfosService.prototype.getGridCellInfos
     * @param params {SuperMap.GetGridCellInfosParameters} 数据服务栅格查询参数类
     * @param callback - {function} 回调函数
     */
    getGridCellInfos: function getGridCellInfos(params, callback) {
        if (!(params instanceof _iclientCommon.GetGridCellInfosParameters)) {
            return;
        }
        var me = this;
        var gridCellQueryService = new _iclientCommon.GetGridCellInfosService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        gridCellQueryService.processAsync(params);
    }
});
var gridCellInfosService = exports.gridCellInfosService = function gridCellInfosService(url, options) {
    return new GridCellInfosService(url, options);
};

_leaflet2["default"].supermap.gridCellInfosService = gridCellInfosService;

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.layerInfoService = exports.LayerInfoService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _ServiceBase = __webpack_require__(8);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.layerInfoService
 * @classdesc 图层信息类
 * @extends L.supermap.ServiceBase
 * @example
 * L.supermap.layerInfoService(url).getLayersInfo(function(result){
 *   //doSomething
 * })
 * @param url - {string} 与服务端交互的地图服务地址。请求地图服务URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}"；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var LayerInfoService = exports.LayerInfoService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.layerInfoService.prototype.getLayerInfo
     * @description 获取图层信息
     * @param callback - {function} 获取信息完成后的回调函数
     */
    getLayersInfo: function getLayersInfo(callback) {
        var me = this;
        var getLayersInfoService = new _iclientCommon.GetLayersInfoService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            }
        });
        getLayersInfoService.processAsync();
    },

    /**
     * @function L.supermap.layerInfoService.prototype.setLayerInfo
     * @description 设置图层信息服务。可以实现临时图层中子图层的修改
     * @param params - {SuperMap.SetLayerInfoParameters} 图层信息相关参数
     * @param callback - {function} 回调函数
     */
    setLayerInfo: function setLayerInfo(params, callback) {
        if (!(params instanceof _iclientCommon.SetLayerInfoParameters)) {
            return;
        }
        var me = this,
            resourceID = params.resourceID,
            tempLayerName = params.tempLayerName,
            layerInfoParams = params.layerInfo;
        if (!resourceID || !tempLayerName) {
            return;
        }
        var url = me.url.concat();
        url += "/tempLayersSet/" + resourceID + "/" + tempLayerName;

        var setLayerInfoService = new _iclientCommon.SetLayerInfoService(url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            }
        });

        setLayerInfoService.processAsync(layerInfoParams);
    },

    /**
     * @function  L.supermap.layerInfoService.prototype.setLayersInfo
     * @description 设置图层信息。可以实现创建新的临时图层和对现有临时图层的修改
     * @param params -{SuperMap.SetLayersInfoParameters} 图层信息设置参数,包括临时图层。
     * @param callback -{function} 回调函数
     */
    setLayersInfo: function setLayersInfo(params, callback) {
        if (!(params instanceof _iclientCommon.SetLayersInfoParameters)) {
            return;
        }
        var me = this,
            resourceID = params.resourceID,
            isTempLayers = params.isTempLayers ? params.isTempLayers : false,
            layersInfo = params.layersInfo;
        if (isTempLayers && !resourceID || !layersInfo) {
            return;
        }
        var setLayersInfoService = new _iclientCommon.SetLayersInfoService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            },
            resourceID: resourceID,
            isTempLayers: isTempLayers
        });

        setLayersInfoService.processAsync(layersInfo);
    },

    /**
     * @function L.supermap.layerInfoService.prototype.setLayerStatus
     * @description 负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。
     * @param params -{SuperMap.SetLayerStatusParameters} 图层信息显示控制参数
     * @param callback -{function} 回调函数
     */
    setLayerStatus: function setLayerStatus(params, callback) {
        if (!(params instanceof _iclientCommon.SetLayerStatusParameters)) {
            return;
        }
        var me = this;
        var setLayerStatusService = new _iclientCommon.SetLayerStatusService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                processCompleted: callback,
                processFailed: callback
            }
        });
        setLayerStatusService.processAsync(params);
    }

});

var layerInfoService = exports.layerInfoService = function layerInfoService(url, options) {
    return new LayerInfoService(url, options);
};

_leaflet2["default"].supermap.layerInfoService = layerInfoService;

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.measureService = exports.MeasureService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _ServiceBase = __webpack_require__(8);

__webpack_require__(4);

var _Util = __webpack_require__(43);

var Util = _interopRequireWildcard(_Util);

var _iclientCommon = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.measureService
 * @classdesc 量算服务服务类
 * @augments L.supermap.ServiceBase
 * @example
 * 用法：
 * L.supermap.measureService(url).measureDistance({
 *     geometry:xxx
 * },function(result){
 *     //doSomething
 * })
 * @param url - {string} 服务访问的地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World 。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。<br>
 *        measureMode - {SuperMap.MeasureMode} 量算模式，包括距离量算模式和面积量算模式。
 */
var MeasureService = exports.MeasureService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.measureService.prototype.measureDistance
     * @description 测距
     * @param params -{SuperMap.MeasureParameters} 测量相关参数类
     * @param callback - {function} 回调函数
     */
    measureDistance: function measureDistance(params, callback) {
        this.measure(_iclientCommon.MeasureMode.DISTANCE, params, callback);
        return this;
    },

    /**
     * @function L.supermap.measureService.prototype.measureArea
     * @description 测面积
     * @param params -{SuperMap.MeasureParameters} 测量相关参数类
     * @param callback - {function} 回调函数
     */
    measureArea: function measureArea(params, callback) {
        this.measure(_iclientCommon.MeasureMode.AREA, params, callback);
        return this;
    },

    /**
     * @function L.supermap.measureService.measure
     * @param params -{SuperMap.MeasureParameters} 测量相关参数类
     * @param callback - {function} 回调函数
     */
    measure: function measure(type, params, callback) {
        if (!(params instanceof _iclientCommon.MeasureParameters)) {
            return;
        }
        var me = this;
        if (params.geometry) {
            params.geometry = Util.toSuperMapGeometry(params.geometry);
        }
        var measureService = new _iclientCommon.MeasureService(me.url, {
            serverType: me.options.serverType,
            measureMode: type,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        measureService.processAsync(params);
    }
});

var measureService = exports.measureService = function measureService(url, options) {
    return new MeasureService(url, options);
};

_leaflet2["default"].supermap.measureService = measureService;

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.networkAnalyst3DService = exports.NetworkAnalyst3DService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _ServiceBase = __webpack_require__(8);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.networkAnalyst3DService
 * @classdesc 3D网络分析服务类
 * @extends L.supermap.ServiceBase
 * @example
 * L.supermap.networkAnalyst3DService(url)
 *  .sinksFacilityAnalyst(params,function(result){
 *     //doSomething
 * })
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                      "http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 服务所需可选参数
 */
var NetworkAnalyst3DService = exports.NetworkAnalyst3DService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function  L.supermap.networkAnalyst3DService.prototype.sinksFacilityAnalyst
     * @description 汇查找服务
     * @param params - {SuperMap.FacilityAnalystSinks3DParameters} 最近设施分析参数类(汇查找资源)
     * @param callback - {function} 回调函数
     */
    sinksFacilityAnalyst: function sinksFacilityAnalyst(params, callback) {
        var me = this;
        var facilityAnalystSinks3DService = new _iclientCommon.FacilityAnalystSinks3DService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        facilityAnalystSinks3DService.processAsync(params);
    },

    /**
     * @function L.supermap.networkAnalyst3DService.prototype.sourcesFacilityAnalyst
     * @description 源查找服务
     * @param params -{SuperMap.FacilityAnalystSources3DParameters} 最近设施分析参数类(源查找服务)
     * @param callback - {function} 回调函数
     *  @return {this} this
     */
    sourcesFacilityAnalyst: function sourcesFacilityAnalyst(params, callback) {
        var me = this;
        var facilityAnalystSources3DService = new _iclientCommon.FacilityAnalystSources3DService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        facilityAnalystSources3DService.processAsync(params);
    },

    /**
     * @function L.supermap.networkAnalyst3DService.prototype.traceUpFacilityAnalyst
     * @description 上游追踪资源服务
     * @param params - {SuperMap.FacilityAnalystTraceup3DParameters} 上游追踪资源参数类
     * @param callback - {function} 回调函数
     *  @return {this} this
     */
    traceUpFacilityAnalyst: function traceUpFacilityAnalyst(params, callback) {
        var me = this;
        var facilityAnalystTraceup3DService = new _iclientCommon.FacilityAnalystTraceup3DService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        facilityAnalystTraceup3DService.processAsync(params);
    },

    /**
     * @function L.supermap.networkAnalyst3DService.prototype.traceDownFacilityAnalyst
     * @description 下游追踪资源服务
     * @param params {SuperMap.FacilityAnalystTracedown3DParameters} 下游追踪资源服务参数类
     * @param callback - {function} 回调函数
     */
    traceDownFacilityAnalyst: function traceDownFacilityAnalyst(params, callback) {
        var me = this;
        var facilityAnalystTracedown3DService = new _iclientCommon.FacilityAnalystTracedown3DService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        facilityAnalystTracedown3DService.processAsync(params);
    },

    /**
     * @function L.supermap.networkAnalyst3DService.prototype.upstreamFacilityAnalyst
     * @description 上游关键设施查找服务
     * @param params -{SuperMap.FacilityAnalystUpstream3DParameters} 上游关键设施查找服务参数类
     * @param callback - {function} 回调函数
     */
    upstreamFacilityAnalyst: function upstreamFacilityAnalyst(params, callback) {
        var me = this;
        var facilityAnalystUpstream3DService = new _iclientCommon.FacilityAnalystUpstream3DService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        facilityAnalystUpstream3DService.processAsync(params);
    }
});

var networkAnalyst3DService = exports.networkAnalyst3DService = function networkAnalyst3DService(url, options) {
    return new NetworkAnalyst3DService(url, options);
};

_leaflet2["default"].supermap.networkAnalyst3DService = networkAnalyst3DService;

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.networkAnalystService = exports.NetworkAnalystService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.networkAnalystService
 * @classdesc 网络分析服务类
 * @augments  L.supermap.ServiceBase
 * @example
 * L.supermap.networkAnalystService(url)
 *  .findPath(params,function(result){
 *     //doSomething
 * })
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。<br>
 */
var NetworkAnalystService = exports.NetworkAnalystService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.burstPipelineAnalyst
     * @description 爆管分析服务:即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
     * @param params -{SuperMap.BurstPipelineAnalystParameters} 爆管分析服务参数类
     * @param callback -{function} 回调函数
     */
    burstPipelineAnalyst: function burstPipelineAnalyst(params, callback) {
        var me = this;
        var burstPipelineAnalystService = new _iclientCommon.BurstPipelineAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        burstPipelineAnalystService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.computeWeightMatrix
     * @description 耗费矩阵分析服务:根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
     * @param params - {SuperMap.ComputeWeightMatrixParameters} 耗费矩阵分析服务参数类
     * @param callback - {function} 回调函数
     */
    computeWeightMatrix: function computeWeightMatrix(params, callback) {
        var me = this;
        var computeWeightMatrixService = new _iclientCommon.ComputeWeightMatrixService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        computeWeightMatrixService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.findClosestFacilities
     * @description 最近设施分析服务:指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
     * @param params - {SuperMap.FindClosestFacilitiesParameters} 最近设施分析服务参数类
     * @param callback -{function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    findClosestFacilities: function findClosestFacilities(params, callback, resultFormat) {
        var me = this;
        var findClosestFacilitiesService = new _iclientCommon.FindClosestFacilitiesService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        findClosestFacilitiesService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.streamFacilityAnalyst
     * @description 上游/下游 关键设施查找资源服务:查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
     * @param params - {SuperMap.FacilityAnalystStreamParameters} 上游/下游 关键设施查找资源服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    streamFacilityAnalyst: function streamFacilityAnalyst(params, callback, resultFormat) {
        var me = this;
        var facilityAnalystStreamService = new _iclientCommon.FacilityAnalystStreamService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        facilityAnalystStreamService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.findLocation
     * @description 选址分区分析服务：确定一个或多个待建设施的最佳或最优位置
     * @param params - {SuperMap.FindLocationParameters} 选址分区分析服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    findLocation: function findLocation(params, callback, resultFormat) {
        var me = this;
        var findLocationService = new _iclientCommon.FindLocationService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        findLocationService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.findPath
     * @description 最佳路径分析服务:在网络数据集中指定一些节点，按照节点的选择顺序，顺序访问这些节点从而求解起止点之间阻抗最小的路经。
     * @param params - {SuperMap.FindPathParameters} 最佳路径分析服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）
     */
    findPath: function findPath(params, callback, resultFormat) {
        var me = this;
        var findPathService = new _iclientCommon.FindPathService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        findPathService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.findTSPPaths
     * @description 旅行商分析服务:路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
     * @param params - {SuperMap.FindTSPPathsParameters} 旅行商分析服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    findTSPPaths: function findTSPPaths(params, callback, resultFormat) {
        var me = this;
        var findTSPPathsService = new _iclientCommon.FindTSPPathsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        findTSPPathsService.processAsync(me._processParams(params));
    },

    /**
     * @function l.supermap.networkAnalystService.prototype.findMTSPPaths
     * @description 多旅行商分析服务:也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。查找经济有效的配送路径，并给出相应的行走路线。
     * @param params - {SuperMap.FindMTSPPathsParameters} 多旅行商分析服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    findMTSPPaths: function findMTSPPaths(params, callback, resultFormat) {
        var me = this;
        var findMTSPPathsService = new _iclientCommon.FindMTSPPathsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        findMTSPPathsService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.findServiceAreas
     * @description 服务区分析服务：以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
     * @param params - {SuperMap.FindServiceAreasParameters} 服务区分析服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    findServiceAreas: function findServiceAreas(params, callback, resultFormat) {
        var me = this;
        var findServiceAreasService = new _iclientCommon.FindServiceAreasService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        findServiceAreasService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.updateEdgeWeight
     * @description 更新边的耗费权重服务
     * @param params - {SuperMap.UpdateEdgeWeightParameters} 更新边的耗费权重服务参数类
     * @param callback - {function} 回调函数
     */
    updateEdgeWeight: function updateEdgeWeight(params, callback) {
        var me = this;
        var updateEdgeWeightService = new _iclientCommon.UpdateEdgeWeightService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        updateEdgeWeightService.processAsync(params);
    },

    /**
     * @function L.supermap.networkAnalystService.prototype.updateTurnNodeWeight
     * @description 转向耗费权重更新服务
     * @param params - {SuperMap.UpdateTurnNodeWeightParameters} 转向耗费权重更新服务参数类
     * @param callback - {function} 回调函数
     */
    updateTurnNodeWeight: function updateTurnNodeWeight(params, callback) {
        var me = this;
        var updateTurnNodeWeightService = new _iclientCommon.UpdateTurnNodeWeightService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        updateTurnNodeWeightService.processAsync(params);
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }

        if (params.centers && _leaflet2["default"].Util.isArray(params.centers)) {
            params.centers.map(function (point, key) {
                params.centers[key] = point instanceof _leaflet2["default"].LatLng ? { x: point.lng, y: point.lat } : point;
                return params.centers[key];
            });
        }

        if (params.nodes && _leaflet2["default"].Util.isArray(params.nodes)) {
            params.nodes.map(function (point, key) {
                params.nodes[key] = point instanceof _leaflet2["default"].LatLng ? { x: point.lng, y: point.lat } : point;
                return params.nodes[key];
            });
        }

        if (params.event && params.event instanceof _leaflet2["default"].LatLng) {
            params.event = { x: params.event.lng, y: params.event.lat };
        }

        if (params.facilities && _leaflet2["default"].Util.isArray(params.facilities)) {
            params.facilities.map(function (point, key) {
                params.facilities[key] = point instanceof _leaflet2["default"].LatLng ? { x: point.lng, y: point.lat } : point;
                return params.facilities[key];
            });
        }

        if (params.parameter && params.parameter.barrierPoints) {
            var barrierPoints = params.parameter.barrierPoints;
            if (_leaflet2["default"].Util.isArray(barrierPoints)) {
                barrierPoints.map(function (point, key) {
                    params.parameter.barrierPoints[key] = point instanceof _leaflet2["default"].LatLng ? {
                        x: point.lng,
                        y: point.lat
                    } : point;
                    return params.parameter.barrierPoints[key];
                });
            } else {
                params.parameter.barrierPoints = [barrierPoints instanceof _leaflet2["default"].LatLng ? {
                    x: barrierPoints.lng,
                    y: barrierPoints.lat
                } : barrierPoints];
            }
        }
        return params;
    },

    _processFormat: function _processFormat(resultFormat) {
        return resultFormat ? resultFormat : _iclientCommon.DataFormat.GEOJSON;
    }

});

var networkAnalystService = exports.networkAnalystService = function networkAnalystService(url, options) {
    return new NetworkAnalystService(url, options);
};

_leaflet2["default"].supermap.networkAnalystService = networkAnalystService;

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processingService = exports.ProcessingService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _CommontypesConversion = __webpack_require__(36);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.processingService
 * @classdesc 分布式分析服务类
 * @extends  L.supermap.ServiceBase
 * @example
 * L.supermap.processingService(url)
 * .getKernelDensityJobs(function(result){
 *     //doSomething
 * })
 * @param url -{string} 分布式分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。
 */
var ProcessingService = exports.ProcessingService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        options = options || {};
        _leaflet2["default"].setOptions(this, options);
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
        this.kernelDensityJobs = {};
        this.summaryMeshJobs = {};
        this.queryJobs = {};
        this.summaryRegionJobs = {};
        this.vectorClipJobs = {};
        this.overlayGeoJobs = {};
        this.buffersJobs = {};
        this.topologyValidatorJobs = {};
        this.summaryAttributesJobs = {};
    },

    /**
     * @function L.supermap.processingService.prototype.getKernelDensityJobs
     * @description 获取密度分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getKernelDensityJobs: function getKernelDensityJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var kernelDensityJobsService = new _iclientCommon.KernelDensityJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        kernelDensityJobsService.getKernelDensityJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getKernelDensityJob
     * @description 获取某一个密度分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getKernelDensityJob: function getKernelDensityJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var kernelDensityJobsService = new _iclientCommon.KernelDensityJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        kernelDensityJobsService.getKernelDensityJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addKernelDensityJob
     * @description 新建一个密度分析。
     * @param params -{SuperMap.KernelDensityJobParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addKernelDensityJob: function addKernelDensityJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var kernelDensityJobsService = new _iclientCommon.KernelDensityJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.kernelDensityJobs[job.id] = job.state;
                }
            },
            format: format
        });
        kernelDensityJobsService.addKernelDensityJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getKernelDensityJobState
     * @description 获取密度分析的状态。
     * @param id - {string}密度分析的id。
     * @return {Object} 密度分析的状态
     */
    getKernelDensityJobState: function getKernelDensityJobState(id) {
        return this.kernelDensityJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryMeshJobs
     * @description 获取点聚合分析的列表。
     * @param callback - {function}  请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getSummaryMeshJobs: function getSummaryMeshJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var summaryMeshJobsService = new _iclientCommon.SummaryMeshJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        summaryMeshJobsService.getSummaryMeshJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryMeshJob
     * @description 获取某一个点聚合分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat}返回的结果类型（默认为GeoJSON）。
     */
    getSummaryMeshJob: function getSummaryMeshJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var summaryMeshJobsService = new _iclientCommon.SummaryMeshJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        summaryMeshJobsService.getSummaryMeshJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addSummaryMeshJob
     * @description 新建一个点聚合分析。
     * @param params - {SuperMap.SummaryMeshJobParameter} 点聚合分析任务参数类。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addSummaryMeshJob: function addSummaryMeshJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var summaryMeshJobsService = new _iclientCommon.SummaryMeshJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.summaryMeshJobs[job.id] = job.state;
                }
            },
            format: format
        });
        summaryMeshJobsService.addSummaryMeshJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryMeshJobState
     * @description 获取点聚合分析的状态。
     * @param id - {string} 点聚合分析的id。
     * @return {Object} 点聚合分析的状态
     */
    getSummaryMeshJobState: function getSummaryMeshJobState(id) {
        return this.summaryMeshJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getQueryJobs
     * @description 获取单对象查询分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getQueryJobs: function getQueryJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var singleObjectQueryJobsService = new _iclientCommon.SingleObjectQueryJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        singleObjectQueryJobsService.getQueryJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getQueryJob
     * @description 获取某一个单对象查询分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getQueryJob: function getQueryJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var singleObjectQueryJobsService = new _iclientCommon.SingleObjectQueryJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        singleObjectQueryJobsService.getQueryJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addQueryJob
     * @description 新建一个单对象查询分析。
     * @param params -{SuperMap.SingleObjectQueryJobsParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addQueryJob: function addQueryJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var singleObjectQueryJobsService = new _iclientCommon.SingleObjectQueryJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.queryJobs[job.id] = job.state;
                }
            },
            format: format
        });
        singleObjectQueryJobsService.addQueryJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getQueryJobState
     * @description 获取单对象查询分析的状态。
     * @param id - {string}单对象查询分析的id。
     * @return {Object} 单对象查询分析的状态
     */
    getQueryJobState: function getQueryJobState(id) {
        return this.queryJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryRegionJobs
     * @description 获取区域汇总分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getSummaryRegionJobs: function getSummaryRegionJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var summaryRegionJobsService = new _iclientCommon.SummaryRegionJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        summaryRegionJobsService.getSummaryRegionJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryRegionJob
     * @description 获取某一个区域汇总分析。
     * @param id - {string}区域汇总分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getSummaryRegionJob: function getSummaryRegionJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var summaryRegionJobsService = new _iclientCommon.SummaryRegionJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        summaryRegionJobsService.getSummaryRegionJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addSummaryRegionJob
     * @description 新建一个区域汇总分析。
     * @param params -{SuperMap.SingleObjectQueryJobsParameter} 创建一个区域汇总分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addSummaryRegionJob: function addSummaryRegionJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var summaryRegionJobsService = new _iclientCommon.SummaryRegionJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.summaryRegionJobs[job.id] = job.state;
                }
            },
            format: format
        });
        summaryRegionJobsService.addSummaryRegionJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryRegionJobState
     * @description 获取区域汇总分析的状态。
     * @param id - {string}区域汇总分析的id。
     * @return {Object} 区域汇总分析的状态
     */
    getSummaryRegionJobState: function getSummaryRegionJobState(id) {
        return this.summaryRegionJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getVectorClipJobs
     * @description 获取矢量裁剪分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getVectorClipJobs: function getVectorClipJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var vectorClipJobsService = new _iclientCommon.VectorClipJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        vectorClipJobsService.getVectorClipJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getVectorClipJob
     * @description 获取某一个矢量裁剪分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getVectorClipJob: function getVectorClipJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var vectorClipJobsService = new _iclientCommon.VectorClipJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        vectorClipJobsService.getVectorClipJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addVectorClipJob
     * @description 新建一个矢量裁剪分析。
     * @param params -{SuperMap.VectorClipJobsParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addVectorClipJob: function addVectorClipJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var vectorClipJobsService = new _iclientCommon.VectorClipJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.vectorClipJobs[job.id] = job.state;
                }
            },
            format: format
        });
        vectorClipJobsService.addVectorClipJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getVectorClipJobState
     * @description 获取矢量裁剪分析的状态。
     * @param id - {string}矢量裁剪分析的id。
     * @return {Object} 矢量裁剪分析的状态
     */
    getVectorClipJobState: function getVectorClipJobState(id) {
        return this.vectorClipJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getOverlayGeoJobs
     * @description 获取叠加分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getOverlayGeoJobs: function getOverlayGeoJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var overlayGeoJobsService = new _iclientCommon.OverlayGeoJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        overlayGeoJobsService.getOverlayGeoJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getOverlayGeoJob
     * @description 获取某一个叠加分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getOverlayGeoJob: function getOverlayGeoJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var overlayGeoJobsService = new _iclientCommon.OverlayGeoJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        overlayGeoJobsService.getOverlayGeoJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addOverlayGeoJob
     * @description 新建一个叠加分析。
     * @param params -{SuperMap.OverlayGeoJobParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addOverlayGeoJob: function addOverlayGeoJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var overlayGeoJobsService = new _iclientCommon.OverlayGeoJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.overlayGeoJobs[job.id] = job.state;
                }
            },
            format: format
        });
        overlayGeoJobsService.addOverlayGeoJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getoverlayGeoJobState
     * @description 获取叠加分析的状态。
     * @param id - {string}叠加分析的id。
     * @return {Object} 叠加分析的状态
     */
    getoverlayGeoJobState: function getoverlayGeoJobState(id) {
        return this.overlayGeoJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getBuffersJobs
     * @description 获取缓冲区分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getBuffersJobs: function getBuffersJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var buffersAnalystJobsService = new _iclientCommon.BuffersAnalystJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        buffersAnalystJobsService.getBuffersJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getBuffersJob
     * @description 获取某一个缓冲区分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getBuffersJob: function getBuffersJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var buffersAnalystJobsService = new _iclientCommon.BuffersAnalystJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        buffersAnalystJobsService.getBuffersJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addBuffersJob
     * @description 新建一个缓冲区分析。
     * @param params -{SuperMap.CreateBufferAnalystJobsParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addBuffersJob: function addBuffersJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var buffersAnalystJobsService = new _iclientCommon.BuffersAnalystJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.buffersJobs[job.id] = job.state;
                }
            },
            format: format
        });
        buffersAnalystJobsService.addBuffersJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getBuffersJobState
     * @description 获取缓冲区分析的状态。
     * @param id - {string}缓冲区分析的id。
     * @return {Object} 缓冲区分析的状态
     */
    getBuffersJobState: function getBuffersJobState(id) {
        return this.buffersJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getTopologyValidatorJobs
     * @description 获取拓扑检查分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getTopologyValidatorJobs: function getTopologyValidatorJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var topologyValidatorJobsService = new _iclientCommon.TopologyValidatorJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        topologyValidatorJobsService.getTopologyValidatorJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getTopologyValidatorJob
     * @description 获取某一个拓扑检查分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getTopologyValidatorJob: function getTopologyValidatorJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var topologyValidatorJobsService = new _iclientCommon.TopologyValidatorJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        topologyValidatorJobsService.getTopologyValidatorJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addTopologyValidatorJob
     * @description 新建一个拓扑检查分析。
     * @param params -{SuperMap.TopologyValidatorJobsParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addTopologyValidatorJob: function addTopologyValidatorJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var topologyValidatorJobsService = new _iclientCommon.TopologyValidatorJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.topologyValidatorJobs[job.id] = job.state;
                }
            },
            format: format
        });
        topologyValidatorJobsService.addTopologyValidatorJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getTopologyValidatorJobState
     * @description 获取拓扑检查分析的状态。
     * @param id - {string}拓扑检查分析的id。
     * @return {Object} 拓扑检查分析的状态
     */
    getTopologyValidatorJobState: function getTopologyValidatorJobState(id) {
        return this.topologyValidatorJobs[id];
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryAttributesJobs
     * @description 获取属性汇总分析的列表。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getSummaryAttributesJobs: function getSummaryAttributesJobs(callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var summaryAttributesJobsService = new _iclientCommon.SummaryAttributesJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        summaryAttributesJobsService.getSummaryAttributesJobs();
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryAttributesJob
     * @description 获取某一个属性汇总分析。
     * @param id - {string}空间分析的id。
     * @param callback - {function} 请求结果的回调函数。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getSummaryAttributesJob: function getSummaryAttributesJob(id, callback, resultFormat) {
        var me = this,
            format = me._processFormat(resultFormat);
        var summaryAttributesJobsService = new _iclientCommon.SummaryAttributesJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: format
        });
        summaryAttributesJobsService.getSummaryAttributesJob(id);
    },

    /**
     * @function L.supermap.processingService.prototype.addSummaryAttributesJob
     * @description 新建一个属性汇总分析。
     * @param params -{SuperMap.SummaryAttributesJobsParameter} 创建一个空间分析的请求参数。
     * @param callback - {function} 请求结果的回调函数。
     * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    addSummaryAttributesJob: function addSummaryAttributesJob(params, callback, seconds, resultFormat) {
        var me = this,
            param = me._processParams(params),
            format = me._processFormat(resultFormat);
        var summaryAttributesJobsService = new _iclientCommon.SummaryAttributesJobsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback,
                processRunning: function processRunning(job) {
                    me.summaryAttributesJobs[job.id] = job.state;
                }
            },
            format: format
        });
        summaryAttributesJobsService.addSummaryAttributesJob(param, seconds);
    },

    /**
     * @function L.supermap.processingService.prototype.getSummaryAttributesJobState
     * @description 获取属性汇总分析的状态。
     * @param id - {string}属性汇总分析的id。
     * @return {Object} 属性汇总分析的状态
     */
    getSummaryAttributesJobState: function getSummaryAttributesJobState(id) {
        return this.summaryAttributesJobs[id];
    },

    _processFormat: function _processFormat(resultFormat) {
        return resultFormat ? resultFormat : _iclientCommon.DataFormat.GEOJSON;
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }
        if (params.bounds) {
            params.bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(params.bounds);
        }
        if (params.query) {
            params.query = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(params.query);
        }
        if (params.geometryQuery) {
            params.geometryQuery = _CommontypesConversion.CommontypesConversion.toProcessingParam(params.geometryQuery);
        }
        if (params.geometryClip) {
            params.geometryClip = _CommontypesConversion.CommontypesConversion.toProcessingParam(params.geometryClip);
        }
        return params;
    }
});
var processingService = exports.processingService = function processingService(url, options) {
    return new ProcessingService(url, options);
};

_leaflet2["default"].supermap.processingService = processingService;

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.queryService = exports.QueryService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _Util = __webpack_require__(43);

var Util = _interopRequireWildcard(_Util);

var _CommontypesConversion = __webpack_require__(36);

var _iclientCommon = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class  L.supermap.queryService
 * @classdesc 地图查询服务类。
 * @extends L.supermap.ServiceBase
 * @param url - {string} 地图查询服务访问地址。
 * @param - options - {Object} 服务交互时所需的可选参数。如：<br>
 *          serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 * @example
 * L.supermap.queryService(url).queryByBounds(param,function(result){
 *   //doSomething
 * })
 */
var QueryService = exports.QueryService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.queryService.prototype.queryByBounds
     * @description bounds查询地图服务
     * @param params - {SuperMap.QueryByBoundsParameters} 通过Bounds查询的相关参数类
     * @param callback -{function} 回掉函数
     * @param resultFormat - {SuperMap.DataFormat} 返回结果类型
     */
    queryByBounds: function queryByBounds(params, callback, resultFormat) {
        var me = this;
        var queryService = new _iclientCommon.QueryByBoundsService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });

        queryService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.queryService.prototype.queryByDistance
     * @description 地图距离查询服务
     * @param params - {SuperMap.QueryByDistanceParameters} Distance查询相关参数类
     * @param callback - {function} 回调函数
     * @param resultFormat -{SuperMap.DataFormat} 返回结果类型
     */
    queryByDistance: function queryByDistance(params, callback, resultFormat) {
        var me = this;
        var queryByDistanceService = new _iclientCommon.QueryByDistanceService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });

        queryByDistanceService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.queryService.prototype.queryBySQL
     * @description 地图SQL查询服务
     * @param params - {SuperMap.QueryBySQLParameters} SQL查询相关参数类
     * @param callback -{function} 回调函数
     * @param resultFormat -{SuperMap.DataFormat} 返回结果类型
     */
    queryBySQL: function queryBySQL(params, callback, resultFormat) {
        var me = this;
        var queryBySQLService = new _iclientCommon.QueryBySQLService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });

        queryBySQLService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.queryService.prototype.queryByGeometry
     * @description 地图几何查询服务
     * @param params - {SuperMap.QueryByGeometryParameters} Geometry查询相关参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回结果类型
     */
    queryByGeometry: function queryByGeometry(params, callback, resultFormat) {
        var me = this;
        var queryByGeometryService = new _iclientCommon.QueryByGeometryService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });

        queryByGeometryService.processAsync(me._processParams(params));
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }
        params.returnContent = params.returnContent == null ? true : params.returnContent;
        if (params.queryParams && !_leaflet2["default"].Util.isArray(params.queryParams)) {
            params.queryParams = [params.queryParams];
        }

        if (params.bounds) {
            params.bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(params.bounds);
        }

        if (params.geometry) {
            if (params.geometry instanceof _leaflet2["default"].Point) {
                params.geometry = new _iclientCommon.GeometryPoint(params.geometry.x, params.geometry.y);
            } else {
                params.geometry = Util.toSuperMapGeometry(params.geometry);
            }
        }

        return params;
    },

    _processFormat: function _processFormat(resultFormat) {
        return resultFormat ? resultFormat : _iclientCommon.DataFormat.GEOJSON;
    }
});

var queryService = exports.queryService = function queryService(url, options) {
    return new QueryService(url, options);
};

_leaflet2["default"].supermap.queryService = queryService;

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.spatialAnalystService = exports.SpatialAnalystService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _Util = __webpack_require__(43);

var Util = _interopRequireWildcard(_Util);

var _CommontypesConversion = __webpack_require__(36);

var _iclientCommon = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.spatialAnalystService
 * @classdesc 空间分析服务类。
 * @description 提供：地区太阳辐射、缓冲区分析、点密度分析、动态分段分析、空间关系分析、插值分析、栅格代数运算、叠加分析、路由定位、路由测量计算、表面分析、地形曲率计算、泰森多边形分析。
 * @extends L.supermap.ServiceBase
 * @example
 *      L.supermap.spatialAnalystService(url)
 *      .bufferAnalysis(params,function(result){
 *          //doSomething
 *      })
 * @param url -{string} 空间分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 */
var SpatialAnalystService = exports.SpatialAnalystService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },
    /**
     * @function L.supermap.spatialAnalystService.prototype.getAreaSolarRadiationResult
     * @description 地区太阳辐射
     * @param params - {SuperMap.AreaSolarRadiationParameters} 地区太阳辐射参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    getAreaSolarRadiationResult: function getAreaSolarRadiationResult(params, callback, resultFormat) {
        var me = this;
        var areaSolarRadiationService = new _iclientCommon.AreaSolarRadiationService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        areaSolarRadiationService.processAsync(params);
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.bufferAnalysis
     * @description 缓冲区分析
     * @param params - {SuperMap.DatasetBufferAnalystParameters} 数据集缓冲区分析参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    bufferAnalysis: function bufferAnalysis(params, callback, resultFormat) {
        var me = this;
        var bufferAnalystService = new _iclientCommon.BufferAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        bufferAnalystService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.densityAnalysis
     * @description 点密度分析
     * @param params - {SuperMap.DensityKernelAnalystParameters} 核密度分析参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    densityAnalysis: function densityAnalysis(params, callback, resultFormat) {
        var me = this;
        var densityAnalystService = new _iclientCommon.DensityAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        densityAnalystService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.generateSpatialData
     * @description 动态分段分析
     * @param params - {SuperMap.GenerateSpatialDataParameters} 动态分段操作参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    generateSpatialData: function generateSpatialData(params, callback, resultFormat) {
        var me = this;
        var generateSpatialDataService = new _iclientCommon.GenerateSpatialDataService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        generateSpatialDataService.processAsync(params);
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.generateSpatialData
     * @description 空间关系分析
     * @param params - {SuperMap.GeoRelationAnalystParameters} 空间关系分析服务参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    geoRelationAnalysis: function geoRelationAnalysis(params, callback, resultFormat) {
        var me = this;
        var geoRelationAnalystService = new _iclientCommon.GeoRelationAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        geoRelationAnalystService.processAsync(params);
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.interpolationAnalysis
     * @description 插值分析
     * @param params - {SuperMap.InterpolationRBFAnalystParameters} 样条插值（径向基函数插值法）分析参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    interpolationAnalysis: function interpolationAnalysis(params, callback, resultFormat) {
        var me = this;
        var interpolationAnalystService = new _iclientCommon.InterpolationAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        interpolationAnalystService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.mathExpressionAnalysis
     * @description 栅格代数运算
     * @param params - {SuperMap.MathExpressionAnalysisParameters} 栅格代数运算参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    mathExpressionAnalysis: function mathExpressionAnalysis(params, callback, resultFormat) {
        var me = this;
        var mathExpressionAnalysisService = new _iclientCommon.MathExpressionAnalysisService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        mathExpressionAnalysisService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.overlayAnalysis
     * @description 叠加分析
     * @param params - {SuperMap.DatasetOverlayAnalystParameters} 数据集叠加分析参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    overlayAnalysis: function overlayAnalysis(params, callback, resultFormat) {
        var me = this;
        var overlayAnalystService = new _iclientCommon.OverlayAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        overlayAnalystService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.routeCalculateMeasure
     * @description 路由测量计算
     * @param params - {SuperMap.RouteCalculateMeasureParameters} 基于路由对象计算指定点M值操作的参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    routeCalculateMeasure: function routeCalculateMeasure(params, callback, resultFormat) {
        var me = this;
        var routeCalculateMeasureService = new _iclientCommon.RouteCalculateMeasureService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        routeCalculateMeasureService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.routeLocate
     * @description 路由定位
     * @param params - {SuperMap.RouteLocatorParameters} 路由对象定位空间对象的参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    routeLocate: function routeLocate(params, callback, resultFormat) {
        var me = this;
        var routeLocatorService = new _iclientCommon.RouteLocatorService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        routeLocatorService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.surfaceAnalysis
     * @description 表面分析
     * @param params - {SuperMap.DatasetSurfaceAnalystParameters} 数据集表面分析参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    surfaceAnalysis: function surfaceAnalysis(params, callback, resultFormat) {
        var me = this;
        var surfaceAnalystService = new _iclientCommon.SurfaceAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        surfaceAnalystService.processAsync(me._processParams(params));
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.terrainCurvatureCalculate
     * @description 地形曲率计算
     * @param params - {SuperMap.TerrainCurvatureCalculationParameters} 地形曲率计算参数类。
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    terrainCurvatureCalculate: function terrainCurvatureCalculate(params, callback, resultFormat) {
        var me = this;
        var terrainCurvatureCalculationService = new _iclientCommon.TerrainCurvatureCalculationService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        terrainCurvatureCalculationService.processAsync(params);
    },

    /**
     * @function L.supermap.spatialAnalystService.prototype.thiessenAnalysis
     * @description 泰森多边形分析
     * @param params - {SuperMap.DatasetThiessenAnalystParameters} 数据集泰森多边形分析参数类
     * @param callback - {function} 回调函数
     * @param resultFormat - {SuperMap.DataFormat} 返回的结果类型（默认为GeoJSON）。
     */
    thiessenAnalysis: function thiessenAnalysis(params, callback, resultFormat) {
        var me = this;
        var thiessenAnalystService = new _iclientCommon.ThiessenAnalystService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            },
            format: me._processFormat(resultFormat)
        });
        thiessenAnalystService.processAsync(me._processParams(params));
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }
        if (params.bounds) {
            params.bounds = _CommontypesConversion.CommontypesConversion.toSuperMapBounds(params.bounds);
        }
        if (params.inputPoints) {
            for (var i = 0; i < params.inputPoints.length; i++) {
                var inputPoint = params.inputPoints[i];
                if (_leaflet2["default"].Util.isArray(inputPoint)) {
                    params.inputPoints[i] = { x: inputPoint[0], y: inputPoint[1], tag: inputPoint[2] };
                }
            }
        }

        if (params.points) {
            for (var _i = 0; _i < params.points.length; _i++) {
                var point = params.points[_i];
                if (_leaflet2["default"].Util.isArray(point)) {
                    params.points[_i] = { x: point[0], y: point[1] };
                } else if (point instanceof _leaflet2["default"].LatLng) {
                    params.points[_i] = { x: point.lng, y: point.lat };
                } else {
                    params.points[_i] = { x: point.x, y: point.y };
                }
            }
        }
        if (params.point) {
            if (_leaflet2["default"].Util.isArray(params.point)) {
                params.point = { x: params.point[0], y: params.point[1] };
            } else if (params.point instanceof _leaflet2["default"].LatLng) {
                params.point = { x: params.point.lng, y: params.point.lat };
            } else {
                params.point = { x: params.point.x, y: params.point.y };
            }
        }
        if (params.extractRegion) {
            params.extractRegion = Util.toSuperMapGeometry(params.extractRegion);
        }
        if (params.extractParameter && params.extractParameter.clipRegion) {
            params.extractParameter.clipRegion = Util.toSuperMapGeometry(params.extractParameter.clipRegion);
        }
        if (params.sourceGeometry) {
            params.sourceGeometry = Util.toSuperMapGeometry(params.sourceGeometry);
        }
        if (params.sourceRoute) {
            if (params.sourceRoute instanceof _leaflet2["default"].Polyline) {
                var target = {};
                target.type = "LINEM";
                target.parts = [params.sourceRoute.getLatLngs().length];
                target.points = [];
                for (var _i2 = 0; _i2 < params.sourceRoute.getLatLngs().length; _i2++) {
                    var _point = params.sourceRoute.getLatLngs()[_i2];
                    target.points = target.points.concat({ x: _point.lng, y: _point.lat, measure: _point.alt });
                }
                params.sourceRoute = target;
            }
        }
        if (params.operateRegions && _leaflet2["default"].Util.isArray(params.operateRegions)) {
            params.operateRegions.map(function (geometry, key) {
                params.operateRegions[key] = Util.toSuperMapGeometry(geometry);
                return params.operateRegions[key];
            });
        }
        // if (params.sourceRoute && params.sourceRoute.components && L.Util.isArray(params.sourceRoute.components)) {
        //     params.sourceRoute.components.map(function (geometry, key) {
        //         params.sourceRoute.components[key] = Util.toSuperMapGeometry(geometry);
        //     });
        // }

        return params;
    },

    _processFormat: function _processFormat(resultFormat) {
        return resultFormat ? resultFormat : _iclientCommon.DataFormat.GEOJSON;
    }
});
var spatialAnalystService = exports.spatialAnalystService = function spatialAnalystService(url, options) {
    return new SpatialAnalystService(url, options);
};

_leaflet2["default"].supermap.spatialAnalystService = spatialAnalystService;

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.themeService = exports.ThemeService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _ServiceBase = __webpack_require__(8);

__webpack_require__(4);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.themeService
 * @classdesc 专题图服务类
 * @extends L.supermap.ServiceBase
 * @example
 * L.supermap.themeService(url,{
 *      projection:projection
 *  }).getThemeInfo(params,function(result){
 *      //doSomething
 * });
 * @param url - {string} 服务的访问地址。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online。
 */
var ThemeService = exports.ThemeService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function L.supermap.themeService.prototype.getThemeInfo
     * @description 获取专题图信息
     * @param params - {SuperMap.ThemeParameters} 专题图参数类
     * @param callback - {function} 回调函数
     */
    getThemeInfo: function getThemeInfo(params, callback) {
        var me = this;
        var themeService = new _iclientCommon.ThemeService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        themeService.processAsync(params);
    }
});

var themeService = exports.themeService = function themeService(url, options) {
    return new ThemeService(url, options);
};

_leaflet2["default"].supermap.themeService = themeService;

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.trafficTransferAnalystService = exports.TrafficTransferAnalystService = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

var _ServiceBase = __webpack_require__(8);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.trafficTransferAnalystService
 * @classdesc 交通换乘分析服务类
 * @example
 * L.supermap.trafficTransferAnalystService(url).queryStop(params,function(result){
 *   //doSomething
 * })
 * @extends L.supermap.ServiceBase
 * @param url - {string} 服务地址
 * @param option - {Object} 可选参数。如：<br>
 *        serverType - {{@link SuperMap.ServerType}} 服务来源 iServer|iPortal|online
 */
var TrafficTransferAnalystService = exports.TrafficTransferAnalystService = _ServiceBase.ServiceBase.extend({

    initialize: function initialize(url, options) {
        _ServiceBase.ServiceBase.prototype.initialize.call(this, url, options);
    },

    /**
     * @function  L.supermap.trafficTransferAnalystService.prototype.queryStop
     * @description 站点查询服务
     * @param params - {SuperMap.StopQueryParameters} 站点查询参数类
     * @param callback - {function} 回调函数
     */
    queryStop: function queryStop(params, callback) {
        var me = this;
        var stopQueryService = new _iclientCommon.StopQueryService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        stopQueryService.processAsync(params);
    },
    /**
     * @function  L.supermap.trafficTransferAnalystService.prototype.analysisTransferPath
     * @description 交通换乘线路查询服务
     * @param params - {SuperMap.TransferPathParameters} 交通换乘线路查询参数类
     * @param callback - {function} 回调函数
     */
    analysisTransferPath: function analysisTransferPath(params, callback) {
        var me = this;
        var transferPathService = new _iclientCommon.TransferPathService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        transferPathService.processAsync(me._processParams(params));
    },
    /**
     * @function  L.supermap.trafficTransferAnalystService.prototype.analysisTransferSolution
     * @description 交通换乘方案查询服务
     * @param params {SuperMap.TransferSolutionParameters} 交通换乘方案查询参数类
     * @param callback - {function} 回调函数
     */
    analysisTransferSolution: function analysisTransferSolution(params, callback) {
        var me = this;
        var transferSolutionService = new _iclientCommon.TransferSolutionService(me.url, {
            serverType: me.options.serverType,
            eventListeners: {
                scope: me,
                processCompleted: callback,
                processFailed: callback
            }
        });
        transferSolutionService.processAsync(me._processParams(params));
    },

    _processParams: function _processParams(params) {
        if (!params) {
            return {};
        }

        if (params.points && _leaflet2["default"].Util.isArray(params.points)) {
            params.points.map(function (point, key) {
                params.points[key] = point instanceof _leaflet2["default"].LatLng ? { x: point.lng, y: point.lat } : point;
                return params.points[key];
            });
        }
        return params;
    }
});

var trafficTransferAnalystService = exports.trafficTransferAnalystService = function trafficTransferAnalystService(url, options) {
    return new TrafficTransferAnalystService(url, options);
};

_leaflet2["default"].supermap.trafficTransferAnalystService = trafficTransferAnalystService;

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Point;

/**
 * A standalone point geometry with useful accessor, comparison, and
 * modification methods.
 *
 * @class Point
 * @param {Number} x the x-coordinate. this could be longitude or screen
 * pixels, or any other sort of unit.
 * @param {Number} y the y-coordinate. this could be latitude or screen
 * pixels, or any other sort of unit.
 * @example
 * var point = new Point(-77, 38);
 */
function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {

    /**
     * Clone this point, returning a new point that can be modified
     * without affecting the old one.
     * @return {Point} the clone
     */
    clone: function clone() {
        return new Point(this.x, this.y);
    },

    /**
     * Add this point's x & y coordinates to another point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    add: function add(p) {
        return this.clone()._add(p);
    },

    /**
     * Subtract this point's x & y coordinates to from point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    sub: function sub(p) {
        return this.clone()._sub(p);
    },

    /**
     * Multiply this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    multByPoint: function multByPoint(p) {
        return this.clone()._multByPoint(p);
    },

    /**
     * Divide this point's x & y coordinates by point,
     * yielding a new point.
     * @param {Point} p the other point
     * @return {Point} output point
     */
    divByPoint: function divByPoint(p) {
        return this.clone()._divByPoint(p);
    },

    /**
     * Multiply this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    mult: function mult(k) {
        return this.clone()._mult(k);
    },

    /**
     * Divide this point's x & y coordinates by a factor,
     * yielding a new point.
     * @param {Point} k factor
     * @return {Point} output point
     */
    div: function div(k) {
        return this.clone()._div(k);
    },

    /**
     * Rotate this point around the 0, 0 origin by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @return {Point} output point
     */
    rotate: function rotate(a) {
        return this.clone()._rotate(a);
    },

    /**
     * Rotate this point around p point by an angle a,
     * given in radians
     * @param {Number} a angle to rotate around, in radians
     * @param {Point} p Point to rotate around
     * @return {Point} output point
     */
    rotateAround: function rotateAround(a, p) {
        return this.clone()._rotateAround(a, p);
    },

    /**
     * Multiply this point by a 4x1 transformation matrix
     * @param {Array<Number>} m transformation matrix
     * @return {Point} output point
     */
    matMult: function matMult(m) {
        return this.clone()._matMult(m);
    },

    /**
     * Calculate this point but as a unit vector from 0, 0, meaning
     * that the distance from the resulting point to the 0, 0
     * coordinate will be equal to 1 and the angle from the resulting
     * point to the 0, 0 coordinate will be the same as before.
     * @return {Point} unit vector point
     */
    unit: function unit() {
        return this.clone()._unit();
    },

    /**
     * Compute a perpendicular point, where the new y coordinate
     * is the old x coordinate and the new x coordinate is the old y
     * coordinate multiplied by -1
     * @return {Point} perpendicular point
     */
    perp: function perp() {
        return this.clone()._perp();
    },

    /**
     * Return a version of this point with the x & y coordinates
     * rounded to integers.
     * @return {Point} rounded point
     */
    round: function round() {
        return this.clone()._round();
    },

    /**
     * Return the magitude of this point: this is the Euclidean
     * distance from the 0, 0 coordinate to this point's x and y
     * coordinates.
     * @return {Number} magnitude
     */
    mag: function mag() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    /**
     * Judge whether this point is equal to another point, returning
     * true or false.
     * @param {Point} other the other point
     * @return {boolean} whether the points are equal
     */
    equals: function equals(other) {
        return this.x === other.x && this.y === other.y;
    },

    /**
     * Calculate the distance from this point to another point
     * @param {Point} p the other point
     * @return {Number} distance
     */
    dist: function dist(p) {
        return Math.sqrt(this.distSqr(p));
    },

    /**
     * Calculate the distance from this point to another point,
     * without the square root step. Useful if you're comparing
     * relative distances.
     * @param {Point} p the other point
     * @return {Number} distance
     */
    distSqr: function distSqr(p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    /**
     * Get the angle from the 0, 0 coordinate to this point, in radians
     * coordinates.
     * @return {Number} angle
     */
    angle: function angle() {
        return Math.atan2(this.y, this.x);
    },

    /**
     * Get the angle from this point to another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleTo: function angleTo(b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    /**
     * Get the angle between this point and another point, in radians
     * @param {Point} b the other point
     * @return {Number} angle
     */
    angleWith: function angleWith(b) {
        return this.angleWithSep(b.x, b.y);
    },

    /*
     * Find the angle of the two vectors, solving the formula for
     * the cross product a x b = |a||b|sin(θ) for θ.
     * @param {Number} x the x-coordinate
     * @param {Number} y the y-coordinate
     * @return {Number} the angle in radians
     */
    angleWithSep: function angleWithSep(x, y) {
        return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
    },

    _matMult: function _matMult(m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function _add(p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function _sub(p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function _mult(k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function _div(k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _multByPoint: function _multByPoint(p) {
        this.x *= p.x;
        this.y *= p.y;
        return this;
    },

    _divByPoint: function _divByPoint(p) {
        this.x /= p.x;
        this.y /= p.y;
        return this;
    },

    _unit: function _unit() {
        this._div(this.mag());
        return this;
    },

    _perp: function _perp() {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function _rotate(angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _rotateAround: function _rotateAround(angle, p) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),
            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function _round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

/**
 * Construct a point from an array if necessary, otherwise if the input
 * is already a Point, or an unknown type, return it unchanged
 * @param {Array<Number>|Point|*} a any kind of input value
 * @return {Point} constructed point, or passed-through value.
 * @example
 * // this
 * var point = Point.convert([0, 1]);
 * // is equivalent to
 * var point = new Point(0, 1);
 */
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.VectorTile = __webpack_require__(335);
module.exports.VectorTileFeature = __webpack_require__(137);
module.exports.VectorTileLayer = __webpack_require__(138);

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var VectorTileLayer = __webpack_require__(138);

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) layers[layer.name] = layer;
    }
}

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DateExt = undefined;

var _SuperMap = __webpack_require__(0);

/**
 * @name Date
 * @memberOf SuperMap
 * @namespace
 * @description 包含parse、toISOString方法的实现，两个方法用来解析RFC 3339日期，遵循 ECMAScript 5规范。
 */
var DateExt = exports.DateExt = _SuperMap.SuperMap.Date = {

    /**
     * @description 生成代表一个具体的日期字符串，该日期遵循ISO 8601标准(详情查看{@link http://tools.ietf.org/html/rfc3339})。
     * @example
     *  var dateString = SuperMap.Date.toISOString(new Date());
     * @param date - {Date} 日期对象。
     * @returns {string} 一个代表日期的字符串。(例如 "2010-08-07T16:58:23.123Z")。
     */
    toISOString: function () {
        //标准的Date会存在toISOString方法，可以直接调用
        if ("toISOString" in Date.prototype) {
            return function (date) {
                return date.toISOString();
            };
        } else {
            // //部分浏览器没有，就得自己组合，组合后的字符串规则不变
            var pad = function pad(num, len) {
                var str = num + "";
                while (str.length < len) {
                    str = "0" + str;
                }
                return str;
            };

            return function (date) {
                var str;
                if (isNaN(date.getTime())) {
                    // ECMA-262 says throw RangeError, Firefox returns
                    // "Invalid Date"
                    str = "Invalid Date";
                } else {
                    str = date.getUTCFullYear() + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + "T" + pad(date.getUTCHours(), 2) + ":" + pad(date.getUTCMinutes(), 2) + ":" + pad(date.getUTCSeconds(), 2) + "." + pad(date.getUTCMilliseconds(), 3) + "Z";
                }
                return str;
            };
        }
    }(),

    /**
     * @description 从一个字符串生成一个日期对象。
     * @example
     *  var date = SuperMap.Date.parse("2010-08-07");
     * @param str - {string} 代表日期的字符串。(例如： "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z","2010-08-07T11:58:23.123-06").
     * @returns {Date} 日期对象，如果字符串无法被解析，则返回一个无效的日期。(例如  isNaN(date.getTime())).
     */
    parse: function parse(str) {
        var date;
        var match = str.match(/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/);
        if (match && (match[1] || match[7])) {
            // must have at least year or time
            var year = parseInt(match[1], 10) || 0;
            var month = parseInt(match[2], 10) - 1 || 0;
            var day = parseInt(match[3], 10) || 1;
            date = new Date(Date.UTC(year, month, day));
            // optional time
            var type = match[7];
            if (type) {
                var hours = parseInt(match[4], 10);
                var minutes = parseInt(match[5], 10);
                var secFrac = parseFloat(match[6]);
                var seconds = secFrac | 0;
                var milliseconds = Math.round(1000 * (secFrac - seconds));
                date.setUTCHours(hours, minutes, seconds, milliseconds);
                // check offset
                if (type !== "Z") {
                    var hoursOffset = parseInt(type, 10);
                    var minutesOffset = parseInt(match[8], 10) || 0;
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
                    date = new Date(date.getTime() + offset);
                }
            }
        } else {
            date = new Date("invalid");
        }
        return date;
    }
};

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Collection = __webpack_require__(27);

Object.defineProperty(exports, 'Collection', {
  enumerable: true,
  get: function get() {
    return _Collection.Collection;
  }
});

var _Curve = __webpack_require__(90);

Object.defineProperty(exports, 'Curve', {
  enumerable: true,
  get: function get() {
    return _Curve.Curve;
  }
});

var _GeoText = __webpack_require__(91);

Object.defineProperty(exports, 'GeoText', {
  enumerable: true,
  get: function get() {
    return _GeoText.GeoText;
  }
});

var _LinearRing = __webpack_require__(31);

Object.defineProperty(exports, 'LinearRing', {
  enumerable: true,
  get: function get() {
    return _LinearRing.LinearRing;
  }
});

var _LineString = __webpack_require__(17);

Object.defineProperty(exports, 'LineString', {
  enumerable: true,
  get: function get() {
    return _LineString.LineString;
  }
});

var _MultiLineString = __webpack_require__(47);

Object.defineProperty(exports, 'MultiLineString', {
  enumerable: true,
  get: function get() {
    return _MultiLineString.MultiLineString;
  }
});

var _MultiPoint = __webpack_require__(38);

Object.defineProperty(exports, 'MultiPoint', {
  enumerable: true,
  get: function get() {
    return _MultiPoint.MultiPoint;
  }
});

var _MultiPolygon = __webpack_require__(48);

Object.defineProperty(exports, 'MultiPolygon', {
  enumerable: true,
  get: function get() {
    return _MultiPolygon.MultiPolygon;
  }
});

var _Point = __webpack_require__(18);

Object.defineProperty(exports, 'GeometryPoint', {
  enumerable: true,
  get: function get() {
    return _Point.Point;
  }
});

var _Polygon = __webpack_require__(49);

Object.defineProperty(exports, 'Polygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.Polygon;
  }
});

var _Rectangle = __webpack_require__(142);

Object.defineProperty(exports, 'Rectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.Rectangle;
  }
});

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = __webpack_require__(337);

Object.keys(_index).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _index[key];
    }
  });
});

var _BaseTypes = __webpack_require__(46);

Object.defineProperty(exports, 'StringExt', {
  enumerable: true,
  get: function get() {
    return _BaseTypes.StringExt;
  }
});
Object.defineProperty(exports, 'NumberExt', {
  enumerable: true,
  get: function get() {
    return _BaseTypes.NumberExt;
  }
});
Object.defineProperty(exports, 'FunctionExt', {
  enumerable: true,
  get: function get() {
    return _BaseTypes.FunctionExt;
  }
});
Object.defineProperty(exports, 'ArrayExt', {
  enumerable: true,
  get: function get() {
    return _BaseTypes.ArrayExt;
  }
});

var _Bounds = __webpack_require__(22);

Object.defineProperty(exports, 'Bounds', {
  enumerable: true,
  get: function get() {
    return _Bounds.Bounds;
  }
});

var _Credential = __webpack_require__(89);

Object.defineProperty(exports, 'Credential', {
  enumerable: true,
  get: function get() {
    return _Credential.Credential;
  }
});

var _Date = __webpack_require__(336);

Object.keys(_Date).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Date[key];
    }
  });
});

var _Event = __webpack_require__(139);

Object.keys(_Event).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Event[key];
    }
  });
});

var _Events = __webpack_require__(62);

Object.defineProperty(exports, 'Events', {
  enumerable: true,
  get: function get() {
    return _Events.Events;
  }
});

var _Feature = __webpack_require__(140);

Object.defineProperty(exports, 'Feature', {
  enumerable: true,
  get: function get() {
    return _Feature.Feature;
  }
});

var _Geometry = __webpack_require__(26);

Object.defineProperty(exports, 'Geometry', {
  enumerable: true,
  get: function get() {
    return _Geometry.Geometry;
  }
});

var _LonLat = __webpack_require__(37);

Object.defineProperty(exports, 'LonLat', {
  enumerable: true,
  get: function get() {
    return _LonLat.LonLat;
  }
});

var _Pixel = __webpack_require__(63);

Object.keys(_Pixel).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _Pixel[key];
    }
  });
});

var _Size = __webpack_require__(141);

Object.defineProperty(exports, 'Size', {
  enumerable: true,
  get: function get() {
    return _Size.Size;
  }
});

var _Util = __webpack_require__(1);

Object.defineProperty(exports, 'CommonUtil', {
  enumerable: true,
  get: function get() {
    return _Util.Util;
  }
});

var _Vector = __webpack_require__(64);

Object.defineProperty(exports, 'GeometryVector', {
  enumerable: true,
  get: function get() {
    return _Vector.Vector;
  }
});

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _TimeControlBase = __webpack_require__(143);

Object.defineProperty(exports, 'TimeControlBase', {
  enumerable: true,
  get: function get() {
    return _TimeControlBase.TimeControlBase;
  }
});

var _TimeFlowControl = __webpack_require__(119);

Object.defineProperty(exports, 'TimeFlowControl', {
  enumerable: true,
  get: function get() {
    return _TimeFlowControl.TimeFlowControl;
  }
});

var _iClient = __webpack_require__(307);

Object.keys(_iClient).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _iClient[key];
    }
  });
});

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WKT = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Format2 = __webpack_require__(92);

var _BaseTypes = __webpack_require__(46);

var _Vector = __webpack_require__(64);

var _Point = __webpack_require__(18);

var _MultiPoint = __webpack_require__(38);

var _LineString = __webpack_require__(17);

var _MultiLineString = __webpack_require__(47);

var _LinearRing = __webpack_require__(31);

var _Polygon = __webpack_require__(49);

var _MultiPolygon = __webpack_require__(48);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Format.WKT
 * @classdesc 用于读写常见文本的类。通过 <SuperMap.Format.WKT> 构造器来创建一个新
 *      的实例。
 * @extends SuperMap.Format
 * @param options - {Object} 可选的选项对象，其属性将被设置到实例。option具体配置项继承自{@link SuperMap.Format}
 */
var WKT = exports.WKT = function (_Format) {
    _inherits(WKT, _Format);

    function WKT(options) {
        _classCallCheck(this, WKT);

        var _this = _possibleConstructorReturn(this, (WKT.__proto__ || Object.getPrototypeOf(WKT)).call(this, options));

        _this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/, // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        _this.CLASS_NAME = "SuperMap.Format.WKT"; /**
                                                  * @private
                                                  * @description Object with properties corresponding to the geometry types.
                                                  * Property values are functions that do the actual data extraction.
                                                  */
        _this.extract = {
            /*
             * @description Return a space delimited string of point coordinates.
             * @param {SuperMap.Geometry.Point} point
             * @returns  {String} A string of coordinates representing the point
             */
            'point': function point(_point) {
                return _point.x + ' ' + _point.y;
            },

            /*
             * @description  Return a comma delimited string of point coordinates from a multipoint.
             * @param {SuperMap.Geometry.MultiPoint} multipoint
             * @returns  {String} A string of point coordinate strings representing
             *                  the multipoint
             */
            'multipoint': function multipoint(_multipoint) {
                var array = [];
                for (var i = 0, len = _multipoint.components.length; i < len; ++i) {
                    array.push('(' + this.extract.point.apply(this, [_multipoint.components[i]]) + ')');
                }
                return array.join(',');
            },


            /*
             * @description  Return a comma delimited string of point coordinates from a line.
             * @param {SuperMap.Geometry.LineString} linestring
             * @returns  {String} A string of point coordinate strings representing
             *                  the linestring
             */
            'linestring': function linestring(_linestring) {
                var array = [];
                for (var i = 0, len = _linestring.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [_linestring.components[i]]));
                }
                return array.join(',');
            },


            /*
             * @description  Return a comma delimited string of linestring strings from a multilinestring.
             * @param {SuperMap.Geometry.MultiLineString} multilinestring
             * @returns  {String} A string of of linestring strings representing
             *                  the multilinestring
             */
            'multilinestring': function multilinestring(_multilinestring) {
                var array = [];
                for (var i = 0, len = _multilinestring.components.length; i < len; ++i) {
                    array.push('(' + this.extract.linestring.apply(this, [_multilinestring.components[i]]) + ')');
                }
                return array.join(',');
            },


            /*
             * @description  Return a comma delimited string of linear ring arrays from a polygon.
             * @param {SuperMap.Geometry.Polygon} polygon
             * @returns  {String} An array of linear ring arrays representing the polygon
             */
            'polygon': function polygon(_polygon) {
                var array = [];
                for (var i = 0, len = _polygon.components.length; i < len; ++i) {
                    array.push('(' + this.extract.linestring.apply(this, [_polygon.components[i]]) + ')');
                }
                return array.join(',');
            },


            /*
             * @description  Return an array of polygon arrays from a multipolygon.
             * @param {SuperMap.Geometry.MultiPolygon} multipolygon
             * @returns  {String} An array of polygon arrays representing
             *                  the multipolygon
             */
            'multipolygon': function multipolygon(_multipolygon) {
                var array = [];
                for (var i = 0, len = _multipolygon.components.length; i < len; ++i) {
                    array.push('(' + this.extract.polygon.apply(this, [_multipolygon.components[i]]) + ')');
                }
                return array.join(',');
            },


            /*
             * @description  Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an <SuperMap.Geometry.Collection>
             * @param {SuperMap.Geometry.Collection} collection
             * @returns  {String} internal WKT representation of the collection
             */
            'collection': function collection(_collection) {
                var array = [];
                for (var i = 0, len = _collection.components.length; i < len; ++i) {
                    array.push(this.extractGeometry.apply(this, [_collection.components[i]]));
                }
                return array.join(',');
            }
        };

        /*
         * @private
         * @description Object with properties corresponding to the geometry types.
         * Property values are functions that do the actual parsing.
         */
        _this.parse = {
            /*
             * @private
             * @description  Return point feature given a point WKT fragment.
             * @param {String} str A WKT fragment representing the point
             * @returns  {SuperMap.Feature.Vector} A point feature
             *
             */
            'point': function point(str) {
                var coords = _BaseTypes.StringExt.trim(str).split(this.regExes.spaces);
                return new _Vector.Vector(new _Point.Point(coords[0], coords[1]));
            },

            /*
             * @description  Return a multipoint feature given a multipoint WKT fragment.
             * @param {String} A WKT fragment representing the multipoint
             * @returns  {SuperMap.Feature.Vector} A multipoint feature
             * @private
             */
            'multipoint': function multipoint(str) {
                var point;
                var points = _BaseTypes.StringExt.trim(str).split(',');
                var components = [];
                for (var i = 0, len = points.length; i < len; ++i) {
                    point = points[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.point.apply(this, [point]).geometry);
                }
                return new _Vector.Vector(new _MultiPoint.MultiPoint(components));
            },

            /*
             * @description  Return a linestring feature given a linestring WKT fragment.
             * @param {String} A WKT fragment representing the linestring
             * @returns  {SuperMap.Feature.Vector} A linestring feature
             * @private
             */
            'linestring': function linestring(str) {
                var points = _BaseTypes.StringExt.trim(str).split(',');
                var components = [];
                for (var i = 0, len = points.length; i < len; ++i) {
                    components.push(this.parse.point.apply(this, [points[i]]).geometry);
                }
                return new _Vector.Vector(new _LineString.LineString(components));
            },

            /*
             * @description  Return a multilinestring feature given a multilinestring WKT fragment.
             * @param {String} A WKT fragment representing the multilinestring
             * @returns  {SuperMap.Feature.Vector} A multilinestring feature
             * @private
             */
            'multilinestring': function multilinestring(str) {
                var line;
                var lines = _BaseTypes.StringExt.trim(str).split(this.regExes.parenComma);
                var components = [];
                for (var i = 0, len = lines.length; i < len; ++i) {
                    line = lines[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.linestring.apply(this, [line]).geometry);
                }
                return new _Vector.Vector(new _MultiLineString.MultiLineString(components));
            },

            /*
             * @description  Return a polygon feature given a polygon WKT fragment.
             * @param {String} A WKT fragment representing the polygon
             * @returns  {SuperMap.Feature.Vector} A polygon feature
             * @private
             */
            'polygon': function polygon(str) {
                var ring, linestring, linearring;
                var rings = _BaseTypes.StringExt.trim(str).split(this.regExes.parenComma);
                var components = [];
                for (var i = 0, len = rings.length; i < len; ++i) {
                    ring = rings[i].replace(this.regExes.trimParens, '$1');
                    linestring = this.parse.linestring.apply(this, [ring]).geometry;
                    linearring = new _LinearRing.LinearRing(linestring.components);
                    components.push(linearring);
                }
                return new _Vector.Vector(new _Polygon.Polygon(components));
            },

            /*
             * @private
             * @description  Return a multipolygon feature given a multipolygon WKT fragment.
             * @param {String} A WKT fragment representing the multipolygon
             * @returns  {SuperMap.Feature.Vector} A multipolygon feature
             *
             */
            'multipolygon': function multipolygon(str) {
                var polygon;
                var polygons = _BaseTypes.StringExt.trim(str).split(this.regExes.doubleParenComma);
                var components = [];
                for (var i = 0, len = polygons.length; i < len; ++i) {
                    polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.polygon.apply(this, [polygon]).geometry);
                }
                return new _Vector.Vector(new _MultiPolygon.MultiPolygon(components));
            },

            /*
             * @description  Return an array of features given a geometrycollection WKT fragment.
             * @param {String} A WKT fragment representing the geometrycollection
             * @returns  {Array} An array of SuperMap.Feature.Vector
             * @private
             */
            'geometrycollection': function geometrycollection(str) {
                // separate components of the collection with |
                str = str.replace(/,\s*([A-Za-z])/g, '|$1');
                var wktArray = _BaseTypes.StringExt.trim(str).split('|');
                var components = [];
                for (var i = 0, len = wktArray.length; i < len; ++i) {
                    components.push(this.read(wktArray[i]));
                }
                return components;
            }

        };

        return _this;
    }

    /**
     * @function SuperMap.Format.WKT.prototype.read
     * @description Deserialize a WKT string and return a vector feature or an
     * array of vector features.  Supports WKT for POINT, MULTIPOINT,
     * LINESTRING, MULTILINESTRING, POLYGON, MULTIPOLYGON, and
     * GEOMETRYCOLLECTION.
     * @param wkt - {string} A WKT string
     * @returns {SuperMap.Feature.Vector|Array} A feature or array of features for
     * GEOMETRYCOLLECTION WKT.
     */


    _createClass(WKT, [{
        key: 'read',
        value: function read(wkt) {
            var features, type, str;
            wkt = wkt.replace(/[\n\r]/g, " ");
            var matches = this.regExes.typeStr.exec(wkt);
            if (matches) {
                type = matches[1].toLowerCase();
                str = matches[2];
                if (this.parse[type]) {
                    features = this.parse[type].apply(this, [str]);
                }
            }
            return features;
        }

        /**
         * @function SuperMap.Format.WKT.prototype.write
         * @description Serialize a feature or array of features into a WKT string.
         * @param features - {SuperMap.Feature.Vector|Array} A feature or array of features
         * @returns {string} The WKT string representation of the input geometries
         */

    }, {
        key: 'write',
        value: function write(features) {
            var collection, geometry, isCollection;
            if (features.constructor === Array) {
                collection = features;
                isCollection = true;
            } else {
                collection = [features];
                isCollection = false;
            }
            var pieces = [];
            if (isCollection) {
                pieces.push('GEOMETRYCOLLECTION(');
            }
            for (var i = 0, len = collection.length; i < len; ++i) {
                if (isCollection && i > 0) {
                    pieces.push(',');
                }
                geometry = collection[i].geometry;
                pieces.push(this.extractGeometry(geometry));
            }
            if (isCollection) {
                pieces.push(')');
            }
            return pieces.join('');
        }

        /**
         * @function SuperMap.Format.WKT.prototype.extractGeometry
         * @description Entry point to construct the WKT for a single Geometry object.
         * @param geometry - {SuperMap.Geometry}
         * @returns {string} A WKT string of representing the geometry
         */

    }, {
        key: 'extractGeometry',
        value: function extractGeometry(geometry) {
            var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
            if (!this.extract[type]) {
                return null;
            }
            var wktType = type === 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
            var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
            return data;
        }
    }]);

    return WKT;
}(_Format2.Format);

_SuperMap.SuperMap.Format.WKT = WKT;

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Format = __webpack_require__(92);

Object.defineProperty(exports, 'Format', {
  enumerable: true,
  get: function get() {
    return _Format.Format;
  }
});

var _GeoJSON = __webpack_require__(14);

Object.defineProperty(exports, 'GeoJSON', {
  enumerable: true,
  get: function get() {
    return _GeoJSON.GeoJSON;
  }
});

var _JSON = __webpack_require__(93);

Object.defineProperty(exports, 'JSONFormat', {
  enumerable: true,
  get: function get() {
    return _JSON.JSONFormat;
  }
});

var _WKT = __webpack_require__(340);

Object.defineProperty(exports, 'WKT', {
  enumerable: true,
  get: function get() {
    return _WKT.WKT;
  }
});

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _iManager = __webpack_require__(120);

Object.defineProperty(exports, 'IManager', {
  enumerable: true,
  get: function get() {
    return _iManager.IManager;
  }
});

var _iManagerCreateNodeParam = __webpack_require__(144);

Object.defineProperty(exports, 'IManagerCreateNodeParam', {
  enumerable: true,
  get: function get() {
    return _iManagerCreateNodeParam.IManagerCreateNodeParam;
  }
});

var _iManagerServiceBase = __webpack_require__(145);

Object.defineProperty(exports, 'IManagerServiceBase', {
  enumerable: true,
  get: function get() {
    return _iManagerServiceBase.IManagerServiceBase;
  }
});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _iPortal = __webpack_require__(121);

Object.defineProperty(exports, 'IPortal', {
  enumerable: true,
  get: function get() {
    return _iPortal.IPortal;
  }
});

var _iPortalMap = __webpack_require__(146);

Object.defineProperty(exports, 'IPortalMap', {
  enumerable: true,
  get: function get() {
    return _iPortalMap.IPortalMap;
  }
});

var _iPortalMapsQueryParam = __webpack_require__(147);

Object.defineProperty(exports, 'IPortalMapsQueryParam', {
  enumerable: true,
  get: function get() {
    return _iPortalMapsQueryParam.IPortalMapsQueryParam;
  }
});

var _iPortalService = __webpack_require__(148);

Object.defineProperty(exports, 'IPortalService', {
  enumerable: true,
  get: function get() {
    return _iPortalService.IPortalService;
  }
});

var _iPortalServiceBase = __webpack_require__(65);

Object.defineProperty(exports, 'IPortalServiceBase', {
  enumerable: true,
  get: function get() {
    return _iPortalServiceBase.IPortalServiceBase;
  }
});

var _iPortalServicesQueryParam = __webpack_require__(149);

Object.defineProperty(exports, 'IPortalServicesQueryParam', {
  enumerable: true,
  get: function get() {
    return _iPortalServicesQueryParam.IPortalServicesQueryParam;
  }
});

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AddressMatchService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FetchRequest = __webpack_require__(21);

var _GeoCodingParameter = __webpack_require__(183);

var _GeoDecodingParameter = __webpack_require__(184);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.AddressMatchService
 * @classdesc 地址匹配服务，包括正向匹配和反向匹配。
 * @param options - {Object} 参数。
 * @param url {string} 地址匹配服务地址。
 */
var AddressMatchService = exports.AddressMatchService = function (_CommonServiceBase) {
    _inherits(AddressMatchService, _CommonServiceBase);

    function AddressMatchService(url, options) {
        _classCallCheck(this, AddressMatchService);

        var _this = _possibleConstructorReturn(this, (AddressMatchService.__proto__ || Object.getPrototypeOf(AddressMatchService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.AddressMatchService";
        return _this;
    }

    /**
     * @function SuperMap.AddressMatchService.prototype.destroy
     * @override
     */


    _createClass(AddressMatchService, [{
        key: 'destroy',
        value: function destroy() {
            _get(AddressMatchService.prototype.__proto__ || Object.getPrototypeOf(AddressMatchService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.code
         * @param url {string} 正向地址匹配服务地址
         * @param params {SuperMap.GeoCodingParameter} 正向地址匹配服务参数
         */

    }, {
        key: 'code',
        value: function code(url, params) {
            if (!(params instanceof _GeoCodingParameter.GeoCodingParameter)) {
                return;
            }
            this.processAsync(url, params);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.decode
         * @param url {string} 反向地址匹配服务地址
         * @param params {SuperMap.GeoDecodingParameter} 反向地址匹配服务参数
         */

    }, {
        key: 'decode',
        value: function decode(url, params) {
            if (!(params instanceof _GeoDecodingParameter.GeoDecodingParameter)) {
                return;
            }
            this.processAsync(url, params);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.processAsync
         * @description 负责将客户端的动态分段服务参数传递到服务端。
         * @param url - {string} 服务地址
         * @param params - {Object} 参数
         */

    }, {
        key: 'processAsync',
        value: function processAsync(url, params) {
            var me = this;
            _FetchRequest.FetchRequest.get(url, params).then(function (response) {
                return response.json();
            }).then(function (result) {
                if (result) {
                    me.serviceProcessCompleted(result);
                } else {
                    me.serviceProcessFailed(result);
                }
            })["catch"](function (e) {
                me.eventListeners.processFailed({ error: e });
            });
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.serviceProcessCompleted
         * @param result - {Object} 服务器返回的结果对象。
         * @description 服务流程是否完成
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            _get(AddressMatchService.prototype.__proto__ || Object.getPrototypeOf(AddressMatchService.prototype), 'serviceProcessCompleted', this).call(this, result);
        }

        /**
         * @function SuperMap.AddressMatchService.prototype.serviceProcessCompleted
         * @param result - {Object} 服务器返回的结果对象。
         * @description 服务流程是否失败
         */

    }, {
        key: 'serviceProcessFailed',
        value: function serviceProcessFailed(result) {
            _get(AddressMatchService.prototype.__proto__ || Object.getPrototypeOf(AddressMatchService.prototype), 'serviceProcessFailed', this).call(this, result);
        }
    }]);

    return AddressMatchService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.AddressMatchService = AddressMatchService;

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AreaSolarRadiationService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _AreaSolarRadiationParameters = __webpack_require__(150);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.AreaSolarRadiationService
 * @classdesc 地区太阳辐射服务类。
 * @param url - {string} 服务的访问地址。如</br> http://localhost:8090/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst 。</br>
 * @param options - {Object} 参数。如:</br>
 * eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myAreaSolarRadiationService = new SuperMap.AreaSolarRadiationService(url);
 * myAreaSolarRadiationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var AreaSolarRadiationService = exports.AreaSolarRadiationService = function (_SpatialAnalystBase) {
    _inherits(AreaSolarRadiationService, _SpatialAnalystBase);

    function AreaSolarRadiationService(url, options) {
        _classCallCheck(this, AreaSolarRadiationService);

        var _this = _possibleConstructorReturn(this, (AreaSolarRadiationService.__proto__ || Object.getPrototypeOf(AreaSolarRadiationService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.AreaSolarRadiationService";
        return _this;
    }

    /**
     * @function SuperMap.AreaSolarRadiationService.prototype.destroy
     * @override
     */


    _createClass(AreaSolarRadiationService, [{
        key: 'destroy',
        value: function destroy() {
            _get(AreaSolarRadiationService.prototype.__proto__ || Object.getPrototypeOf(AreaSolarRadiationService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.AreaSolarRadiationService.prototype.processAsync
         * @description  负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.AreaSolarRadiationParameters} 地区太阳辐射参数
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            if (!(parameter instanceof _AreaSolarRadiationParameters.AreaSolarRadiationParameters)) {
                return;
            }
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            var parameterObject = {};

            if (parameter instanceof _AreaSolarRadiationParameters.AreaSolarRadiationParameters) {
                me.url += 'datasets/' + parameter.dataset + '/solarradiation';
            }

            _AreaSolarRadiationParameters.AreaSolarRadiationParameters.toObject(parameter, parameterObject);
            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return AreaSolarRadiationService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.AreaSolarRadiationService = AreaSolarRadiationService;

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BufferAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _DatasetBufferAnalystParameters = __webpack_require__(160);

var _GeometryBufferAnalystParameters = __webpack_require__(186);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.BufferAnalystService
 * @classdesc 缓冲区分析服务类
 * 该类负责将客户设置的缓冲区分析参数传递给服务端，并接收服务端返回的缓冲区分析结果数据。
 * 缓冲区分析结果通过该类支持的事件的监听函数参数获取
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myBufferAnalystService = new SuperMap.BufferAnalystService(url, {
     *     eventListeners: {
     *           "processCompleted": bufferCompleted,
     *           "processFailed": bufferFailed
     *           }
     *    });
 * (end)
 *
 *
 */
var BufferAnalystService = exports.BufferAnalystService = function (_SpatialAnalystBase) {
    _inherits(BufferAnalystService, _SpatialAnalystBase);

    function BufferAnalystService(url, options) {
        _classCallCheck(this, BufferAnalystService);

        /**
         * @member SuperMap.BufferAnalystService.prototype.mode -{string}
         * @description 缓冲区分析类型
         */
        var _this = _possibleConstructorReturn(this, (BufferAnalystService.__proto__ || Object.getPrototypeOf(BufferAnalystService)).call(this, url, options));

        _this.mode = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.BufferAnalystService";
        return _this;
    }

    /**
     * @function SuperMap.BufferAnalystService.prototype.destroy
     * @override
     */


    _createClass(BufferAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(BufferAnalystService.prototype.__proto__ || Object.getPrototypeOf(BufferAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @method SuperMap.BufferAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {BufferAnalystParameters} 缓冲区分析参数
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            if (parameter instanceof _DatasetBufferAnalystParameters.DatasetBufferAnalystParameters) {
                me.mode = "datasets";
                me.url += 'datasets/' + parameter.dataset + '/buffer';
                _DatasetBufferAnalystParameters.DatasetBufferAnalystParameters.toObject(parameter, parameterObject);
            } else if (parameter instanceof _GeometryBufferAnalystParameters.GeometryBufferAnalystParameters) {
                me.mode = "geometry";
                me.url += 'geometry/buffer';
                _GeometryBufferAnalystParameters.GeometryBufferAnalystParameters.toObject(parameter, parameterObject);
            }

            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @method SuperMap.BufferAnalystService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */
        // toGeoJSONResult(result) {
        //     if (!result) {
        //         return result;
        //     }
        //
        //     var analystResult = super.toGeoJSONResult(result);
        //     if (analystResult.resultGeometry) {
        //         var geoJSONFormat = new GeoJSON();
        //         result = JSON.parse(geoJSONFormat.write(analystResult.resultGeometry));
        //     }
        //     return result;
        // }


    }]);

    return BufferAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.BufferAnalystService = BufferAnalystService;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BuffersAnalystJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _BuffersAnalystJobsParameter = __webpack_require__(153);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.BuffersAnalystJobsService
 * @classdesc 缓冲区分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 缓冲区分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var BuffersAnalystJobsService = exports.BuffersAnalystJobsService = function (_ProcessingServiceBas) {
    _inherits(BuffersAnalystJobsService, _ProcessingServiceBas);

    function BuffersAnalystJobsService(url, options) {
        _classCallCheck(this, BuffersAnalystJobsService);

        var _this = _possibleConstructorReturn(this, (BuffersAnalystJobsService.__proto__ || Object.getPrototypeOf(BuffersAnalystJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/buffers";
        _this.CLASS_NAME = "SuperMap.BuffersAnalystJobsService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(BuffersAnalystJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(BuffersAnalystJobsService.prototype.__proto__ || Object.getPrototypeOf(BuffersAnalystJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.BuffersAnalystJobsService.protitype.getBufferJobs
         * @description 获取缓冲区分析所有任务
         */

    }, {
        key: 'getBuffersJobs',
        value: function getBuffersJobs() {
            _get(BuffersAnalystJobsService.prototype.__proto__ || Object.getPrototypeOf(BuffersAnalystJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.BuffersAnalystJobsService.protitype.getBufferJob
         * @description 获取指定id的缓冲区分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getBuffersJob',
        value: function getBuffersJob(id) {
            _get(BuffersAnalystJobsService.prototype.__proto__ || Object.getPrototypeOf(BuffersAnalystJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.BuffersAnalystJobsService.protitype.addBufferJob
         * @description 新建缓冲区分析服务
         * @param params - {SuperMap.BuffersAnalystJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addBuffersJob',
        value: function addBuffersJob(params, seconds) {
            _get(BuffersAnalystJobsService.prototype.__proto__ || Object.getPrototypeOf(BuffersAnalystJobsService.prototype), 'addJob', this).call(this, this.url, params, _BuffersAnalystJobsParameter.BuffersAnalystJobsParameter, seconds);
        }
    }]);

    return BuffersAnalystJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.BuffersAnalystJobsService = BuffersAnalystJobsService;

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BurstPipelineAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _BurstPipelineAnalystParameters = __webpack_require__(154);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.BurstPipelineAnalystService
 * @classdesc 爆管分析服务类;即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
 * @extends SuperMap.NetworkAnalystServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var BurstPipelineAnalystService = exports.BurstPipelineAnalystService = function (_NetworkAnalystServic) {
    _inherits(BurstPipelineAnalystService, _NetworkAnalystServic);

    function BurstPipelineAnalystService(url, options) {
        _classCallCheck(this, BurstPipelineAnalystService);

        var _this = _possibleConstructorReturn(this, (BurstPipelineAnalystService.__proto__ || Object.getPrototypeOf(BurstPipelineAnalystService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.BurstPipelineAnalystService";
        return _this;
    }

    /**
     * @function SuperMap.BurstPipelineAnalystService.prototype.destroy
     * @override
     */


    _createClass(BurstPipelineAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(BurstPipelineAnalystService.prototype.__proto__ || Object.getPrototypeOf(BurstPipelineAnalystService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.BurstPipelineAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @params params - {SuperMap.BurstPipelineAnalystParameters} 爆管分析参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _BurstPipelineAnalystParameters.BurstPipelineAnalystParameters)) {
                return null;
            }
            var me = this,
                jsonObject;
            var end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "burstAnalyse" : "/burstAnalyse") + ".json?";

            jsonObject = {
                sourceNodeIDs: params.sourceNodeIDs,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };

            //必传参数不正确，就终止
            if (params.edgeID !== null && params.nodeID !== null) {
                return;
            }
            if (params.edgeID === null && params.nodeID === null) {
                return;
            }
            if (params.edgeID !== null) {
                jsonObject.edgeID = params.edgeID;
            } else {
                jsonObject.nodeID = params.nodeID;
            }

            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return BurstPipelineAnalystService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.BurstPipelineAnalystService = BurstPipelineAnalystService;

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChartFeatureInfoSpecsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ChartFeatureInfoSpecsService
 * @classdesc 海图物标信息服务类，通过该服务类可以查询到服务端支持的所有海图物标信息。<br>
 *              用户可以通过两种方式获取查询结果：<br>
 *              一种是通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件；<br>
 *              另一种是使用 AsyncResponder 类实现异步处理。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图（特指海图）服务地址。<br>
 *        如："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图"。<br>
 *        发送请求格式类似于："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图/chartFeatureInfoSpecs.json"
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var ChartFeatureInfoSpecsService = exports.ChartFeatureInfoSpecsService = function (_CommonServiceBase) {
    _inherits(ChartFeatureInfoSpecsService, _CommonServiceBase);

    function ChartFeatureInfoSpecsService(url, options) {
        _classCallCheck(this, ChartFeatureInfoSpecsService);

        var _this = _possibleConstructorReturn(this, (ChartFeatureInfoSpecsService.__proto__ || Object.getPrototypeOf(ChartFeatureInfoSpecsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ChartFeatureInfoSpecsService";
        return _this;
    }

    /**
     * @function SuperMap.ChartFeatureInfoSpecsService.prototype.destroy
     * @override
     */


    _createClass(ChartFeatureInfoSpecsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ChartFeatureInfoSpecsService.prototype.__proto__ || Object.getPrototypeOf(ChartFeatureInfoSpecsService.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.ChartFeatureInfoSpecsService.prototype.processAsync
         * @description 根据地图（特指海图）服务地址与服务端完成异步通讯，获取物标信息。<br>
         *               当查询物标信息成功时，将触发 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE <br>
         *               事件。用可以通过户两种方式获取图层信息: <br>
         *                 1. 通过 AsyncResponder 类获取（推荐使用）；<br>
         *                 2. 通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                method = "GET",
                end = me.url.substr(me.url.length - 1, 1);
            if (!me.isTempLayers) {
                me.url += end === "/" ? '' : '/';
                me.url += "chartFeatureInfoSpecs.json?";
            } else {
                me.url += ".json?";
            }
            me.request({
                method: method,
                params: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return ChartFeatureInfoSpecsService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.ChartFeatureInfoSpecsService = ChartFeatureInfoSpecsService;

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChartQueryService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _CommonServiceBase2 = __webpack_require__(6);

var _QueryParameters = __webpack_require__(32);

var _ChartQueryParameters = __webpack_require__(156);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ChartQueryService
 * @classdesc 海图查询服务类。该类负责将海图查询所需参数（ChartQueryParameters）传递至服务端，并获取服务端的返回结果。<br>
 *      用户可以通过两种方式获取查询结果:<br>
 *      1.通过 AsyncResponder 类获取（推荐使用）；<br>
 *      2.通过监听 QueryEvent.PROCESS_COMPLETE 事件获取。<br>
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图查询服务访问地址。如："http://192.168.168.35:8090/iserver/services/map-ChartW/rest/maps/海图"。
 * @param options - {Object} 服务交互时所需的可选参数。<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @example
 * 下面示例显示了如何进行海图属性查询：
 * var nameArray = ["GB4X0000_52000"];
 * var chartQueryFilterParameter = new ChartQueryFilterParameter({
 *       isQueryPoint:true,
 *        isQueryLine:true,
 *        isQueryRegion:true,
 *        attributeFilter:"SmID<10",
 *        chartFeatureInfoSpecCode:1
 *    });
 *
 * var chartQueryParameters = new SuperMap.ChartQueryParameters({
 *        queryMode:"ChartAttributeQuery",
 *        chartLayerNames:nameArray,
 *        returnContent:true,
 *        chartQueryFilterParameters:[chartQueryFilterParameter]
 *    });
 *
 * var chartQueryService = new SuperMap.ChartQueryService(url);
 *
 * chartQueryService.events.on({
 *        "processCompleted":processCompleted,
 *        "processFailed":processFailed
 *    });
 * chartQueryService.processAsync(chartQueryParameters);
 */
var ChartQueryService = exports.ChartQueryService = function (_CommonServiceBase) {
    _inherits(ChartQueryService, _CommonServiceBase);

    function ChartQueryService(url, options) {
        _classCallCheck(this, ChartQueryService);

        var _this = _possibleConstructorReturn(this, (ChartQueryService.__proto__ || Object.getPrototypeOf(ChartQueryService)).call(this, url, options));

        options = options || {};

        /**
         * @member SuperMap.ChartQueryService.prototype.returnContent -{boolean}
         * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
         */
        _this.returnContent = null;

        /**
         * @member SuperMap.ChartQueryService.prototype.format -{SuperMap.DataFormat}
         * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
         *              参数格式为"ISERVER","GEOJSON",GEOJSON
         */
        _this.format = _REST.DataFormat.GEOJSON;

        if (options) {
            _Util.Util.extend(_this, options);
        }
        var me = _this,
            end;
        if (options && options.format) {
            me.format = options.format.toUpperCase();
        }

        if (!me.url) {
            return _possibleConstructorReturn(_this);
        }
        end = me.url.substr(me.url.length - 1, 1);

        // TODO 待iServer featureResul资源GeoJSON表述bug修复当使用以下注释掉的逻辑
        // if (me.format==="geojson") {
        //     me.url += (end == "/") ? "featureResults.geojson?" : "/featureResults.geojson?";
        // } else {
        //     me.url += (end == "/") ? "featureResults.json?" : "/featureResults.json?";
        // }
        me.url += end === "/" ? "queryResults.json?" : "/queryResults.json?";

        _this.CLASS_NAME = "SuperMap.ChartQueryService";
        return _this;
    }

    /**
     * @function SuperMap.ChartQueryService.prototype.destroy
     * @override
     */


    _createClass(ChartQueryService, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            _CommonServiceBase2.CommonServiceBase.prototype.destroy.apply(this, arguments);
            me.returnContent = null;
            me.format = null;
        }

        /**
         * @function SuperMap.ChartQueryService.prototype.processAsync
         * @description 使用服务地址 URL 实例化 ChartQueryService 对象。
         * @param params - {SuperMap.ChartQueryParameters} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            //todo重点需要添加代码的地方
            if (!(params instanceof _ChartQueryParameters.ChartQueryParameters)) {
                return;
            }
            var me = this,
                jsonParameters;
            me.returnContent = params.returnContent;
            jsonParameters = params.getVariablesJson();
            if (me.returnContent) {
                me.url += "returnContent=" + me.returnContent;
            }
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ChartQueryService.prototype.serviceProcessCompleted
         * @description 查询完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            if (result && result.recordsets && me.format === _REST.DataFormat.GEOJSON) {
                for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                    if (recordsets[i].features) {
                        var geoJSONFormat = new _GeoJSON.GeoJSON();
                        recordsets[i].features = JSON.parse(geoJSONFormat.write(recordsets[i].features));
                    }
                }
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }

        /**
         * @function SuperMap.ChartQueryService.prototype.getQueryParameters
         * @description 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
         * @param params - {Object} JSON 字符串表示的查询参数。
         * @return {SuperMap.QueryParameters} 返回查询结果
         */

    }, {
        key: 'getQueryParameters',
        value: function getQueryParameters(params) {
            return new _QueryParameters.QueryParameters({
                queryMode: params.queryMode,
                bounds: params.bounds,
                chartLayerNames: params.chartLayerNames,
                chartQueryFilterParameters: params.chartQueryFilterParameters,
                returnContent: params.returnContent
            });
        }
    }]);

    return ChartQueryService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.ChartQueryService = ChartQueryService;

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ComputeWeightMatrixService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ComputeWeightMatrixParameters = __webpack_require__(159);

var _NetworkAnalystServiceBase = __webpack_require__(15);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ComputeWeightMatrixService
 * @classdesc 耗费矩阵分析服务类。<br>
 *               耗费矩阵是根据交通网络分析参数中的耗费字段来计算一个二维数组，
 *               用来存储指定的任意两点间的资源消耗。
 *               耗费矩阵分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var mycomputeWeightMatrixService = new SuperMap.ComputeWeightMatrixService(url,{
 *     eventListeners: {
 *	       "processCompleted": computeWeightMatrixCompleted,
 *		   "processFailed": computeWeightMatrixnError
 *		   }
 * });
 * @param url - {string} 耗费矩阵分析服务地址。请求服务的URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var ComputeWeightMatrixService = exports.ComputeWeightMatrixService = function (_NetworkAnalystServic) {
    _inherits(ComputeWeightMatrixService, _NetworkAnalystServic);

    function ComputeWeightMatrixService(url, options) {
        _classCallCheck(this, ComputeWeightMatrixService);

        var _this = _possibleConstructorReturn(this, (ComputeWeightMatrixService.__proto__ || Object.getPrototypeOf(ComputeWeightMatrixService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.ComputeWeightMatrixService";
        return _this;
    }

    /**
     * @function SuperMap.ComputeWeightMatrixService.prototype.destroy
     * @override
     */


    _createClass(ComputeWeightMatrixService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ComputeWeightMatrixService.prototype.__proto__ || Object.getPrototypeOf(ComputeWeightMatrixService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.ComputeWeightMatrixService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.ComputeWeightMatrixParameters} 耗费矩阵分析参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _ComputeWeightMatrixParameters.ComputeWeightMatrixParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "weightmatrix" : "/weightmatrix") + ".json?";
            jsonObject = {
                parameter: _Util.Util.toJSON(params.parameter),
                nodes: me.getJson(params.isAnalyzeById, params.nodes)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ComputeWeightMatrixService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 分析参数数组
         * @return- {string} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) {
                        jsonString += ",";
                    }
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var _i = 0; _i < len; _i++) {
                    if (_i > 0) {
                        jsonString += ",";
                    }
                    jsonString += params[_i];
                }
            }
            jsonString += ']';
            return jsonString;
        }
    }]);

    return ComputeWeightMatrixService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.ComputeWeightMatrixService = ComputeWeightMatrixService;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataFlowService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _Util = __webpack_require__(1);

var _SecurityManager = __webpack_require__(35);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DataFlowService
 * @classdesc 实时数据服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 实时数据服务地址
 * @param options - {Object} 加载实时数据可选参数。如：<br>
 *        style - {function} 设置数据加载样式。<br>
 *        onEachFeature - {function} 设置每个数据加载popup等。<br>
 *        geometry - {Array<Object>} 设置增添的几何要素对象数组。
 *        excludeField - -{Object} 排除字段
 */
var DataFlowService = exports.DataFlowService = function (_CommonServiceBase) {
    _inherits(DataFlowService, _CommonServiceBase);

    function DataFlowService(url, options) {
        _classCallCheck(this, DataFlowService);

        options = options || {};
        /*
         * @constant EVENT_TYPES
         * {Array<string>}
         * 此类支持的事件类型
         */
        options.EVENT_TYPES = ["broadcastSocketConnected", "broadcastSocketError", "broadcastFailed", "broadcastSuccessed", "subscribeSocketConnected", "subscribeSocketError", "messageSuccessed", "setFilterParamSuccessed"];

        /**
         * @member SuperMap.DataFlowService.prototype.geometry -{Aarry<Object>}
         * @description 设置增添的几何要素对象数组。
         */
        var _this = _possibleConstructorReturn(this, (DataFlowService.__proto__ || Object.getPrototypeOf(DataFlowService)).call(this, url, options));

        _this.geometry = null;

        /**
         * @member SuperMap.DataFlowService.prototype.prjCoordSys -{Object}
         * @description 动态投影参数
         */
        _this.prjCoordSys = null;

        /**
         * @member SuperMap.DataFlowService.prototype.excludeField -{Object}
         * @description 排除字段
         */
        _this.excludeField = null;

        var me = _this;
        var end = me.url.substr(me.url.length - 1, 1);
        if (end !== '/') {
            me.url += "/";
        }
        if (options) {
            _Util.Util.extend(me, options);
        }

        _this.CLASS_NAME = "SuperMap.DataFlowService";
        return _this;
    }

    /**
     * @function SuperMap.DataFlowService.prototype.initBroadcast
     * @description 初始化广播
     * @return{SuperMap.DataFlowService}
     */


    _createClass(DataFlowService, [{
        key: 'initBroadcast',
        value: function initBroadcast() {
            var me = this;
            this.broadcastWebSocket = this._connect(me.url + 'broadcast');
            this.broadcastWebSocket.onopen = function (e) {
                me.broadcastWebSocket.isOpen = true;
                e.eventType = 'broadcastSocketConnected';
                me.events.triggerEvent('broadcastSocketConnected', e);
            };
            this.broadcastWebSocket.onclose = function (e) {
                me.broadcastWebSocket.isOpen = false;
                e.eventType = 'broadcastSocketConnected';
                me.events.triggerEvent('broadcastSocketConnected', e);
            };
            this.broadcastWebSocket.onerror = function (e) {
                e.eventType = 'broadcastSocketError';
                me.events.triggerEvent('broadcastSocketError', e);
            };
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.broadcast
         * @description 加载广播数据
         * @param geoJSONFeature {JSON} json格式的要素数据
         */

    }, {
        key: 'broadcast',
        value: function broadcast(geoJSONFeature) {
            if (!this.broadcastWebSocket.isOpen) {
                this.events.triggerEvent('broadcastFailed');
                return;
            }
            this.broadcastWebSocket.send(JSON.stringify(geoJSONFeature));
            this.events.triggerEvent('broadcastSuccessed');
        }

        /**
         * @function SuperMap.DataFlowService.prototype.initSubscribe
         * @description 初始化订阅数据
         * @return {this} this
         */

    }, {
        key: 'initSubscribe',
        value: function initSubscribe() {
            var me = this;
            this.subscribeWebSocket = this._connect(this.url + 'subscribe');
            this.subscribeWebSocket.onopen = function (e) {
                me.subscribeWebSocket.send(me._getFilterParams());
                e.eventType = 'subscribeSocketConnected';
                me.events.triggerEvent('subscribeSocketConnected', e);
            };
            this.subscribeWebSocket.onerror = function (e) {
                e.eventType = 'subscribeSocketError';
                me.events.triggerEvent('subscribeSocketError', e);
            };
            this.subscribeWebSocket.onmessage = function (e) {
                me._onMessage(e);
            };
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.setExcludeField
         * @description 设置排除字段
         * @param excludeField - {Object} 排除字段
         * @return {this} this
         */

    }, {
        key: 'setExcludeField',
        value: function setExcludeField(excludeField) {
            this.excludeField = excludeField;
            this.subscribeWebSocket.send(this._getFilterParams());
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.setGeometry
         * @description 设置添加的几何要素数据
         * @param geometry - {Array<Object>} 设置增添的几何要素对象数组。
         * @return {this} this
         */

    }, {
        key: 'setGeometry',
        value: function setGeometry(geometry) {
            this.geometry = geometry;
            this.subscribeWebSocket.send(this._getFilterParams());
            return this;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.unSubscribe
         * @description 结束订阅数据
         */

    }, {
        key: 'unSubscribe',
        value: function unSubscribe() {
            if (!this.subscribeWebSocket) {
                return;
            }
            this.subscribeWebSocket.close();
            this.subscribeWebSocket = null;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.unBroadcast
         * @description 结束加载广播
         */

    }, {
        key: 'unBroadcast',
        value: function unBroadcast() {
            if (this.broadcastWebSocket) {
                return;
            }
            this.broadcastWebSocket.close();
            this.broadcastWebSocket = null;
        }

        /**
         * @function SuperMap.DataFlowService.prototype.destroy
         * @override
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            _CommonServiceBase2.CommonServiceBase.prototype.destroy.apply(this, arguments);
            var me = this;
            me.geometry = null;
            me.prjCoordSys = null;
            me.excludeField = null;
            this.unBroadcast();
            this.unSubscribe();
        }
    }, {
        key: '_getFilterParams',
        value: function _getFilterParams() {
            var filter = {
                filterParam: {
                    prjCoordSys: this.prjCoordSys,
                    excludeField: this.excludeField,
                    geometry: this.geometry
                }
            };
            return _Util.Util.toJSON(filter);
        }
    }, {
        key: '_onMessage',
        value: function _onMessage(e) {
            if (e.data && e.data.indexOf("filterParam") > 0) {
                var filterParam = JSON.parse(e.data);
                e.filterParam = filterParam;
                e.eventType = 'setFilterParamSuccessed';
                this.events.triggerEvent('setFilterParamSuccessed', e);
                return;
            }
            var feature = JSON.parse(e.data);
            e.featureResult = feature;
            e.eventType = 'messageSuccessed';
            this.events.triggerEvent('messageSuccessed', e);
        }
    }, {
        key: '_connect',
        value: function _connect(url) {
            url = this._appendCredentials(url);
            if ("WebSocket" in window) {
                return new WebSocket(url);
            } else if ("MozWebSocket" in window) {
                var mozWebSocket = window.MozWebSocket;
                return new mozWebSocket(url);
            } else {
                console.log("no WebSocket");
                return null;
            }
        }
    }, {
        key: '_appendCredentials',
        value: function _appendCredentials(url) {
            var token = _SecurityManager.SecurityManager.getToken(url);
            if (token) {
                url += "?token=" + token;
            }
            return url;
        }
    }]);

    return DataFlowService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.DataFlowService = DataFlowService;

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DensityAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _DensityKernelAnalystParameters = __webpack_require__(166);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.DensityAnalystService
 * @classdesc
 *  密度分析服务类，密度分析可计算每个输出栅格像元周围圆形邻域内输入的点或线对象的密度。
 *  密度分析，在某种意义上来说，相当于在表面上将输入的点线对象的测量值散开来，将每个点或线对象的测量量分布在整个研究区域，并计算输出栅格中每个像元的密度值。目前提供1种密度分析：核密度分析（Kernel）。
 * @param  url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example  例如：
 *  var myDensityAnalystService = new SuperMap.DensityAnalystService(url);
 *  myDensityAnalystService.on({
 *     "processCompleted": processCompleted,
 *     "processFailed": processFailed
 *     }
 *  );
 */
var DensityAnalystService = exports.DensityAnalystService = function (_SpatialAnalystBase) {
    _inherits(DensityAnalystService, _SpatialAnalystBase);

    function DensityAnalystService(url, options) {
        _classCallCheck(this, DensityAnalystService);

        /**
         * @member SuperMap.DensityAnalystService.prototype.mode -{string}
         * @description 密度分析类型。
         */
        var _this = _possibleConstructorReturn(this, (DensityAnalystService.__proto__ || Object.getPrototypeOf(DensityAnalystService)).call(this, url, options));

        _this.mode = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.DensityAnalystService";
        return _this;
    }

    /**
     * @function SuperMap.DensityAnalystService.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    _createClass(DensityAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(DensityAnalystService.prototype.__proto__ || Object.getPrototypeOf(DensityAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.DensityAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {DensityKernelAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }
            var parameterObject = new Object();

            if (parameter instanceof _DensityKernelAnalystParameters.DensityKernelAnalystParameters) {
                me.url += 'datasets/' + parameter.dataset + '/densityanalyst/kernel';
                me.mode = "kernel";
            }

            _DensityKernelAnalystParameters.DensityKernelAnalystParameters.toObject(parameter, parameterObject);
            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return DensityAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.DensityAnalystService = DensityAnalystService;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EditFeaturesService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

var _CommonServiceBase2 = __webpack_require__(6);

var _EditFeaturesParameters = __webpack_require__(167);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.EditFeaturesService
 * @classdesc 数据服务中数据集添加、更新、删除服务类。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 服务端的数据服务资源地址。请求数据服务中数据集编辑服务，URL 应为：</br>
 * http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/datasources/name/{数据源名}/datasets/name/{数据集名} 。</br>
 * 例如：http://localhost:8090/iserver/services/data-jingjin/rest/data/datasources/name/Jingjin/datasets/name/Landuse_R
 * @param options - {Object} 参数。如:</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @example
 * var myService = new SuperMap.EditFeaturesService(url, {eventListeners: {
 *     "processCompleted": editFeatureCompleted,
 *     "processFailed": editFeatureError
 *       }
 * };
 *
 */
var EditFeaturesService = exports.EditFeaturesService = function (_CommonServiceBase) {
    _inherits(EditFeaturesService, _CommonServiceBase);

    function EditFeaturesService(url, options) {
        _classCallCheck(this, EditFeaturesService);

        /**
         * @member SuperMap.EditFeaturesService.prototype.returnContent -{boolean}
         * @description要素添加时，isUseBatch 不传或传为 false 的情况下有效。true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。默认不传时为 false。
         */
        var _this = _possibleConstructorReturn(this, (EditFeaturesService.__proto__ || Object.getPrototypeOf(EditFeaturesService)).call(this, url, options));

        _this.returnContent = false;

        /**
         * @member SuperMap.EditFeaturesService.prototype.isUseBatch -{boolean}
         * @description 是否使用批量添加要素功能，要素添加时有效。
         *           批量添加能够提高要素编辑效率。
         *           true 表示批量添加；false 表示不使用批量添加。默认不传时为 false。
         */
        _this.isUseBatch = false;

        if (options) {
            _Util.Util.extend(_this, options);
        }
        var me = _this,
            end;
        end = me.url.substr(me.url.length - 1, 1);
        me.url += end == "/" ? "features.json?" : "/features.json?";

        _this.CLASS_NAME = "SuperMap.EditFeaturesService";
        return _this;
    }

    /**
     * @function SuperMap.EditFeaturesService.prototype.destroy
     * @override
     */


    _createClass(EditFeaturesService, [{
        key: 'destroy',
        value: function destroy() {
            _get(EditFeaturesService.prototype.__proto__ || Object.getPrototypeOf(EditFeaturesService.prototype), 'destroy', this).call(this);
            var me = this;
            me.returnContent = null;
            me.isUseBatch = null;
            me.fromIndex = null;
            me.toIndex = null;
        }

        /**
         * @function SuperMap.EditFeaturesService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.EditFeaturesParameters} 编辑要素参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _EditFeaturesParameters.EditFeaturesParameters)) {
                return;
            }
            var me = this,
                method = "POST",
                ids = "",
                editType = params.editType,
                jsonParameters = null;

            me.returnContent = params.returnContent;
            me.isUseBatch = params.isUseBatch;
            jsonParameters = _EditFeaturesParameters.EditFeaturesParameters.toJsonParameters(params);
            if (editType === _REST.EditType.DELETE) {
                ids = _Util.Util.toJSON(params.IDs);
                me.url += "ids=" + ids;
                method = "DELETE";
                jsonParameters = ids;
            } else if (editType === _REST.EditType.UPDATE) {
                method = "PUT";
            } else {
                if (me.isUseBatch) {
                    me.url += "isUseBatch=" + me.isUseBatch;
                    me.returnContent = false;
                }
                if (me.returnContent) {
                    me.url += "returnContent=" + me.returnContent;
                    method = "POST";
                }
            }

            me.request({
                method: method,
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return EditFeaturesService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.EditFeaturesService = EditFeaturesService;

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystSinks3DService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FacilityAnalystSinks3DParameters = __webpack_require__(168);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSinks3DService
 * @classdesc  最近设施分析服务类(汇查找资源)<br>
 *                最近设施分析是指在网络上给定一个事件点和一组设施点，
 *                查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *                该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *                最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myFacilityAnalystSinks3DService = new SuperMap.FacilityAnalystSinks3DService(url, {
 *     eventListeners: {
 *	       "processCompleted": facilityAnalystSinks3DCompleted,
 *		   "processFailed": facilityAnalystSinks3DError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *              例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。<br>
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystSinks3DService = exports.FacilityAnalystSinks3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystSinks3DService, _CommonServiceBase);

    function FacilityAnalystSinks3DService(url, options) {
        _classCallCheck(this, FacilityAnalystSinks3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSinks3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystSinks3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSinks3DService";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystSinks3DService.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystSinks3DService, [{
        key: 'destroy',
        value: function destroy() {
            _CommonServiceBase2.CommonServiceBase.prototype.destroy.apply(this, arguments);
        }

        /**
         * @function SuperMap.FacilityAnalystSinks3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystSinks3DParameters} 最近设施分析参数类(汇查找资源)
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FacilityAnalystSinks3DParameters.FacilityAnalystSinks3DParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "sinks" : "/sinks") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystSinks3DService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.FacilityAnalystSinks3DService = FacilityAnalystSinks3DService;

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystSources3DService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FacilityAnalystSources3DParameters = __webpack_require__(169);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystSources3DService
 * @classdesc 最近设施分析服务类(源查找资源) <br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，
 *               查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *               该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *               最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @param  url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystSources3DService = exports.FacilityAnalystSources3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystSources3DService, _CommonServiceBase);

    function FacilityAnalystSources3DService(url, options) {
        _classCallCheck(this, FacilityAnalystSources3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystSources3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystSources3DService";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystSources3DService.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystSources3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystSources3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystSources3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystSources3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystSources3DParameters} 最近设施分析参数类(源查找资源)
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FacilityAnalystSources3DParameters.FacilityAnalystSources3DParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "sources" : "/sources") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystSources3DService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.FacilityAnalystSources3DService = FacilityAnalystSources3DService;

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystStreamService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FacilityAnalystStreamParameters = __webpack_require__(170);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystStreamService
 * @description 上游/下游 关键设施查找资源服务类;即查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
 * @extends SuperMap.NetworkAnalystServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystStreamService = exports.FacilityAnalystStreamService = function (_NetworkAnalystServic) {
    _inherits(FacilityAnalystStreamService, _NetworkAnalystServic);

    function FacilityAnalystStreamService(url, options) {
        _classCallCheck(this, FacilityAnalystStreamService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystStreamService.__proto__ || Object.getPrototypeOf(FacilityAnalystStreamService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystStreamService";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystStreamService.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystStreamService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystStreamService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystStreamService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystStreamService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystStreamParameters} 上游/下游关键设施查找资源参数类。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FacilityAnalystStreamParameters.FacilityAnalystStreamParameters)) {
                return;
            }
            var me = this,
                jsonObject;
            var end = me.url.substr(me.url.length - 1, 1);

            //URL 通过参数类型来判断是 上游 还是下游 查询
            if (params.queryType === 0) {
                me.url = me.url + (end === "/" ? "upstreamcirticalfaclilities" : "/upstreamcirticalfaclilities") + ".json?";
            } else if (params.queryType === 1) {
                me.url = me.url + (end === "/" ? "downstreamcirticalfaclilities" : "/downstreamcirticalfaclilities") + ".json?";
            } else {
                return;
            }

            jsonObject = {
                sourceNodeIDs: params.sourceNodeIDs,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };

            if (params.edgeID !== null && params.nodeID !== null) {
                return;
            }
            if (params.edgeID === null && params.nodeID === null) {
                return;
            }
            if (params.edgeID !== null) {
                jsonObject.edgeID = params.edgeID;
            } else {
                jsonObject.nodeID = params.nodeID;
            }

            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystStreamService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FacilityAnalystStreamService = FacilityAnalystStreamService;

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystTracedown3DService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FacilityAnalystTracedown3DParameters = __webpack_require__(171);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTracedown3DService
 * @classdesc 下游追踪资源服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystTracedown3DService = exports.FacilityAnalystTracedown3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystTracedown3DService, _CommonServiceBase);

    function FacilityAnalystTracedown3DService(url, options) {
        _classCallCheck(this, FacilityAnalystTracedown3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTracedown3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTracedown3DService";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystTracedown3DService.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystTracedown3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTracedown3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTracedown3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystTracedown3DService.prototype.processAsync
         * @description负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystTracedown3DParameters} 下游追踪资源参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FacilityAnalystTracedown3DParameters.FacilityAnalystTracedown3DParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "tracedownresult" : "/tracedownresult") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystTracedown3DService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.FacilityAnalystTracedown3DService = FacilityAnalystTracedown3DService;

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystTraceup3DService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FacilityAnalystTraceup3DParameters = __webpack_require__(172);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystTraceup3DService
 * @classdesc 上游追踪资源服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystTraceup3DService = exports.FacilityAnalystTraceup3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystTraceup3DService, _CommonServiceBase);

    /*
     * @function SuperMap.FacilityAnalystTraceup3DService.constructor
     * @description 上游追踪资源服务类构造函数。
     * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
     *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
     *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function FacilityAnalystTraceup3DService(url, options) {
        _classCallCheck(this, FacilityAnalystTraceup3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystTraceup3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystTraceup3DService";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystTraceup3DService.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystTraceup3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystTraceup3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystTraceup3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystTraceup3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystTraceup3DParameters} 上游追踪资源参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FacilityAnalystTraceup3DParameters.FacilityAnalystTraceup3DParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "traceupresult" : "/traceupresult") + ".json?";
            jsonObject = {
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                weightName: params.weightName,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystTraceup3DService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.FacilityAnalystTraceup3DService = FacilityAnalystTraceup3DService;

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FacilityAnalystUpstream3DService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _FacilityAnalystUpstream3DParameters = __webpack_require__(173);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FacilityAnalystUpstream3DService
 * @classdesc 上游关键设施查找资源服务类
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FacilityAnalystUpstream3DService = exports.FacilityAnalystUpstream3DService = function (_CommonServiceBase) {
    _inherits(FacilityAnalystUpstream3DService, _CommonServiceBase);

    function FacilityAnalystUpstream3DService(url, options) {
        _classCallCheck(this, FacilityAnalystUpstream3DService);

        var _this = _possibleConstructorReturn(this, (FacilityAnalystUpstream3DService.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FacilityAnalystUpstream3DService";
        return _this;
    }

    /**
     * @function SuperMap.FacilityAnalystUpstream3DService.prototype.destroy
     * @override
     */


    _createClass(FacilityAnalystUpstream3DService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FacilityAnalystUpstream3DService.prototype.__proto__ || Object.getPrototypeOf(FacilityAnalystUpstream3DService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FacilityAnalystUpstream3DService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FacilityAnalystUpstream3DParameters} 上游关键设施查找资源参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FacilityAnalystUpstream3DParameters.FacilityAnalystUpstream3DParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "upstreamcirticalfaclilities" : "/upstreamcirticalfaclilities") + ".json?";
            jsonObject = {
                sourceNodeIDs: params.sourceNodeIDs,
                edgeID: params.edgeID,
                nodeID: params.nodeID,
                isUncertainDirectionValid: params.isUncertainDirectionValid
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FacilityAnalystUpstream3DService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.FacilityAnalystUpstream3DService = FacilityAnalystUpstream3DService;

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FieldStatisticService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

var _Util = __webpack_require__(1);

__webpack_require__(175);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FieldStatisticService
 * @classdesc 字段查询统计服务类。用来完成对指定数据集指定字段的查询统计分析，即求平均值，最大值等。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为:http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param options - {Object} 可选参数。</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 *        datasource - {string} 数据集所在的数据源名称。</br>
 *        dataset - {string} 数据集名称。</br>
 *        field - {string} 查询统计的目标字段名称。</br>
 *        statisticMode - {StatisticMode} 字段查询统计的方法类型。</br>
 * @example
 * var myService = new SuperMap.FieldStatisticService(url, {eventListeners: {
 *     "processCompleted": fieldStatisticCompleted,
 *     "processFailed": fieldStatisticError
 *     }，
 *     datasource: "World",
 *     dataset: "Countries",
 *     field: "SmID",
 *     statisticMode: StatisticMode.AVERAGE
 * };
 */

var FieldStatisticService = exports.FieldStatisticService = function (_CommonServiceBase) {
    _inherits(FieldStatisticService, _CommonServiceBase);

    function FieldStatisticService(url, options) {
        _classCallCheck(this, FieldStatisticService);

        /**
         * @member SuperMap.FieldStatisticService.prototype.datasource -{string}
         * @description 数据集所在的数据源名称。
         */
        var _this = _possibleConstructorReturn(this, (FieldStatisticService.__proto__ || Object.getPrototypeOf(FieldStatisticService)).call(this, url, options));

        _this.datasource = null;

        /**
         * @member SuperMap.FieldStatisticService.prototype.dataset -{string}
         * @description 数据集名称。
         */
        _this.dataset = null;

        /**
         * @member SuperMap.FieldStatisticService.prototype.field -{string}
         * @description 查询统计的目标字段名称。
         */
        _this.field = null;

        /**
         * @member SuperMap.FieldStatisticService.prototype.statisticMode -{string}
         * @description 字段查询统计的方法类型。
         */
        _this.statisticMode = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.FieldStatisticService";
        return _this;
    }

    /**
     * @function SuperMap.FieldStatisticService.prototype.destroy
     * @override
     */


    _createClass(FieldStatisticService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FieldStatisticService.prototype.__proto__ || Object.getPrototypeOf(FieldStatisticService.prototype), 'destroy', this).call(this);
            var me = this;
            me.datasource = null;
            me.dataset = null;
            me.field = null;
            me.statisticMode = null;
        }

        /**
         * @function SuperMap.FieldStatisticService.prototype.processAsync
         * @description 执行服务，进行指定字段的查询统计。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                end = me.url.substr(me.url.length - 1, 1),
                fieldStatisticURL = "datasources/" + me.datasource + "/datasets/" + me.dataset + "/fields/" + me.field + "/" + me.statisticMode;
            me.url += end == "/" ? fieldStatisticURL + ".json?" : "/" + fieldStatisticURL + ".json?";

            me.request({
                method: "GET",
                data: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return FieldStatisticService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.FieldStatisticService = FieldStatisticService;

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindClosestFacilitiesService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _GeoJSON = __webpack_require__(14);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FindClosestFacilitiesParameters = __webpack_require__(176);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindClosestFacilitiesService
 * @classdesc 最近设施分析服务类。<br>
 *               最近设施分析是指在网络上给定一个事件点和一组设施点，
 *               查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *               该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *              最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myfindClosestFacilitiesService = new SuperMap.FindClosestFacilitiesService(url, {
 *     eventListeners: {
 *	       "processCompleted": findClosestFacilitiesCompleted,
 *		   "processFailed": findClosestFacilitiesError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindClosestFacilitiesService = exports.FindClosestFacilitiesService = function (_NetworkAnalystServic) {
    _inherits(FindClosestFacilitiesService, _NetworkAnalystServic);

    /*
     * @function SuperMap.FindClosestFacilitiesService.prototype.constructor
     * @description 最近设施分析服务类构造函数。
     * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
     *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
     *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function FindClosestFacilitiesService(url, options) {
        _classCallCheck(this, FindClosestFacilitiesService);

        var _this = _possibleConstructorReturn(this, (FindClosestFacilitiesService.__proto__ || Object.getPrototypeOf(FindClosestFacilitiesService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindClosestFacilitiesService";
        return _this;
    }

    /**
     * @function SuperMap.FindClosestFacilitiesService.prototype.destroy
     * @override
     */


    _createClass(FindClosestFacilitiesService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindClosestFacilitiesService.prototype.__proto__ || Object.getPrototypeOf(FindClosestFacilitiesService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindClosestFacilitiesService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindClosestFacilitiesParameters} 最近设施分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FindClosestFacilitiesParameters.FindClosestFacilitiesParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "closestfacility" : "/closestfacility") + ".json?";
            jsonObject = {
                expectFacilityCount: params.expectFacilityCount,
                fromEvent: params.fromEvent,
                maxWeight: params.maxWeight,
                parameter: _Util.Util.toJSON(params.parameter),
                event: _Util.Util.toJSON(params.event),
                facilities: me.getJson(params.isAnalyzeById, params.facilities)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindClosestFacilitiesService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过ID来分析
         * @param params - {Array} 分析参数数组
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) {
                        jsonString += ",";
                    }
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var _i = 0; _i < len; _i++) {
                    if (_i > 0) {
                        jsonString += ",";
                    }
                    jsonString += params[_i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindClosestFacilitiesService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.facilityPathList) {
                return result;
            }

            var geoJSONFormat = new _GeoJSON.GeoJSON();
            result.facilityPathList.map(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
                return path;
            });
            return result;
        }
    }]);

    return FindClosestFacilitiesService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FindClosestFacilitiesService = FindClosestFacilitiesService;

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindLocationService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FindLocationParameters = __webpack_require__(177);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindLocationService
 * @classdesc 选址分区分析服务类。
 *               选址分区分析是为了确定一个或多个待建设施的最佳或最优位置，使得设施可以用一种最经济有效的方式为需求方提供服务或者商品。
 *               选址分区不仅仅是一个选址过程，还要将需求点的需求分配到相应的新建设施的服务区中，因此称之为选址与分区。
 *               选址分区分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * (start code)
 * var findLocationService = new SuperMap.FindLocationService(url, {
 *     eventListeners: {
 *         "processCompleted": findLocationCompleted,
 *		   "processFailed": findLocationError
 *		   }
 * });
 * (end)
 * @param url - {string} 服务的访问地址。<br>
 *                        如 http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindLocationService = exports.FindLocationService = function (_NetworkAnalystServic) {
    _inherits(FindLocationService, _NetworkAnalystServic);

    function FindLocationService(url, options) {
        _classCallCheck(this, FindLocationService);

        var _this = _possibleConstructorReturn(this, (FindLocationService.__proto__ || Object.getPrototypeOf(FindLocationService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindLocationService";
        return _this;
    }

    /**
     * @function SuperMap.FindLocationService.prototype.destroy
     * @override
     */


    _createClass(FindLocationService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindLocationService.prototype.__proto__ || Object.getPrototypeOf(FindLocationService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindLocationService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindLocationParameters} 选址分区分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FindLocationParameters.FindLocationParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "location" : "/location") + ".json?";
            jsonObject = {
                isFromCenter: params.isFromCenter,
                expectedSupplyCenterCount: params.expectedSupplyCenterCount,
                weightName: params.weightName,
                turnWeightField: params.turnWeightField,
                returnEdgeFeature: true,
                returnEdgeGeometry: true,
                returnNodeFeature: true,
                mapParameter: _Util.Util.toJSON(params.mapParameter),
                supplyCenters: me.getCentersJson(params.supplyCenters)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindLocationService.prototype.getCentersJson
         * @description 将数组对象转化为JSON字符串。
         * @param params - {Array} 需要转换的参数
         * @return {string} 转化后的JSON字符串。
         */

    }, {
        key: 'getCentersJson',
        value: function getCentersJson(params) {
            var json = "[",
                len = params ? params.length : 0;
            for (var i = 0; i < len; i++) {
                if (i > 0) {
                    json += ",";
                }
                json += _Util.Util.toJSON(params[i]);
            }
            json += "]";
            return json;
        }

        /**
         * @function SuperMap.FindLocationService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON.GeoJSON();
            if (result.demandResults) {
                result.demandResults = JSON.parse(geoJSONFormat.write(result.demandResults));
            }
            if (result.supplyResults) {
                result.supplyResults = JSON.parse(geoJSONFormat.write(result.supplyResults));
            }

            return result;
        }
    }]);

    return FindLocationService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FindLocationService = FindLocationService;

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindMTSPPathsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FindMTSPPathsParameters = __webpack_require__(178);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindMTSPPathsService
 * @classdesc 多旅行商分析服务类<br>
 *               多旅行商分析也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。<br>
 *               查找经济有效的配送路径，并给出相应的行走路线。<br>
 *               物流配送功能就是解决如何合理分配配送次序和送货路线，使配送总花费达到最小或每个配送中心的花费达到最小。<br>
 *               该类负责将客户端指定的多旅行商分析参数传递给服务端，并接收服务端返回的结果数据。<br>
 *               多旅行商分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myFindMTSPPathsService = new SuperMap.FindMTSPPathsService(url, {
 *     eventListeners: {
 *         "processCompleted": findMTSPPathsCompleted,
 *		   "processFailed": findMTSPPathsError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindMTSPPathsService = exports.FindMTSPPathsService = function (_NetworkAnalystServic) {
    _inherits(FindMTSPPathsService, _NetworkAnalystServic);

    function FindMTSPPathsService(url, options) {
        _classCallCheck(this, FindMTSPPathsService);

        var _this = _possibleConstructorReturn(this, (FindMTSPPathsService.__proto__ || Object.getPrototypeOf(FindMTSPPathsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindMTSPPathsService";
        return _this;
    }

    /**
     * @function SuperMap.FindMTSPPathsService.prototype.destroy
     * @override
     */


    _createClass(FindMTSPPathsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindMTSPPathsService.prototype.__proto__ || Object.getPrototypeOf(FindMTSPPathsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindMTSPPathsService..prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindMTSPPathsParameters} 多旅行商分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FindMTSPPathsParameters.FindMTSPPathsParameters)) {
                return;
            }
            var me = this,
                jsonObject,

            //end = me.url.substr(me.url.length - 1, 1),
            centers = me.getJson(params.isAnalyzeById, params.centers),
                nodes = me.getJson(params.isAnalyzeById, params.nodes);
            me.url = me.url + "/mtsppath" + ".json?";
            jsonObject = {
                centers: centers,
                nodes: nodes,
                parameter: _Util.Util.toJSON(params.parameter),
                hasLeastTotalCost: params.hasLeastTotalCost
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindMTSPPathsService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 需要转换的数字
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) {
                        jsonString += ",";
                    }
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var _i = 0; _i < len; _i++) {
                    if (_i > 0) {
                        jsonString += ",";
                    }
                    jsonString += params[_i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindMTSPPathsService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.pathList) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON.GeoJSON();
            result.pathList.map(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
                return path;
            });
            return result;
        }
    }]);

    return FindMTSPPathsService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FindMTSPPathsService = FindMTSPPathsService;

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindPathService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FindPathParameters = __webpack_require__(179);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindPathService
 * @classdesc 最佳路径分析服务类。<br>
 *               最佳路径是在网络数据集中指定一些节点，按照节点的选择顺序，<br>
 *               顺序访问这些节点从而求解起止点之间阻抗最小的路经。<br>
 *               该类负责将客户端指定的最佳路径分析参数传递给服务端，并接收服务端返回的结果数据。<br>
 *               最佳路径分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myFindPathService = new SuperMap.FindPathService(url, {
 *     eventListeners: {
 *	       "processCompleted": findPathCompleted,
 *		   "processFailed": findPathError
 *		   }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *               例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindPathService = exports.FindPathService = function (_NetworkAnalystServic) {
    _inherits(FindPathService, _NetworkAnalystServic);

    function FindPathService(url, options) {
        _classCallCheck(this, FindPathService);

        var _this = _possibleConstructorReturn(this, (FindPathService.__proto__ || Object.getPrototypeOf(FindPathService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindPathService";
        return _this;
    }

    /**
     * @function SuperMap.FindPathService.prototype.destroy
     * @override
     */


    _createClass(FindPathService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindPathService.prototype.__proto__ || Object.getPrototypeOf(FindPathService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindPathService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindPathParameters} 最佳路径分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FindPathParameters.FindPathParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "path" : "/path") + ".json?";
            jsonObject = {
                hasLeastEdgeCount: params.hasLeastEdgeCount,
                parameter: _Util.Util.toJSON(params.parameter),
                nodes: me.getJson(params.isAnalyzeById, params.nodes)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindPathService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 需要转换的数字
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) {
                        jsonString += ",";
                    }
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var _i = 0; _i < len; _i++) {
                    if (_i > 0) {
                        jsonString += ",";
                    }
                    jsonString += params[_i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindMTSPPathsService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.pathList || result.pathList.length < 1) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON.GeoJSON();
            result.pathList.forEach(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
            });
            return result;
        }
    }]);

    return FindPathService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FindPathService = FindPathService;

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindServiceAreasService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FindServiceAreasParameters = __webpack_require__(180);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindServiceAreasService
 * @classdesc 服务区分析服务类。<br>
 *               服务区分析是以指定服务站点为中心，<br>
 *               在一定服务范围内查找网络上服务站点能够提供服务的区域范围。<br>
 *               该类负责将客户端指定的服务区分析参数传递给服务端，并接收服务端返回的结果数据。<br>
 *               服务区分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var myFindServiceAreasService = new SuperMap.FindServiceAreasService(url, {
 *          eventListeners: {
 *              "processCompleted": findServiceAreasCompleted,
 *              "processFailed": findServiceAreasError
 *          }
 * });
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象
 */
var FindServiceAreasService = exports.FindServiceAreasService = function (_NetworkAnalystServic) {
    _inherits(FindServiceAreasService, _NetworkAnalystServic);

    function FindServiceAreasService(url, options) {
        _classCallCheck(this, FindServiceAreasService);

        var _this = _possibleConstructorReturn(this, (FindServiceAreasService.__proto__ || Object.getPrototypeOf(FindServiceAreasService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindServiceAreasService";
        return _this;
    }

    /**
     * @function SuperMap.FindServiceAreasService.prototype.destroy
     * @override
     */


    _createClass(FindServiceAreasService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindServiceAreasService.prototype.__proto__ || Object.getPrototypeOf(FindServiceAreasService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindServiceAreasService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindServiceAreasParameters} 服务区分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FindServiceAreasParameters.FindServiceAreasParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "servicearea" : "/servicearea") + ".json?";
            jsonObject = {
                isFromCenter: params.isFromCenter,
                isCenterMutuallyExclusive: params.isCenterMutuallyExclusive,
                parameter: _Util.Util.toJSON(params.parameter),
                centers: me.getJson(params.isAnalyzeById, params.centers),
                weights: me.getJson(true, params.weights)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindServiceAreasService.prototype.getJson
         * @description 将对象转化为JSON字符串。
         * @param isAnalyzeById - {boolean} 是否通过id分析
         * @param params - {Array} 需要转换的数字
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJson',
        value: function getJson(isAnalyzeById, params) {
            var jsonString = "[",
                len = params ? params.length : 0;

            if (isAnalyzeById === false) {
                for (var i = 0; i < len; i++) {
                    if (i > 0) {
                        jsonString += ",";
                    }
                    jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
                }
            } else if (isAnalyzeById == true) {
                for (var _i = 0; _i < len; _i++) {
                    if (_i > 0) {
                        jsonString += ",";
                    }
                    jsonString += params[_i];
                }
            }
            jsonString += ']';
            return jsonString;
        }

        /**
         * @function SuperMap.FindServiceAreasService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.serviceAreaList) {
                return result;
            }
            var geoJSONFormat = new _GeoJSON.GeoJSON();
            result.serviceAreaList.map(function (serviceArea) {
                if (serviceArea.serviceRegion) {
                    serviceArea.serviceRegion = JSON.parse(geoJSONFormat.write(serviceArea.serviceRegion));
                }
                if (serviceArea.edgeFeatures) {
                    serviceArea.edgeFeatures = JSON.parse(geoJSONFormat.write(serviceArea.edgeFeatures));
                }
                if (serviceArea.nodeFeatures) {
                    serviceArea.nodeFeatures = JSON.parse(geoJSONFormat.write(serviceArea.nodeFeatures));
                }
                if (serviceArea.routes) {
                    serviceArea.routes = JSON.parse(geoJSONFormat.write(serviceArea.routes));
                }
                return serviceArea;
            });

            return result;
        }
    }]);

    return FindServiceAreasService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FindServiceAreasService = FindServiceAreasService;

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FindTSPPathsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _FindTSPPathsParameters = __webpack_require__(181);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.FindTSPPathsService
 * @classdesc 旅行商分析服务类<br>
 *               旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
 *               旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
 *               该类负责将客户端指定的旅行商分析参数传递给服务端，并接收服务端返回的结果数据。
 *               旅行商分析结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * (start code)
 * var myFindTSPPathsService = new SuperMap.FindTSPPathsService(url, {
 *     eventListeners: {
 *	      "processCompleted": findTSPPathsCompleted,
 *		  "processFailed": findTSPPathsError
 *		  }
 *  });
 * (end)
 * @param url - {string} 网络分析服务地址。请求网络分析服务，URL应为：
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var FindTSPPathsService = exports.FindTSPPathsService = function (_NetworkAnalystServic) {
    _inherits(FindTSPPathsService, _NetworkAnalystServic);

    function FindTSPPathsService(url, options) {
        _classCallCheck(this, FindTSPPathsService);

        var _this = _possibleConstructorReturn(this, (FindTSPPathsService.__proto__ || Object.getPrototypeOf(FindTSPPathsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.FindTSPPathsService";
        return _this;
    }

    /**
     * @function SuperMap.FindTSPPathsService.prototype.destroy
     * @override
     */


    _createClass(FindTSPPathsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(FindTSPPathsService.prototype.__proto__ || Object.getPrototypeOf(FindTSPPathsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.FindTSPPathsService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param params - {SuperMap.FindTSPPathsParameters} 旅行商分析服务参数类
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _FindTSPPathsParameters.FindTSPPathsParameters)) {
                return;
            }
            var me = this,
                jsonObject,
                end = me.url.substr(me.url.length - 1, 1);
            me.url = me.url + (end === "/" ? "tsppath" : "/tsppath") + ".json?";
            jsonObject = {
                parameter: _SuperMap.SuperMap.Util.toJSON(params.parameter),
                endNodeAssigned: params.endNodeAssigned,
                nodes: me.getNodesJson(params)
            };
            me.request({
                method: "GET",
                params: jsonObject,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.FindTSPPathsService.prototype.getNodesJson
         * @description 将节点对象转化为JSON字符串。
         * @param params - {SuperMap.FindTSPPathsParameters}
         * @return {string} 转化后的JSON字符串。
         */

    }, {
        key: 'getNodesJson',
        value: function getNodesJson(params) {
            var jsonParameters = "",
                nodesString,
                i,
                len,
                nodes;
            if (params.isAnalyzeById === false) {
                for (nodesString = "[", i = 0, nodes = params.nodes, len = nodes.length; i < len; i++) {
                    if (i > 0) {
                        nodesString += ",";
                    }
                    nodesString += '{"x":' + nodes[i].x + ',"y":' + nodes[i].y + '}';
                }
                nodesString += ']';
                jsonParameters += nodesString;
            } else if (params.isAnalyzeById == true) {
                var nodeIDsString = "[",
                    _nodes = params.nodes,
                    _len = _nodes.length;
                for (var _i = 0; _i < _len; _i++) {
                    if (_i > 0) {
                        nodeIDsString += ",";
                    }
                    nodeIDsString += _nodes[_i];
                }
                nodeIDsString += ']';
                jsonParameters += nodeIDsString;
            }
            return jsonParameters;
        }

        /**
         * @function SuperMap.FindTSPPathsService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result || !result.tspPathList) {
                return null;
            }
            var geoJSONFormat = new _GeoJSON.GeoJSON();
            result.tspPathList.forEach(function (path) {
                if (path.route) {
                    path.route = JSON.parse(geoJSONFormat.write(path.route));
                }
                if (path.pathGuideItems) {
                    path.pathGuideItems = JSON.parse(geoJSONFormat.write(path.pathGuideItems));
                }
                if (path.edgeFeatures) {
                    path.edgeFeatures = JSON.parse(geoJSONFormat.write(path.edgeFeatures));
                }
                if (path.nodeFeatures) {
                    path.nodeFeatures = JSON.parse(geoJSONFormat.write(path.nodeFeatures));
                }
            });
            return result;
        }
    }]);

    return FindTSPPathsService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.FindTSPPathsService = FindTSPPathsService;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GenerateSpatialDataService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _GenerateSpatialDataParameters = __webpack_require__(182);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GenerateSpatialDataService
 * @classdesc
 * 动态分段分析服务类。
 * 该类负责将客户设置的动态分段分析服务参数传递给服务端，并接收服务端返回的动态分段分析结果数据。
 * 获取的结果数据包括 originResult 、result 两种，其中，originResult 为服务端返回的用 JSON 对象表示的动态分段分析结果数据，result 为服务端返回的动态分段分析结果数据。
 *  @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 *  @param options - {Object} 可选参数。如:</br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 实例化该类如下例所示：
 * (start code)
 *  function GenerateSpatialData(){
     *
     *  //配置数据返回选项(option)
     *  var option = new SuperMap.DataReturnOption({
     *      expectCount: 1000,
     *      dataset: "generateSpatialData",
     *      deleteExistResultDataset: true,
     *      dataReturnMode: SuperMap.DataReturnMode.DATASET_ONLY
     *  }),
     *  //配置动态分段参数(Parameters)
     *  parameters = new SuperMap.GenerateSpatialDataParameters({
     *      routeTable: "RouteDT_road@Changchun",
     *      routeIDField: "RouteID",
     *      eventTable: "LinearEventTabDT@Changchun",
     *      eventRouteIDField: "RouteID",
     *      measureField: "",
     *      measureStartField: "LineMeasureFrom",
     *      measureEndField: "LineMeasureTo",
     *      measureOffsetField: "",
     *      errorInfoField: "",
     *      retainedFields:[],
     *      dataReturnOption: option
     *  }),
     *  //配置动态分段iService
     *  iService = new SuperMap.GenerateSpatialDataService(Changchun_spatialanalyst, {
     *      eventListeners: {
     *          processCompleted: generateCompleted,
     *          processFailed: generateFailded
     *      }
     *  });
     *  //执行
     *  iService.processAsync(parameters);
     *  function Completed(generateSpatialDataEventArgs){//todo};
     *  function Error(generateSpatialDataEventArgs){//todo};
     * (end)
     */
var GenerateSpatialDataService = exports.GenerateSpatialDataService = function (_SpatialAnalystBase) {
    _inherits(GenerateSpatialDataService, _SpatialAnalystBase);

    function GenerateSpatialDataService(url, options) {
        _classCallCheck(this, GenerateSpatialDataService);

        var _this = _possibleConstructorReturn(this, (GenerateSpatialDataService.__proto__ || Object.getPrototypeOf(GenerateSpatialDataService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GenerateSpatialDataService";
        return _this;
    }

    /**
     * @function SuperMap.GenerateSpatialDataService.prototype.destroy
     * @override
     */


    _createClass(GenerateSpatialDataService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GenerateSpatialDataService.prototype.__proto__ || Object.getPrototypeOf(GenerateSpatialDataService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GenerateSpatialDataService.prototype.processAsync
         * @description 负责将客户端的动态分段服务参数传递到服务端。
         * @param params - {SuperMap.GenerateSpatialDataParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _GenerateSpatialDataParameters.GenerateSpatialDataParameters)) {
                return;
            }
            var me = this,
                jsonParameters;

            jsonParameters = me.getJsonParameters(params);

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.GenerateSpatialDataService.prototype.getJsonParameters
         * @description 将参数转化为 JSON 字符串。
         * @param params -  {SuperMap.GenerateSpatialDataParameters}
         * @return {string}转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters = "",
                jsonStr = "datasets/" + params.routeTable + "/linearreferencing/generatespatialdata",
                me = this,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? jsonStr + ".json" : "/" + jsonStr + ".json";

            me.url += "?returnContent=true";
            jsonParameters = _Util.Util.toJSON(params);
            return jsonParameters;
        }
    }]);

    return GenerateSpatialDataService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.GenerateSpatialDataService = GenerateSpatialDataService;

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GeoRelationAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _GeoRelationAnalystParameters = __webpack_require__(185);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GeoRelationAnalystService
 * @classdesc
 * 空间关系分析服务类。
 * 该类负责将客户设置的空间关系分析服务参数传递给服务端，并接收服务端返回的空间关系分析结果数据。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.SpatialAnalystBase
 * @example 实例化该类如下例所示：
 * (start code)
 *  function datasetGeoRelationAnalystProcess() {
     *      var referenceFilter = new SuperMap.FilterParameter({
     *                              name:"Frame_R@Changchun",
     *                              attributeFilter:"SmID>0"});
     *      var sourceFilter = new SuperMap.FilterParameter({
     *                          attributeFilter:"SmID>0"});
     *      //初始化服务类
     *      var datasetGeoRelationService = new SuperMap.GeoRelationAnalystService(
     *          "http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst/"),
     *      //构建参数类
     *      datasetGeoRelationParameters = new SuperMap.GeoRelationAnalystParameters({
     *          dataset: "Park@Changchun",
     *          startRecord: 0,
     *          expectCount: 20,
     *          sourceFilter: sourceFilter,
     *          referenceFilter: referenceFilter,
     *          spatialRelationType: SuperMap.SpatialRelationType.INTERSECT,
     *          isBorderInside: true,
     *          returnFeature: true,
     *          returnGeoRelatedOnly: true
     *      });
     *      datasetGeoRelationService.events.on({
     *          "processCompleted": datasetGeoRelationAnalystCompleted,
     *          "processFailed": datasetGeoRelationAnalystFailed});
     *      //执行
     *      datasetGeoRelationService.processAsync(datasetGeoRelationParameters);
     *  }
 *  function Completed(datasetGeoRelationAnalystCompleted){//todo};
 *  function Error(datasetGeoRelationAnalystFailed){//todo};
 * (end)
 *
 */
var GeoRelationAnalystService = exports.GeoRelationAnalystService = function (_SpatialAnalystBase) {
    _inherits(GeoRelationAnalystService, _SpatialAnalystBase);

    function GeoRelationAnalystService(url, options) {
        _classCallCheck(this, GeoRelationAnalystService);

        var _this = _possibleConstructorReturn(this, (GeoRelationAnalystService.__proto__ || Object.getPrototypeOf(GeoRelationAnalystService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GeoRelationAnalystService";
        return _this;
    }

    /**
     * @function SuperMap.GeoRelationAnalystService.prototype.destroy
     * @override
     */


    _createClass(GeoRelationAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GeoRelationAnalystService.prototype.__proto__ || Object.getPrototypeOf(GeoRelationAnalystService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GeoRelationAnalystService.prototype.processAsync
         * @description 负责将客户端的空间关系分析参数传递到服务端
         * @param parameter - {SuperMap.GeoRelationAnalystParameters} 空间关系分析所需的参数信息。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            if (!(parameter instanceof _GeoRelationAnalystParameters.GeoRelationAnalystParameters)) {
                return;
            }
            var me = this;
            var end = me.url.substr(me.url.length - 1, 1);
            if (end === '/') {
                me.url += 'datasets/' + parameter.dataset + '/georelation';
            } else {
                me.url += '/datasets/' + parameter.dataset + '/georelation';
            }

            var jsonParameters = _SuperMap.SuperMap.Util.toJSON(parameter);

            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return GeoRelationAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.GeoRelationAnalystService = GeoRelationAnalystService;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByBoundsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _GetFeaturesServiceBase = __webpack_require__(41);

var _GetFeaturesByBoundsParameters = __webpack_require__(190);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBoundsService
 * @classdesc 数据集范围查询服务类,查询与指定范围对象符合一定空间关系的矢量要素。
 * @description 数据集范围查询服务类构造函数。
 * @extends SuperMap.GetFeaturesServiceBase
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @example
 * var myGetFeaturesByBoundsService = new SuperMa.GetFeaturesByBoundsService(url, {
 *     eventListeners: {
 *           "processCompleted": getFeatureCompleted,
 *           "processFailed": getFeatureError
 *           }
 * });
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 */

var GetFeaturesByBoundsService = exports.GetFeaturesByBoundsService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByBoundsService, _GetFeaturesServiceBa);

    function GetFeaturesByBoundsService(url, options) {
        _classCallCheck(this, GetFeaturesByBoundsService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByBoundsService.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByBoundsService";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByBoundsService.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByBoundsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBoundsService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBoundsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByBoundsService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。在本类中重写此方法，可以实现不同种类的查询（ID SQL Buffer GeometryBounds等）。
         * @param params {SuperMap.GetFeaturesByBoundsParameters}
         * @return {string} 转化后的 JSON 字符串。
         *
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesByBoundsParameters.GetFeaturesByBoundsParameters.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByBoundsService;
}(_GetFeaturesServiceBase.GetFeaturesServiceBase);

_SuperMap.SuperMap.GetFeaturesByBoundsService = GetFeaturesByBoundsService;

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByBufferService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _GetFeaturesServiceBase = __webpack_require__(41);

var _GetFeaturesByBufferParameters = __webpack_require__(191);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByBufferService
 * @classdesc 数据服务中数据集缓冲区查询服务类。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @extends SuperMap.GetFeaturesServiceBase
 * @example
 * var myGetFeaturesByBufferService = new SuperMap.GetFeaturesByBufferService(url, {
 *     eventListeners: {
 *           "processCompleted": GetFeaturesCompleted,
 *           "processFailed": GetFeaturesError
 *           }
 * });
 * function GetFeaturesCompleted(object){//todo};
 * function GetFeaturesError(object){//todo};
 */

var GetFeaturesByBufferService = exports.GetFeaturesByBufferService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByBufferService, _GetFeaturesServiceBa);

    function GetFeaturesByBufferService(url, options) {
        _classCallCheck(this, GetFeaturesByBufferService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByBufferService.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByBufferService";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByBufferService.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByBufferService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByBufferService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByBufferService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByBufferService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。在本类中重写此方法，可以实现不同种类的查询（IDs SQL Buffer Geometry等）。
         * @param params {SuperMap.GetFeaturesByBufferParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            if (!(params instanceof _GetFeaturesByBufferParameters.GetFeaturesByBufferParameters)) {
                return;
            }
            return _SuperMap.SuperMap.GetFeaturesByBufferParameters.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByBufferService;
}(_GetFeaturesServiceBase.GetFeaturesServiceBase);

_SuperMap.SuperMap.GetFeaturesByBufferService = GetFeaturesByBufferService;

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByGeometryService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _GetFeaturesServiceBase = __webpack_require__(41);

var _GetFeaturesByGeometryParameters = __webpack_require__(192);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByGeometryService
 * @classdesc 数据集几何查询服务类,查询与指定几何对象符合一定空间关系的矢量要素。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务。
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data；
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data"
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @extends SuperMap.GetFeaturesServiceBase
 * @example
 * var myService = new SuperMap.GetFeaturesByGeometryService(url, {
     *     eventListeners: {
     *           "processCompleted": getFeatureCompleted,
     *           "processFailed": getFeatureError
     *           }
     * });
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 */
var GetFeaturesByGeometryService = exports.GetFeaturesByGeometryService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByGeometryService, _GetFeaturesServiceBa);

    function GetFeaturesByGeometryService(url, options) {
        _classCallCheck(this, GetFeaturesByGeometryService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByGeometryService.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByGeometryService";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByGeometryService.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByGeometryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByGeometryService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByGeometryService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByGeometryService.prototype.getJsonParameters
         * @param params - {SuperMap.GetFeaturesByGeometryParameters}
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（ID SQL Buffer Geometry等）。
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesByGeometryParameters.GetFeaturesByGeometryParameters.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByGeometryService;
}(_GetFeaturesServiceBase.GetFeaturesServiceBase);

_SuperMap.SuperMap.GetFeaturesByGeometryService = GetFeaturesByGeometryService;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesByIDsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _GetFeaturesServiceBase = __webpack_require__(41);

var _GetFeaturesByIDsParameters = __webpack_require__(193);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesByIDsService
 * @classdesc 数据集ID查询服务类。在数据集集合中查找指定 ID 号对应的空间地物要素。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务。
 *              URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 *              例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @extends SuperMap.GetFeaturesServiceBase
 * @example
 * var myGetFeaturesByIDsService = new SuperMap.GetFeaturesByIDsService(url, {
 *     eventListeners: {
 *         "processCompleted": getFeatureCompleted,
 *         "processFailed": getFeatureError
 *            }
 *     });
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 */
var GetFeaturesByIDsService = exports.GetFeaturesByIDsService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesByIDsService, _GetFeaturesServiceBa);

    function GetFeaturesByIDsService(url, options) {
        _classCallCheck(this, GetFeaturesByIDsService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesByIDsService.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesByIDsService";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesByIDsService.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesByIDsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesByIDsService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesByIDsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.GetFeaturesByIDsService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（ID SQL Buffer Geometry等）。
         * @param  params - {SuperMap.GetFeaturesByIDsParameters}
         * @return {string} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesByIDsParameters.GetFeaturesByIDsParameters.toJsonParameters(params);
        }
    }]);

    return GetFeaturesByIDsService;
}(_GetFeaturesServiceBase.GetFeaturesServiceBase);

_SuperMap.SuperMap.GetFeaturesByIDsService = GetFeaturesByIDsService;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFeaturesBySQLService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _GetFeaturesServiceBase = __webpack_require__(41);

var _GetFeaturesBySQLParameters = __webpack_require__(194);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFeaturesBySQLService
 * @constructs SuperMap.GetFeaturesBySQLService
 * @classdesc
 * 数据服务中数据集 SQL 查询服务类。
 * 在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
 * @param url - {string} 数据查询结果资源地址。请求数据服务中数据集查询服务，
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param  options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @extends SuperMap.GetFeaturesServiceBase
 * @example
 * var myGetFeaturesBySQLService = new SuperMap.GetFeaturesBySQLService(url, {
     *     eventListeners: {
     *         "processCompleted": GetFeaturesCompleted,
     *         "processFailed": GetFeaturesError
     *         }
     * });
 * function getFeaturesCompleted(object){//todo};
 * function getFeaturesError(object){//todo};
 *
 */
var GetFeaturesBySQLService = exports.GetFeaturesBySQLService = function (_GetFeaturesServiceBa) {
    _inherits(GetFeaturesBySQLService, _GetFeaturesServiceBa);

    function GetFeaturesBySQLService(url, options) {
        _classCallCheck(this, GetFeaturesBySQLService);

        var _this = _possibleConstructorReturn(this, (GetFeaturesBySQLService.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.GetFeaturesBySQLService";
        return _this;
    }

    /**
     * @function SuperMap.GetFeaturesBySQLService.prototype.destroy
     * @override
     */


    _createClass(GetFeaturesBySQLService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFeaturesBySQLService.prototype.__proto__ || Object.getPrototypeOf(GetFeaturesBySQLService.prototype), 'destroy', this).call(this);
        }

        /*
         * @function SuperMap.GetFeaturesBySQLService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         * 在本类中重写此方法，可以实现不同种类的查询（ID SQL Buffer Geometry等）。
         * @param params - {SuperMap.GetFeaturesBySQLParameters}
         * @return {string} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            return _GetFeaturesBySQLParameters.GetFeaturesBySQLParameters.toJsonParameters(params);
        }
    }]);

    return GetFeaturesBySQLService;
}(_GetFeaturesServiceBase.GetFeaturesServiceBase);

_SuperMap.SuperMap.GetFeaturesBySQLService = GetFeaturesBySQLService;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetFieldsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetFieldsService
 * @classdesc 字段查询服务，支持查询指定数据集的中所有属性字段（field）的集合。
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 *        datasource - {string}</br>
 *        dataset - {string}</br>
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myService = new SuperMap.GetFieldsService(url, {eventListeners: {
 *     "processCompleted": getFieldsCompleted,
 *     "processFailed": getFieldsError
 *     },
 *     datasource: "World",
 *     dataset: "Countries"
 * };
 *
 */
var GetFieldsService = exports.GetFieldsService = function (_CommonServiceBase) {
    _inherits(GetFieldsService, _CommonServiceBase);

    function GetFieldsService(url, options) {
        _classCallCheck(this, GetFieldsService);

        /**
         * @member SuperMap.GetFieldsService.prototype.datasource -{string}
         * @description 要查询的数据集所在的数据源名称。
         */
        var _this = _possibleConstructorReturn(this, (GetFieldsService.__proto__ || Object.getPrototypeOf(GetFieldsService)).call(this, url, options));

        _this.datasource = null;

        /**
         *  @member SuperMap.GetFieldsService.prototype.dataset -{string}
         *  @description 要查询的数据集名称。
         */
        _this.dataset = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.GetFieldsService";
        return _this;
    }

    /**
     * @function SuperMap.GetFieldsService.prototype.destroy
     * @override
     */


    _createClass(GetFieldsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetFieldsService.prototype.__proto__ || Object.getPrototypeOf(GetFieldsService.prototype), 'destroy', this).call(this);
            var me = this;
            me.datasource = null;
            me.dataset = null;
        }

        /**
         * @function SuperMap.GetFieldsService.prototype.processAsync
         * @description 执行服务，查询指定数据集的字段信息。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                end = me.url.substr(me.url.length - 1, 1),
                datasetURL = "datasources/" + me.datasource + "/datasets/" + me.dataset;
            me.url += end == "/" ? datasetURL + "/fields.json?" : "/" + datasetURL + "/fields.json?";

            me.request({
                method: "GET",
                data: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return GetFieldsService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.GetFieldsService = GetFieldsService;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetGridCellInfosService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _GetGridCellInfosParameters = __webpack_require__(195);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetGridCellInfosService
 * @classdesc 数据栅格查询服务，支持查询指定地理位置的栅格信息。
 * @param url - {string} 查询服务地址。例如: http://localhost:8090/iserver/services/data-jingjin/rest/data
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myService = new SuperMap.GetGridCellInfosService(url, {eventListeners: {
 *     "processCompleted": queryCompleted,
 *     "processFailed": queryError
 *     }
 * });
 *
 */
var GetGridCellInfosService = exports.GetGridCellInfosService = function (_CommonServiceBase) {
    _inherits(GetGridCellInfosService, _CommonServiceBase);

    function GetGridCellInfosService(url, options) {
        _classCallCheck(this, GetGridCellInfosService);

        /**
         * @member SuperMap.GetGridCellInfosService.prototype.datasetName -{string}
         * @description 数据集名称。
         */
        var _this = _possibleConstructorReturn(this, (GetGridCellInfosService.__proto__ || Object.getPrototypeOf(GetGridCellInfosService)).call(this, url, options));

        _this.datasetName = null;

        /**
         * @member SuperMap.GetGridCellInfosService.prototype.dataSourceName -{string}
         * @description 数据源名称。
         */
        _this.dataSourceName = null;

        /**
         * @member SuperMap.GetGridCellInfosService.prototype.datasetType -{string}
         * @description 数据集类型。
         */
        _this.datasetType = null;

        /**
         * @member SuperMap.GetGridCellInfosService.prototype.X -{number}
         * @description 要查询的地理位置X轴
         */
        _this.X = null;

        /**
         * @member SuperMap.GetGridCellInfosService.prototype.Y-{number}
         * @description 要查询的地理位置Y轴
         */
        _this.Y = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.GetGridCellInfosService";
        return _this;
    }

    /**
     * @function SuperMap.GetGridCellInfosService.prototype.destroy
     * @override
     */


    _createClass(GetGridCellInfosService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetGridCellInfosService.prototype.__proto__ || Object.getPrototypeOf(GetGridCellInfosService.prototype), 'destroy', this).call(this);
            var me = this;
            me.X = null;
            me.Y = null;
            me.datasetName = null;
            me.dataSourceName = null;
            me.datasetType = null;
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.processAsync
         * @description 执行服务，查询数据集信息。
         * @param params - {SuperMap.GetGridCellInfosParameters} 查询参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _GetGridCellInfosParameters.GetGridCellInfosParameters)) {
                return;
            }
            _Util.Util.extend(this, params);
            var me = this;
            var end = me.url.substr(me.url.length - 1, 1);
            me.url += end == "/" ? "datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".json" : "/datasources/" + me.dataSourceName + "/datasets/" + me.datasetName + ".json";

            me.queryRequest(me.getDatasetInfoCompleted, me.getDatasetInfoFailed);
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.queryRequest
         * @description 执行服务，查询。
         * @param successFun -{function} 成功后执行的函数
         * @param failedFunc -{function} 失败后执行的函数
         */

    }, {
        key: 'queryRequest',
        value: function queryRequest(successFun, failedFunc) {
            var me = this;
            me.request({
                method: "GET",
                data: null,
                scope: me,
                success: successFun,
                failure: failedFunc
            });
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.getDatasetInfoCompleted
         * @description  数据集查询完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getDatasetInfoCompleted',
        value: function getDatasetInfoCompleted(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            me.datasetType = result.datasetInfo.type;
            me.queryGridInfos();
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.queryGridInfos
         * @description 执行服务，查询数据集栅格信息信息。
         */

    }, {
        key: 'queryGridInfos',
        value: function queryGridInfos() {
            var me = this,
                re = /\.json/,
                index = re.exec(me.url).index,
                urlBack = me.url.substring(index),
                urlFront = me.url.substring(0, me.url.length - urlBack.length);
            if (me.datasetType == "GRID") {
                me.url = urlFront + "/gridValue" + urlBack;
            } else {
                me.url = urlFront + "/imageValue" + urlBack;
            }

            if (me.X != null && me.Y != null) {
                me.url += '?x=' + me.X + '&y=' + me.Y;
            }
            me.queryRequest(me.serviceProcessCompleted, me.serviceProcessFailed);
        }

        /**
         * @function SuperMap.GetGridCellInfosService.prototype.getDatasetInfoFailed
         * @description 数据集查询失败，执行此方法。
         * @param result -  {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'getDatasetInfoFailed',
        value: function getDatasetInfoFailed(result) {
            var me = this;
            me.serviceProcessFailed(result);
        }
    }]);

    return GetGridCellInfosService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.GetGridCellInfosService = GetGridCellInfosService;

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.GetLayersInfoService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _ServerTheme = __webpack_require__(219);

var _Grid = __webpack_require__(196);

var _Image = __webpack_require__(197);

var _Vector = __webpack_require__(254);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.GetLayersInfoService
 * @classdesc 获取图层信息服务类构造函数。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的地图服务地址。请求地图服务,URL 应为：<br>
 *         http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；<br>
 *         如 http://localhost:8090/iserver/services/map-world/rest/maps/World 。<br>
 *         如果查询临时图层的信息，请指定完成的url，包含临时图层ID信息，如：<br>
 *         http://localhost:8090/iserver/services/map-world/rest/maps/World/tempLayersSet/resourceID
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *         serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *         format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 *         isTempLayers - {boolean} 当前url对应的图层是否是临时图层。
 */
var GetLayersInfoService = exports.GetLayersInfoService = function (_CommonServiceBase) {
    _inherits(GetLayersInfoService, _CommonServiceBase);

    function GetLayersInfoService(url, options) {
        _classCallCheck(this, GetLayersInfoService);

        /**
         * @member SuperMap.GetLayersInfoService.prototype.isTempLayers -{Boolean}
         * @description 当前url对应的图层是否是临时图层。
         */
        var _this = _possibleConstructorReturn(this, (GetLayersInfoService.__proto__ || Object.getPrototypeOf(GetLayersInfoService)).call(this, url, options));

        _this.isTempLayers = false;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.GetLayersInfoService";
        return _this;
    }

    /**
     * @function SuperMap.GetLayersInfoService.prototype.destroy
     * @override
     */


    _createClass(GetLayersInfoService, [{
        key: 'destroy',
        value: function destroy() {
            _get(GetLayersInfoService.prototype.__proto__ || Object.getPrototypeOf(GetLayersInfoService.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.GetLayersInfoService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this,
                method = "GET",
                end = me.url.substr(me.url.length - 1, 1);
            if (!me.isTempLayers) {
                me.url += end === "/" ? '' : '/';
                me.url += "layers.json?";
            } else {
                me.url += ".json?";
            }
            me.request({
                method: method,
                params: null,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.GetLayersInfoService.prototype.serviceProcessCompleted
         * @description 编辑完成，执行此方法。
         * @param result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this,
                existRes,
                layers,
                len;
            result = _Util.Util.transformResult(result);

            existRes = !!result && result.length > 0;
            layers = existRes ? result[0].subLayers.layers : null;
            len = layers ? layers.length : 0;
            me.handleLayers(len, layers);
            me.events.triggerEvent("processCompleted", { result: result[0] });
        }

        /**
         * TODO 专题图时候可能会用到
         * @function SuperMap.GetLayersInfoService.prototype.handleLayers
         * @description 处理iserver 新增图层组数据 (subLayers.layers 中可能还会含有 subLayers.layers)
         * @param len - {number} subLayers.layers的长度
         * @param layers - {Array} subLayers.layers
         */

    }, {
        key: 'handleLayers',
        value: function handleLayers(len, layers) {
            var me = this,
                tempLayer;
            if (len) {
                for (var i = 0; i < len; i++) {
                    if (layers[i].subLayers && layers[i].subLayers.layers && layers[i].subLayers.layers.length > 0) {
                        me.handleLayers(layers[i].subLayers.layers.length, layers[i].subLayers.layers);
                    } else {
                        var type = layers[i].ugcLayerType;
                        switch (type) {
                            case 'THEME':
                                tempLayer = new _ServerTheme.ServerTheme();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            case 'GRID':
                                tempLayer = new _Grid.Grid();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            case 'IMAGE':
                                tempLayer = new _Image.UGCImage();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            case 'VECTOR':
                                tempLayer = new _Vector.Vector();
                                tempLayer.fromJson(layers[i]);
                                layers[i] = tempLayer;
                                break;
                            default:
                                break;
                        }
                    }
                }
            }
        }
    }]);

    return GetLayersInfoService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.GetLayersInfoService = GetLayersInfoService;

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InterpolationAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _InterpolationRBFAnalystParameters = __webpack_require__(200);

var _InterpolationDensityAnalystParameters = __webpack_require__(379);

var _InterpolationIDWAnalystParameters = __webpack_require__(198);

var _InterpolationKrigingAnalystParameters = __webpack_require__(199);

var _InterpolationAnalystParameters = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationAnalystService
 * @classdesc
 * 插值分析服务类
 * 插值分析可以将有限的采样点数据，通过插值算法对采样点周围的数值情况进行预测，可以掌握研究区域内数据的总体分布状况，从而使采样的离散点不仅仅反映其所在位置的数值情况，还可以反映区域的数值分布。目前SuperMap iServer的插值功能提供从点数据集插值得到栅格数据集的功能，支持以下常用的内插方法，包括：反距离加权插值、克吕金（Kriging）插值法、样条（径向基函数，Radial Basis Function）插值、点密度插值。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 *
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myTInterpolationAnalystService = new SuperMap.InterpolationAnalystService(url);
 * myTInterpolationAnalystService.events.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var InterpolationAnalystService = exports.InterpolationAnalystService = function (_SpatialAnalystBase) {
    _inherits(InterpolationAnalystService, _SpatialAnalystBase);

    function InterpolationAnalystService(url, options) {
        _classCallCheck(this, InterpolationAnalystService);

        /**
         * @member SuperMap.InterpolationAnalystService.prototype.mode -{string}
         * @description 插值分析类型。
         */

        var _this = _possibleConstructorReturn(this, (InterpolationAnalystService.__proto__ || Object.getPrototypeOf(InterpolationAnalystService)).call(this, url, options));

        _this.mode = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        return _this;
    }

    /**
     * @function SuperMap.InterpolationAnalystService.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */


    _createClass(InterpolationAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationAnalystService.prototype.__proto__ || Object.getPrototypeOf(InterpolationAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
            this.CLASS_NAME = "SuperMap.InterpolationAnalystService";
        }

        /**
         * @function SuperMap.InterpolationAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param  parameter - {SuperMap.InterpolationAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            if (parameter instanceof _InterpolationDensityAnalystParameters.InterpolationDensityAnalystParameters) {
                me.mode = "Density";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/density';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/density';
                }
            } else if (parameter instanceof _InterpolationIDWAnalystParameters.InterpolationIDWAnalystParameters) {
                me.mode = "IDW";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/idw';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/idw';
                }
            } else if (parameter instanceof _InterpolationRBFAnalystParameters.InterpolationRBFAnalystParameters) {
                me.mode = "RBF";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/rbf';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/rbf';
                }
            } else if (parameter instanceof _InterpolationKrigingAnalystParameters.InterpolationKrigingAnalystParameters) {
                me.mode = "Kriging";
                if (parameter.InterpolationAnalystType === "geometry") {
                    me.url += 'geometry/interpolation/kriging';
                } else {
                    me.url += 'datasets/' + parameter.dataset + '/interpolation/kriging';
                }
            }
            _InterpolationAnalystParameters.InterpolationAnalystParameters.toObject(parameter, parameterObject);
            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return InterpolationAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.InterpolationAnalystService = InterpolationAnalystService;

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.InterpolationDensityAnalystParameters = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _InterpolationAnalystParameters = __webpack_require__(42);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.InterpolationDensityAnalystParameters
 * @classdesc 点密度差值分析参数类。
 * @param options - {Object} 可选参数。如:</br>
 *        bounds - {Object} 插值分析的范围，用于确定结果栅格数据集的范围。Bounds类型可以是SuperMap.Bounds|L.Bounds|ol.extent。</br>
 *        searchRadius - {number} 查找半径，即参与运算点的查找范围，与点数据集单位相同，默认值为0。</br>
 *        zValueFieldName - {string} 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型( SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        zValueScale - {number} 用于进行插值分析值的缩放比率，默认值为1。</br>
 *        resolution - {number} 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。</br>
 *        filterQueryParameter - {{@link SuperMap.FilterParameter}} 属性过滤条件。</br>
 *        outputDatasetName - {string} 插值分析结果数据集的名称。必设参数</br>
 *        outputDatasourceName - {string} 插值分析结果数据源的名称。必设参数</br>
 *        pixelFormat - {string} 指定结果栅格数据集存储的像素格式。</br>
 *        dataset - {string} 用来做插值分析的数据源中数据集的名称，该名称用形如"数据集名称@数据源别名"形式来表示。当插值分析类型( SuperMap.InterpolationAnalystType)为 dataset 时，必设参数。</br>
 *        inputPoints - {Array <Object>} 用于做插值分析的离散点集合。当插值分析类型（ SuperMap.InterpolationAnalystType）为 geometry 时，必设参数。
 *                      点类型可以是SuperMap.Geometry.Point|L.LatLng|L.Point|ol.geom.Point。</br>
 * @extends SuperMap.InterpolationAnalystParameters
 * @example
 * var myInterpolationDensityAnalystParameters = new SuperMap.InterpolationDensityAnalystParameters({
 *      dataset: "SamplesP@Interpolation",
 *      searchRadius: "100000",
 *      pixelFormat: "BIT16",
 *      zValueFieldName: "AVG_TMP",
 *      resolution: 3000,
 *      filterQueryParameter: {
 *          attributeFilter: ""
 *      },
 *      outputDatasetName: "myDensity"
 * });
 */
var InterpolationDensityAnalystParameters = exports.InterpolationDensityAnalystParameters = function (_InterpolationAnalyst) {
    _inherits(InterpolationDensityAnalystParameters, _InterpolationAnalyst);

    function InterpolationDensityAnalystParameters(options) {
        _classCallCheck(this, InterpolationDensityAnalystParameters);

        var _this = _possibleConstructorReturn(this, (InterpolationDensityAnalystParameters.__proto__ || Object.getPrototypeOf(InterpolationDensityAnalystParameters)).call(this, options));

        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.InterpolationDensityAnalystParameters";
        return _this;
    }

    /**
     * @function SuperMap.InterpolationDensityAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(InterpolationDensityAnalystParameters, [{
        key: 'destroy',
        value: function destroy() {
            _get(InterpolationDensityAnalystParameters.prototype.__proto__ || Object.getPrototypeOf(InterpolationDensityAnalystParameters.prototype), 'destroy', this).call(this);
        }
    }]);

    return InterpolationDensityAnalystParameters;
}(_InterpolationAnalystParameters.InterpolationAnalystParameters);

_SuperMap.SuperMap.InterpolationDensityAnalystParameters = InterpolationDensityAnalystParameters;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KernelDensityJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _KernelDensityJobParameter = __webpack_require__(201);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.KernelDensityJobsService
 * @classdesc 核密度分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 核密度分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var KernelDensityJobsService = exports.KernelDensityJobsService = function (_ProcessingServiceBas) {
    _inherits(KernelDensityJobsService, _ProcessingServiceBas);

    function KernelDensityJobsService(url, options) {
        _classCallCheck(this, KernelDensityJobsService);

        var _this = _possibleConstructorReturn(this, (KernelDensityJobsService.__proto__ || Object.getPrototypeOf(KernelDensityJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/density";
        _this.CLASS_NAME = "SuperMap.KernelDensityJobsService";
        return _this;
    }

    /**
     * @function SuperMap.KernelDensityJobsService.prototype.destroy
     * @override
     */


    _createClass(KernelDensityJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.prototype.getKernelDensityJobs
         * @description 获取核密度分析任务
         */

    }, {
        key: 'getKernelDensityJobs',
        value: function getKernelDensityJobs() {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.prototype.getKernelDensityJobs
         * @description 获取指定id的核密度分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getKernelDensityJob',
        value: function getKernelDensityJob(id) {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.prototype.addKernelDensityJob
         * @description 新建核密度分析服务
         * @param params - {SuperMap.KernelDensityJobParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addKernelDensityJob',
        value: function addKernelDensityJob(params, seconds) {
            _get(KernelDensityJobsService.prototype.__proto__ || Object.getPrototypeOf(KernelDensityJobsService.prototype), 'addJob', this).call(this, this.url, params, _KernelDensityJobParameter.KernelDensityJobParameter, seconds);
        }
    }]);

    return KernelDensityJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.KernelDensityJobsService = KernelDensityJobsService;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.MapService
 * @classdesc 地图信息服务类。
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myMapService = new SuperMap.MapService(url, {
 * eventListeners:{
 *     "processCompleted": MapServiceCompleted,
 *       "processFailed": MapServiceFailed
 *       }
 * });
 *
 * @param url - {string} 服务的访问地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param options - {Object} 可选参数 。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var MapService = exports.MapService = function (_CommonServiceBase) {
    _inherits(MapService, _CommonServiceBase);

    function MapService(url, options) {
        _classCallCheck(this, MapService);

        /**
         * @member  SuperMap.MapService.prototype.projection -{string}
         * @description 根据投影参数获取地图状态信息。如"EPSG:4326"
         */
        var _this = _possibleConstructorReturn(this, (MapService.__proto__ || Object.getPrototypeOf(MapService)).call(this, url, options));

        _this.projection = null;

        _this.CLASS_NAME = "SuperMap.MapService";
        if (options) {
            _Util.Util.extend(_this, options);
        }
        var me = _this;

        me.url += ".json";

        if (me.projection) {
            var arr = me.projection.split(":");
            if (arr instanceof Array) {
                if (arr.length === 2) {
                    me.url += "?prjCoordSys={\"epsgCode\":" + arr[1] + "}";
                }
                if (arr.length === 1) {
                    me.url += "?prjCoordSys={\"epsgCode\":" + arr[0] + "}";
                }
            }
        }
        return _this;
    }

    /**
     * @function  destroy
     * @description 释放资源，将引用的资源属性置空。
     */


    _createClass(MapService, [{
        key: 'destroy',
        value: function destroy() {
            _get(MapService.prototype.__proto__ || Object.getPrototypeOf(MapService.prototype), 'destroy', this).call(this);
            var me = this;
            if (me.events) {
                me.events.un(me.eventListeners);
                me.events.listeners = null;
                me.events.destroy();
                me.events = null;
                me.eventListeners = null;
            }
        }

        /**
         * @function  SuperMap.MapService.prototype.processAsync
         * @description 负责将客户端的设置的参数传递到服务端，与服务端完成异步通讯。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            var me = this;
            me.request({
                method: "GET",
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: getMapStatusCompleted
         * 获取地图状态完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            var codeStatus = result.code >= 200 && result.code < 300 || result.code == 0 || result.code === 304;
            var isCodeValid = result.code && codeStatus;
            if (!result.code || isCodeValid) {
                me.events && me.events.triggerEvent("processCompleted", { result: result });
            } else {
                ////在没有token是返回的是200，但是其实是没有权限，所以这里也应该是触发失败事件
                me.events.triggerEvent("processFailed", { error: result });
            }
        }
    }]);

    return MapService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.MapService = MapService;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MathExpressionAnalysisService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _MathExpressionAnalysisParameters = __webpack_require__(208);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.MathExpressionAnalysisService
 * @classdesc 栅格代数运算服务类。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myMathExpressionAnalysisService = new SuperMap.MathExpressionAnalysisService(url);
 * myMathExpressionAnalysisService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var MathExpressionAnalysisService = exports.MathExpressionAnalysisService = function (_SpatialAnalystBase) {
    _inherits(MathExpressionAnalysisService, _SpatialAnalystBase);

    function MathExpressionAnalysisService(url, options) {
        _classCallCheck(this, MathExpressionAnalysisService);

        var _this = _possibleConstructorReturn(this, (MathExpressionAnalysisService.__proto__ || Object.getPrototypeOf(MathExpressionAnalysisService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.MathExpressionAnalysisService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(MathExpressionAnalysisService, [{
        key: 'destroy',
        value: function destroy() {
            _get(MathExpressionAnalysisService.prototype.__proto__ || Object.getPrototypeOf(MathExpressionAnalysisService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.MathExpressionAnalysisService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param  parameter - {SuperMap.MathExpressionAnalysisParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            var parameterObject = {};

            if (parameter instanceof _MathExpressionAnalysisParameters.MathExpressionAnalysisParameters) {
                me.url += 'datasets/' + parameter.dataset + '/mathanalyst';
            }

            _MathExpressionAnalysisParameters.MathExpressionAnalysisParameters.toObject(parameter, parameterObject);
            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return MathExpressionAnalysisService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.MathExpressionAnalysisService = MathExpressionAnalysisService;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MeasureService = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _MeasureParameters = __webpack_require__(209);

var _ServerGeometry = __webpack_require__(9);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.MeasureService
 * @classdesc 量算服务类。
 *              该类负责将量算参数传递到服务端，并获取服务端返回的量算结果。
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myMeasuerService = new SuperMap.MeasureService(url, {
 *      measureMode: SuperMap.MeasureMode.DISTANCE,
 *      eventListeners:{
 *          "processCompleted": measureCompleted
 *      }
 * });
 * @param url - {string} 服务访问的地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。<br>
 *        measureMode - {MeasureMode} 量算模式，包括距离量算模式和面积量算模式。
 */
var MeasureService = exports.MeasureService = function (_CommonServiceBase) {
    _inherits(MeasureService, _CommonServiceBase);

    function MeasureService(url, options) {
        _classCallCheck(this, MeasureService);

        /**
         * @member SuperMap.MeasureService.prototype.measureMode -{SuperMap.MeasureMode}
         * @description 量算模式，包括距离量算模式和面积量算模式。默认值为：MeasureMode.DISTANCE 。
         */
        var _this = _possibleConstructorReturn(this, (MeasureService.__proto__ || Object.getPrototypeOf(MeasureService)).call(this, url, options));

        _this.measureMode = _REST.MeasureMode.DISTANCE;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.MeasureService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(MeasureService, [{
        key: 'destroy',
        value: function destroy() {
            _get(MeasureService.prototype.__proto__ || Object.getPrototypeOf(MeasureService.prototype), 'destroy', this).call(this);
            var me = this;
            me.measureMode = null;
        }

        /**
         * @function SuperMap.MeasureService.prototype.processAsync
         * @description 负责将客户端的量算参数传递到服务端。
         * @param params - {SuperMap.MeasureParameters} 量算参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _MeasureParameters.MeasureParameters)) {
                return;
            }
            var me = this,
                geometry = params.geometry,
                pointsCount = 0,
                point2ds = null,
                end = null;
            if (!geometry) {
                return;
            }
            end = me.url.substr(me.url.length - 1, 1);
            if (me.measureMode === _REST.MeasureMode.AREA) {
                me.url += end === "/" ? "area.json?" : "/area.json?";
            } else {
                me.url += end === "/" ? "distance.json?" : "/distance.json?";
            }
            var serverGeometry = _ServerGeometry.ServerGeometry.fromGeometry(geometry);
            if (!serverGeometry) {
                return;
            }
            pointsCount = serverGeometry.parts[0];
            point2ds = serverGeometry.points.splice(0, pointsCount);

            var prjCoordSysTemp, prjCodeTemp, paramsTemp;
            if (params.prjCoordSys) {
                if (_typeof(params.prjCoordSys) === "object") {
                    prjCodeTemp = params.prjCoordSys.projCode;
                    prjCoordSysTemp = '{"epsgCode"' + prjCodeTemp.substring(prjCodeTemp.indexOf(":"), prjCodeTemp.length) + "}";
                } else if (typeof params.prjCoordSys === "string") {
                    prjCoordSysTemp = '{"epsgCode"' + params.prjCoordSys.substring(params.prjCoordSys.indexOf(":"), params.prjCoordSys.length) + "}";
                }
                paramsTemp = {
                    "point2Ds": _Util.Util.toJSON(point2ds),
                    "unit": params.unit,
                    "prjCoordSys": prjCoordSysTemp
                };
            } else {
                paramsTemp = { "point2Ds": _Util.Util.toJSON(point2ds), "unit": params.unit };
            }

            me.request({
                method: "GET",
                params: paramsTemp,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return MeasureService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.MeasureService = MeasureService;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OverlayAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _DatasetOverlayAnalystParameters = __webpack_require__(162);

var _GeometryOverlayAnalystParameters = __webpack_require__(187);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.OverlayAnalystService
 * @classdesc
 * 叠加分析服务类
 * 该类负责将客户设置的叠加分析参数传递给服务端，并接收服务端返回的叠加分析结果数据。
 * 叠加分析结果通过该类支持的事件的监听函数参数获取
 * @param url - {string} 服务的访问地址。如http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * (start code)
 * var myOverlayAnalystService = new SuperMap.OverlayAnalystService(url, {
     *     eventListeners: {
     *	       "processCompleted": OverlayCompleted,
     *		   "processFailed": OverlayFailed
     *		   }
     * });
 * (end)
 */

var OverlayAnalystService = exports.OverlayAnalystService = function (_SpatialAnalystBase) {
    _inherits(OverlayAnalystService, _SpatialAnalystBase);

    function OverlayAnalystService(url, options) {
        _classCallCheck(this, OverlayAnalystService);

        /**
         * @member SuperMap.OverlayAnalystService.prototype.mode -{string}
         * @description 叠加分析类型
         */
        var _this = _possibleConstructorReturn(this, (OverlayAnalystService.__proto__ || Object.getPrototypeOf(OverlayAnalystService)).call(this, url, options));

        _this.mode = null;

        if (options) {
            _Util.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.OverlayAnalystService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(OverlayAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(OverlayAnalystService.prototype.__proto__ || Object.getPrototypeOf(OverlayAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.OverlayAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.OverlayAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            if (parameter instanceof _DatasetOverlayAnalystParameters.DatasetOverlayAnalystParameters) {
                me.mode = "datasets";
                me.url += 'datasets/' + parameter.sourceDataset + '/overlay';
                _DatasetOverlayAnalystParameters.DatasetOverlayAnalystParameters.toObject(parameter, parameterObject);
            } else if (parameter instanceof _GeometryOverlayAnalystParameters.GeometryOverlayAnalystParameters) {
                me.mode = "geometry";
                me.url += 'geometry/overlay';
                _GeometryOverlayAnalystParameters.GeometryOverlayAnalystParameters.toObject(parameter, parameterObject);
            }

            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return OverlayAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.OverlayAnalystService = OverlayAnalystService;

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OverlayGeoJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _OverlayGeoJobParameter = __webpack_require__(211);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.OverlayGeoJobsService
 * @classdesc 叠加分析任务类。
 * @param url -{string} 叠加分析任务地址。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        events - {SuperMap.Events} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。
 */
var OverlayGeoJobsService = exports.OverlayGeoJobsService = function (_ProcessingServiceBas) {
    _inherits(OverlayGeoJobsService, _ProcessingServiceBas);

    function OverlayGeoJobsService(url, options) {
        _classCallCheck(this, OverlayGeoJobsService);

        var _this = _possibleConstructorReturn(this, (OverlayGeoJobsService.__proto__ || Object.getPrototypeOf(OverlayGeoJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/overlay";
        _this.CLASS_NAME = "SuperMap.OverlayGeoJobsService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(OverlayGeoJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(OverlayGeoJobsService.prototype.__proto__ || Object.getPrototypeOf(OverlayGeoJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.OverlayGeoJobsService.prototype.getOverlayGeoJobs
         * @description 获取叠加分析任务
         */

    }, {
        key: 'getOverlayGeoJobs',
        value: function getOverlayGeoJobs() {
            _get(OverlayGeoJobsService.prototype.__proto__ || Object.getPrototypeOf(OverlayGeoJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.OverlayGeoJobsService.prototype.getOverlayGeoJob
         * @description 获取指定id的叠加分析任务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getOverlayGeoJob',
        value: function getOverlayGeoJob(id) {
            _get(OverlayGeoJobsService.prototype.__proto__ || Object.getPrototypeOf(OverlayGeoJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.OverlayGeoJobsService.prototype.addOverlayGeoJob
         * @description 新建点叠加析服务
         * @param params - {SuperMap.OverlayGeoJobParameter} 创建一个叠加分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addOverlayGeoJob',
        value: function addOverlayGeoJob(params, seconds) {
            _get(OverlayGeoJobsService.prototype.__proto__ || Object.getPrototypeOf(OverlayGeoJobsService.prototype), 'addJob', this).call(this, this.url, params, _OverlayGeoJobParameter.OverlayGeoJobParameter, seconds);
        }
    }]);

    return OverlayGeoJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.OverlayGeoJobsService = OverlayGeoJobsService;

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryByBoundsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryService2 = __webpack_require__(51);

var _QueryByBoundsParameters = __webpack_require__(213);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByBoundsService
 * @classdesc Bounds 查询服务类。
 * @augments SuperMap.QueryService
 * @example
 * (start end)
 * var myQueryByBoundsService = new SuperMap.QueryByBoundsService(url, {
 *     eventListeners: {
 *         "processCompleted": queryCompleted,
 *		   "processFailed": queryError
 *		   }
 * });
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * (end)
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var QueryByBoundsService = exports.QueryByBoundsService = function (_QueryService) {
    _inherits(QueryByBoundsService, _QueryService);

    function QueryByBoundsService(url, options) {
        _classCallCheck(this, QueryByBoundsService);

        var _this = _possibleConstructorReturn(this, (QueryByBoundsService.__proto__ || Object.getPrototypeOf(QueryByBoundsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryByBoundsService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(QueryByBoundsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByBoundsService.prototype.__proto__ || Object.getPrototypeOf(QueryByBoundsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryByBoundsService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql geometry distance bounds 等）。
         * @param params - {SuperMap.QueryByBoundsParameters} Bounds 查询参数。
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            if (!(params instanceof _QueryByBoundsParameters.QueryByBoundsParameters)) {
                return null;
            }
            var me = this,
                jsonParameters = "",
                qp = null,
                bounds = params.bounds;
            qp = me.getQueryParameters(params);
            jsonParameters += "'queryMode':'BoundsQuery','queryParameters':";
            jsonParameters += _Util.Util.toJSON(qp);
            jsonParameters += ",'bounds': {'rightTop':{'y':" + bounds.top + ",'x':" + bounds.right + "},'leftBottom':{'y':" + bounds.bottom + ",'x':" + bounds.left + "}}";
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryByBoundsService;
}(_QueryService2.QueryService);

_SuperMap.SuperMap.QueryByBoundsService = QueryByBoundsService;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryByDistanceService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryService2 = __webpack_require__(51);

var _QueryByDistanceParameters = __webpack_require__(214);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByDistanceService
 * @description Distance查询服务类。
 * @extends SuperMap.QueryService
 * @example
 * var myQueryByDistService = new SuperMap.QueryByDistanceService(url, {
 *     eventListeners: {
 *         "processCompleted": queryCompleted,
 *		   "processFailed": queryError
 *		   }
 * });
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var QueryByDistanceService = exports.QueryByDistanceService = function (_QueryService) {
    _inherits(QueryByDistanceService, _QueryService);

    function QueryByDistanceService(url, options) {
        _classCallCheck(this, QueryByDistanceService);

        var _this = _possibleConstructorReturn(this, (QueryByDistanceService.__proto__ || Object.getPrototypeOf(QueryByDistanceService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryByDistanceService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(QueryByDistanceService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByDistanceService.prototype.__proto__ || Object.getPrototypeOf(QueryByDistanceService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryByDistanceService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql geometry distance bounds等）。
         * @param params - {SuperMap.QueryByDistanceParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            if (!(params instanceof _QueryByDistanceParameters.QueryByDistanceParameters)) {
                return;
            }
            var me = this,
                jsonParameters = "",
                qp = me.getQueryParameters(params);
            var sg = _ServerGeometry.ServerGeometry.fromGeometry(params.geometry);

            jsonParameters += params.isNearest ? "'queryMode':'FindNearest','queryParameters':" : "'queryMode':'DistanceQuery','queryParameters':";
            jsonParameters += _Util.Util.toJSON(qp);
            jsonParameters += ",'geometry':" + _Util.Util.toJSON(sg) + ",'distance':" + params.distance;
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryByDistanceService;
}(_QueryService2.QueryService);

_SuperMap.SuperMap.QueryByDistanceService = QueryByDistanceService;

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryByGeometryService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryService2 = __webpack_require__(51);

var _QueryByGeometryParameters = __webpack_require__(215);

var _ServerGeometry = __webpack_require__(9);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryByGeometryService
 * @classdesc Geometry查询服务类。
 * @extends SuperMap.QueryService
 * @example
 * var myQueryByGeometryService = new SuperMap.QueryByGeometryService(url, {
 *     eventListeners: {
 *	      "processCompleted": queryCompleted,
 *		  "processFailed": queryError
 *		  }
 * });
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var QueryByGeometryService = exports.QueryByGeometryService = function (_QueryService) {
    _inherits(QueryByGeometryService, _QueryService);

    /*
     * @function SuperMap.QueryByGeometryService.prototype.constructor
     * @description Geometry 查询服务类构造函数。
     * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function QueryByGeometryService(url, options) {
        _classCallCheck(this, QueryByGeometryService);

        var _this = _possibleConstructorReturn(this, (QueryByGeometryService.__proto__ || Object.getPrototypeOf(QueryByGeometryService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryByGeometryService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(QueryByGeometryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryByGeometryService.prototype.__proto__ || Object.getPrototypeOf(QueryByGeometryService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryByGeometryService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql geometry distance bounds等）。
         * @param params - {SuperMap.QueryByGeometryParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            if (!(params instanceof _QueryByGeometryParameters.QueryByGeometryParameters)) {
                return;
            }
            var me = this,
                jsonParameters = "",
                qp = null,
                geometry = params.geometry,
                sg = _ServerGeometry.ServerGeometry.fromGeometry(geometry);
            qp = me.getQueryParameters(params);
            jsonParameters += "'queryMode':'SpatialQuery','queryParameters':";
            jsonParameters += _Util.Util.toJSON(qp) + ",'geometry':" + _Util.Util.toJSON(sg) + ",'spatialQueryMode':" + _Util.Util.toJSON(params.spatialQueryMode);
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryByGeometryService;
}(_QueryService2.QueryService);

_SuperMap.SuperMap.QueryByGeometryService = QueryByGeometryService;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueryBySQLService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _QueryService2 = __webpack_require__(51);

var _QueryBySQLParameters = __webpack_require__(216);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.QueryBySQLService
 * @classdesc SQL 查询服务类。在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
 * @extends SuperMap.QueryService
 * @example
 * var queryParam = new SuperMap.FilterParameter({
 *     name: "Countries@World.1",
 *     attributeFilter: "Pop_1994>1000000000 and SmArea>900"
 * });
 * var queryBySQLParams = new SuperMap.QueryBySQLParameters({
 *     queryParams: [queryParam]
 * });
 * var myQueryBySQLService = new SuperMap.QueryBySQLService(url, {eventListeners: {
 *     "processCompleted": queryCompleted,
 *     "processFailed": queryError
 *	   }
 * });
 * queryBySQLService.processAsync(queryBySQLParams);
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var QueryBySQLService = exports.QueryBySQLService = function (_QueryService) {
    _inherits(QueryBySQLService, _QueryService);

    /*
     * @function SuperMap.QueryBySQLService.prototype.constructor
     * @descriptionSQL 查询服务类构造函数。
     * @param url - {string} 服务的访问地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
     * @param options - {Object} 互服务时所需可选参数。如：<br>
     *         eventListeners - {Object} 需要被注册的监听器对象。
     */
    function QueryBySQLService(url, options) {
        _classCallCheck(this, QueryBySQLService);

        var _this = _possibleConstructorReturn(this, (QueryBySQLService.__proto__ || Object.getPrototypeOf(QueryBySQLService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.QueryBySQLService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(QueryBySQLService, [{
        key: 'destroy',
        value: function destroy() {
            _get(QueryBySQLService.prototype.__proto__ || Object.getPrototypeOf(QueryBySQLService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.QueryBySQLService.prototype.getJsonParameters
         * @description 将查询参数转化为 JSON 字符串。
         *              在本类中重写此方法，可以实现不同种类的查询（sql geometry distance bounds等）。
         * @param params - {SuperMap.QueryBySQLParameters}
         * @return {Object} 转化后的 JSON 字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            if (!(params instanceof _QueryBySQLParameters.QueryBySQLParameters)) {
                return;
            }
            var me = this,
                jsonParameters = "",
                qp = null;
            qp = me.getQueryParameters(params);
            jsonParameters += "'queryMode':'SqlQuery','queryParameters':";
            jsonParameters += _Util.Util.toJSON(qp);
            jsonParameters = "{" + jsonParameters + "}";
            return jsonParameters;
        }
    }]);

    return QueryBySQLService;
}(_QueryService2.QueryService);

_SuperMap.SuperMap.QueryBySQLService = QueryBySQLService;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RouteCalculateMeasureService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _RouteCalculateMeasureParameters = __webpack_require__(217);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.RouteCalculateMeasureService
 * @classdesc
 * 该类负责将客户设置的计算指定点的M值参数传递给服务端，并接收服务端返回的
 *      指定点的M值。通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.SpatialAnalystBase
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @example 实例化该类如下例所示：
 * (start code)
 * var parameters = new SuperMap.RouteCalculateMeasureParameters({
     *     "sourceRoute":{
     *         "type":"LINEM",
     *        "parts":[4],
     *         "points":[
     *             {
     *                 "measure":0,
     *                 "y":-6674.466867067764,
     *                 "x":3817.3527876130133
     *             },
     *             {
     *                 "measure":199.57954019411724,
     *                 "y":-6670.830929417594,
     *                 "x":3617.806369901496
     *             },
     *             {
     *                 "measure":609.3656478634477,
     *                "y":-6877.837541432356,
     *                 "x":3264.1498746678444
     *             },
     *             {
     *                 "measure":936.0174126282958,
     *                 "y":-7038.687780615184,
     *                 "x":2979.846206068903
     *             }
     *         ]
     *     },
     *     "tolerance":1,
     *     "point":{
     *         "x":3330.7754269417,
     *         "y":-6838.8394457216
     *     },
     *     "isIgnoreGap":false
     * });
 *
 * var routeCalculateMeasureService = new SuperMap.RouteCalculateMeasureService(spatialAnalystURL, {
     *     eventListeners:{
     *         processCompleted:calculateCompleted,
     *         processFailed:calculateFailded
     *     }
     * );
     * routeCalculateMeasureService.processAsync(parameters);
     *
     *  //执行
     * function calculateCompleted(){todo}
     * function calculateFailded(){todo}
     * (end)
     *
     */
var RouteCalculateMeasureService = exports.RouteCalculateMeasureService = function (_SpatialAnalystBase) {
    _inherits(RouteCalculateMeasureService, _SpatialAnalystBase);

    function RouteCalculateMeasureService(url, options) {
        _classCallCheck(this, RouteCalculateMeasureService);

        var _this = _possibleConstructorReturn(this, (RouteCalculateMeasureService.__proto__ || Object.getPrototypeOf(RouteCalculateMeasureService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.RouteCalculateMeasureService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(RouteCalculateMeasureService, [{
        key: 'destroy',
        value: function destroy() {
            _get(RouteCalculateMeasureService.prototype.__proto__ || Object.getPrototypeOf(RouteCalculateMeasureService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.RouteCalculateMeasureService.prototype.processAsync
         * @description 负责将客户端的基于路由对象计算指定点M值操作的参数传递到服务端。
         * @param params - {SuperMap.RouteCalculateMeasureParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _RouteCalculateMeasureParameters.RouteCalculateMeasureParameters)) {
                return;
            }
            var me = this,
                jsonParameters;

            jsonParameters = me.getJsonParameters(params);

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.RouteCalculateMeasureService.prototype.getJsonParameters
         * @description 将参数转化为 JSON 字符串。
         * @param params - {SuperMap.RouteCalculateMeasureParameters}
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters,
                jsonStr = "geometry/calculatemeasure",
                me = this,
                end;
            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? jsonStr + ".json" : "/" + jsonStr + ".json";
            me.url += "?returnContent=true";
            jsonParameters = _Util.Util.toJSON(params);
            return jsonParameters;
        }
    }]);

    return RouteCalculateMeasureService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.RouteCalculateMeasureService = RouteCalculateMeasureService;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RouteLocatorService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _RouteLocatorParameters = __webpack_require__(218);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.RouteLocatorService
 * @classdesc 路由对象定位空间对象的服务类。
 * @extends SuperMap.SpatialAnalystBase
 * @param options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url -{string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @example 实例化该类如下例所示：
 * (start code)
 * var routeLocatorParameters_point = new SuperMap.RouteLocatorParameters({
     *   "sourceRoute":{
     *       "type":"LINEM",
     *       "parts":[4],
     *       "points":[
     *           {
     *               "measure":0,
     *               "y":-6674.466867067764,
     *               "x":3817.3527876130133
     *           },
     *           {
     *               "measure":199.57954019411724,
     *               "y":-6670.830929417594,
     *               "x":3617.806369901496
     *          },
     *           {
     *               "measure":609.3656478634477,
     *               "y":-6877.837541432356,
     *               "x":3264.1498746678444
     *           },
     *           {
     *               "measure":936.0174126282958,
     *               "y":-7038.687780615184,
     *               "x":2979.846206068903
     *           }
     *       ]
     *   },
     *   "type":"POINT",
     *   "measure":10,
     *   "offset":3,
     *   "isIgnoreGap":true
     * });
 * var routeLocatorService = new SuperMap.RouteLocatorService(spatialAnalystURL, {
     *     eventListeners:{
     *         processCompleted:routeLocatorCompleted,
     *         processFailed:routeLocatorFailded
     *     }
     * );
     * routeLocatorService.processAsync(routeLocatorParameters_point);
     *
     *  //执行
     * function routeLocatorCompleted(){todo}
     * function routeLocatorFailded(){todo}
     * (end)
     *
     */
var RouteLocatorService = exports.RouteLocatorService = function (_SpatialAnalystBase) {
    _inherits(RouteLocatorService, _SpatialAnalystBase);

    function RouteLocatorService(url, options) {
        _classCallCheck(this, RouteLocatorService);

        var _this = _possibleConstructorReturn(this, (RouteLocatorService.__proto__ || Object.getPrototypeOf(RouteLocatorService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.RouteLocatorService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(RouteLocatorService, [{
        key: 'destroy',
        value: function destroy() {
            _get(RouteLocatorService.prototype.__proto__ || Object.getPrototypeOf(RouteLocatorService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.RouteLocatorService.prototype.processAsync
         * @description 负责将客户端的基于路由对象计算指定点M值操作的参数传递到服务端。
         * @param params - {SuperMap.RouteLocatorParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _RouteLocatorParameters.RouteLocatorParameters)) {
                return;
            }
            var me = this,
                jsonParameters;

            jsonParameters = me.getJsonParameters(params);

            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.RouteLocatorService.prototype.processAsync
         * @description 将参数转化为 JSON 字符串。
         * @param params - {SuperMap.RouteLocatorParameters}
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters,
                jsonStr = "geometry/routelocator",
                me = this,
                end;
            end = me.url.substr(me.url.length - 1, 1);

            if (params.dataset) {
                jsonStr = "datasets/" + params.dataset + "/linearreferencing/routelocator";
                params.sourceRoute = null;
            }
            me.url += end === "/" ? jsonStr + ".json" : "/" + jsonStr + ".json";
            me.url += "?returnContent=true";
            jsonParameters = _Util.Util.toJSON(params);
            return jsonParameters;
        }
    }]);

    return RouteLocatorService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.RouteLocatorService = RouteLocatorService;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerFeature = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Vector = __webpack_require__(64);

var _ServerGeometry = __webpack_require__(9);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class SuperMap.ServerFeature
 * 服务端矢量要素类。
 * 该类描述了服务端返回的矢量要素的相关信息，包括字段和几何信息。
 */
var ServerFeature = exports.ServerFeature = function () {
    /*
     * Constructor: SuperMap.ServerFeature
     * 服务端矢量要素类构造函数。
     *
     * Parameters:
     * options - {Object} 参数。
     *
     * Allowed options properties:
     * fieldNames - {Array(String)} 矢量要素的属性字段名集合。
     * fieldValues - {Array(String)} 矢量要素的属性字段值集合。
     * geometry - {<SuperMap.ServerGeometry>} 矢量要素的几何信息。
     */
    function ServerFeature(options) {
        _classCallCheck(this, ServerFeature);

        /*
         * APIProperty: fieldNames
         * {Array(String)} 矢量要素的属性字段名集合。
         */
        this.fieldNames = null;

        /*
         * APIProperty: fieldValues
         * {Array(String)} 矢量要素的属性字段值集合。
         */
        this.fieldValues = null;

        /*
         * APIProperty: geometry
         * {<SuperMap.ServerGeometry>} 矢量要素的几何信息。
         */
        this.geometry = null;
        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ServerFeature";
    }

    /*
     * @function SuperMap.ServerFeature.prototype.destroy
     * APIMethod: destroy
     * 释放资源，将引用资源的属性置空。
     */


    _createClass(ServerFeature, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.fieldNames = null;
            me.fieldValues = null;
            if (me.geometry) {
                me.geometry.destroy();
                me.geometry = null;
            }
        }

        /*
         * APIMethod: toFeature
         * 将服务端矢量要素 ServerFeature 转换为客户端矢量要素 Feature。
         *
         * Returns
         * {<Vector>} 转换后的客户端矢量要素。
         */

    }, {
        key: 'toFeature',
        value: function toFeature() {
            var names,
                values,
                geo,
                attr = {},
                me = this,
                feature;

            names = me.fieldNames;
            values = me.fieldValues;
            for (var i in names) {
                attr[names[i]] = values[i];
            }
            if (me.geometry) {
                geo = me.geometry.toGeometry();
            }
            feature = new _Vector.Vector(geo, attr);
            if (me.geometry && me.geometry.id) {
                feature.fid = me.geometry.id;
            }

            return feature;
        }

        /*
         * Function: SuperMap.ServerFeature.fromJson
         * 将 JSON 对象表示服务端矢量要素转换为 ServerFeature
         *
         * Parameters:
         * jsonObject - {Object} 要转换的 JSON 对象。
         *
         * Returns:
         * {SuperMap.ServerFeature} 转化后的 ServerFeature 对象。
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            var geo = null;
            if (!jsonObject) {
                return;
            }
            geo = jsonObject.geometry;
            if (geo) {
                geo = _ServerGeometry.ServerGeometry.fromJson(geo);
            }
            return new ServerFeature({
                fieldNames: jsonObject.fieldNames,
                fieldValues: jsonObject.fieldValues,
                geometry: geo
            });
        }
    }]);

    return ServerFeature;
}();

_SuperMap.SuperMap.ServerFeature = ServerFeature;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SetLayerInfoService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

__webpack_require__(220);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SetLayerInfoService
 * @classdesc 设置图层信息服务类。可以实现临时图层中子图层的修改
 *              该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的地图服务地址。请求地图服务,URL 应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World"；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var SetLayerInfoService = exports.SetLayerInfoService = function (_CommonServiceBase) {
    _inherits(SetLayerInfoService, _CommonServiceBase);

    function SetLayerInfoService(url, options) {
        _classCallCheck(this, SetLayerInfoService);

        var _this = _possibleConstructorReturn(this, (SetLayerInfoService.__proto__ || Object.getPrototypeOf(SetLayerInfoService)).call(this, url, options));

        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.SetLayerInfoService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(SetLayerInfoService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SetLayerInfoService.prototype.__proto__ || Object.getPrototypeOf(SetLayerInfoService.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.SetLayerInfoService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {Object} 修改后的图层资源信息。<br>
         *        该参数可以使用获取图层信息服务<{@link SuperMap.GetLayersInfoService}>返回图层信息，解析结果result.subLayers.layers[i]，然后对其属性进行修改来获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var me = this;
            me.url += ".json";
            var jsonParamsStr = _Util.Util.toJSON(params);
            me.request({
                method: "PUT",
                data: jsonParamsStr,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return SetLayerInfoService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.SetLayerInfoService = SetLayerInfoService;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SetLayerStatusService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _SetLayerStatusParameters = __webpack_require__(221);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SetLayerStatusService
 * @classdesc  子图层显示控制服务类。该类负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。<br>
 *                用户获取服务端返回的各子图层显示状态有两种方式：<br>
 *                一种是通过监听 SetLayerEvent.PROCESS_COMPLETE 事件；<br>
 *                一种是使用 AsyncResponder 类实现异步处理。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图服务访问地址。请求地图服务,URL 应为：<br>
 *               http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *         serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *         format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var SetLayerStatusService = exports.SetLayerStatusService = function (_CommonServiceBase) {
    _inherits(SetLayerStatusService, _CommonServiceBase);

    function SetLayerStatusService(url, options) {
        _classCallCheck(this, SetLayerStatusService);

        var _this = _possibleConstructorReturn(this, (SetLayerStatusService.__proto__ || Object.getPrototypeOf(SetLayerStatusService)).call(this, url, options));

        _this.lastparams = null;

        _this.mapUrl = url;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.SetLayerStatusService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(SetLayerStatusService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SetLayerStatusService.prototype.__proto__ || Object.getPrototypeOf(SetLayerStatusService.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.SetLayerStatusService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务 <SuperMap.SetLayerStatusParameters>
         *         返回图层信息，然后对其属性进行修改来获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _SetLayerStatusParameters.SetLayerStatusParameters)) {
                return;
            }
            var me = this,
                method = "POST";
            me.url = me.mapUrl;
            var end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';

            if (params.resourceID == null) {
                me.url += "tempLayersSet";
                me.url += ".json?";

                me.lastparams = params;

                me.request({
                    method: method,
                    scope: me,
                    success: me.createTempLayerComplete,
                    failure: me.serviceProcessFailed
                });
            } else {
                me.url += "tempLayersSet/" + params.resourceID;
                me.url += ".json?";

                me.url += "elementRemain=true&reference=" + params.resourceID + "&holdTime=" + params.holdTime.toString();

                var jsonParameters = '[{';

                jsonParameters += '"type":"UGC",';
                if (params.layerStatusList != null && params.layerStatusList.length > 0) {
                    jsonParameters += '"subLayers":' + params.toJSON();
                }
                jsonParameters += ',"visible":' + true + ',';
                jsonParameters += '"name":"' + this.getMapName(this.mapUrl) + '"';

                jsonParameters += '}]';

                me.request({
                    method: "PUT",
                    data: jsonParameters,
                    scope: me,
                    success: me.serviceProcessCompleted,
                    failure: me.serviceProcessFailed
                });
            }
        }

        /*
         * Method: createTempLayerComplete
         * 设置完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象，记录设置操作是否成功。
         */

    }, {
        key: 'createTempLayerComplete',
        value: function createTempLayerComplete(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            if (result.succeed) {
                me.lastparams.resourceID = result.newResourceID;
            }

            me.processAsync(me.lastparams);
        }
    }, {
        key: 'getMapName',
        value: function getMapName(url) {
            var mapUrl = url;
            if (mapUrl.charAt(mapUrl.length - 1) === "/") {
                mapUrl = mapUrl.substr(0, mapUrl.length - 1);
            }
            var index = mapUrl.lastIndexOf("/");
            var mapName = mapUrl.substring(index + 1, mapUrl.length);
            return mapName;
        }

        /*
         * Method: setLayerCompleted
         * 设置完成，执行此方法。
         *
         * Parameters:
         * result - {Object} 服务器返回的结果对象，记录设置操作是否成功。
         */

    }, {
        key: 'serviceProcessCompleted',
        value: function serviceProcessCompleted(result) {
            var me = this;
            result = _Util.Util.transformResult(result);
            if (result != null && me.lastparams != null) {
                result.newResourceID = me.lastparams.resourceID;
            }
            me.events.triggerEvent("processCompleted", { result: result });
        }
    }]);

    return SetLayerStatusService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.SetLayerStatusService = SetLayerStatusService;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SetLayersInfoService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

__webpack_require__(222);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SetLayersInfoService
 * @classdesc  设置图层信息服务类。可以实现创建新的临时图层和对现有临时图层的修改，<br>
 *                当 isTempLayers 为 false的时候执行创建临时图层。当 isTempLayers 为 ture 并且临时图层资源 resourceID 被设置有效时执行对临时图层的编辑。<br>
 *                该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的地图服务地址。请求地图服务,URL 应为：<br>
 *              http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         resourceID - {string} 图层资源ID，临时图层的资源ID标记。<br>
 *         isTempLayers - {boolean} 当前url对应的图层是否是临时图层。<br>
 *         eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *         serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *         format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。<br>
 */
var SetLayersInfoService = exports.SetLayersInfoService = function (_CommonServiceBase) {
    _inherits(SetLayersInfoService, _CommonServiceBase);

    function SetLayersInfoService(url, options) {
        _classCallCheck(this, SetLayersInfoService);

        /**
         * @member SuperMap.SetLayersInfoService.prototype.resourceID - {string}
         * @description 图层资源ID，临时图层的资源ID标记。
         */
        var _this = _possibleConstructorReturn(this, (SetLayersInfoService.__proto__ || Object.getPrototypeOf(SetLayersInfoService)).call(this, url, options));

        _this.resourceID = null;

        /**
         * @function SuperMap.SetLayersInfoService.prototype.isTempLayers -{boolean}
         * @description 当前url对应的图层是否是临时图层。
         */
        _this.isTempLayers = false;

        if (options) {
            _SuperMap.SuperMap.Util.extend(_this, options);
        }

        _this.CLASS_NAME = "SuperMap.SetLayersInfoService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(SetLayersInfoService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SetLayersInfoService.prototype.__proto__ || Object.getPrototypeOf(SetLayersInfoService.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.SetLayersInfoService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param  params - {Object} 修改后的图层资源信息。该参数可以使用获取图层信息服务 <{@link SuperMap.GetLayersInfoService}>返回图层信息，然后对其属性进行修改来获取。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!params) {
                return;
            }
            var jsonParams,
                subLayers = [],
                me = this,
                method = "",
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            //创建临时图层和设置修改临时图层信息对应不同的资源URL
            if (me.isTempLayers) {
                me.url += "tempLayersSet/" + me.resourceID;
                method = "PUT";
            } else {
                me.url += "tempLayersSet";
                method = "POST";
            }
            me.url += ".json?";
            if (!params.subLayers) {
                params.subLayers = { layers: [] };
            }
            if (!params.subLayers.layers) {
                params.subLayers.layers = [];
            }
            var layers = params.subLayers.layers,
                len = layers.length;
            for (var i in layers) {
                if (layers[i].ugcLayerType === "GRID") {
                    var colorDictionary = {};
                    var colorDics = layers[i].colorDictionarys;
                    for (var j in colorDics) {
                        var key = colorDics[j].elevation;
                        colorDictionary[key] = colorDics[j].color;
                    }
                }
                layers[i].colorDictionary = colorDictionary;
                delete layers[i].colorDictionarys;
            }

            for (var _i = 0; _i < len; _i++) {
                if (layers[_i].toJsonObject) {
                    //将图层信息转换成服务端能识别的简单json对象
                    subLayers.push(layers[_i].toJsonObject());
                } else {
                    subLayers.push(layers[_i]);
                }
            }
            jsonParams = _Util.Util.extend(jsonParams, params);
            jsonParams.subLayers = { "layers": subLayers };
            jsonParams.object = null;
            var jsonParamsStr = _Util.Util.toJSON([jsonParams]);
            me.request({
                method: method,
                data: jsonParamsStr,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return SetLayersInfoService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.SetLayersInfoService = SetLayersInfoService;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SingleObjectQueryJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _SingleObjectQueryJobsParameter = __webpack_require__(223);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SingleObjectQueryJobsService
 * @classdesc 单对象查询分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 单对象空间查询分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var SingleObjectQueryJobsService = exports.SingleObjectQueryJobsService = function (_ProcessingServiceBas) {
    _inherits(SingleObjectQueryJobsService, _ProcessingServiceBas);

    function SingleObjectQueryJobsService(url, options) {
        _classCallCheck(this, SingleObjectQueryJobsService);

        var _this = _possibleConstructorReturn(this, (SingleObjectQueryJobsService.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/query";
        _this.CLASS_NAME = "SuperMap.SingleObjectQueryJobsService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(SingleObjectQueryJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SingleObjectQueryJobsService.protitype.getQueryJobs
         * @description 获取单对象空间查询分析所有任务
         */

    }, {
        key: 'getQueryJobs',
        value: function getQueryJobs() {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.protitype.getQueryJob
         * @description 获取指定id的单对象空间查询分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getQueryJob',
        value: function getQueryJob(id) {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SingleObjectQueryJobsService.protitype.addQueryJob
         * @description 新建单对象空间查询分析服务
         * @param params - {SuperMap.SingleObjectQueryJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addQueryJob',
        value: function addQueryJob(params, seconds) {
            _get(SingleObjectQueryJobsService.prototype.__proto__ || Object.getPrototypeOf(SingleObjectQueryJobsService.prototype), 'addJob', this).call(this, this.url, params, _SingleObjectQueryJobsParameter.SingleObjectQueryJobsParameter, seconds);
        }
    }]);

    return SingleObjectQueryJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.SingleObjectQueryJobsService = SingleObjectQueryJobsService;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StopQueryService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _StopQueryParameters = __webpack_require__(224);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.StopQueryService
 * @classdesc
 * 站点查询服务类。
 * 返回结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 与客户端交互的站点查询服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 *
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.StopQueryService(url, {eventListeners: {
     *     "processCompleted": StopQueryCompleted,
     *     "processFailed": StopQueryError
     *     }
     * };
 * (end)
 *
 *
 */

var StopQueryService = exports.StopQueryService = function (_CommonServiceBase) {
    _inherits(StopQueryService, _CommonServiceBase);

    function StopQueryService(url, options) {
        _classCallCheck(this, StopQueryService);

        var _this = _possibleConstructorReturn(this, (StopQueryService.__proto__ || Object.getPrototypeOf(StopQueryService)).call(this, url, options));

        options = options || {};
        _Util.Util.extend(_this, options);
        _this.CLASS_NAME = "SuperMap.StopQueryService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(StopQueryService, [{
        key: 'destroy',
        value: function destroy() {
            _get(StopQueryService.prototype.__proto__ || Object.getPrototypeOf(StopQueryService.prototype), 'destroy', this).call(this);
            _Util.Util.reset(this);
        }

        /**
         * @function SuperMap.StopQueryService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.StopQueryParameters} 交通换乘参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _StopQueryParameters.StopQueryParameters)) {
                return;
            }
            var me = this,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            me.url += "stops/keyword/" + params.keyWord;
            me.url += ".json?";

            me.request({
                method: "GET",
                params: { returnPosition: params.returnPosition },
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return StopQueryService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.StopQueryService = StopQueryService;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SummaryAttributesJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _SummaryAttributesJobsParameter = __webpack_require__(225);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SummaryAttributesJobsService
 * @classdesc 属性汇总分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 汇总统计分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var SummaryAttributesJobsService = exports.SummaryAttributesJobsService = function (_ProcessingServiceBas) {
    _inherits(SummaryAttributesJobsService, _ProcessingServiceBas);

    function SummaryAttributesJobsService(url, options) {
        _classCallCheck(this, SummaryAttributesJobsService);

        var _this = _possibleConstructorReturn(this, (SummaryAttributesJobsService.__proto__ || Object.getPrototypeOf(SummaryAttributesJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/summaryattributes";
        _this.CLASS_NAME = "SuperMap.SummaryAttributesJobsService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(SummaryAttributesJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SummaryAttributesJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryAttributesJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SummaryAttributesJobsService.protitype.getSummaryAttributesJobs
         * @description 获取属性汇总分析所有任务
         */

    }, {
        key: 'getSummaryAttributesJobs',
        value: function getSummaryAttributesJobs() {
            _get(SummaryAttributesJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryAttributesJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.SummaryAttributesJobsService.protitype.getSummaryAttributesJob
         * @description 获取指定id的属性汇总分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getSummaryAttributesJob',
        value: function getSummaryAttributesJob(id) {
            _get(SummaryAttributesJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryAttributesJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SummaryAttributesJobsService.protitype.addSummaryAttributesJob
         * @description 新建属性汇总分析服务
         * @param params - {SuperMap.SummaryAttributesJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addSummaryAttributesJob',
        value: function addSummaryAttributesJob(params, seconds) {
            _get(SummaryAttributesJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryAttributesJobsService.prototype), 'addJob', this).call(this, this.url, params, _SummaryAttributesJobsParameter.SummaryAttributesJobsParameter, seconds);
        }
    }]);

    return SummaryAttributesJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.SummaryAttributesJobsService = SummaryAttributesJobsService;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SummaryMeshJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _SummaryMeshJobParameter = __webpack_require__(226);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SummaryMeshJobsService
 * @classdesc 点聚合分析任务类。
 * @param url -{string} 点聚合分析任务地址。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        events - {SuperMap.Events} 处理所有事件的对象。<br>
 *        eventListeners - {Object} 听器对象。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        index - {number}服务访问地址在数组中的位置。<br>
 *        length - {number}服务访问地址数组长度。
 */
var SummaryMeshJobsService = exports.SummaryMeshJobsService = function (_ProcessingServiceBas) {
    _inherits(SummaryMeshJobsService, _ProcessingServiceBas);

    function SummaryMeshJobsService(url, options) {
        _classCallCheck(this, SummaryMeshJobsService);

        var _this = _possibleConstructorReturn(this, (SummaryMeshJobsService.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/aggregatepoints";
        _this.CLASS_NAME = "SuperMap.SummaryMeshJobsService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(SummaryMeshJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SummaryMeshJobsService.prototype.getSummaryMeshJobs
         * @description 获取点聚合分析任务
         */

    }, {
        key: 'getSummaryMeshJobs',
        value: function getSummaryMeshJobs() {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.SummaryMeshJobsService.prototype.getSummaryMeshJob
         * @description 获取指定ip的点聚合分析任务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getSummaryMeshJob',
        value: function getSummaryMeshJob(id) {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SummaryMeshJobsService.prototype.addSummaryMeshJob
         * @description 新建点聚合分析服务
         * @param params - {SuperMap.SummaryMeshJobParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addSummaryMeshJob',
        value: function addSummaryMeshJob(params, seconds) {
            _get(SummaryMeshJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryMeshJobsService.prototype), 'addJob', this).call(this, this.url, params, _SummaryMeshJobParameter.SummaryMeshJobParameter, seconds);
        }
    }]);

    return SummaryMeshJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.SummaryMeshJobsService = SummaryMeshJobsService;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SummaryRegionJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _SummaryRegionJobParameter = __webpack_require__(227);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SummaryRegionJobsService
 * @classdesc 区域汇总分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 区域汇总分析服务地址。
 * @param options - {Object} 区域汇总分析服务可选参数。
 */
var SummaryRegionJobsService = exports.SummaryRegionJobsService = function (_ProcessingServiceBas) {
    _inherits(SummaryRegionJobsService, _ProcessingServiceBas);

    function SummaryRegionJobsService(url, options) {
        _classCallCheck(this, SummaryRegionJobsService);

        var _this = _possibleConstructorReturn(this, (SummaryRegionJobsService.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/summaryregion";
        _this.CLASS_NAME = "SuperMap.SummaryRegionJobsService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(SummaryRegionJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SummaryRegionJobsService.prototype.getSummaryRegionJobs
         * @description 获取区域汇总分析任务集合。
         */

    }, {
        key: 'getSummaryRegionJobs',
        value: function getSummaryRegionJobs() {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.SummaryRegionJobsService.prototype.getSummaryRegionJob
         * @description 获取指定id的区域汇总分析任务。
         * @param id -{string} 要获取区域汇总分析任务的id
         */

    }, {
        key: 'getSummaryRegionJob',
        value: function getSummaryRegionJob(id) {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.SummaryRegionJobsService.prototype.addSummaryRegionJob
         * @description 新建区域汇总任务。
         * @param params - {SuperMap.SummaryRegionJobParameter} 创建一个区域汇总任务的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addSummaryRegionJob',
        value: function addSummaryRegionJob(params, seconds) {
            _get(SummaryRegionJobsService.prototype.__proto__ || Object.getPrototypeOf(SummaryRegionJobsService.prototype), 'addJob', this).call(this, this.url, params, _SummaryRegionJobParameter.SummaryRegionJobParameter, seconds);
        }
    }]);

    return SummaryRegionJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.SummaryRegionJobsService = SummaryRegionJobsService;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SupplyCenter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.SupplyCenter
 * @classdesc 资源供给中心类。在资源分配和选址分区分析两个功能中使用。
 * @param options - {Object} 可选参数。如：<br>
 *        maxWeight - {number}资源供给中心的最大耗费值，必设参数。<br>
 *        nodeID - {integer} 资源供给中心点的结点 ID 号，必设参数。资源供给中心必须是结点。<br>
 *        resourceValue - {number}资源供给中心能提供的最大服务量或商品数量，必设参数。<br>
 *        type - {{@link SuperMap.SupplyCenterType}} 资源供给中心点的类型常量。
 */
var SupplyCenter = exports.SupplyCenter = function () {
    function SupplyCenter(options) {
        _classCallCheck(this, SupplyCenter);

        /**
         * @member SuperMap.SupplyCenter.prototype.maxWeight -{number}
         * @description 资源供给中心的最大耗费值，必设参数。中心点最大阻值设置越小，表示中心点所提供的资源可影响范围越大。
         *              最大阻力值是用来限制需求点到中心点的花费。
         *              如果需求点（弧段或结点）到此中心的花费大于最大阻力值，则该需求点不属于该资源供给中心提供资源的范围。
         */
        this.maxWeight = null;

        /**
         * @member SuperMap.SupplyCenter.prototype.nodeID -{integer}
         * @description 资源供给中心点的结点 ID 号，必设参数。资源供给中心必须是结点。
         */
        this.nodeID = null;

        /**
         * @member SuperMap.SupplyCenter.prototype.resourceValue -{number}
         * @description 资源供给中心能提供的最大服务量或商品数量，必设参数。例如资源中心为学校，资源中心资源量表示该学校能够接纳多少学生。
         */
        this.resourceValue = null;

        /**
         * @member SuperMap.SupplyCenter.prototype.type -{SuperMap.SupplyCenterType}
         * @description 资源供给中心点的类型常量。资源供给中心点的类型包括非中心，固定中心和可选中心。
         *              固定中心用于资源分配分析；固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
         */
        this.type = null;

        if (options) {
            _Util.Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.SupplyCenter";
    }

    /**
     * @function SuperMap.SupplyCenter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */


    _createClass(SupplyCenter, [{
        key: 'destroy',
        value: function destroy() {
            var me = this;
            me.maxWeight = null;
            me.nodeID = null;
            me.resourceValue = null;
            me.type = null;
        }

        /**
         * @function SuperMap.SupplyCenter.fromJson
         * @description 将服务端JSON对象转换成当前客户端对象
         * @param jsonObject - {Object} 要转换的 JSON 对象。
         * @return{SuperMap.SupplyCenter} SupplyCenter对象
         */

    }], [{
        key: 'fromJson',
        value: function fromJson(jsonObject) {
            if (!jsonObject) {
                return;
            }
            return new SupplyCenter({
                maxWeight: jsonObject.maxWeight,
                nodeID: jsonObject.nodeID,
                resourceValue: jsonObject.resourceValue,
                type: jsonObject.type
            });
        }
    }]);

    return SupplyCenter;
}();

_SuperMap.SuperMap.SupplyCenter = SupplyCenter;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SurfaceAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _Util = __webpack_require__(1);

var _DatasetSurfaceAnalystParameters = __webpack_require__(163);

var _GeometrySurfaceAnalystParameters = __webpack_require__(188);

var _SurfaceAnalystParameters = __webpack_require__(69);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.SurfaceAnalystService
 * @classdesc
 * 表面分析服务类。
 * 该类负责将客户设置的表面分析服务参数传递给服务端，并接收服务端返回的表面分析服务分析结果数据。
 * 表面分析结果通过该类支持的事件的监听函数参数获取
 * @param options - {Object} 可选参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。s
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var mySurfaceAnalystService = new SuperMap.SurfaceAnalystService(url, {
     *      eventListeners: {
     *	       "processCompleted": surfaceAnalysCompleted,
     *		   "processFailed": surfaceAnalysFailed
     *		   }
     * });
 * (end)
 *
 */
var SurfaceAnalystService = exports.SurfaceAnalystService = function (_SpatialAnalystBase) {
    _inherits(SurfaceAnalystService, _SpatialAnalystBase);

    function SurfaceAnalystService(url, options) {
        _classCallCheck(this, SurfaceAnalystService);

        var _this = _possibleConstructorReturn(this, (SurfaceAnalystService.__proto__ || Object.getPrototypeOf(SurfaceAnalystService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.SurfaceAnalystService";
        return _this;
    }

    /**
     * @function SuperMap.SurfaceAnalystService.prototype.destroy
     * @description 释放资源,将引用的资源属性置空。
     */


    _createClass(SurfaceAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(SurfaceAnalystService.prototype.__proto__ || Object.getPrototypeOf(SurfaceAnalystService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.SurfaceAnalystService.prototype.processAsync
         * @description 负责将客户端的表面分析服务参数传递到服务端。
         * @param params - {SuperMap.SurfaceAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _SurfaceAnalystParameters.SurfaceAnalystParameters)) {
                return;
            }
            var me = this,
                jsonParameters;
            jsonParameters = me.getJsonParameters(params);
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.SurfaceAnalystService.prototype.getJsonParameters
         * @description 将参数转化为 JSON 字符串。
         * @param params - {SuperMap.SurfaceAnalystParameters}
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(params) {
            var jsonParameters = "";
            var parameterObject = {};
            var me = this,
                end;
            if (params instanceof _DatasetSurfaceAnalystParameters.DatasetSurfaceAnalystParameters) {
                end = me.url.substr(me.url.length - 1, 1);
                me.url += end === "/" ? "datasets/" + params.dataset + "/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true" : "/datasets/" + params.dataset + "/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true";
                _DatasetSurfaceAnalystParameters.DatasetSurfaceAnalystParameters.toObject(params, parameterObject);
                jsonParameters = _Util.Util.toJSON(parameterObject);
            } else if (params instanceof _GeometrySurfaceAnalystParameters.GeometrySurfaceAnalystParameters) {
                end = me.url.substr(me.url.length - 1, 1);
                me.url += end === "/" ? "geometry/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true" : "/geometry/" + params.surfaceAnalystMethod.toLowerCase() + ".json?returnContent=true";
                jsonParameters = _Util.Util.toJSON(params);
            } else {
                return;
            }
            return jsonParameters;
        }
    }]);

    return SurfaceAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.SurfaceAnalystService = SurfaceAnalystService;

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TerrainCurvatureCalculationService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _TerrainCurvatureCalculationParameters = __webpack_require__(229);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TerrainCurvatureCalculationService
 * @classdesc 地形曲率计算服务类。
 * @extends SuperMap.SpatialAnalystBase
 * @param options - {Object} 可选参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @example 例如：
 * (start code)
 * var myTerrainCurvatureCalculationService = new SuperMap.TerrainCurvatureCalculationService(url);
 * myTerrainCurvatureCalculationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 *
 */
var TerrainCurvatureCalculationService = exports.TerrainCurvatureCalculationService = function (_SpatialAnalystBase) {
    _inherits(TerrainCurvatureCalculationService, _SpatialAnalystBase);

    function TerrainCurvatureCalculationService(url, options) {
        _classCallCheck(this, TerrainCurvatureCalculationService);

        var _this = _possibleConstructorReturn(this, (TerrainCurvatureCalculationService.__proto__ || Object.getPrototypeOf(TerrainCurvatureCalculationService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TerrainCurvatureCalculationService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(TerrainCurvatureCalculationService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TerrainCurvatureCalculationService.prototype.__proto__ || Object.getPrototypeOf(TerrainCurvatureCalculationService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TerrainCurvatureCalculationService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.TerrainCurvatureCalculationParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            var parameterObject = {};

            if (parameter instanceof _TerrainCurvatureCalculationParameters.TerrainCurvatureCalculationParameters) {
                me.url += 'datasets/' + parameter.dataset + '/terraincalculation/curvature';
            }

            _TerrainCurvatureCalculationParameters.TerrainCurvatureCalculationParameters.toObject(parameter, parameterObject);
            var jsonParameters = _SuperMap.SuperMap.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TerrainCurvatureCalculationService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.TerrainCurvatureCalculationService = TerrainCurvatureCalculationService;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeLabelUniqueItem = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ServerTextStyle = __webpack_require__(33);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeLabelUniqueItem
 * @classdesc 单值标签专题图的子项
 * @description 标签专题图用专题值对点、线、面等对象做标注，值得注意的是，单值标签专题图允许用户通过 uniqueExpression <br>
 *              字段指定用于单值的字段，同一值的标签具有相同的显示风格，其中每一个值就是一个专题图子项，<br>
 *              每一个子项都具有其名称、风格、指定的单值、X方向偏移量和Y方向偏移量。
 * @param options - {Object} 可选参数。如：<br>
 *        caption - {string} 专题图子项的名称。<br>
 *        unique - {string} 单值专题图子项的值，可以为数字、字符串等。<br>
 *        offsetX - {number}标签在X方向偏移量。<br>
 *        offsetY - {number}标签在Y方向偏移量。<br>
 *        visible - {boolean} 标签专题图子项是否可见。<br>
 *        style - {{@link SuperMap.ServerTextStyle}} 标签专题图子项文本的显示风格。
 */
var ThemeLabelUniqueItem = exports.ThemeLabelUniqueItem = function () {
  function ThemeLabelUniqueItem(options) {
    _classCallCheck(this, ThemeLabelUniqueItem);

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.caption -{string}
     * @description 标签专题子项的标题。
     */
    this.caption = null;

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.unique -{string}
     * @description 单值专题图子项的值，可以为数字、字符串等。
     */
    this.unique = null;

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.offsetX -{number}
     * @description 标签在X方向偏移量。
     */
    this.offsetX = 0;

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.offsetY -{number}
     * @description 标签在Y方向偏移量。
     */
    this.offsetY = 0;

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.visible -{boolean}
     * @description 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。默认值为 true。
     */
    this.visible = true;

    /**
     * @member SuperMap.ThemeLabelUniqueItem.prototype.style -{SuperMap.ServerTextStyle}
     * @description 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：
     *              uniformMixedStyle（标签文本的复合风格），SuperMap.ThemeLabelUniqueItem.style（单值子项的文本风格），uniformStyle（统一文本风格）。
     */
    this.style = new _ServerTextStyle.ServerTextStyle();

    if (options) {
      _Util.Util.extend(this, options);
    }
    this.CLASS_NAME = "SuperMap.ThemeLabelUniqueItem";
  }

  /**
   * @function SuperMap.ThemeLabelUniqueItem.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */


  _createClass(ThemeLabelUniqueItem, [{
    key: 'destroy',
    value: function destroy() {
      var me = this;
      me.unique = null;
      me.caption = null;
      me.offsetX = null;
      me.offsetY = null;
      if (me.style) {
        me.style.destroy();
        me.style = null;
      }
      me.visible = null;
    }

    /**
     * @function SuperMap.ThemeLabelUniqueItem.fromObj
     * @description 从传入对象获取单值标签专题图的子项类。
     * @param obj - {Object} 传入对象
     * @return {SuperMap.ThemeLabelUniqueItem} ThemeLabelUniqueItem对象
     */

  }], [{
    key: 'fromObj',
    value: function fromObj(obj) {
      if (!obj) {
        return;
      }
      var t = new ThemeLabelUniqueItem();
      _Util.Util.copy(t, obj);
      return t;
    }
  }]);

  return ThemeLabelUniqueItem;
}();

_SuperMap.SuperMap.ThemeLabelUniqueItem = ThemeLabelUniqueItem;

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _ThemeParameters = __webpack_require__(244);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThemeService
 * @classdesc 专题图服务类。
 * @extends SuperMap.CommonServiceBase
 * @example
 * var myThemeService = new SuperMap.ThemeService(url, {
 *     eventListeners: {
 *           "processCompleted": themeCompleted,
 *           "processFailed": themeFailed
 *           }
 * });
 * @param url - {string} 服务的访问地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var ThemeService = exports.ThemeService = function (_CommonServiceBase) {
    _inherits(ThemeService, _CommonServiceBase);

    function ThemeService(url, options) {
        _classCallCheck(this, ThemeService);

        var _this = _possibleConstructorReturn(this, (ThemeService.__proto__ || Object.getPrototypeOf(ThemeService)).call(this, url, options));

        if (options) {
            _SuperMap.SuperMap.Util.extend(_this, options);
        }
        var end,
            me = _this;
        end = me.url.substr(me.url.length - 1, 1);
        me.url += end === "/" ? "tempLayersSet.json?" : "/tempLayersSet.json?";

        _this.CLASS_NAME = "SuperMap.ThemeService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(ThemeService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThemeService.prototype.__proto__ || Object.getPrototypeOf(ThemeService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.ThemeService.prototype.processAsync
         * @description 负责将客户端的专题图参数传递到服务端。
         * @param params - {SuperMap.ThemeParameters} 专题图参数类。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _ThemeParameters.ThemeParameters)) {
                return;
            }
            var me = this,
                jsonParameters = null;
            jsonParameters = me.getJsonParameters(params);
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ThemeService.prototype.getJsonParameters
         * @description 将专题图参数参数转化为 JSON 字符串。
         * @param params - {SuperMap.ThemeParameters} 专题图参数类。
         * @return {Object} 转化后的JSON字符串。
         */

    }, {
        key: 'getJsonParameters',
        value: function getJsonParameters(parameter) {
            var jsonParameters = "",
                themeObj = null,
                filters = null,
                orderBys = null,
                fieldValuesDisplayFilter;
            jsonParameters += "[{'type': 'UGC','subLayers': {'layers': [";
            for (var themeID in parameter.themes) {
                themeObj = parameter.themes[themeID];
                var jsonTheme = _Util.Util.toJSON(themeObj);
                jsonTheme = jsonTheme.slice(0, -1);

                jsonParameters += "{'theme': " + jsonTheme + "},'type': 'UGC','ugcLayerType': 'THEME',";
                filters = parameter.displayFilters;
                if (filters && filters.length > 0) {
                    if (filters.length === 1) {
                        jsonParameters += "'displayFilter':\"" + filters[0] + "\",";
                    } else {
                        jsonParameters += "'displayFilter':\"" + filters[themeID] + "\",";
                    }
                }
                orderBys = parameter.displayOrderBy;
                if (orderBys && orderBys.length > 0) {
                    if (orderBys.length === 1) {
                        jsonParameters += "'displayOrderBy':'" + orderBys[0] + "',";
                    } else {
                        jsonParameters += "'displayOrderBy':'" + orderBys[themeID] + "',";
                    }
                }

                fieldValuesDisplayFilter = parameter.fieldValuesDisplayFilter;
                if (fieldValuesDisplayFilter) {
                    jsonParameters += "'fieldValuesDisplayFilter':" + _Util.Util.toJSON(fieldValuesDisplayFilter) + ",";
                }

                if (parameter.joinItems && parameter.joinItems.length > 0 && parameter.joinItems[themeID]) {
                    jsonParameters += "'joinItems':[" + _Util.Util.toJSON(parameter.joinItems[themeID]) + "],";
                }
                if (parameter.datasetNames && parameter.dataSourceNames) {
                    var datasetID = parameter.datasetNames[themeID] ? themeID : parameter.datasetNames.length - 1;
                    var dataSourceID = parameter.dataSourceNames[themeID] ? themeID : parameter.dataSourceNames.length - 1;
                    jsonParameters += "'datasetInfo': {'name': '" + parameter.datasetNames[datasetID] + "','dataSourceName': '" + parameter.dataSourceNames[dataSourceID] + "'}},";
                } else {
                    jsonParameters += "},";
                }
            }
            //去除多余的逗号
            if (parameter.themes && parameter.themes.length > 0) {
                jsonParameters = jsonParameters.substring(0, jsonParameters.length - 1);
            }
            jsonParameters += "]},";
            var urlArray = this.url.split("/");
            var jsonMapName = urlArray[urlArray.length - 2];

            jsonParameters += "'name': '" + jsonMapName + "'}]";
            return jsonParameters;
        }
    }]);

    return ThemeService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.ThemeService = ThemeService;

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThiessenAnalystService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _SpatialAnalystBase2 = __webpack_require__(10);

var _DatasetThiessenAnalystParameters = __webpack_require__(164);

var _GeometryThiessenAnalystParameters = __webpack_require__(189);

var _GeoJSON = __webpack_require__(14);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.ThiessenAnalystService
 * @classdesc
 * 泰森多边形分析服务类
 * 该类负责将客户设置的泰森多边形分析参数传递给服务端，并接收服务端返回的分析结果数据。
 * 泰森多边形分析结果通过该类支持的事件的监听函数参数获取
 * 泰森多边形分析的参数支持两种，当参数为 {SuperMap.DatasetThiessenAnalystParameters} 类型
 * 时，执行数据集泰森多边形分析，当参数为 {SuperMap.GeometryThiessenAnalystParameters} 类型时，
 * 执行几何对象泰森多边形分析。
 * @param options - {Object} 参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 * @param url - {string} 服务的访问地址。
 * 如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 *
 * @extends SuperMap.SpatialAnalystBase
 * @example 例如：
 * (start code)
 * var myThiessenAnalystService = new SuperMap.ThiessenAnalystService(url, {
     *     eventListeners: {
     *           "processCompleted": bufferCompleted,
     *           "processFailed": bufferFailed
     *           }
     *    });
 * (end)
 *
 */
var ThiessenAnalystService = exports.ThiessenAnalystService = function (_SpatialAnalystBase) {
    _inherits(ThiessenAnalystService, _SpatialAnalystBase);

    function ThiessenAnalystService(url, options) {
        _classCallCheck(this, ThiessenAnalystService);

        /**
         * @member SuperMap.ThiessenAnalystService.prototype.mode -{string}
         * @description 缓冲区分析类型
         */
        var _this = _possibleConstructorReturn(this, (ThiessenAnalystService.__proto__ || Object.getPrototypeOf(ThiessenAnalystService)).call(this, url, options));

        _this.mode = null;
        if (options) {
            _Util.Util.extend(_this, options);
        }
        _this.CLASS_NAME = "SuperMap.ThiessenAnalystService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(ThiessenAnalystService, [{
        key: 'destroy',
        value: function destroy() {
            _get(ThiessenAnalystService.prototype.__proto__ || Object.getPrototypeOf(ThiessenAnalystService.prototype), 'destroy', this).call(this);
            this.mode = null;
        }

        /**
         * @function SuperMap.ThiessenAnalystService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         * @param parameter - {SuperMap.DatasetThiessenAnalystParameters}|{GeometryThiessenAnalystParameters}
         */

    }, {
        key: 'processAsync',
        value: function processAsync(parameter) {
            var parameterObject = {};
            var me = this;

            var end = me.url.substr(me.url.length - 1, 1);
            if (end !== '/') {
                me.url += "/";
            }

            if (parameter instanceof _DatasetThiessenAnalystParameters.DatasetThiessenAnalystParameters) {
                me.mode = "datasets";
                me.url += 'datasets/' + parameter.dataset + '/thiessenpolygon';
                _DatasetThiessenAnalystParameters.DatasetThiessenAnalystParameters.toObject(parameter, parameterObject);
            } else if (parameter instanceof _GeometryThiessenAnalystParameters.GeometryThiessenAnalystParameters) {
                me.mode = "geometry";
                me.url += 'geometry/thiessenpolygon';
                _GeometryThiessenAnalystParameters.GeometryThiessenAnalystParameters.toObject(parameter, parameterObject);
            }

            var jsonParameters = _Util.Util.toJSON(parameterObject);
            me.url += '.json?returnContent=true';
            me.request({
                method: "POST",
                data: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /**
         * @function SuperMap.ThiessenAnalystService.prototype.toGeoJSONResult
         * @description 将含有geometry的数据转换为geojson格式。
         * @result - {Object} 服务器返回的结果对象。
         */

    }, {
        key: 'toGeoJSONResult',
        value: function toGeoJSONResult(result) {
            if (!result) {
                return result;
            }

            result = _get(ThiessenAnalystService.prototype.__proto__ || Object.getPrototypeOf(ThiessenAnalystService.prototype), 'toGeoJSONResult', this).call(this, result);
            if (result.regions) {
                var geoJSONFormat = new _GeoJSON.GeoJSON();
                result.regions = JSON.parse(geoJSONFormat.write(result.regions));
            }
            return result;
        }
    }]);

    return ThiessenAnalystService;
}(_SpatialAnalystBase2.SpatialAnalystBase);

_SuperMap.SuperMap.ThiessenAnalystService = ThiessenAnalystService;

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TilesetsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _CommonServiceBase2 = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TilesetsService
 * @classdesc 切片列表信息查询服务类;即查询切片地图服务的切片列表，返回切片集名称、地图切片元数据信息、切片版本集信息
 * @extends SuperMap.CommonServiceBase
 * @param url - {string} 地图服务地址。URL应为：<br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{服务名}/rest/maps/map；<br>
 *                       例如: "http://localhost:8090/iserver/services/test/rest/maps/tianlocal";
 * @param options - {Object} 交互服务时所需可选参数。如：<br>
 *        eventListeners - {Object} 事件监听器对象。有processCompleted属性可传入处理完成后的回调函数。processFailed属性传入处理失败后的回调函数。<br>
 *        serverType - {SuperMap.ServerType} 服务器类型，iServer|iPortal|Online。<br>
 *        format -{SuperMap.DataFormat} 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 */
var TilesetsService = exports.TilesetsService = function (_CommonServiceBase) {
    _inherits(TilesetsService, _CommonServiceBase);

    function TilesetsService(url, options) {
        _classCallCheck(this, TilesetsService);

        var _this = _possibleConstructorReturn(this, (TilesetsService.__proto__ || Object.getPrototypeOf(TilesetsService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TilesetsService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(TilesetsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TilesetsService.prototype.__proto__ || Object.getPrototypeOf(TilesetsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TilesetsService.prototype.processAsync
         * @description 负责将客户端的查询参数传递到服务端。
         */

    }, {
        key: 'processAsync',
        value: function processAsync() {
            if (!this.url) {
                return;
            }
            var me = this;
            var end = me.url.substr(me.url.length - 1, 1);

            me.url = me.url + (end === "/" ? "tilesets" : "/tilesets") + ".json?";

            me.request({
                method: "GET",
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TilesetsService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.TilesetsService = TilesetsService;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TopologyValidatorJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _TopologyValidatorJobsParameter = __webpack_require__(246);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TopologyValidatorJobsService
 * @classdesc 拓扑检查分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 拓扑检查分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var TopologyValidatorJobsService = exports.TopologyValidatorJobsService = function (_ProcessingServiceBas) {
    _inherits(TopologyValidatorJobsService, _ProcessingServiceBas);

    function TopologyValidatorJobsService(url, options) {
        _classCallCheck(this, TopologyValidatorJobsService);

        var _this = _possibleConstructorReturn(this, (TopologyValidatorJobsService.__proto__ || Object.getPrototypeOf(TopologyValidatorJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/topologyvalidator";
        _this.CLASS_NAME = "SuperMap.TopologyValidatorJobsService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(TopologyValidatorJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TopologyValidatorJobsService.prototype.__proto__ || Object.getPrototypeOf(TopologyValidatorJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TopologyValidatorJobsService.protitype.getTopologyValidatorJobs
         * @description 获取拓扑检查分析所有任务
         */

    }, {
        key: 'getTopologyValidatorJobs',
        value: function getTopologyValidatorJobs() {
            _get(TopologyValidatorJobsService.prototype.__proto__ || Object.getPrototypeOf(TopologyValidatorJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.TopologyValidatorJobsService.protitype.getTopologyValidatorJob
         * @description 获取指定id的拓扑检查分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getTopologyValidatorJob',
        value: function getTopologyValidatorJob(id) {
            _get(TopologyValidatorJobsService.prototype.__proto__ || Object.getPrototypeOf(TopologyValidatorJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.TopologyValidatorJobsService.protitype.addTopologyValidatorJob
         * @description 新建拓扑检查分析服务
         * @param params - {SuperMap.TopologyValidatorJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addTopologyValidatorJob',
        value: function addTopologyValidatorJob(params, seconds) {
            _get(TopologyValidatorJobsService.prototype.__proto__ || Object.getPrototypeOf(TopologyValidatorJobsService.prototype), 'addJob', this).call(this, this.url, params, _TopologyValidatorJobsParameter.TopologyValidatorJobsParameter, seconds);
        }
    }]);

    return TopologyValidatorJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.TopologyValidatorJobsService = TopologyValidatorJobsService;

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransferPathService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _TransferPathParameters = __webpack_require__(248);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TransferPathService
 * @classdesc 交通换乘线路查询服务类，根据交通换乘分析结果(TransferSolutionResult)，获取某一条乘车路线的详细信息。
 *            返回结果通过该类支持的事件的监听函数参数获取
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * var myService = new SuperMap.TransferPathService(url, {eventListeners: {
 *     "processCompleted": TrafficTransferCompleted,
 *     "processFailed": TrafficTransferError
 *     }
 * };
 * @param url - {string} 与客户端交互的交通换乘线路查询服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param options - {Object} 可選参数。如:</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。
 */
var TransferPathService = exports.TransferPathService = function (_CommonServiceBase) {
    _inherits(TransferPathService, _CommonServiceBase);

    function TransferPathService(url, options) {
        _classCallCheck(this, TransferPathService);

        var _this = _possibleConstructorReturn(this, (TransferPathService.__proto__ || Object.getPrototypeOf(TransferPathService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TransferPathService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(TransferPathService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TransferPathService.prototype.__proto__ || Object.getPrototypeOf(TransferPathService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TransferPathService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.TransferPathParameters} 交通换乘参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _TransferPathParameters.TransferPathParameters)) {
                return;
            }
            var me = this,
                method = "GET",
                jsonParameters,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            me.url += "path.json?";

            jsonParameters = {
                points: _Util.Util.toJSON(params.points),
                transferLines: _Util.Util.toJSON(params['transferLines'])
            };

            me.request({
                method: method,
                params: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TransferPathService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.TransferPathService = TransferPathService;

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransferSolutionService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _CommonServiceBase2 = __webpack_require__(6);

var _TransferSolutionParameters = __webpack_require__(249);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.TransferSolutionService
 * @classdesc
 * 交通换乘方案查询服务类。
 * 返回结果通过该类支持的事件的监听函数参数获取。
 * @param url - {string} 与客户端交互的交通换乘方案查询服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param options - {Object} 参数。如</br>
 *        eventListeners - {Object} 需要被注册的监听器对象。</br>
 * @extends SuperMap.CommonServiceBase
 * @example 例如：
 * (start code)
 * var myService = new SuperMap.TransferSolutionService(url, {eventListeners: {
     *     "processCompleted": trafficTransferCompleted,
     *     "processFailed": trafficTransferError
     *     }
     * };
 * (end)
 *
 */
var TransferSolutionService = exports.TransferSolutionService = function (_CommonServiceBase) {
    _inherits(TransferSolutionService, _CommonServiceBase);

    function TransferSolutionService(url, options) {
        _classCallCheck(this, TransferSolutionService);

        var _this = _possibleConstructorReturn(this, (TransferSolutionService.__proto__ || Object.getPrototypeOf(TransferSolutionService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.TransferSolutionService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(TransferSolutionService, [{
        key: 'destroy',
        value: function destroy() {
            _get(TransferSolutionService.prototype.__proto__ || Object.getPrototypeOf(TransferSolutionService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.TransferSolutionService.prototype.processAsync
         * @description 负责将客户端的更新参数传递到服务端。
         * @param params - {SuperMap.TransferSolutionParameters} 交通换乘参数。
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _TransferSolutionParameters.TransferSolutionParameters)) {
                return;
            }
            var me = this,
                method = "GET",
                jsonParameters,
                end;

            end = me.url.substr(me.url.length - 1, 1);
            me.url += end === "/" ? '' : '/';
            me.url += "solutions.json?";

            jsonParameters = {
                points: _Util.Util.toJSON(params.points),
                walkingRatio: params['walkingRatio'],
                transferTactic: params['transferTactic'],
                solutionCount: params['solutionCount'],
                transferPreference: params["transferPreference"]
            };
            if (params.evadeLines) {
                jsonParameters["evadeLines"] = _Util.Util.toJSON(params.evadeLines);
            }
            if (params.evadeStops) {
                jsonParameters["evadeStops"] = _Util.Util.toJSON(params.evadeStops);
            }
            if (params.priorLines) {
                jsonParameters["priorLines"] = _Util.Util.toJSON(params.priorLines);
            }
            if (params.priorStops) {
                jsonParameters["priorStops"] = _Util.Util.toJSON(params.priorStops);
            }
            if (params.travelTime) {
                jsonParameters["travelTime"] = params.travelTime;
            }

            me.request({
                method: method,
                params: jsonParameters,
                scope: me,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }
    }]);

    return TransferSolutionService;
}(_CommonServiceBase2.CommonServiceBase);

_SuperMap.SuperMap.TransferSolutionService = TransferSolutionService;

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateEdgeWeightService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _UpdateEdgeWeightParameters = __webpack_require__(252);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UpdateEdgeWeightService
 * @classdesc 更新边的边的耗费权重服务
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 *(start code)
 * var updateEdgeWeightService = new SuperMap.UpdateEdgeWeightService(url, {
 *     eventListeners: {
 *         "processCompleted": UpdateEdgeWeightCompleted,      //参数为SuperMap.UpdateEdgeWeightEventArgs
 *		   "processFailed": UpdateEdgeWeightError             //参数为SuperMap.ServiceFailedEventArgs
 *		   }
 * });
 * (end)
 * @param url - {string} 服务的访问地址。 如:<br>
 *                       http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var UpdateEdgeWeightService = exports.UpdateEdgeWeightService = function (_NetworkAnalystServic) {
    _inherits(UpdateEdgeWeightService, _NetworkAnalystServic);

    function UpdateEdgeWeightService(url, options) {
        _classCallCheck(this, UpdateEdgeWeightService);

        var _this = _possibleConstructorReturn(this, (UpdateEdgeWeightService.__proto__ || Object.getPrototypeOf(UpdateEdgeWeightService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.UpdateEdgeWeightService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(UpdateEdgeWeightService, [{
        key: 'destroy',
        value: function destroy() {
            _get(UpdateEdgeWeightService.prototype.__proto__ || Object.getPrototypeOf(UpdateEdgeWeightService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.UpdateEdgeWeightService.prototype.processAsync
         * @description 开始异步执行边的边的耗费权重的更新
         * @param params - {SuperMap.UpdateEdgeWeightParameters} 边的耗费权重更新服务参数类
         * @example
         * (code)
         *  var updateEdgeWeightParam=new SuperMapUpdateEdgeWeightParameters({
         *          edgeId:"20"
         *          fromNodeId:"26"
         *          toNodeId:"109"
         *          weightField:"time"
         *          edgeWeight:"25"
         *      });
         *  updateEdgeWeightService.processAsync(updateEdgeWeightParam);
         * (end)
         */

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _UpdateEdgeWeightParameters.UpdateEdgeWeightParameters)) {
                return;
            }

            var me = this,
                end = me.url.substr(me.url.length - 1, 1);
            var paramStr = me.parse(params);
            if (end === "/") {
                me.url.splice(me.url.length - 1, 1);
            }
            me.url = me.url + paramStr + ".json?";
            var data = params.edgeWeight ? params.edgeWeight : null;
            me.request({
                method: "PUT",
                scope: me,
                data: data,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: parse
         * 将更新服务参数解析为用‘/’做分隔的字符串
         */

    }, {
        key: 'parse',
        value: function parse(params) {
            if (!params) {
                return;
            }
            var paramStr = "";
            for (var attr in params) {
                if (params[attr] === "" || params[attr] === "edgeWeight") {
                    continue;
                }
                switch (attr) {
                    case "edgeId":
                        paramStr += "/edgeweight/" + params[attr];
                        break;
                    case "fromNodeId":
                        paramStr += "/fromnode/" + params[attr];
                        break;
                    case "toNodeId":
                        paramStr += "/tonode/" + params[attr];
                        break;
                    case "weightField":
                        paramStr += "/weightfield/" + params[attr];
                        break;
                    default:
                        break;
                }
            }
            return paramStr;
        }
    }]);

    return UpdateEdgeWeightService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.UpdateEdgeWeightService = UpdateEdgeWeightService;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UpdateTurnNodeWeightService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _NetworkAnalystServiceBase = __webpack_require__(15);

var _UpdateTurnNodeWeightParameters = __webpack_require__(253);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.UpdateTurnNodeWeightService
 * @classdesc 转向耗费权重更新服务类
 * @extends SuperMap.NetworkAnalystServiceBase
 * @example
 * var UpdateTurnNodeWeightService = new SuperMap.UpdateTurnNodeWeightService(url, {
 *     eventListeners: {
 *         "processCompleted": UpdateTurnNodeWeightCompleted,    //参数为SuperMap.UpdateTurnNodeWeightEventArgs
 *		   "processFailed": UpdateTurnNodeWeightError          //参数为SuperMap.ServiceFailedEventArgs
 *		   }
 * });
 * @param url - {string} 服务的访问地址。如:<br>
 *                       http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param options - {Object} 互服务时所需可选参数。如：<br>
 *         eventListeners - {Object} 需要被注册的监听器对象。
 */
var UpdateTurnNodeWeightService = exports.UpdateTurnNodeWeightService = function (_NetworkAnalystServic) {
    _inherits(UpdateTurnNodeWeightService, _NetworkAnalystServic);

    function UpdateTurnNodeWeightService(url, options) {
        _classCallCheck(this, UpdateTurnNodeWeightService);

        var _this = _possibleConstructorReturn(this, (UpdateTurnNodeWeightService.__proto__ || Object.getPrototypeOf(UpdateTurnNodeWeightService)).call(this, url, options));

        _this.CLASS_NAME = "SuperMap.UpdateTurnNodeWeightService";
        return _this;
    }

    /**
     * @override
     */


    _createClass(UpdateTurnNodeWeightService, [{
        key: 'destroy',
        value: function destroy() {
            _get(UpdateTurnNodeWeightService.prototype.__proto__ || Object.getPrototypeOf(UpdateTurnNodeWeightService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.UpdateTurnNodeWeightService.prototype.processAsync
         * @description 开始异步执行转向耗费权重的更新
         * @param params - {SuperMap.UpdateTurnNodeWeightParameters} 转向耗费权重更新服务参数类
         * @example
         * (code)
         *  var updateTurnNodeWeightParam=new SuperMap.UpdateTurnNodeWeightParameters({
         *           nodeId:"106"
         *           fromEdgeId:"6508"
         *           toEdgeId:"6504"
         *           weightField:"TurnCost"
         *           turnNodeWeight:"50"
         *       });
         *  updateTurnNodeWeightService.processAsync(updateTurnNodeWeightParam);
         * (end)
         **/

    }, {
        key: 'processAsync',
        value: function processAsync(params) {
            if (!(params instanceof _UpdateTurnNodeWeightParameters.UpdateTurnNodeWeightParameters)) {
                return;
            }

            var me = this,
                end = me.url.substr(me.url.length - 1, 1);
            var paramStr = me.parse(params);
            if (end === "/") {
                me.url.splice(me.url.length - 1, 1);
            }
            me.url = me.url + paramStr + ".json?";
            var data = params.turnNodeWeight ? params.turnNodeWeight : null;
            me.request({
                method: "PUT",
                scope: me,
                data: data,
                success: me.serviceProcessCompleted,
                failure: me.serviceProcessFailed
            });
        }

        /*
         * Method: parse
         * 将更新服务参数解析为用‘/’做分隔的字符串
         * */

    }, {
        key: 'parse',
        value: function parse(params) {
            if (!params) {
                return;
            }
            var paramStr = "";
            for (var attr in params) {
                if (params[attr] === "" || params[attr] === "turnNodeWeight") {
                    continue;
                }
                switch (attr) {
                    case "nodeId":
                        paramStr += "/turnnodeweight/" + params[attr];
                        break;
                    case "fromEdgeId":
                        paramStr += "/fromedge/" + params[attr];
                        break;
                    case "toEdgeId":
                        paramStr += "/toedge/" + params[attr];
                        break;
                    case "weightField":
                        paramStr += "/weightfield/" + params[attr];
                        break;
                    default:
                        break;
                }
            }
            return paramStr;
        }
    }]);

    return UpdateTurnNodeWeightService;
}(_NetworkAnalystServiceBase.NetworkAnalystServiceBase);

_SuperMap.SuperMap.UpdateTurnNodeWeightService = UpdateTurnNodeWeightService;

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorClipJobsService = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ProcessingServiceBase = __webpack_require__(19);

var _VectorClipJobsParameter = __webpack_require__(255);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.VectorClipJobsService
 * @classdesc 矢量裁剪分析服务类
 * @extends SuperMap.ProcessingServiceBase
 * @param url -{string} 矢量裁剪分析服务地址。
 * @param options - {Object} 交互服务时所需可选参数。
 */
var VectorClipJobsService = exports.VectorClipJobsService = function (_ProcessingServiceBas) {
    _inherits(VectorClipJobsService, _ProcessingServiceBas);

    function VectorClipJobsService(url, options) {
        _classCallCheck(this, VectorClipJobsService);

        var _this = _possibleConstructorReturn(this, (VectorClipJobsService.__proto__ || Object.getPrototypeOf(VectorClipJobsService)).call(this, url, options));

        _this.url += "/spatialanalyst/vectorclip";
        _this.CLASS_NAME = "SuperMap.VectorClipJobsService";
        return _this;
    }

    /**
     *@override
     */


    _createClass(VectorClipJobsService, [{
        key: 'destroy',
        value: function destroy() {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.VectorClipJobsService.protitype.getVectorClipJobs
         * @description 获取矢量裁剪分析所有任务
         */

    }, {
        key: 'getVectorClipJobs',
        value: function getVectorClipJobs() {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'getJobs', this).call(this, this.url);
        }

        /**
         * @function SuperMap.KernelDensityJobsService.protitype.getVectorClipJob
         * @description 获取指定id的矢量裁剪分析服务
         * @param id -{string} 指定要获取数据的id
         */

    }, {
        key: 'getVectorClipJob',
        value: function getVectorClipJob(id) {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'getJobs', this).call(this, this.url + '/' + id);
        }

        /**
         * @function SuperMap.VectorClipJobsService.protitype.addVectorClipJob
         * @description 新建矢量裁剪分析服务
         * @param params - {SuperMap.VectorClipJobsParameter} 创建一个空间分析的请求参数。
         * @param seconds - {number}开始创建后，获取创建成功结果的时间间隔。
         */

    }, {
        key: 'addVectorClipJob',
        value: function addVectorClipJob(params, seconds) {
            _get(VectorClipJobsService.prototype.__proto__ || Object.getPrototypeOf(VectorClipJobsService.prototype), 'addJob', this).call(this, this.url, params, _VectorClipJobsParameter.VectorClipJobsParameter, seconds);
        }
    }]);

    return VectorClipJobsService;
}(_ProcessingServiceBase.ProcessingServiceBase);

_SuperMap.SuperMap.VectorClipJobsService = VectorClipJobsService;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _AddressMatchService = __webpack_require__(344);

Object.defineProperty(exports, 'AddressMatchService', {
  enumerable: true,
  get: function get() {
    return _AddressMatchService.AddressMatchService;
  }
});

var _AreaSolarRadiationParameters = __webpack_require__(150);

Object.defineProperty(exports, 'AreaSolarRadiationParameters', {
  enumerable: true,
  get: function get() {
    return _AreaSolarRadiationParameters.AreaSolarRadiationParameters;
  }
});

var _AreaSolarRadiationService = __webpack_require__(345);

Object.defineProperty(exports, 'AreaSolarRadiationService', {
  enumerable: true,
  get: function get() {
    return _AreaSolarRadiationService.AreaSolarRadiationService;
  }
});

var _BufferAnalystParameters = __webpack_require__(94);

Object.defineProperty(exports, 'BufferAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _BufferAnalystParameters.BufferAnalystParameters;
  }
});

var _BufferAnalystService = __webpack_require__(346);

Object.defineProperty(exports, 'BufferAnalystService', {
  enumerable: true,
  get: function get() {
    return _BufferAnalystService.BufferAnalystService;
  }
});

var _BufferDistance = __webpack_require__(151);

Object.defineProperty(exports, 'BufferDistance', {
  enumerable: true,
  get: function get() {
    return _BufferDistance.BufferDistance;
  }
});

var _BuffersAnalystJobsParameter = __webpack_require__(153);

Object.defineProperty(exports, 'BuffersAnalystJobsParameter', {
  enumerable: true,
  get: function get() {
    return _BuffersAnalystJobsParameter.BuffersAnalystJobsParameter;
  }
});

var _BuffersAnalystJobsService = __webpack_require__(347);

Object.defineProperty(exports, 'BuffersAnalystJobsService', {
  enumerable: true,
  get: function get() {
    return _BuffersAnalystJobsService.BuffersAnalystJobsService;
  }
});

var _BufferSetting = __webpack_require__(152);

Object.defineProperty(exports, 'BufferSetting', {
  enumerable: true,
  get: function get() {
    return _BufferSetting.BufferSetting;
  }
});

var _BurstPipelineAnalystParameters = __webpack_require__(154);

Object.defineProperty(exports, 'BurstPipelineAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _BurstPipelineAnalystParameters.BurstPipelineAnalystParameters;
  }
});

var _BurstPipelineAnalystService = __webpack_require__(348);

Object.defineProperty(exports, 'BurstPipelineAnalystService', {
  enumerable: true,
  get: function get() {
    return _BurstPipelineAnalystService.BurstPipelineAnalystService;
  }
});

var _ChartFeatureInfoSpecsService = __webpack_require__(349);

Object.defineProperty(exports, 'ChartFeatureInfoSpecsService', {
  enumerable: true,
  get: function get() {
    return _ChartFeatureInfoSpecsService.ChartFeatureInfoSpecsService;
  }
});

var _ChartQueryFilterParameter = __webpack_require__(155);

Object.defineProperty(exports, 'ChartQueryFilterParameter', {
  enumerable: true,
  get: function get() {
    return _ChartQueryFilterParameter.ChartQueryFilterParameter;
  }
});

var _ChartQueryParameters = __webpack_require__(156);

Object.defineProperty(exports, 'ChartQueryParameters', {
  enumerable: true,
  get: function get() {
    return _ChartQueryParameters.ChartQueryParameters;
  }
});

var _ChartQueryService = __webpack_require__(350);

Object.defineProperty(exports, 'ChartQueryService', {
  enumerable: true,
  get: function get() {
    return _ChartQueryService.ChartQueryService;
  }
});

var _ClipParameter = __webpack_require__(157);

Object.defineProperty(exports, 'ClipParameter', {
  enumerable: true,
  get: function get() {
    return _ClipParameter.ClipParameter;
  }
});

var _ColorDictionary = __webpack_require__(158);

Object.defineProperty(exports, 'ColorDictionary', {
  enumerable: true,
  get: function get() {
    return _ColorDictionary.ColorDictionary;
  }
});

var _CommonServiceBase = __webpack_require__(6);

Object.defineProperty(exports, 'CommonServiceBase', {
  enumerable: true,
  get: function get() {
    return _CommonServiceBase.CommonServiceBase;
  }
});

var _ComputeWeightMatrixParameters = __webpack_require__(159);

Object.defineProperty(exports, 'ComputeWeightMatrixParameters', {
  enumerable: true,
  get: function get() {
    return _ComputeWeightMatrixParameters.ComputeWeightMatrixParameters;
  }
});

var _ComputeWeightMatrixService = __webpack_require__(351);

Object.defineProperty(exports, 'ComputeWeightMatrixService', {
  enumerable: true,
  get: function get() {
    return _ComputeWeightMatrixService.ComputeWeightMatrixService;
  }
});

var _DataFlowService = __webpack_require__(352);

Object.defineProperty(exports, 'DataFlowService', {
  enumerable: true,
  get: function get() {
    return _DataFlowService.DataFlowService;
  }
});

var _DataReturnOption = __webpack_require__(50);

Object.defineProperty(exports, 'DataReturnOption', {
  enumerable: true,
  get: function get() {
    return _DataReturnOption.DataReturnOption;
  }
});

var _DatasetBufferAnalystParameters = __webpack_require__(160);

Object.defineProperty(exports, 'DatasetBufferAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _DatasetBufferAnalystParameters.DatasetBufferAnalystParameters;
  }
});

var _DatasetInfo = __webpack_require__(161);

Object.defineProperty(exports, 'DatasetInfo', {
  enumerable: true,
  get: function get() {
    return _DatasetInfo.DatasetInfo;
  }
});

var _DatasetOverlayAnalystParameters = __webpack_require__(162);

Object.defineProperty(exports, 'DatasetOverlayAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _DatasetOverlayAnalystParameters.DatasetOverlayAnalystParameters;
  }
});

var _DatasetSurfaceAnalystParameters = __webpack_require__(163);

Object.defineProperty(exports, 'DatasetSurfaceAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _DatasetSurfaceAnalystParameters.DatasetSurfaceAnalystParameters;
  }
});

var _DatasetThiessenAnalystParameters = __webpack_require__(164);

Object.defineProperty(exports, 'DatasetThiessenAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _DatasetThiessenAnalystParameters.DatasetThiessenAnalystParameters;
  }
});

var _DatasourceConnectionInfo = __webpack_require__(165);

Object.defineProperty(exports, 'DatasourceConnectionInfo', {
  enumerable: true,
  get: function get() {
    return _DatasourceConnectionInfo.DatasourceConnectionInfo;
  }
});

var _DensityAnalystService = __webpack_require__(353);

Object.defineProperty(exports, 'DensityAnalystService', {
  enumerable: true,
  get: function get() {
    return _DensityAnalystService.DensityAnalystService;
  }
});

var _DensityKernelAnalystParameters = __webpack_require__(166);

Object.defineProperty(exports, 'DensityKernelAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _DensityKernelAnalystParameters.DensityKernelAnalystParameters;
  }
});

var _EditFeaturesParameters = __webpack_require__(167);

Object.defineProperty(exports, 'EditFeaturesParameters', {
  enumerable: true,
  get: function get() {
    return _EditFeaturesParameters.EditFeaturesParameters;
  }
});

var _EditFeaturesService = __webpack_require__(354);

Object.defineProperty(exports, 'EditFeaturesService', {
  enumerable: true,
  get: function get() {
    return _EditFeaturesService.EditFeaturesService;
  }
});

var _FacilityAnalyst3DParameters = __webpack_require__(39);

Object.defineProperty(exports, 'FacilityAnalyst3DParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalyst3DParameters.FacilityAnalyst3DParameters;
  }
});

var _FacilityAnalystSinks3DParameters = __webpack_require__(168);

Object.defineProperty(exports, 'FacilityAnalystSinks3DParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystSinks3DParameters.FacilityAnalystSinks3DParameters;
  }
});

var _FacilityAnalystSinks3DService = __webpack_require__(355);

Object.defineProperty(exports, 'FacilityAnalystSinks3DService', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystSinks3DService.FacilityAnalystSinks3DService;
  }
});

var _FacilityAnalystSources3DParameters = __webpack_require__(169);

Object.defineProperty(exports, 'FacilityAnalystSources3DParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystSources3DParameters.FacilityAnalystSources3DParameters;
  }
});

var _FacilityAnalystSources3DService = __webpack_require__(356);

Object.defineProperty(exports, 'FacilityAnalystSources3DService', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystSources3DService.FacilityAnalystSources3DService;
  }
});

var _FacilityAnalystStreamParameters = __webpack_require__(170);

Object.defineProperty(exports, 'FacilityAnalystStreamParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystStreamParameters.FacilityAnalystStreamParameters;
  }
});

var _FacilityAnalystStreamService = __webpack_require__(357);

Object.defineProperty(exports, 'FacilityAnalystStreamService', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystStreamService.FacilityAnalystStreamService;
  }
});

var _FacilityAnalystTracedown3DParameters = __webpack_require__(171);

Object.defineProperty(exports, 'FacilityAnalystTracedown3DParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystTracedown3DParameters.FacilityAnalystTracedown3DParameters;
  }
});

var _FacilityAnalystTracedown3DService = __webpack_require__(358);

Object.defineProperty(exports, 'FacilityAnalystTracedown3DService', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystTracedown3DService.FacilityAnalystTracedown3DService;
  }
});

var _FacilityAnalystTraceup3DParameters = __webpack_require__(172);

Object.defineProperty(exports, 'FacilityAnalystTraceup3DParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystTraceup3DParameters.FacilityAnalystTraceup3DParameters;
  }
});

var _FacilityAnalystTraceup3DService = __webpack_require__(359);

Object.defineProperty(exports, 'FacilityAnalystTraceup3DService', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystTraceup3DService.FacilityAnalystTraceup3DService;
  }
});

var _FacilityAnalystUpstream3DParameters = __webpack_require__(173);

Object.defineProperty(exports, 'FacilityAnalystUpstream3DParameters', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystUpstream3DParameters.FacilityAnalystUpstream3DParameters;
  }
});

var _FacilityAnalystUpstream3DService = __webpack_require__(360);

Object.defineProperty(exports, 'FacilityAnalystUpstream3DService', {
  enumerable: true,
  get: function get() {
    return _FacilityAnalystUpstream3DService.FacilityAnalystUpstream3DService;
  }
});

var _FieldParameters = __webpack_require__(174);

Object.defineProperty(exports, 'FieldParameters', {
  enumerable: true,
  get: function get() {
    return _FieldParameters.FieldParameters;
  }
});

var _FieldStatisticService = __webpack_require__(361);

Object.defineProperty(exports, 'FieldStatisticService', {
  enumerable: true,
  get: function get() {
    return _FieldStatisticService.FieldStatisticService;
  }
});

var _FieldStatisticsParameters = __webpack_require__(175);

Object.defineProperty(exports, 'FieldStatisticsParameters', {
  enumerable: true,
  get: function get() {
    return _FieldStatisticsParameters.FieldStatisticsParameters;
  }
});

var _FilterParameter = __webpack_require__(16);

Object.defineProperty(exports, 'FilterParameter', {
  enumerable: true,
  get: function get() {
    return _FilterParameter.FilterParameter;
  }
});

var _FindClosestFacilitiesParameters = __webpack_require__(176);

Object.defineProperty(exports, 'FindClosestFacilitiesParameters', {
  enumerable: true,
  get: function get() {
    return _FindClosestFacilitiesParameters.FindClosestFacilitiesParameters;
  }
});

var _FindClosestFacilitiesService = __webpack_require__(362);

Object.defineProperty(exports, 'FindClosestFacilitiesService', {
  enumerable: true,
  get: function get() {
    return _FindClosestFacilitiesService.FindClosestFacilitiesService;
  }
});

var _FindLocationParameters = __webpack_require__(177);

Object.defineProperty(exports, 'FindLocationParameters', {
  enumerable: true,
  get: function get() {
    return _FindLocationParameters.FindLocationParameters;
  }
});

var _FindLocationService = __webpack_require__(363);

Object.defineProperty(exports, 'FindLocationService', {
  enumerable: true,
  get: function get() {
    return _FindLocationService.FindLocationService;
  }
});

var _FindMTSPPathsParameters = __webpack_require__(178);

Object.defineProperty(exports, 'FindMTSPPathsParameters', {
  enumerable: true,
  get: function get() {
    return _FindMTSPPathsParameters.FindMTSPPathsParameters;
  }
});

var _FindMTSPPathsService = __webpack_require__(364);

Object.defineProperty(exports, 'FindMTSPPathsService', {
  enumerable: true,
  get: function get() {
    return _FindMTSPPathsService.FindMTSPPathsService;
  }
});

var _FindPathParameters = __webpack_require__(179);

Object.defineProperty(exports, 'FindPathParameters', {
  enumerable: true,
  get: function get() {
    return _FindPathParameters.FindPathParameters;
  }
});

var _FindPathService = __webpack_require__(365);

Object.defineProperty(exports, 'FindPathService', {
  enumerable: true,
  get: function get() {
    return _FindPathService.FindPathService;
  }
});

var _FindServiceAreasParameters = __webpack_require__(180);

Object.defineProperty(exports, 'FindServiceAreasParameters', {
  enumerable: true,
  get: function get() {
    return _FindServiceAreasParameters.FindServiceAreasParameters;
  }
});

var _FindServiceAreasService = __webpack_require__(366);

Object.defineProperty(exports, 'FindServiceAreasService', {
  enumerable: true,
  get: function get() {
    return _FindServiceAreasService.FindServiceAreasService;
  }
});

var _FindTSPPathsParameters = __webpack_require__(181);

Object.defineProperty(exports, 'FindTSPPathsParameters', {
  enumerable: true,
  get: function get() {
    return _FindTSPPathsParameters.FindTSPPathsParameters;
  }
});

var _FindTSPPathsService = __webpack_require__(367);

Object.defineProperty(exports, 'FindTSPPathsService', {
  enumerable: true,
  get: function get() {
    return _FindTSPPathsService.FindTSPPathsService;
  }
});

var _GenerateSpatialDataParameters = __webpack_require__(182);

Object.defineProperty(exports, 'GenerateSpatialDataParameters', {
  enumerable: true,
  get: function get() {
    return _GenerateSpatialDataParameters.GenerateSpatialDataParameters;
  }
});

var _GenerateSpatialDataService = __webpack_require__(368);

Object.defineProperty(exports, 'GenerateSpatialDataService', {
  enumerable: true,
  get: function get() {
    return _GenerateSpatialDataService.GenerateSpatialDataService;
  }
});

var _GeoCodingParameter = __webpack_require__(183);

Object.defineProperty(exports, 'GeoCodingParameter', {
  enumerable: true,
  get: function get() {
    return _GeoCodingParameter.GeoCodingParameter;
  }
});

var _GeoDecodingParameter = __webpack_require__(184);

Object.defineProperty(exports, 'GeoDecodingParameter', {
  enumerable: true,
  get: function get() {
    return _GeoDecodingParameter.GeoDecodingParameter;
  }
});

var _GeometryBufferAnalystParameters = __webpack_require__(186);

Object.defineProperty(exports, 'GeometryBufferAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _GeometryBufferAnalystParameters.GeometryBufferAnalystParameters;
  }
});

var _GeometryOverlayAnalystParameters = __webpack_require__(187);

Object.defineProperty(exports, 'GeometryOverlayAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _GeometryOverlayAnalystParameters.GeometryOverlayAnalystParameters;
  }
});

var _GeometrySurfaceAnalystParameters = __webpack_require__(188);

Object.defineProperty(exports, 'GeometrySurfaceAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _GeometrySurfaceAnalystParameters.GeometrySurfaceAnalystParameters;
  }
});

var _GeometryThiessenAnalystParameters = __webpack_require__(189);

Object.defineProperty(exports, 'GeometryThiessenAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _GeometryThiessenAnalystParameters.GeometryThiessenAnalystParameters;
  }
});

var _GeoRelationAnalystParameters = __webpack_require__(185);

Object.defineProperty(exports, 'GeoRelationAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _GeoRelationAnalystParameters.GeoRelationAnalystParameters;
  }
});

var _GeoRelationAnalystService = __webpack_require__(369);

Object.defineProperty(exports, 'GeoRelationAnalystService', {
  enumerable: true,
  get: function get() {
    return _GeoRelationAnalystService.GeoRelationAnalystService;
  }
});

var _GetFeaturesByBoundsParameters = __webpack_require__(190);

Object.defineProperty(exports, 'GetFeaturesByBoundsParameters', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByBoundsParameters.GetFeaturesByBoundsParameters;
  }
});

var _GetFeaturesByBoundsService = __webpack_require__(370);

Object.defineProperty(exports, 'GetFeaturesByBoundsService', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByBoundsService.GetFeaturesByBoundsService;
  }
});

var _GetFeaturesByBufferParameters = __webpack_require__(191);

Object.defineProperty(exports, 'GetFeaturesByBufferParameters', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByBufferParameters.GetFeaturesByBufferParameters;
  }
});

var _GetFeaturesByBufferService = __webpack_require__(371);

Object.defineProperty(exports, 'GetFeaturesByBufferService', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByBufferService.GetFeaturesByBufferService;
  }
});

var _GetFeaturesByGeometryParameters = __webpack_require__(192);

Object.defineProperty(exports, 'GetFeaturesByGeometryParameters', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByGeometryParameters.GetFeaturesByGeometryParameters;
  }
});

var _GetFeaturesByGeometryService = __webpack_require__(372);

Object.defineProperty(exports, 'GetFeaturesByGeometryService', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByGeometryService.GetFeaturesByGeometryService;
  }
});

var _GetFeaturesByIDsParameters = __webpack_require__(193);

Object.defineProperty(exports, 'GetFeaturesByIDsParameters', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByIDsParameters.GetFeaturesByIDsParameters;
  }
});

var _GetFeaturesByIDsService = __webpack_require__(373);

Object.defineProperty(exports, 'GetFeaturesByIDsService', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesByIDsService.GetFeaturesByIDsService;
  }
});

var _GetFeaturesBySQLParameters = __webpack_require__(194);

Object.defineProperty(exports, 'GetFeaturesBySQLParameters', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesBySQLParameters.GetFeaturesBySQLParameters;
  }
});

var _GetFeaturesBySQLService = __webpack_require__(374);

Object.defineProperty(exports, 'GetFeaturesBySQLService', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesBySQLService.GetFeaturesBySQLService;
  }
});

var _GetFeaturesParametersBase = __webpack_require__(40);

Object.defineProperty(exports, 'GetFeaturesParametersBase', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesParametersBase.GetFeaturesParametersBase;
  }
});

var _GetFeaturesServiceBase = __webpack_require__(41);

Object.defineProperty(exports, 'GetFeaturesServiceBase', {
  enumerable: true,
  get: function get() {
    return _GetFeaturesServiceBase.GetFeaturesServiceBase;
  }
});

var _GetFieldsService = __webpack_require__(375);

Object.defineProperty(exports, 'GetFieldsService', {
  enumerable: true,
  get: function get() {
    return _GetFieldsService.GetFieldsService;
  }
});

var _GetGridCellInfosParameters = __webpack_require__(195);

Object.defineProperty(exports, 'GetGridCellInfosParameters', {
  enumerable: true,
  get: function get() {
    return _GetGridCellInfosParameters.GetGridCellInfosParameters;
  }
});

var _GetGridCellInfosService = __webpack_require__(376);

Object.defineProperty(exports, 'GetGridCellInfosService', {
  enumerable: true,
  get: function get() {
    return _GetGridCellInfosService.GetGridCellInfosService;
  }
});

var _GetLayersInfoService = __webpack_require__(377);

Object.defineProperty(exports, 'GetLayersInfoService', {
  enumerable: true,
  get: function get() {
    return _GetLayersInfoService.GetLayersInfoService;
  }
});

var _Grid = __webpack_require__(196);

Object.defineProperty(exports, 'Grid', {
  enumerable: true,
  get: function get() {
    return _Grid.Grid;
  }
});

var _Image = __webpack_require__(197);

Object.defineProperty(exports, 'UGCImage', {
  enumerable: true,
  get: function get() {
    return _Image.UGCImage;
  }
});

var _InterpolationAnalystParameters = __webpack_require__(42);

Object.defineProperty(exports, 'InterpolationAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _InterpolationAnalystParameters.InterpolationAnalystParameters;
  }
});

var _InterpolationAnalystService = __webpack_require__(378);

Object.defineProperty(exports, 'InterpolationAnalystService', {
  enumerable: true,
  get: function get() {
    return _InterpolationAnalystService.InterpolationAnalystService;
  }
});

var _InterpolationIDWAnalystParameters = __webpack_require__(198);

Object.defineProperty(exports, 'InterpolationIDWAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _InterpolationIDWAnalystParameters.InterpolationIDWAnalystParameters;
  }
});

var _InterpolationKrigingAnalystParameters = __webpack_require__(199);

Object.defineProperty(exports, 'InterpolationKrigingAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _InterpolationKrigingAnalystParameters.InterpolationKrigingAnalystParameters;
  }
});

var _InterpolationRBFAnalystParameters = __webpack_require__(200);

Object.defineProperty(exports, 'InterpolationRBFAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _InterpolationRBFAnalystParameters.InterpolationRBFAnalystParameters;
  }
});

var _JoinItem = __webpack_require__(66);

Object.defineProperty(exports, 'JoinItem', {
  enumerable: true,
  get: function get() {
    return _JoinItem.JoinItem;
  }
});

var _KernelDensityJobParameter = __webpack_require__(201);

Object.defineProperty(exports, 'KernelDensityJobParameter', {
  enumerable: true,
  get: function get() {
    return _KernelDensityJobParameter.KernelDensityJobParameter;
  }
});

var _KernelDensityJobsService = __webpack_require__(380);

Object.defineProperty(exports, 'KernelDensityJobsService', {
  enumerable: true,
  get: function get() {
    return _KernelDensityJobsService.KernelDensityJobsService;
  }
});

var _LabelImageCell = __webpack_require__(202);

Object.defineProperty(exports, 'LabelImageCell', {
  enumerable: true,
  get: function get() {
    return _LabelImageCell.LabelImageCell;
  }
});

var _LabelMatrixCell = __webpack_require__(67);

Object.defineProperty(exports, 'LabelMatrixCell', {
  enumerable: true,
  get: function get() {
    return _LabelMatrixCell.LabelMatrixCell;
  }
});

var _LabelMixedTextStyle = __webpack_require__(203);

Object.defineProperty(exports, 'LabelMixedTextStyle', {
  enumerable: true,
  get: function get() {
    return _LabelMixedTextStyle.LabelMixedTextStyle;
  }
});

var _LabelSymbolCell = __webpack_require__(204);

Object.defineProperty(exports, 'LabelSymbolCell', {
  enumerable: true,
  get: function get() {
    return _LabelSymbolCell.LabelSymbolCell;
  }
});

var _LabelThemeCell = __webpack_require__(205);

Object.defineProperty(exports, 'LabelThemeCell', {
  enumerable: true,
  get: function get() {
    return _LabelThemeCell.LabelThemeCell;
  }
});

var _LayerStatus = __webpack_require__(206);

Object.defineProperty(exports, 'LayerStatus', {
  enumerable: true,
  get: function get() {
    return _LayerStatus.LayerStatus;
  }
});

var _LinkItem = __webpack_require__(207);

Object.defineProperty(exports, 'LinkItem', {
  enumerable: true,
  get: function get() {
    return _LinkItem.LinkItem;
  }
});

var _MapService = __webpack_require__(381);

Object.defineProperty(exports, 'MapService', {
  enumerable: true,
  get: function get() {
    return _MapService.MapService;
  }
});

var _MathExpressionAnalysisParameters = __webpack_require__(208);

Object.defineProperty(exports, 'MathExpressionAnalysisParameters', {
  enumerable: true,
  get: function get() {
    return _MathExpressionAnalysisParameters.MathExpressionAnalysisParameters;
  }
});

var _MathExpressionAnalysisService = __webpack_require__(382);

Object.defineProperty(exports, 'MathExpressionAnalysisService', {
  enumerable: true,
  get: function get() {
    return _MathExpressionAnalysisService.MathExpressionAnalysisService;
  }
});

var _MeasureParameters = __webpack_require__(209);

Object.defineProperty(exports, 'MeasureParameters', {
  enumerable: true,
  get: function get() {
    return _MeasureParameters.MeasureParameters;
  }
});

var _MeasureService = __webpack_require__(383);

Object.defineProperty(exports, 'MeasureService', {
  enumerable: true,
  get: function get() {
    return _MeasureService.MeasureService;
  }
});

var _NetworkAnalystServiceBase = __webpack_require__(15);

Object.defineProperty(exports, 'NetworkAnalystServiceBase', {
  enumerable: true,
  get: function get() {
    return _NetworkAnalystServiceBase.NetworkAnalystServiceBase;
  }
});

var _OverlapDisplayedOptions = __webpack_require__(210);

Object.defineProperty(exports, 'OverlapDisplayedOptions', {
  enumerable: true,
  get: function get() {
    return _OverlapDisplayedOptions.OverlapDisplayedOptions;
  }
});

var _OverlayAnalystParameters = __webpack_require__(95);

Object.defineProperty(exports, 'OverlayAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _OverlayAnalystParameters.OverlayAnalystParameters;
  }
});

var _OverlayAnalystService = __webpack_require__(384);

Object.defineProperty(exports, 'OverlayAnalystService', {
  enumerable: true,
  get: function get() {
    return _OverlayAnalystService.OverlayAnalystService;
  }
});

var _OverlayGeoJobParameter = __webpack_require__(211);

Object.defineProperty(exports, 'OverlayGeoJobParameter', {
  enumerable: true,
  get: function get() {
    return _OverlayGeoJobParameter.OverlayGeoJobParameter;
  }
});

var _OverlayGeoJobsService = __webpack_require__(385);

Object.defineProperty(exports, 'OverlayGeoJobsService', {
  enumerable: true,
  get: function get() {
    return _OverlayGeoJobsService.OverlayGeoJobsService;
  }
});

var _PointWithMeasure = __webpack_require__(212);

Object.defineProperty(exports, 'PointWithMeasure', {
  enumerable: true,
  get: function get() {
    return _PointWithMeasure.PointWithMeasure;
  }
});

var _ProcessingServiceBase = __webpack_require__(19);

Object.defineProperty(exports, 'ProcessingServiceBase', {
  enumerable: true,
  get: function get() {
    return _ProcessingServiceBase.ProcessingServiceBase;
  }
});

var _QueryByBoundsParameters = __webpack_require__(213);

Object.defineProperty(exports, 'QueryByBoundsParameters', {
  enumerable: true,
  get: function get() {
    return _QueryByBoundsParameters.QueryByBoundsParameters;
  }
});

var _QueryByBoundsService = __webpack_require__(386);

Object.defineProperty(exports, 'QueryByBoundsService', {
  enumerable: true,
  get: function get() {
    return _QueryByBoundsService.QueryByBoundsService;
  }
});

var _QueryByDistanceParameters = __webpack_require__(214);

Object.defineProperty(exports, 'QueryByDistanceParameters', {
  enumerable: true,
  get: function get() {
    return _QueryByDistanceParameters.QueryByDistanceParameters;
  }
});

var _QueryByDistanceService = __webpack_require__(387);

Object.defineProperty(exports, 'QueryByDistanceService', {
  enumerable: true,
  get: function get() {
    return _QueryByDistanceService.QueryByDistanceService;
  }
});

var _QueryByGeometryParameters = __webpack_require__(215);

Object.defineProperty(exports, 'QueryByGeometryParameters', {
  enumerable: true,
  get: function get() {
    return _QueryByGeometryParameters.QueryByGeometryParameters;
  }
});

var _QueryByGeometryService = __webpack_require__(388);

Object.defineProperty(exports, 'QueryByGeometryService', {
  enumerable: true,
  get: function get() {
    return _QueryByGeometryService.QueryByGeometryService;
  }
});

var _QueryBySQLParameters = __webpack_require__(216);

Object.defineProperty(exports, 'QueryBySQLParameters', {
  enumerable: true,
  get: function get() {
    return _QueryBySQLParameters.QueryBySQLParameters;
  }
});

var _QueryBySQLService = __webpack_require__(389);

Object.defineProperty(exports, 'QueryBySQLService', {
  enumerable: true,
  get: function get() {
    return _QueryBySQLService.QueryBySQLService;
  }
});

var _QueryParameters = __webpack_require__(32);

Object.defineProperty(exports, 'QueryParameters', {
  enumerable: true,
  get: function get() {
    return _QueryParameters.QueryParameters;
  }
});

var _QueryService = __webpack_require__(51);

Object.defineProperty(exports, 'QueryService', {
  enumerable: true,
  get: function get() {
    return _QueryService.QueryService;
  }
});

var _Route = __webpack_require__(68);

Object.defineProperty(exports, 'Route', {
  enumerable: true,
  get: function get() {
    return _Route.Route;
  }
});

var _RouteCalculateMeasureParameters = __webpack_require__(217);

Object.defineProperty(exports, 'RouteCalculateMeasureParameters', {
  enumerable: true,
  get: function get() {
    return _RouteCalculateMeasureParameters.RouteCalculateMeasureParameters;
  }
});

var _RouteCalculateMeasureService = __webpack_require__(390);

Object.defineProperty(exports, 'RouteCalculateMeasureService', {
  enumerable: true,
  get: function get() {
    return _RouteCalculateMeasureService.RouteCalculateMeasureService;
  }
});

var _RouteLocatorParameters = __webpack_require__(218);

Object.defineProperty(exports, 'RouteLocatorParameters', {
  enumerable: true,
  get: function get() {
    return _RouteLocatorParameters.RouteLocatorParameters;
  }
});

var _RouteLocatorService = __webpack_require__(391);

Object.defineProperty(exports, 'RouteLocatorService', {
  enumerable: true,
  get: function get() {
    return _RouteLocatorService.RouteLocatorService;
  }
});

var _ServerColor = __webpack_require__(20);

Object.defineProperty(exports, 'ServerColor', {
  enumerable: true,
  get: function get() {
    return _ServerColor.ServerColor;
  }
});

var _ServerFeature = __webpack_require__(392);

Object.defineProperty(exports, 'ServerFeature', {
  enumerable: true,
  get: function get() {
    return _ServerFeature.ServerFeature;
  }
});

var _ServerGeometry = __webpack_require__(9);

Object.defineProperty(exports, 'ServerGeometry', {
  enumerable: true,
  get: function get() {
    return _ServerGeometry.ServerGeometry;
  }
});

var _ServerStyle = __webpack_require__(11);

Object.defineProperty(exports, 'ServerStyle', {
  enumerable: true,
  get: function get() {
    return _ServerStyle.ServerStyle;
  }
});

var _ServerTextStyle = __webpack_require__(33);

Object.defineProperty(exports, 'ServerTextStyle', {
  enumerable: true,
  get: function get() {
    return _ServerTextStyle.ServerTextStyle;
  }
});

var _ServerTheme = __webpack_require__(219);

Object.defineProperty(exports, 'ServerTheme', {
  enumerable: true,
  get: function get() {
    return _ServerTheme.ServerTheme;
  }
});

var _SetLayerInfoParameters = __webpack_require__(220);

Object.defineProperty(exports, 'SetLayerInfoParameters', {
  enumerable: true,
  get: function get() {
    return _SetLayerInfoParameters.SetLayerInfoParameters;
  }
});

var _SetLayerInfoService = __webpack_require__(393);

Object.defineProperty(exports, 'SetLayerInfoService', {
  enumerable: true,
  get: function get() {
    return _SetLayerInfoService.SetLayerInfoService;
  }
});

var _SetLayersInfoParameters = __webpack_require__(222);

Object.defineProperty(exports, 'SetLayersInfoParameters', {
  enumerable: true,
  get: function get() {
    return _SetLayersInfoParameters.SetLayersInfoParameters;
  }
});

var _SetLayersInfoService = __webpack_require__(395);

Object.defineProperty(exports, 'SetLayersInfoService', {
  enumerable: true,
  get: function get() {
    return _SetLayersInfoService.SetLayersInfoService;
  }
});

var _SetLayerStatusParameters = __webpack_require__(221);

Object.defineProperty(exports, 'SetLayerStatusParameters', {
  enumerable: true,
  get: function get() {
    return _SetLayerStatusParameters.SetLayerStatusParameters;
  }
});

var _SetLayerStatusService = __webpack_require__(394);

Object.defineProperty(exports, 'SetLayerStatusService', {
  enumerable: true,
  get: function get() {
    return _SetLayerStatusService.SetLayerStatusService;
  }
});

var _SingleObjectQueryJobsParameter = __webpack_require__(223);

Object.defineProperty(exports, 'SingleObjectQueryJobsParameter', {
  enumerable: true,
  get: function get() {
    return _SingleObjectQueryJobsParameter.SingleObjectQueryJobsParameter;
  }
});

var _SingleObjectQueryJobsService = __webpack_require__(396);

Object.defineProperty(exports, 'SingleObjectQueryJobsService', {
  enumerable: true,
  get: function get() {
    return _SingleObjectQueryJobsService.SingleObjectQueryJobsService;
  }
});

var _SpatialAnalystBase = __webpack_require__(10);

Object.defineProperty(exports, 'SpatialAnalystBase', {
  enumerable: true,
  get: function get() {
    return _SpatialAnalystBase.SpatialAnalystBase;
  }
});

var _StopQueryParameters = __webpack_require__(224);

Object.defineProperty(exports, 'StopQueryParameters', {
  enumerable: true,
  get: function get() {
    return _StopQueryParameters.StopQueryParameters;
  }
});

var _StopQueryService = __webpack_require__(397);

Object.defineProperty(exports, 'StopQueryService', {
  enumerable: true,
  get: function get() {
    return _StopQueryService.StopQueryService;
  }
});

var _SummaryAttributesJobsParameter = __webpack_require__(225);

Object.defineProperty(exports, 'SummaryAttributesJobsParameter', {
  enumerable: true,
  get: function get() {
    return _SummaryAttributesJobsParameter.SummaryAttributesJobsParameter;
  }
});

var _SummaryAttributesJobsService = __webpack_require__(398);

Object.defineProperty(exports, 'SummaryAttributesJobsService', {
  enumerable: true,
  get: function get() {
    return _SummaryAttributesJobsService.SummaryAttributesJobsService;
  }
});

var _SummaryMeshJobParameter = __webpack_require__(226);

Object.defineProperty(exports, 'SummaryMeshJobParameter', {
  enumerable: true,
  get: function get() {
    return _SummaryMeshJobParameter.SummaryMeshJobParameter;
  }
});

var _SummaryMeshJobsService = __webpack_require__(399);

Object.defineProperty(exports, 'SummaryMeshJobsService', {
  enumerable: true,
  get: function get() {
    return _SummaryMeshJobsService.SummaryMeshJobsService;
  }
});

var _SummaryRegionJobParameter = __webpack_require__(227);

Object.defineProperty(exports, 'SummaryRegionJobParameter', {
  enumerable: true,
  get: function get() {
    return _SummaryRegionJobParameter.SummaryRegionJobParameter;
  }
});

var _SummaryRegionJobsService = __webpack_require__(400);

Object.defineProperty(exports, 'SummaryRegionJobsService', {
  enumerable: true,
  get: function get() {
    return _SummaryRegionJobsService.SummaryRegionJobsService;
  }
});

var _SupplyCenter = __webpack_require__(401);

Object.defineProperty(exports, 'SupplyCenter', {
  enumerable: true,
  get: function get() {
    return _SupplyCenter.SupplyCenter;
  }
});

var _SurfaceAnalystParameters = __webpack_require__(69);

Object.defineProperty(exports, 'SurfaceAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _SurfaceAnalystParameters.SurfaceAnalystParameters;
  }
});

var _SurfaceAnalystParametersSetting = __webpack_require__(228);

Object.defineProperty(exports, 'SurfaceAnalystParametersSetting', {
  enumerable: true,
  get: function get() {
    return _SurfaceAnalystParametersSetting.SurfaceAnalystParametersSetting;
  }
});

var _SurfaceAnalystService = __webpack_require__(402);

Object.defineProperty(exports, 'SurfaceAnalystService', {
  enumerable: true,
  get: function get() {
    return _SurfaceAnalystService.SurfaceAnalystService;
  }
});

var _TerrainCurvatureCalculationParameters = __webpack_require__(229);

Object.defineProperty(exports, 'TerrainCurvatureCalculationParameters', {
  enumerable: true,
  get: function get() {
    return _TerrainCurvatureCalculationParameters.TerrainCurvatureCalculationParameters;
  }
});

var _TerrainCurvatureCalculationService = __webpack_require__(403);

Object.defineProperty(exports, 'TerrainCurvatureCalculationService', {
  enumerable: true,
  get: function get() {
    return _TerrainCurvatureCalculationService.TerrainCurvatureCalculationService;
  }
});

var _Theme = __webpack_require__(23);

Object.defineProperty(exports, 'Theme', {
  enumerable: true,
  get: function get() {
    return _Theme.Theme;
  }
});

var _ThemeDotDensity = __webpack_require__(96);

Object.defineProperty(exports, 'ThemeDotDensity', {
  enumerable: true,
  get: function get() {
    return _ThemeDotDensity.ThemeDotDensity;
  }
});

var _ThemeFlow = __webpack_require__(70);

Object.defineProperty(exports, 'ThemeFlow', {
  enumerable: true,
  get: function get() {
    return _ThemeFlow.ThemeFlow;
  }
});

var _ThemeGraduatedSymbol = __webpack_require__(97);

Object.defineProperty(exports, 'ThemeGraduatedSymbol', {
  enumerable: true,
  get: function get() {
    return _ThemeGraduatedSymbol.ThemeGraduatedSymbol;
  }
});

var _ThemeGraduatedSymbolStyle = __webpack_require__(230);

Object.defineProperty(exports, 'ThemeGraduatedSymbolStyle', {
  enumerable: true,
  get: function get() {
    return _ThemeGraduatedSymbolStyle.ThemeGraduatedSymbolStyle;
  }
});

var _ThemeGraph = __webpack_require__(98);

Object.defineProperty(exports, 'ThemeGraph', {
  enumerable: true,
  get: function get() {
    return _ThemeGraph.ThemeGraph;
  }
});

var _ThemeGraphAxes = __webpack_require__(231);

Object.defineProperty(exports, 'ThemeGraphAxes', {
  enumerable: true,
  get: function get() {
    return _ThemeGraphAxes.ThemeGraphAxes;
  }
});

var _ThemeGraphItem = __webpack_require__(232);

Object.defineProperty(exports, 'ThemeGraphItem', {
  enumerable: true,
  get: function get() {
    return _ThemeGraphItem.ThemeGraphItem;
  }
});

var _ThemeGraphSize = __webpack_require__(233);

Object.defineProperty(exports, 'ThemeGraphSize', {
  enumerable: true,
  get: function get() {
    return _ThemeGraphSize.ThemeGraphSize;
  }
});

var _ThemeGraphText = __webpack_require__(234);

Object.defineProperty(exports, 'ThemeGraphText', {
  enumerable: true,
  get: function get() {
    return _ThemeGraphText.ThemeGraphText;
  }
});

var _ThemeGridRange = __webpack_require__(235);

Object.defineProperty(exports, 'ThemeGridRange', {
  enumerable: true,
  get: function get() {
    return _ThemeGridRange.ThemeGridRange;
  }
});

var _ThemeGridRangeItem = __webpack_require__(236);

Object.defineProperty(exports, 'ThemeGridRangeItem', {
  enumerable: true,
  get: function get() {
    return _ThemeGridRangeItem.ThemeGridRangeItem;
  }
});

var _ThemeGridUnique = __webpack_require__(237);

Object.defineProperty(exports, 'ThemeGridUnique', {
  enumerable: true,
  get: function get() {
    return _ThemeGridUnique.ThemeGridUnique;
  }
});

var _ThemeGridUniqueItem = __webpack_require__(238);

Object.defineProperty(exports, 'ThemeGridUniqueItem', {
  enumerable: true,
  get: function get() {
    return _ThemeGridUniqueItem.ThemeGridUniqueItem;
  }
});

var _ThemeLabel = __webpack_require__(71);

Object.defineProperty(exports, 'ThemeLabel', {
  enumerable: true,
  get: function get() {
    return _ThemeLabel.ThemeLabel;
  }
});

var _ThemeLabelAlongLine = __webpack_require__(239);

Object.defineProperty(exports, 'ThemeLabelAlongLine', {
  enumerable: true,
  get: function get() {
    return _ThemeLabelAlongLine.ThemeLabelAlongLine;
  }
});

var _ThemeLabelBackground = __webpack_require__(240);

Object.defineProperty(exports, 'ThemeLabelBackground', {
  enumerable: true,
  get: function get() {
    return _ThemeLabelBackground.ThemeLabelBackground;
  }
});

var _ThemeLabelItem = __webpack_require__(241);

Object.defineProperty(exports, 'ThemeLabelItem', {
  enumerable: true,
  get: function get() {
    return _ThemeLabelItem.ThemeLabelItem;
  }
});

var _ThemeLabelText = __webpack_require__(242);

Object.defineProperty(exports, 'ThemeLabelText', {
  enumerable: true,
  get: function get() {
    return _ThemeLabelText.ThemeLabelText;
  }
});

var _ThemeLabelUniqueItem = __webpack_require__(404);

Object.defineProperty(exports, 'ThemeLabelUniqueItem', {
  enumerable: true,
  get: function get() {
    return _ThemeLabelUniqueItem.ThemeLabelUniqueItem;
  }
});

var _ThemeMemoryData = __webpack_require__(243);

Object.defineProperty(exports, 'ThemeMemoryData', {
  enumerable: true,
  get: function get() {
    return _ThemeMemoryData.ThemeMemoryData;
  }
});

var _ThemeOffset = __webpack_require__(72);

Object.defineProperty(exports, 'ThemeOffset', {
  enumerable: true,
  get: function get() {
    return _ThemeOffset.ThemeOffset;
  }
});

var _ThemeParameters = __webpack_require__(244);

Object.defineProperty(exports, 'ThemeParameters', {
  enumerable: true,
  get: function get() {
    return _ThemeParameters.ThemeParameters;
  }
});

var _ThemeRange = __webpack_require__(99);

Object.defineProperty(exports, 'ThemeRange', {
  enumerable: true,
  get: function get() {
    return _ThemeRange.ThemeRange;
  }
});

var _ThemeRangeItem = __webpack_require__(245);

Object.defineProperty(exports, 'ThemeRangeItem', {
  enumerable: true,
  get: function get() {
    return _ThemeRangeItem.ThemeRangeItem;
  }
});

var _ThemeService = __webpack_require__(405);

Object.defineProperty(exports, 'ThemeService', {
  enumerable: true,
  get: function get() {
    return _ThemeService.ThemeService;
  }
});

var _ThemeUnique = __webpack_require__(100);

Object.defineProperty(exports, 'ThemeUnique', {
  enumerable: true,
  get: function get() {
    return _ThemeUnique.ThemeUnique;
  }
});

var _ThemeUniqueItem = __webpack_require__(101);

Object.defineProperty(exports, 'ThemeUniqueItem', {
  enumerable: true,
  get: function get() {
    return _ThemeUniqueItem.ThemeUniqueItem;
  }
});

var _ThiessenAnalystParameters = __webpack_require__(73);

Object.defineProperty(exports, 'ThiessenAnalystParameters', {
  enumerable: true,
  get: function get() {
    return _ThiessenAnalystParameters.ThiessenAnalystParameters;
  }
});

var _ThiessenAnalystService = __webpack_require__(406);

Object.defineProperty(exports, 'ThiessenAnalystService', {
  enumerable: true,
  get: function get() {
    return _ThiessenAnalystService.ThiessenAnalystService;
  }
});

var _TilesetsService = __webpack_require__(407);

Object.defineProperty(exports, 'TilesetsService', {
  enumerable: true,
  get: function get() {
    return _TilesetsService.TilesetsService;
  }
});

var _TopologyValidatorJobsParameter = __webpack_require__(246);

Object.defineProperty(exports, 'TopologyValidatorJobsParameter', {
  enumerable: true,
  get: function get() {
    return _TopologyValidatorJobsParameter.TopologyValidatorJobsParameter;
  }
});

var _TopologyValidatorJobsService = __webpack_require__(408);

Object.defineProperty(exports, 'TopologyValidatorJobsService', {
  enumerable: true,
  get: function get() {
    return _TopologyValidatorJobsService.TopologyValidatorJobsService;
  }
});

var _TransferLine = __webpack_require__(247);

Object.defineProperty(exports, 'TransferLine', {
  enumerable: true,
  get: function get() {
    return _TransferLine.TransferLine;
  }
});

var _TransferPathParameters = __webpack_require__(248);

Object.defineProperty(exports, 'TransferPathParameters', {
  enumerable: true,
  get: function get() {
    return _TransferPathParameters.TransferPathParameters;
  }
});

var _TransferPathService = __webpack_require__(409);

Object.defineProperty(exports, 'TransferPathService', {
  enumerable: true,
  get: function get() {
    return _TransferPathService.TransferPathService;
  }
});

var _TransferSolutionService = __webpack_require__(410);

Object.defineProperty(exports, 'TransferSolutionService', {
  enumerable: true,
  get: function get() {
    return _TransferSolutionService.TransferSolutionService;
  }
});

var _TransportationAnalystParameter = __webpack_require__(34);

Object.defineProperty(exports, 'TransportationAnalystParameter', {
  enumerable: true,
  get: function get() {
    return _TransportationAnalystParameter.TransportationAnalystParameter;
  }
});

var _TransportationAnalystResultSetting = __webpack_require__(250);

Object.defineProperty(exports, 'TransportationAnalystResultSetting', {
  enumerable: true,
  get: function get() {
    return _TransportationAnalystResultSetting.TransportationAnalystResultSetting;
  }
});

var _TransferSolutionParameters = __webpack_require__(249);

Object.defineProperty(exports, 'TransferSolutionParameters', {
  enumerable: true,
  get: function get() {
    return _TransferSolutionParameters.TransferSolutionParameters;
  }
});

var _UGCLayer = __webpack_require__(102);

Object.defineProperty(exports, 'UGCLayer', {
  enumerable: true,
  get: function get() {
    return _UGCLayer.UGCLayer;
  }
});

var _UGCMapLayer = __webpack_require__(251);

Object.defineProperty(exports, 'UGCMapLayer', {
  enumerable: true,
  get: function get() {
    return _UGCMapLayer.UGCMapLayer;
  }
});

var _UGCSubLayer = __webpack_require__(52);

Object.defineProperty(exports, 'UGCSubLayer', {
  enumerable: true,
  get: function get() {
    return _UGCSubLayer.UGCSubLayer;
  }
});

var _UpdateEdgeWeightParameters = __webpack_require__(252);

Object.defineProperty(exports, 'UpdateEdgeWeightParameters', {
  enumerable: true,
  get: function get() {
    return _UpdateEdgeWeightParameters.UpdateEdgeWeightParameters;
  }
});

var _UpdateEdgeWeightService = __webpack_require__(411);

Object.defineProperty(exports, 'UpdateEdgeWeightService', {
  enumerable: true,
  get: function get() {
    return _UpdateEdgeWeightService.UpdateEdgeWeightService;
  }
});

var _UpdateTurnNodeWeightParameters = __webpack_require__(253);

Object.defineProperty(exports, 'UpdateTurnNodeWeightParameters', {
  enumerable: true,
  get: function get() {
    return _UpdateTurnNodeWeightParameters.UpdateTurnNodeWeightParameters;
  }
});

var _UpdateTurnNodeWeightService = __webpack_require__(412);

Object.defineProperty(exports, 'UpdateTurnNodeWeightService', {
  enumerable: true,
  get: function get() {
    return _UpdateTurnNodeWeightService.UpdateTurnNodeWeightService;
  }
});

var _Vector = __webpack_require__(254);

Object.defineProperty(exports, 'Vector', {
  enumerable: true,
  get: function get() {
    return _Vector.Vector;
  }
});

var _VectorClipJobsParameter = __webpack_require__(255);

Object.defineProperty(exports, 'VectorClipJobsParameter', {
  enumerable: true,
  get: function get() {
    return _VectorClipJobsParameter.VectorClipJobsParameter;
  }
});

var _VectorClipJobsService = __webpack_require__(413);

Object.defineProperty(exports, 'VectorClipJobsService', {
  enumerable: true,
  get: function get() {
    return _VectorClipJobsService.VectorClipJobsService;
  }
});

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OnlineQueryDatasParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

__webpack_require__(257);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.OnlineQueryDatasParameter
 * @classdesc myDatas服务资源查询参数
 * @param options -{Object} 查询参数
 */
var OnlineQueryDatasParameter = exports.OnlineQueryDatasParameter = function () {
  function OnlineQueryDatasParameter(options) {
    _classCallCheck(this, OnlineQueryDatasParameter);

    options = options || {};

    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.userNames -{Array<string>}
     * @description 数据作者名。可以根据数据作者名查询，默认查询全部。
     */
    this.userNames = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.types  -{Array<Object>}
     * @description  数据类型
     */
    this.types = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.fileName  -{string}
     * @description  文件名称。
     */
    this.fileName = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.serviceStatuses  -{string}
     * @description  服务发布状态。
     */
    this.serviceStatuses = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.serviceId  -{string}
     * @description  服务 id 。
     */
    this.serviceId = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.ids  -{Array<integer>}
     * @description  由数据项 id 组成的整型数组。
     */
    this.ids = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.keywords  -{Array<string>}
     * @description 关键字。
     */
    this.keywords = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.orderBy  -{string}
     * @description 排序字段。
     */
    this.orderBy = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.tags  -{Array<string>}
     * @description 数据的标签。
     */
    this.tags = null;
    /**
     * @member SuperMap.OnlineQueryDatasParameter.prototype.filterFields  -{Array<string>}
     * @description 用于关键字查询时的过滤字段。
     */
    this.filterFields = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.OnlineQueryDatasParameter";
  }

  /**
   * @function SuperMap.OnlineQueryDatasParameter.prototype.toJSON
   * @description 返回对应的json对象
   * @returns {Object} 对应的json对象
   */


  _createClass(OnlineQueryDatasParameter, [{
    key: 'toJSON',
    value: function toJSON() {
      var me = this;
      var jsonObj = {
        "types": me.types,
        "fileName": me.fileName,
        "serviceStatuses": me.serviceStatuses,
        "serviceId": me.serviceId,
        "ids": me.ids,
        "keywords": me.keywords,
        "orderBy": me.orderBy,
        "tags": me.tags,
        "filterFields": me.filterFields
      };
      for (var key in jsonObj) {
        if (jsonObj[key] == null) {
          delete jsonObj[key];
        }
      }
      return jsonObj;
    }
  }]);

  return OnlineQueryDatasParameter;
}();

_SuperMap.SuperMap.OnlineQueryDatasParameter = OnlineQueryDatasParameter;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OnlineServiceBase = exports.OnlineResources = exports.OnlineQueryDatasParameter = exports.OnlineData = exports.Online = undefined;

var _Online = __webpack_require__(122);

Object.defineProperty(exports, 'Online', {
  enumerable: true,
  get: function get() {
    return _Online.Online;
  }
});

var _OnlineData = __webpack_require__(256);

Object.defineProperty(exports, 'OnlineData', {
  enumerable: true,
  get: function get() {
    return _OnlineData.OnlineData;
  }
});

var _OnlineQueryDatasParameter = __webpack_require__(415);

Object.defineProperty(exports, 'OnlineQueryDatasParameter', {
  enumerable: true,
  get: function get() {
    return _OnlineQueryDatasParameter.OnlineQueryDatasParameter;
  }
});

var _OnlineServiceBase = __webpack_require__(258);

Object.defineProperty(exports, 'OnlineServiceBase', {
  enumerable: true,
  get: function get() {
    return _OnlineServiceBase.OnlineServiceBase;
  }
});

var _OnlineResources = __webpack_require__(257);

var OnlineResources = _interopRequireWildcard(_OnlineResources);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

exports.OnlineResources = OnlineResources;

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Bar = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeFactory = __webpack_require__(24);

var _Polygon = __webpack_require__(75);

var _Color = __webpack_require__(105);

var _Util = __webpack_require__(1);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Bar
 * @classdesc 柱状图 。
 * @description 图表 Bar 配置对象 chartsSetting（<SuperMap.Layer.Graph::chartsSetting>） 可设属性如下：</br>
 *              width - {number} 专题要素（图表）宽度，必设参数。</br>
 *              height - {number} 专题要素（图表）高度，必设参数。</br>
 *              codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
 *              XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。</br>
 *              YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。</br>
 *              dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）
 *                                                     在左、下，右，上四个方向上的内偏距值。当使用坐标轴时 dataViewBoxParameter 的默认值为：[45, 15, 15, 15]；
 *                                                     不使用坐标轴时 dataViewBoxParameter 的默认值为：[5, 5, 5, 5]。</br>
 *              decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
 *              useBackground - {boolean} 是否使用图表背景框，默认使用。</br>
 *              backgroundStyle - {Object} 背景样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Rectangle::style>。</br>
 *              backgroundRadius - {Array<number>} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 ,
 *                                         则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0, 0, 0, 0]。</br>
 *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。长度为 3 的数组，第一元素表示第一个图形左端与数据视图框左端的空白间距，第二个元素表示图形间空白间距，
 *                                            第三个元素表示最后一个图形右端与数据视图框右端端的空白间距 。</br>
 *              showShadow - {boolean} 阴影开关 默认是打开。</br>
 *              barShadowStyle - {Object} 阴影样式,如：{shadowBlur : 8, shadowOffsetX: 2 , shadowOffsetY : 2,shadowColor : "rgba(100,100,100,0.8)"}</br>
 *              barLinearGradient - {Array<string>} 按字段设置柱条样式[渐变开始颜色,渐变终止颜色]  与 themeLayer.themeFields 中的字段一一对应），
 *                                                  如：[["#00FF00","#00CD00"],["#00CCFF","#5E87A2"],["#00FF66","#669985"],["#CCFF00","#94A25E"],["#FF9900","#A2945E"]]</br>
 *              useAxis - {boolean} 是否使用坐标轴，默认使用坐标轴。</br>
 *              axisStyle - {Object} 坐标轴样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。</br>
 *              axisUseArrow - {boolean} 坐标轴是否使用箭头，默认值：false，不使用箭头。</br>
 *              axisYTick - {number} y 轴刻度数量，默认值：0 ，不使用刻度。</br>
 *              axisYLabels - {Array<string>} y 轴上的标签组内容，标签顺序沿着数据视图框左面条边自上而下，等距排布。例如：["1000", "750", "500", "250", "0"]。</br>
 *              axisYLabelsStyle - {Object} y 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。</br>
 *              axisYLabelsOffset - {Array<number>} y 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 y 轴标签组横向上的偏移量，向左为正，默认值：0；数组第二项表示 y 轴标签组纵向上的偏移量，向下为正，默认值：0。</br>
 *              axisXLabels - {Array<string>} x 轴上的标签组内容，标签顺序沿着数据视图框下面条边自左向右排布，例如：["92年", "95年", "99年"]。标签排布规则：当标签数量与 xShapeInfo 中的属性 xShapeCenter 数量相同（即标签个数与数据个数相等时）, 按照 xShapeCenter 提供的位置排布标签,否则沿数据视图框下面条边等距排布标签。</br>
 *              axisXLabelsStyle - {Object} x 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。</br>
 *              axisXLabelsOffset - {Array<number>} x 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 x 轴标签组横向上的偏移量，向左为正，默认值：0；数组第二项表示 x 轴标签组纵向上的偏移量，向下为正，默认值：0。</br>
 *              useXReferenceLine - {boolean) 是否使用水平参考线，如果为 true，在 axisYTick 大于 0 时有效，水平参考线是 y 轴刻度在数据视图框里的延伸。</br>
 *              xReferenceLineStyle - {Object) 水平参考线样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。</br>
 *              barStyle - {Object} 柱状图柱条基础 style，此参数控制柱条基础样式，优先级低于 barStyleByFields 和 barStyleByCodomain。此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。</br>
 *              barStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为柱条赋 style，此参数按字段控制柱条样式，优先级低于 barStyleByCodomain，高于 barStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],barStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的柱条使用 style1，字段 POP_1995 对应的柱条使用 style2 ，字段 POP_1999 对应的柱条使用 style3。</br>
 *              barStyleByCodomain - {Array<Object>} 按柱条代表的数据值所在值域范围控制柱条样式，优先级高于 barStyle 和 barStyleByFields。</br>
 *              barHoverStyle - {Object} 柱条 hover 状态时的样式，barHoverAble 为 true 时有效。</br>
 *              barHoverAble - {Object} 是否允许柱条使用 hover 状态，默认允许。同时设置 barHoverAble 和 barClickAble 为 false，可以直接屏蔽柱条对专题图层事件的响应。</br>
 *              barClickAble - {Object} 是否允许柱条被点击，默认允许。同时设置 barHoverAble 和 barClickAble 为 false，可以直接屏蔽柱条对专题图层事件的响应。</br>
 * @example
 * // barStyleByCodomain参数用法如下：
 * // barStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。
 * // barStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * @extends SuperMap.Feature.Theme.Graph
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 属性中的参与此图表生成的属性字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @return {SuperMap.Feature.Theme.Bar} 返回一个柱状图表对象。
 */
var Bar = exports.Bar = function (_Graph) {
    _inherits(Bar, _Graph);

    function Bar(data, layer, fields, setting, lonlat) {
        _classCallCheck(this, Bar);

        var _this = _possibleConstructorReturn(this, (Bar.__proto__ || Object.getPrototypeOf(Bar)).call(this, data, layer, fields, setting, lonlat));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Bar";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Bar.prototype.destroy
     * @override
     */


    _createClass(Bar, [{
        key: 'destroy',
        value: function destroy() {
            _get(Bar.prototype.__proto__ || Object.getPrototypeOf(Bar.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Bar.prototype.assembleShapes
         * @description 图表图形装配函数。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            //默认渐变颜色数组
            var deafaultColors = [["#00FF00", "#00CD00"], ["#00CCFF", "#5E87A2"], ["#00FF66", "#669985"], ["#CCFF00", "#94A25E"], ["#FF9900", "#A2945E"]];

            //默认阴影
            var deafaultShawdow = {
                showShadow: true,
                shadowBlur: 8,
                shadowColor: "rgba(100,100,100,0.8)",
                shadowOffsetX: 2,
                shadowOffsetY: 2
            };

            // 图表配置对象
            var sets = this.setting;

            if (typeof sets.barLinearGradient !== "undefined") {
                sets.barLinearGradient = deafaultColors;
            }

            // 默认数据视图框
            if (!sets.dataViewBoxParameter) {
                if (typeof sets.useAxis === "undefined" || sets.useAxis) {
                    sets.dataViewBoxParameter = [45, 15, 15, 15];
                } else {
                    sets.dataViewBoxParameter = [5, 5, 5, 5];
                }
            }

            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }
            // 值域
            var codomain = this.DVBCodomain;
            // 重要步骤：定义图表 Bar 数据视图框中单位值的含义
            this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;

            // 数据视图域
            var dvb = this.dataViewBox;
            // 用户数据值
            var fv = this.dataValues;
            if (fv.length < 1) {
                return;
            } // 没有数据

            // 数据溢出值域范围处理
            for (var _i = 0, fvLen = fv.length; _i < fvLen; _i++) {
                if (fv[_i] < codomain[0] || fv[_i] > codomain[1]) {
                    return;
                }
            }

            // 获取 x 轴上的图形信息
            var xShapeInfo = this.calculateXShapeInfo();
            if (!xShapeInfo) {
                return;
            }
            // 每个柱条 x 位置
            var xsLoc = xShapeInfo.xPositions;
            // 柱条宽度
            var xsWdith = xShapeInfo.width;

            // 背景框，默认启用
            if (typeof sets.useBackground === "undefined" || sets.useBackground) {
                // 将背景框图形添加到模型的 shapes 数组，注意添加顺序，后添加的图形在先添加的图形之上。
                this.shapes.push(_ShapeFactory.ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
            }

            // 坐标轴, 默认启用
            if (typeof sets.useAxis === "undefined" || sets.useAxis) {
                // 添加坐标轴图形数组
                this.shapes = this.shapes.concat(_ShapeFactory.ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));
            }

            for (var i = 0; i < fv.length; i++) {
                // 计算柱条 top 边的 y 轴坐标值
                var yPx = dvb[1] - (fv[i] - codomain[0]) / this.DVBUnitValue;

                // 柱条节点数组
                var poiLists = [[xsLoc[i] - xsWdith / 2, dvb[1] - 1], [xsLoc[i] + xsWdith / 2, dvb[1] - 1], [xsLoc[i] + xsWdith / 2, yPx], [xsLoc[i] - xsWdith / 2, yPx]];

                // 柱条参数对象（一个面参数对象）
                var barParams = new _Polygon.Polygon(poiLists);

                // 柱条 阴影 style
                if (typeof sets.showShadow === "undefined" || sets.showShadow) {
                    if (sets.barShadowStyle) {
                        var sss = sets.barShadowStyle;
                        if (sss.shadowBlur) {
                            deafaultShawdow.shadowBlur = sss.shadowBlur;
                        }
                        if (sss.shadowColor) {
                            deafaultShawdow.shadowColor = sss.shadowColor;
                        }
                        if (sss.shadowOffsetX) {
                            deafaultShawdow.shadowOffsetX = sss.shadowOffsetX;
                        }
                        if (sss.shadowOffsetY) {
                            deafaultShawdow.shadowOffsetY = sss.shadowOffsetY;
                        }
                    }
                    barParams.style = {};
                    _Util.Util.copyAttributesWithClip(barParams.style, deafaultShawdow);
                }

                // 图形携带的数据信息
                barParams.refDataID = this.data.id;
                barParams.dataInfo = {
                    field: this.fields[i],
                    value: fv[i]
                };

                // 柱条 hover click
                if (typeof sets.barHoverAble !== "undefined") {
                    barParams.hoverable = sets.barHoverAble;
                }
                if (typeof sets.barClickAble !== "undefined") {
                    barParams.clickable = sets.barClickAble;
                }

                // 创建柱条并添加到图表图形数组中
                this.shapes.push(this.shapeFactory.createShape(barParams));
            }

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }

        /**
         * @function SuperMap.Feature.Theme.Bar.prototype.calculateXShapeInfo
         * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
         *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
         *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         *              本函数中图形配置对象 setting 可设属性：
         *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。
         *              长度为 3 的数组，第一元素表示第一个图形左端与数据视图框左端的空白间距，第二个元素表示图形间空白间距，
         *              第三个元素表示最后一个图形右端与数据视图框右端端的空白间距 。
         * @return {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性：
         *         xPositions - {Array<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         *         width - {number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         *
         */

    }, {
        key: 'calculateXShapeInfo',
        value: function calculateXShapeInfo() {
            var dvb = this.dataViewBox; // 数据视图框
            var sets = this.setting; // 图表配置对象
            var fvc = this.dataValues.length; // 数组值个数

            if (fvc < 1) {
                return null;
            }

            var xBlank; // x 轴空白间隔参数
            var xShapePositions = []; // x 轴上图形的位置
            var xShapeWidth = 0; // x 轴上图形宽度(自适应)
            var dvbWidth = this.DVBWidth; // 数据视图框宽度

            //  x 轴空白间隔参数处理
            if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 3) {
                xBlank = sets.xShapeBlank;
                var xsLen = dvbWidth - (xBlank[0] + xBlank[2] + (fvc - 1) * xBlank[1]);
                if (xsLen <= fvc) {
                    return null;
                }
                xShapeWidth = xsLen / fvc;
            } else {
                // 默认使用等距离空白间隔，空白间隔为图形宽度
                xShapeWidth = dvbWidth / (2 * fvc + 1);
                xBlank = [xShapeWidth, xShapeWidth, xShapeWidth];
            }

            // 图形 x 轴上的位置计算
            var xOffset = 0;
            for (var i = 0; i < fvc; i++) {
                if (i == 0) {
                    xOffset = xBlank[0] + xShapeWidth / 2;
                } else {
                    xOffset += xShapeWidth + xBlank[1];
                }

                xShapePositions.push(dvb[0] + xOffset);
            }

            return {
                "xPositions": xShapePositions,
                "width": xShapeWidth
            };
        }

        /**
         * @function SuperMap.Feature.Theme.Bar.prototype.resetLinearGradient
         * @description 图表的相对坐标存在的时候，重新计算渐变的颜色(目前用于二维柱状图 所以子类实现此方法)。
         */

    }, {
        key: 'resetLinearGradient',
        value: function resetLinearGradient() {
            if (this.RelativeCoordinate) {
                var shpelength = this.shapes.length;
                var barLinearGradient = this.setting.barLinearGradient;
                var index = -1;
                for (var i = 0; i < shpelength; i++) {
                    var shape = this.shapes[i];
                    if (shape.CLASS_NAME === "SuperMap.LevelRenderer.Shape.SmicPolygon") {
                        var style = shape.style;
                        //计算出当前的绝对 x y
                        var x1 = this.location[0] + style.pointList[0][0];
                        var x2 = this.location[0] + style.pointList[1][0];

                        //渐变颜色
                        index++;
                        //以防定义的颜色数组不够用
                        if (index >= barLinearGradient.length) {
                            index = index % barLinearGradient.length;
                        }
                        var color1 = barLinearGradient[index][0];
                        var color2 = barLinearGradient[index][1];

                        //颜色
                        var zcolor = new _Color.Color();
                        var linearGradient = zcolor.getLinearGradient(x1, 0, x2, 0, [[0, color1], [1, color2]]);

                        //赋值
                        shape.style.color = linearGradient;
                    }
                }
            }
        }
    }]);

    return Bar;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.Bar = Bar;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Bar3D = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _ShapeFactory = __webpack_require__(24);

var _Polygon = __webpack_require__(75);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Bar3D
 * @classdesc 三维柱状图 。
 * @extends SuperMap.Feature.Theme.Graph
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @return {SuperMap.Feature.Theme.Bar3D} 返回一个三维柱状图表对象。
 *
 * @description 图表 Bar3D 配置对象 chartsSetting（<SuperMap.Layer.Graph::chartsSetting>） 可设属性如下：</br>
 *              width - {number} 专题要素（图表）宽度，必设参数。</br>
 *              height - {number} 专题要素（图表）高度，必设参数。</br>
 *              codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
 *              XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。</br>
 *              YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。</br>
 *              dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。当使用坐标轴时 dataViewBoxParameter 的默认值为：[45, 25, 20, 20]；不使用坐标轴时 dataViewBoxParameter 的默认值为：[5, 5, 5, 5]。</br>
 *              decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
 *              useBackground - {boolean} 是否使用图表背景框，默认使用。</br>
 *              backgroundStyle - {Object} 背景样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Rectangle::style>。</br>
 *              backgroundRadius - {Array<number>} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 ,则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0, 0, 0, 0]。</br>
 *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。长度为 3 的数组，第一元素表示第一个图形左端与数据视图框左端的空白间距，第二个元素表示图形间空白间距，第三个元素表示最后一个图形右端与数据视图框右端端的空白间距 。</br>
 *              bar3DParameter - {number} 3D 柱状参数，3d柱形正面相对于背面向 x 轴和 y 轴负方向偏移的绝对值，默认值：10。</br>
 *              useAxis - {boolean} 是否使用坐标轴，默认使用坐标轴。</br>
 *              axisStyle - {Object} 坐标轴样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。</br>
 *              axisUseArrow - {boolean} 坐标轴是否使用箭头，默认值：true，使用箭头。</br>
 *              axisYTick - {number} y 轴刻度数量，默认值：0 ，不使用刻度。</br>
 *              axisYLabels - {Array<string>} y 轴上的标签组内容，标签顺序沿着数据视图框左面条边自上而下，等距排布。例如：["1000", "750", "500", "250", "0"]。</br>
 *              axisYLabelsStyle - {Object} y 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。</br>
 *              axisYLabelsOffset - {Array<number>} y 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 y 轴标签组横向上的偏移量，向左为正，默认值：0；数组第二项表示 y 轴标签组纵向上的偏移量，向下为正，默认值：0。</br>
 *              axisXLabels - {Array<string>} x 轴上的标签组内容，标签顺序沿着数据视图框下面条边自左向右排布，例如：["92年", "95年", "99年"]。标签排布规则：当标签数量与 xShapeInfo 中的属性 xShapeCenter 数量相同（即标签个数与数据个数相等时）, 按照 xShapeCenter 提供的位置排布标签，否则沿数据视图框下面条边等距排布标签。</br>
 *              axisXLabelsStyle - {Object} x 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。</br>
 *              axisXLabelsOffset - {Array<number>} x 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 x 轴标签组横向上的偏移量，向左为正，默认值：-10；数组第二项表示 x 轴标签组纵向上的偏移量，向下为正，默认值：10。</br>
 *              useXReferenceLine - {boolean) 是否使用水平参考线，如果为 true，在 axisYTick 大于 0 时有效，水平参考线是 y 轴刻度在数据视图框里的延伸。</br>
 *              xReferenceLineStyle - {Object) 水平参考线样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。</br>
 *              axis3DParameter - {number} 3D 坐标轴参数，此属性值在大于等于 15 时有效，默认值：20。</br>
 *              barFaceStyle - {Object} 3d 柱状图柱条正面基础 style，此参数控制柱条正面基础样式，优先级低于 barFaceStyleByFields 和 barFaceStyleByCodomain。此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style>。</br>
 *              barFaceStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为柱条正面赋 style，此参数按字段控制柱条正面样式，优先级低于 barFaceStyleByCodomain，高于 barFaceStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],barFaceStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的柱条正面使用 style1，字段 POP_1995 对应的柱条正面使用 style2 ，字段 POP_1999 对应的柱条正面使用 style3。</br>
 *              barFaceStyleByCodomain - {Array<Object>} 按柱条正面代表的数据值所在值域范围控制柱条正面样式，优先级高于 barFaceStyle 和 barFaceStyleByFields。</br>
 *              barSideStyle - {Object} 3d 柱状图柱条侧面基础 style，此参数控制柱条侧面基础样式，优先级低于 barSideStyleByFields 和 barSideStyleByCodomain此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> ，默认值：barFaceStyle。</br>
 *              barSideStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为柱条侧面赋style，此数按字段控制柱条侧面样式，优先级低于 barSideStyleByCodomain，高于 barSideStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],barSideStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的柱条侧面使用 style1，字段 POP_1995对应的柱条侧面使用style2，字段POP_1999对应的柱条侧面使用style3。默认值：barFaceStyleByFields。</br>
 *              barSideStyleByCodomain - {Array<Object>} 按柱条侧面代表的数据值所在值域范围控制柱条侧面样式，优先级高于 barSideStyle 和 barSideStyleByFields。默认值：barFaceStyleByCodomain。</br>
 *              barFaceHoverStyle - {Object} 3d 柱条正面 hover 状态时的样式，barHoverAble 为 true 时有效。</br>
 *              barSideHoverStyle - {Object} 3d 柱条侧面 hover 状态时的样式，barHoverAble 为 true 时有效，默认值：barFaceHoverStyle。</br>
 *              barTopHoverStyle - {Object} 3d 柱条顶面 hover 状态时的样式，barHoverAble 为 true 时有效，默认值：barFaceHoverStyle。</br>
 *              barHoverAble - {Object} 是否允许柱条使用 hover 状态，默认允许。同时设置 barHoverAble 和 barClickAble 为 false，可以直接屏蔽柱条对专题图层事件的响应。</br>
 *              barClickAble - {Object} 是否允许柱条被点击，默认允许。同时设置 barHoverAble 和 barClickAble 为 false，可以直接屏蔽柱条对专题图层事件的响应。</br>
 *              barTopStyle - {Object} 3d 柱状图柱条顶面基础 style，此参数控制柱条顶面基础样式，优先级低于 barTopStyleByFields 和 barTopStyleByCodomain此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> ，默认值：barFaceStyle。</br>
 *              barTopStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为柱条顶面赋 style，此参数按字段控制柱条顶面样式，优先级低于 barTopStyleByCodomain，高于 barTopStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],barTopStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的柱条顶面使用 style1，字段 POP_1995 对应的柱条顶面使用 style2 ，字段 POP_1999 对应的柱条顶面使用 style3。默认值：barFaceStyleByFields。</br>
 *              barTopStyleByCodomain - {Array<Object>} 按柱条顶面代表的数据值所在值域范围控制柱条顶面样式，优先级高于 barTopStyle 和 barTopStyleByFields。默认值：barFaceStyleByCodomain。</br>
 *
 * @example
 * // barFaceStyleByCodomain 用法示例如下：
 * // barFaceStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。
 * // barFaceStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 *
 * @example
 * // barSideStyleByCodomain 用法示例如下：
 * // barSideStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。
 * // barSideStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 *
 * @example
 * // barTopStyleByCodomain 用法示例如下：
 * // barTopStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Polygon::style> 。
 * // barTopStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 */

var Bar3D = exports.Bar3D = function (_Graph) {
    _inherits(Bar3D, _Graph);

    function Bar3D(data, layer, fields, setting, lonlat) {
        _classCallCheck(this, Bar3D);

        var _this = _possibleConstructorReturn(this, (Bar3D.__proto__ || Object.getPrototypeOf(Bar3D)).call(this, data, layer, fields, setting, lonlat));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Bar3D";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Bar3D.prototype.destroy
     * @override
     */


    _createClass(Bar3D, [{
        key: 'destroy',
        value: function destroy() {
            _get(Bar3D.prototype.__proto__ || Object.getPrototypeOf(Bar3D.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Bar3D.prototype.assembleShapes
         * @description 图形装配实现（扩展接口）。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            // 图表配置对象
            var sets = this.setting;

            // 默认数据视图框
            if (!sets.dataViewBoxParameter) {
                if (typeof sets.useAxis === "undefined" || sets.useAxis) {
                    sets.dataViewBoxParameter = [45, 25, 20, 20];
                } else {
                    sets.dataViewBoxParameter = [5, 5, 5, 5];
                }
            }

            // 3d 柱图的坐标轴默认使用坐标轴箭头
            sets.axisUseArrow = typeof sets.axisUseArrow !== "undefined" ? sets.axisUseArrow : true;
            sets.axisXLabelsOffset = typeof sets.axisXLabelsOffset !== "undefined" ? sets.axisXLabelsOffset : [-10, 10];

            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }

            // 值域
            var codomain = this.DVBCodomain;
            // 重要步骤：定义图表 Bar 数据视图框中单位值的含义
            this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;
            // 数据视图域
            var dvb = this.dataViewBox;
            // 用户数据值
            var fv = this.dataValues;
            if (fv.length < 1) {
                return;
            } // 没有数据

            // 数据溢出值域范围处理
            for (var i = 0, fvLen = fv.length; i < fvLen; i++) {
                if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                    return;
                }
            }

            // 获取 x 轴上的图形信息
            var xShapeInfo = this.calculateXShapeInfo();
            if (!xShapeInfo) {
                return;
            }
            // 每个柱条 x 位置
            var xsLoc = xShapeInfo.xPositions;
            // 柱条宽度
            var xsWdith = xShapeInfo.width;

            // 坐标轴, 默认启用
            if (typeof sets.useBackground === "undefined" || sets.useBackground) {
                this.shapes.push(_ShapeFactory.ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
            }

            // 坐标轴
            if (!sets.axis3DParameter || isNaN(sets.axis3DParameter) || sets.axis3DParameter < 15) {
                sets.axis3DParameter = 20;
            }
            if (typeof sets.useAxis === "undefined" || sets.useAxis) {
                this.shapes = this.shapes.concat(_ShapeFactory.ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));
            }

            // 3d 偏移量, 默认值 10;
            var offset3d = sets.bar3DParameter && !isNaN(sets.bar3DParameter) ? sets.bar3DParameter : 10;

            for (var _i = 0; _i < fv.length; _i++) {
                // 无 3d 偏移量时的柱面顶部 y 坐标
                var yPx = dvb[1] - (fv[_i] - codomain[0]) / this.DVBUnitValue;
                // 无 3d 偏移量时的柱面的左、右端 x 坐标
                var iPoiL = xsLoc[_i] - xsWdith / 2;
                var iPoiR = xsLoc[_i] + xsWdith / 2;

                // 3d 柱顶面节点
                var bar3DTopPois = [[iPoiL, yPx], [iPoiR, yPx], [iPoiR - offset3d, yPx + offset3d], [iPoiL - offset3d, yPx + offset3d]];

                // 3d 柱侧面节点
                var bar3DSidePois = [[iPoiR, yPx], [iPoiR - offset3d, yPx + offset3d], [iPoiR - offset3d, dvb[1] + offset3d], [iPoiR, dvb[1]]];

                // 3d 柱正面节点
                var bar3DFacePois = [[iPoiL - offset3d, dvb[1] + offset3d], [iPoiR - offset3d, dvb[1] + offset3d], [iPoiR - offset3d, yPx + offset3d], [iPoiL - offset3d, yPx + offset3d]];
                if (offset3d <= 0) {
                    // offset3d <= 0 时正面不偏移
                    bar3DFacePois = [[iPoiL, dvb[1]], [iPoiR, dvb[1]], [iPoiR, yPx], [iPoiL, yPx]];
                }

                // 新建 3d 柱面顶面、侧面、正面图形参数对象
                var polyTopSP = new _Polygon.Polygon(bar3DTopPois);
                var polySideSP = new _Polygon.Polygon(bar3DSidePois);
                var polyFaceSP = new _Polygon.Polygon(bar3DFacePois);

                // 侧面、正面图形 style 默认值
                sets.barSideStyle = sets.barSideStyle ? sets.barSideStyle : sets.barFaceStyle;
                sets.barSideStyleByFields = sets.barSideStyleByFields ? sets.barSideStyleByFields : sets.barFaceStyleByFields;
                sets.barSideStyleByCodomain = sets.barSideStyleByCodomain ? sets.barSideStyleByCodomain : sets.barFaceStyleByCodomain;
                sets.barTopStyle = sets.barTopStyle ? sets.barTopStyle : sets.barFaceStyle;
                sets.barTopStyleByFields = sets.barTopStyleByFields ? sets.barTopStyleByFields : sets.barFaceStyleByFields;
                sets.barTopStyleByCodomain = sets.barTopStyleByCodomain ? sets.barTopStyleByCodomain : sets.barFaceStyleByCodomain;
                // 顶面、侧面、正面图形 style
                polyFaceSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool({
                    stroke: true,
                    strokeColor: "#ffffff",
                    fillColor: "#ee9900"
                }, sets.barFaceStyle, sets.barFaceStyleByFields, sets.barFaceStyleByCodomain, _i, fv[_i]);
                polySideSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool({
                    stroke: true,
                    strokeColor: "#ffffff",
                    fillColor: "#ee9900"
                }, sets.barSideStyle, sets.barSideStyleByFields, sets.barSideStyleByCodomain, _i, fv[_i]);
                polyTopSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool({
                    stroke: true,
                    strokeColor: "#ffffff",
                    fillColor: "#ee9900"
                }, sets.barTopStyle, sets.barTopStyleByFields, sets.barTopStyleByCodomain, _i, fv[_i]);

                // 3d 柱条高亮样式
                sets.barSideHoverStyle = sets.barSideHoverStyle ? sets.barSideHoverStyle : sets.barFaceHoverStyle;
                sets.barTopHoverStyle = sets.barTopHoverStyle ? sets.barTopHoverStyle : sets.barFaceHoverStyle;
                polyFaceSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool({ stroke: true }, sets.barFaceHoverStyle);
                polySideSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool({ stroke: true }, sets.barSideHoverStyle);
                polyTopSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool({ stroke: true }, sets.barTopHoverStyle);

                // 图形携带的数据 id 信息 & 高亮模式
                polyTopSP.refDataID = polySideSP.refDataID = polyFaceSP.refDataID = this.data.id;
                // hover 模式（组合）
                polyTopSP.isHoverByRefDataID = polySideSP.isHoverByRefDataID = polyFaceSP.isHoverByRefDataID = true;
                // 高亮组(当鼠标 hover 到组内任何一个图形，整个组的图形都会高亮。refDataHoverGroup 在 isHoverByRefDataID 为 true 时有效)
                polyTopSP.refDataHoverGroup = polySideSP.refDataHoverGroup = polyFaceSP.refDataHoverGroup = _Util.Util.createUniqueID("lr_shg");
                // 图形携带的数据信息
                polyTopSP.dataInfo = polySideSP.dataInfo = polyFaceSP.dataInfo = {
                    field: this.fields[_i],
                    value: fv[_i]
                };

                // 3d 柱条顶面、侧面、正面图形 hover click 设置
                if (typeof sets.barHoverAble !== "undefined") {
                    polyTopSP.hoverable = polySideSP.hoverable = polyFaceSP.hoverable = sets.barHoverAble;
                }
                if (typeof sets.barClickAble !== "undefined") {
                    polyTopSP.clickable = polySideSP.clickable = polyFaceSP.clickable = sets.barClickAble;
                }

                // 创建3d 柱条的顶面、侧面、正面图形并添加到图表的图形列表数组
                this.shapes.push(this.shapeFactory.createShape(polySideSP));
                this.shapes.push(this.shapeFactory.createShape(polyTopSP));
                this.shapes.push(this.shapeFactory.createShape(polyFaceSP));
            }

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }

        /**
         * @function SuperMap.Feature.Theme.Bar3D.prototype.calculateXShapeInfo
         * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
         *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
         *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         *              本函数中图形配置对象 setting 可设属性:</br>
         *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。
         *              长度为 3 的数组，第一元素表示第一个图形左端与数据视图框左端的空白间距，第二个元素表示图形间空白间距，
         *              第三个元素表示最后一个图形右端与数据视图框右端端的空白间距 。
         * @return {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性:</br>
         *                  xPositions - {Array<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。</br>
         *                  width - {number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         */

    }, {
        key: 'calculateXShapeInfo',
        value: function calculateXShapeInfo() {
            var dvb = this.dataViewBox; // 数据视图框
            var sets = this.setting; // 图表配置对象
            var fvc = this.dataValues.length; // 数组值个数

            if (fvc < 1) {
                return null;
            }

            var xBlank; // x 轴空白间隔参数
            var xShapePositions = []; // x 轴上图形的位置
            var xShapeWidth = 0; // x 轴上图形宽度(自适应)
            var dvbWidth = this.DVBWidth; // 数据视图框宽度

            //  x 轴空白间隔参数处理
            if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 3) {
                xBlank = sets.xShapeBlank;
                var xsLen = dvbWidth - (xBlank[0] + xBlank[2] + (fvc - 1) * xBlank[1]);
                if (xsLen <= fvc) {
                    return null;
                }
                xShapeWidth = xsLen / fvc;
            } else {
                // 默认使用等距离空白间隔，空白间隔为图形宽度
                xShapeWidth = dvbWidth / (2 * fvc + 1);
                xBlank = [xShapeWidth, xShapeWidth, xShapeWidth];
            }

            // 图形 x 轴上的位置计算
            var xOffset = 0;
            for (var i = 0; i < fvc; i++) {
                if (i == 0) {
                    xOffset = xBlank[0] + xShapeWidth / 2;
                } else {
                    xOffset += xShapeWidth + xBlank[1];
                }

                xShapePositions.push(dvb[0] + xOffset);
            }

            return {
                "xPositions": xShapePositions,
                "width": xShapeWidth
            };
        }
    }]);

    return Bar3D;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.Bar3D = Bar3D;

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Circle = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Theme = __webpack_require__(77);

var _Circle = __webpack_require__(103);

var _ShapeFactory = __webpack_require__(24);

var _RankSymbol2 = __webpack_require__(259);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Circle
 * @classdesc 圆类。
 * @description 符号 Circle 配置对象 symbolSetting（<SuperMap.Layer.RankSymbol::setting>） 可设属性如下：<br>
 *            codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。<br>
 *            maxR - {number} 圆形的最大半径。<br>
 *            minR - {number} 圆形的最小半径。<br>
 *            fillColor - {string} 圆形的填充色，如：fillColor: "#FFB980"。<br>
 *            circleStyle - {Object} 圆形的基础 style，此参数控制圆形基础样式，优先级低于 circleStyleByFields 和 circleStyleByCodomain。<br>
 *            decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。<br>
 *            circleHoverStyle - {Object} 圆形 hover 状态时的样式，circleHoverAble 为 true 时有效。<br>
 *            circleHoverAble - {Object} 是否允许圆形使用 hover 状态，默认允许。同时设置 circleHoverAble 和 circleClickAble 为 false，可以直接屏蔽图形对专题图层事件的响应。<br>
 *            circleClickAble - {Object} 是否允许圆形被点击，默认允许。同时设置 circleHoverAble 和 circleClickAble 为 false，可以直接屏蔽图形对专题图层事件的响应。
 * @extends SuperMap.Feature.Theme.RankSymbol
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.RankSymbol} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @return {SuperMap.Feature.Theme.Circle} 返回一个圆图。
 */
var Circle = exports.Circle = function (_RankSymbol) {
    _inherits(Circle, _RankSymbol);

    function Circle(data, layer, fields, setting, lonlat) {
        _classCallCheck(this, Circle);

        var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, data, layer, fields, setting, lonlat));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Circle";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Circle.prototype.destroy
     * @override
     */


    _createClass(Circle, [{
        key: 'destroy',
        value: function destroy() {
            _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Circle.prototype.assembleShapes
         * @description 装配图形（扩展接口）。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            //默认填充颜色
            var defaultFillColor = "#ff9277";

            // setting 属性是否已成功赋值
            if (!this.setting) {
                return false;
            }
            var sets = this.setting;
            // 检测 setting 的必设参数
            if (!sets.codomain) {
                return false;
            }

            // 数据
            var decimalNumber = typeof sets.decimalNumber !== "undefined" && !isNaN(sets.decimalNumber) ? sets.decimalNumber : -1;
            var dataEffective = _Theme.Theme.getDataValues(this.data, this.fields, decimalNumber);
            this.dataValues = dataEffective ? dataEffective : [];

            // 数据值数组
            var fv = this.dataValues;
            //if(fv.length != 1) return;       // 没有数据 或者数据不唯一
            //if(fv[0] < 0) return;            //数据为负值

            //用户应该定义最大 最小半径  默认最大半径MaxR:100 最小半径MinR:0;
            if (!sets.maxR) {
                sets.maxR = 100;
            }
            if (!sets.minR) {
                sets.minR = 0;
            }

            // 值域范围
            var codomain = this.DVBCodomain;

            // 重要步骤：定义Circle数据视图框中单位值的含义，单位值：1所代表的长度
            // 用户定义了值域范围
            if (codomain && codomain[1] - codomain[0] > 0) {
                this.DVBUnitValue = sets.maxR / (codomain[1] - codomain[0]);
            } else {
                //this.DVBUnitValue = sets.maxR / maxValue;
                this.DVBUnitValue = sets.maxR;
            }

            var uv = this.DVBUnitValue;
            //圆半径
            var r = fv[0] * uv + sets.minR;
            this.width = 2 * r;
            this.height = 2 * r;

            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }

            //假如用户设置了值域范围 没有在值域范围直接返回
            if (codomain) {
                if (fv[0] < codomain[0] || fv[0] > codomain[1]) {
                    return;
                }
            }

            var dvbCenter = this.DVBCenterPoint; // 数据视图框中心作为圆心

            //圆形对象参数
            var circleSP = new _Circle.Circle(dvbCenter[0], dvbCenter[1], r);

            //circleSP.sytle 初始化
            circleSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.circleStyle, null, null, 0);
            //图形的填充颜色
            if (typeof sets.fillColor !== "undefined") {
                //用户自定义
                circleSP.style.fillColor = sets.fillColor;
            } else {
                //当前默认
                circleSP.style.fillColor = defaultFillColor;
            }
            //圆形 Hover样式
            circleSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.circleHoverStyle);
            //圆形 Hover 与 click 设置
            if (typeof sets.circleHoverAble !== "undefined") {
                circleSP.hoverable = sets.circleHoverAble;
            }
            if (typeof sets.circleClickAble !== "undefined") {
                circleSP.clickable = sets.circleClickAble;
            }

            //图形携带的数据信息
            circleSP.refDataID = this.data.id;
            circleSP.dataInfo = {
                field: this.fields[0],
                r: r,
                value: fv[0]
            };

            // 创建扇形并把此扇形添加到图表图形数组
            this.shapes.push(this.shapeFactory.createShape(circleSP));

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }
    }]);

    return Circle;
}(_RankSymbol2.RankSymbol);

_SuperMap.SuperMap.Feature.Theme.Circle = Circle;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Line = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeFactory = __webpack_require__(24);

var _Point = __webpack_require__(74);

var _Line = __webpack_require__(104);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Line
 * @classdesc 折线图。
 * @description 图表 Line 配置对象 chartsSetting（<SuperMap.Layer.Graph::chartsSetting>）可设属性如下：<br>
 *              width - {number} 专题要素（图表）宽度，必设参数。<br>
 *              height - {number} 专题要素（图表）高度，必设参数。<br>
 *              codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。<br>
 *              XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。<br>
 *              YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。<br>
 *              dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，
 *                      它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。
 *                      当使用坐标轴时 dataViewBoxParameter 的默认值为：[45, 15, 15, 15]；不使用坐标轴时 dataViewBoxParameter 的默认值为：[5, 5, 5, 5]。<br>
 *              decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。<br>
 *              useBackground - {boolean} 是否使用图表背景框。<br>
 *              backgroundStyle - {Object} 背景样式，此样式对象对象可设属性：<SuperMap.Feature.ShapeParameters.Rectangle::style>。<br>
 *              backgroundRadius - {Array<number>} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 ,
 *                      则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0, 0, 0, 0]。<br>
 *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。长度为 2 的数组，第一元素表示折线左端点与数据视图框左端的空白间距，
 *                       第二个元素表示折线右端点右端与数据视图框右端端的空白间距。<br>
 *              axisStyle - {Object} 坐标轴样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style>。<br>
 *              axisUseArrow - {boolean} 坐标轴是否使用箭头，默认值：false，不使用箭头。<br>
 *              axisYTick - {number} y 轴刻度数量，默认值：0 ，不使用刻度。<br>
 *              axisYLabels - {Array<string>} y 轴上的标签组内容，标签顺序沿着数据视图框左面条边自上而下，等距排布。例如：["1000", "750", "500", "250", "0"]。<br>
 *              axisYLabelsStyle - {Object} y 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。<br>
 *              axisYLabelsOffset - {Array<number>} y 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 y 轴标签组横向上的偏移量，向左为正，默认值：0；
 *                       数组第二项表示 y 轴标签组纵向上的偏移量，向下为正，默认值：0。<br>
 *              axisXLabels - {Array<string>} x 轴上的标签组内容，标签顺序沿着数据视图框下面条边自左向右排布，例如：["92年", "95年", "99年"]。
 *                       标签排布规则：当标签数量与 xShapeInfo 中的属性 xShapeCenter 数量相同（即标签个数与数据个数相等时）, 按照 xShapeCenter 提供的位置排布标签，
 *                       否则沿数据视图框下面条边等距排布标签。<br>
 *              axisXLabelsStyle - {Object} x 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。<br>
 *              axisXLabelsOffset - {Array<number>} x 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 x 轴标签组横向上的偏移量，向左为正，默认值：0；
 *                       数组第二项表示 x 轴标签组纵向上的偏移量，向下为正，默认值：0。<br>
 *              useXReferenceLine - {Boolean} 是否使用水平参考线，如果为 true，在 axisYTick 大于 0 时有效，水平参考线是 y 轴刻度在数据视图框里的延伸。<br>
 *              xReferenceLineStyle - {Object} 水平参考线样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style>。<br>
 *              lineStyle - {Object} 折线图中折线 style，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style>。<br>
 *              pointStyle - {Object} 折线图中折线节点基础 style，此参数控制折线节点基础样式，优先级低于 pointStyleByFields 和 pointStyleByCodomain。
 *                       此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Point::style> 。<br>
 *              pointStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为折线节点赋 style，此参数按字段控制折线节点样式，
 *                       优先级低于 pointStyleByCodomain，高于 pointStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Point::style> 。
 *                       此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],
 *                       pointStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的折线节点使用 style1，字段 POP_1995 对应的折线节点使用 style2 ，字段 POP_1999 对应的折线节点使用 style3。<br>
 *              pointStyleByCodomain - {Array<Object>} 按折线节点代表的数据值所在值域范围控制折线节点样式，优先级高于 pointStyle 和 pointStyleByFields。<br>
 *              pointHoverStyle - {Object} 折线节点 hover 状态时的样式，pointHoverAble 为 true 时有效。<br>
 *              pointHoverAble - {Object} 是否允许折线节点使用 hover 状态，默认允许。同时设置 pointHoverAble 和 pointClickAble 为 false，可以直接屏蔽折线节点对专题图层事件的响应。<br>
 *              pointClickAble - {Object} 是否允许折线节点被点击，默认允许。同时设置 pointHoverAble 和 pointClickAble 为 false，可以直接屏蔽折线节点对专题图层事件的响应。
 * @example
 * // pointStyleByCodomain 参数用法示例
 * // pointStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Point::style> 。
 * // pointStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 *
 * @extends SuperMap.Feature.Theme.Graph
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @return {SuperMap.Feature.Theme.Line} 返回一个折线图。
 */
var Line = exports.Line = function (_Graph) {
    _inherits(Line, _Graph);

    /*
     * @function SuperMap.Feature.Theme.Line.prototype.Constructor
     * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
     * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。
     * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
     * @param setting - {Object} 图表配置对象，必设参数。
     * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
     * @return {SuperMap.Feature.Theme.Line} 返回一个折线图。
     */
    function Line(data, layer, fields, setting, lonlat, options) {
        _classCallCheck(this, Line);

        var _this = _possibleConstructorReturn(this, (Line.__proto__ || Object.getPrototypeOf(Line)).call(this, data, layer, fields, setting, lonlat, options));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Line";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Line.prototype.destroy
     * @override
     */


    _createClass(Line, [{
        key: 'destroy',
        value: function destroy() {
            _get(Line.prototype.__proto__ || Object.getPrototypeOf(Line.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Line.prototype.assembleShapes
         * @description 装配图形（扩展接口）。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            // 图表配置对象
            var sets = this.setting;

            // 默认数据视图框
            if (!sets.dataViewBoxParameter) {
                if (typeof sets.useAxis === "undefined" || sets.useAxis) {
                    sets.dataViewBoxParameter = [45, 15, 15, 15];
                } else {
                    sets.dataViewBoxParameter = [5, 5, 5, 5];
                }
            }

            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }

            var dvb = this.dataViewBox;

            // 值域
            var codomain = this.DVBCodomain;
            // 重要步骤：定义图表 Bar 数据视图框中单位值的含义
            this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;
            var uv = this.DVBUnitValue;
            // 数据值数组
            var fv = this.dataValues;
            if (fv.length < 1) {
                return;
            } // 没有数据

            // 获取 x 轴上的图形信息
            var xShapeInfo = this.calculateXShapeInfo();
            if (!xShapeInfo) {
                return;
            }
            // 折线每个节点的 x 位置
            var xsLoc = xShapeInfo.xPositions;

            // 背景框，默认启用
            if (typeof sets.useBackground === "undefined" || sets.useBackground) {
                // 将背景框图形添加到模型的 shapes 数组，注意添加顺序，后添加的图形在先添加的图形之上。
                this.shapes.push(_ShapeFactory.ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
            }

            // 折线图必须使用坐标轴
            this.shapes = this.shapes.concat(_ShapeFactory.ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));

            // var isDataEffective = true;

            var xPx; // 折线节点 x 坐标
            var yPx; // 折线节点 y 坐标
            var poiLists = []; // 折线节点数组

            var shapePois = []; // 折线节点图形数组
            for (var i = 0, len = fv.length; i < len; i++) {
                // 数据溢出值域检查
                if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                    // isDataEffective = false;
                    return null;
                }

                xPx = xsLoc[i];
                yPx = dvb[1] - (fv[i] - codomain[0]) / uv;

                // 折线节点参数对象
                var poiSP = new _Point.Point(xPx, yPx);
                // 折线节点 style
                poiSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool({ fillColor: "#ee9900" }, sets.pointStyle, sets.pointStyleByFields, sets.pointStyleByCodomain, i, fv[i]);
                // 折线节点 hover 样式
                poiSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.pointHoverStyle);

                // 折线节点 hover click
                if (typeof sets.pointHoverAble !== "undefined") {
                    poiSP.hoverable = sets.pointHoverAble;
                }
                if (typeof sets.pointClickAble !== "undefined") {
                    poiSP.clickable = sets.pointClickAble;
                }

                // 图形携带的数据信息
                poiSP.refDataID = this.data.id;
                poiSP.dataInfo = {
                    field: this.fields[i],
                    value: fv[i]
                };

                // 创建图形并把此图形添加到折线节点图形数组
                shapePois.push(this.shapeFactory.createShape(poiSP));

                // 添加折线节点到折线节点数组
                var poi = [xPx, yPx];
                poiLists.push(poi);
            }

            // 折线参数对象
            var lineSP = new _Line.Line(poiLists);
            lineSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool({ strokeColor: "#ee9900" }, sets.lineStyle);
            // 禁止事件响应
            lineSP.clickable = false;
            lineSP.hoverable = false;
            var shapeLine = this.shapeFactory.createShape(lineSP);
            this.shapes.push(shapeLine);

            // 添加节点到图表图形数组
            this.shapes = this.shapes.concat(shapePois);

            // // 数据范围检测未通过，清空图形
            // if (isDataEffective === false) {
            //     this.shapes = [];
            // }

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }

        /**
         * @function SuperMap.Feature.Theme.Line.prototype.calculateXShapeInfo
         * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
         *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
         *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         *              本函数中图形配置对象 setting 可设属性：<br>
         *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。
         *              长度为 2 的数组，第一元素表示第折线左端点与数据视图框左端的空白间距，第二个元素表示折线右端点右端与数据视图框右端端的空白间距 。
         * @return {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性：<br>
         *         xPositions - {Array<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。<br>
         *         width - {number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         */

    }, {
        key: 'calculateXShapeInfo',
        value: function calculateXShapeInfo() {
            var dvb = this.dataViewBox; // 数据视图框
            var sets = this.setting; // 图表配置对象
            var fvc = this.dataValues.length; // 数组值个数

            if (fvc < 1) {
                return null;
            }

            var xBlank; // x 轴空白间隔参数
            var xShapePositions = []; // x 轴上图形的位置
            var xShapeWidth = 0; // x 轴上图形宽度(自适应)
            var dvbWidth = this.DVBWidth; // 数据视图框宽度
            var unitOffset = 0; // 单位偏移量

            //  x 轴空白间隔参数处理
            if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 2) {
                xBlank = sets.xShapeBlank;
                var xsLen = dvbWidth - (xBlank[0] + xBlank[1]);
                if (xsLen <= fvc) {
                    return null;
                }
                unitOffset = xsLen / (fvc - 1);
            } else {
                // 默认使用等距离空白间隔，空白间隔为图形宽度
                unitOffset = dvbWidth / (fvc + 1);
                xBlank = [unitOffset, unitOffset, unitOffset];
            }

            // 图形 x 轴上的位置计算
            var xOffset = 0;
            for (var i = 0; i < fvc; i++) {
                if (i == 0) {
                    xOffset = xBlank[0];
                } else {
                    xOffset += unitOffset;
                }

                xShapePositions.push(dvb[0] + xOffset);
            }

            return {
                "xPositions": xShapePositions,
                "width": xShapeWidth
            };
        }
    }]);

    return Line;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.Line = Line;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Pie = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeFactory = __webpack_require__(24);

var _Sector = __webpack_require__(76);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Pie
 * @classdesc 饼图。
 * @description 图表 Pie 配置对象 chartsSetting（<SuperMap.Layer.Graph::chartsSetting>） 可设属性如下：</br>
 * width - {number} 专题要素（图表）宽度，必设参数。</br>
 * height - {number} 专题要素（图表）高度，必设参数。</br>
 * codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
 * XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。</br>
 * YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。</br>
 * dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，
 * 它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。默认值为：[0, 0, 0, 0]。</br>
 * decimalNumber - {Array<number>}数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
 * useBackground - {boolean} 是否使用图表背景框，默认不使用。</br>
 * backgroundStyle - {Object} 背景样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Rectangle::style>。</br>
 * backgroundRadius - {Array<number>} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 ,则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0, 0, 0, 0]。</br>
 * sectorStyle - {Object} 饼图中扇形的基础 style，此参数控制饼图扇形基础样式，优先级低于 sectorStyleByFields 和 sectorStyleByCodomain。
 * 此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Sector::style> 。</br>
 * sectorStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为饼图扇形赋 style，此参数按字段控制饼图扇形样式，优先级低于 sectorStyleByCodomain，高于 sectorStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Sector::style> 。此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],
 * sectorStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的饼图扇形使用 style1，字段 POP_1995 对应的饼图扇形使用 style2 ，字段 POP_1999 对应的饼图扇形使用 style3。</br>
 * sectorStyleByCodomain - {Array<Object>} 按饼图扇形代表的数据值所在值域范围控制饼图扇形样式，优先级高于 sectorStyle 和 sectorStyleByFields。
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 *
 * @example
 * // sectorStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Sector::style> 。
 * // sectorStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * sectorHoverStyle - {Object} 饼图扇形 hover 状态时的样式，sectorHoverAble 为 true 时有效。</br>
 * sectorHoverAble - {Object} 是否允许饼图扇形使用 hover 状态，默认允许。同时设置 sectorHoverAble 和 sectorClickAble 为 false，可以直接屏蔽饼图扇形对专题图层事件的响应。</br>
 * sectorClickAble - {Object} 是否允许饼图扇形被点击，默认允许。同时设置 sectorHoverAble 和 sectorClickAble 为 false，可以直接屏蔽饼图扇形对专题图层事件的响应。
 * @extends {SuperMap.Feature.Theme.Graph}
 */
var Pie = exports.Pie = function (_Graph) {
    _inherits(Pie, _Graph);

    function Pie(data, layer, fields, setting, lonlat) {
        _classCallCheck(this, Pie);

        var _this = _possibleConstructorReturn(this, (Pie.__proto__ || Object.getPrototypeOf(Pie)).call(this, data, layer, fields, setting, lonlat));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Pie";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Pie.prototype.destroy
     * @description 销毁此专题要素。调用 destroy 后此对象所以属性置为 null。
     */


    _createClass(Pie, [{
        key: 'destroy',
        value: function destroy() {
            _get(Pie.prototype.__proto__ || Object.getPrototypeOf(Pie.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Pie.prototype.assembleShapes
         * @description 装配图形（扩展接口）。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            // 图表配置对象
            var sets = this.setting;

            // 一个默认 style 组
            var defaultStyleGroup = [{ fillColor: "#ff9277" }, { fillColor: "#dddd00" }, { fillColor: "#ffc877" }, { fillColor: "#bbe3ff" }, { fillColor: "#d5ffbb" }, { fillColor: "#bbbbff" }, { fillColor: "#ddb000" }, { fillColor: "#b0dd00" }, { fillColor: "#e2bbff" }, { fillColor: "#ffbbe3" }, { fillColor: "#ff7777" }, { fillColor: "#ff9900" }, { fillColor: "#83dd00" }, { fillColor: "#77e3ff" }, { fillColor: "#778fff" }, { fillColor: "#c877ff" }, { fillColor: "#ff77ab" }, { fillColor: "#ff6600" }, { fillColor: "#aa8800" }, { fillColor: "#77c7ff" }, { fillColor: "#ad77ff" }, { fillColor: "#ff77ff" }, { fillColor: "#dd0083" }, { fillColor: "#777700" }, { fillColor: "#00aa00" }, { fillColor: "#0088aa" }, { fillColor: "#8400dd" }, { fillColor: "#aa0088" }, { fillColor: "#dd0000" }, { fillColor: "#772e00" }];

            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }

            // 背景框，默认不启用
            if (sets.useBackground) {
                this.shapes.push(_ShapeFactory.ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
            }

            // 数据值数组
            var fv = this.dataValues;
            if (fv.length < 1) {
                return;
            } // 没有数据

            // 值域范围
            var codomain = this.DVBCodomain;
            // 值域范围检测
            for (var _i = 0; _i < fv.length; _i++) {
                if (fv[_i] < codomain[0] || fv[_i] > codomain[1]) {
                    return;
                }
            }

            // 值的绝对值总和
            var valueSum = 0;
            for (var _i2 = 0; _i2 < fv.length; _i2++) {
                valueSum += Math.abs(fv[_i2]);
            }

            // 重要步骤：定义图表 Pie 数据视图框中单位值的含义，单位值：每度代表的数值
            this.DVBUnitValue = 360 / valueSum;
            var uv = this.DVBUnitValue;

            var dvbCenter = this.DVBCenterPoint; // 数据视图框中心作为扇心

            var startAngle = 0; // 扇形起始边角度
            var endAngle = 0; // 扇形终止边角度
            var startAngleTmp = startAngle; // 扇形临时起始边角度
            // 扇形（自适应）半径
            var r = this.DVBHeight < this.DVBWidth ? this.DVBHeight / 2 : this.DVBWidth / 2;

            for (var i = 0; i < fv.length; i++) {
                var fvi = Math.abs(fv[i]);
                //计算终止角
                if (i === 0) {
                    endAngle = startAngle + fvi * uv;
                } else if (i === fvi.length - 1) {
                    endAngle = startAngleTmp;
                } else {
                    endAngle = startAngle + fvi * uv;
                }
                //矫正误差计算
                if (endAngle - startAngle >= 360) {
                    endAngle = 359.9999999;
                }

                // 扇形参数对象
                var sectorSP = new _Sector.Sector(dvbCenter[0], dvbCenter[1], r, startAngle, endAngle);
                // 扇形样式
                if (typeof sets.sectorStyleByFields === "undefined") {
                    // 使用默认 style 组
                    var colorIndex = i % defaultStyleGroup.length;
                    sectorSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, defaultStyleGroup, null, colorIndex);
                } else {
                    sectorSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, sets.sectorStyleByFields, sets.sectorStyleByCodomain, i, fv[i]);
                }

                // 扇形 hover 样式
                sectorSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.sectorHoverStyle);
                // 扇形 hover 与 click 设置
                if (typeof sets.sectorHoverAble !== "undefined") {
                    sectorSP.hoverable = sets.sectorHoverAble;
                }
                if (typeof sets.sectorClickAble !== "undefined") {
                    sectorSP.clickable = sets.sectorClickAble;
                }
                // 图形携带的数据信息
                sectorSP.refDataID = this.data.id;
                sectorSP.dataInfo = {
                    field: this.fields[i],
                    value: fv[i]
                };

                // 创建扇形并把此扇形添加到图表图形数组
                this.shapes.push(this.shapeFactory.createShape(sectorSP));

                // 把上一次的结束角度作为下一次的起始角度
                startAngle = endAngle;
            }

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }
    }]);

    return Pie;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.Pie = Pie;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Point = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeFactory = __webpack_require__(24);

var _Point = __webpack_require__(74);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Point
 * @classdesc 点状图。
 * @description 图表 Point 配置对象 chartsSetting(SuperMap.Layer.Graph::chartsSetting) 可设属性如下：</br>
 * width - {number} 专题要素（图表）宽度，必设参数。</br>
 * height - {number} 专题要素（图表）高度，必设参数。</br>
 * codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
 * XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。</br>
 * YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。</br>
 * dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，
 *                     它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。
 *                     当使用坐标轴时 dataViewBoxParameter 的默认值为：[45, 15, 15, 15]；不使用坐标轴时 dataViewBoxParameter 的默认值为：[5, 5, 5, 5]。</br>
 * decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
 * useBackground - {boolean} 是否使用图表背景框。</br>
 * backgroundStyle - {Object} 背景样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Rectangle::style>。</br>
 * backgroundRadius - {Array<number>} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 ,
 *                 则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0, 0, 0, 0]。</br>
 * xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。
 *                 长度为 2 的数组，第一个元素表示第一个（沿 x 轴方向）图形点与数据视图框左端的空白间距，第二个元素表示最后一个（沿 x 轴方向）图形点与数据视图框右端端的空白间距 。</br>
 * axisStyle - {Object} 坐标轴样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。</br>
 * axisUseArrow - {boolean} 坐标轴是否使用箭头，默认值：false，不使用箭头。</br>
 * axisYTick - {number} y 轴刻度数量，默认值：0 ，不使用刻度。</br>
 * axisYLabels - {Array<string>} y 轴上的标签组内容，标签顺序沿着数据视图框左面条边自上而下，等距排布。例如：["1000", "750", "500", "250", "0"]。</br>
 * axisYLabelsStyle - {Object} y 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。</br>
 * axisYLabelsOffset - {Array<number>} y 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 y 轴标签组横向上的偏移量，向左为正，默认值：0；
 *                 数组第二项表示 y 轴标签组纵向上的偏移量，向下为正，默认值：0。</br>
 * axisXLabels - {Array<string>} x 轴上的标签组内容，标签顺序沿着数据视图框下面条边自左向右排布，例如：["92年", "95年", "99年"]。
 *                 标签排布规则：当标签数量与 xShapeInfo 中的属性 xShapeCenter 数量相同（即标签个数与数据个数相等时）, 按照 xShapeCenter 提供的位置排布标签，
 *                 否则沿数据视图框下面条边等距排布标签。</br>
 * axisXLabelsStyle - {Object} x 轴上的标签组样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Label::style> 。</br>
 * axisXLabelsOffset - {Array<number>} x 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 x 轴标签组横向上的偏移量，向左为正，默认值：0；
 *                 数组第二项表示 x 轴标签组纵向上的偏移量，向下为正，默认值：0。</br>
 * useXReferenceLine - {Boolean} 是否使用水平参考线，如果为 true，在 axisYTick 大于 0 时有效，水平参考线是 y 轴刻度在数据视图框里的延伸。</br>
 * xReferenceLineStyle - {Object} 水平参考线样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Line::style> 。</br>
 * pointStyle - {Object} 点状图中图形点基础 style，此参数控制图形点基础样式，优先级低于 pointStyleByFields 和 pointStyleByCodomain。
 *               此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Point::style> 。</br>
 * pointStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为图形点赋 style，此参数按字段控制图形点样式，
 *               优先级低于 pointStyleByCodomain，高于 pointStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Point::style> 。
 *               此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],
 * pointStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的图形点使用 style1，字段 POP_1995 对应的图形点使用 style2 ，字段 POP_1999 对应的图形点使用 style3。</br>
 * pointStyleByCodomain - {Array<Object>} 按图形点代表的数据值所在值域范围控制图形点样式，优先级高于 pointStyle 和 pointStyleByFields。</br>
 *
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。
 * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。
 * @param setting - {Object} 图表配置对象，必设参数。
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 *
 * @example
 * // pointStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Point::style> 。
 * // pointStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * pointHoverStyle - {Object} 图形点 hover 状态时的样式，pointHoverAble 为 true 时有效。
 * pointHoverAble - {Object} 是否允许图形点使用 hover 状态，默认允许。同时设置 pointHoverAble 和 pointClickAble 为 false，可以直接屏蔽图形点对专题图层事件的响应。
 * pointClickAble - {Object} 是否允许图形点被点击，默认允许。同时设置 pointHoverAble 和 pointClickAble 为 false，可以直接屏蔽图形点对专题图层事件的响应。
 *@extends {SuperMap.Feature.Theme.Graph}

 */
var Point = exports.Point = function (_Graph) {
    _inherits(Point, _Graph);

    function Point(data, layer, fields, setting, lonlat, options) {
        _classCallCheck(this, Point);

        var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, data, layer, fields, setting, lonlat, options));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Point";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Point.prototype.destroy
     * @description 销毁此专题要素。调用 destroy 后此对象所以属性置为 null。
     */


    _createClass(Point, [{
        key: 'destroy',
        value: function destroy() {
            _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.prototype.Point.assembleShapes
         * @description 装配图形（扩展接口）。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            // 图表配置对象
            var sets = this.setting;

            // 默认数据视图框
            if (!sets.dataViewBoxParameter) {
                if (typeof sets.useAxis === "undefined" || sets.useAxis) {
                    sets.dataViewBoxParameter = [45, 15, 15, 15];
                } else {
                    sets.dataViewBoxParameter = [5, 5, 5, 5];
                }
            }

            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }

            var dvb = this.dataViewBox;

            // 值域
            var codomain = this.DVBCodomain;
            // 重要步骤：定义图表 Bar 数据视图框中单位值的含义
            this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;
            var uv = this.DVBUnitValue;
            var fv = this.dataValues;

            // 获取 x 轴上的图形信息
            var xShapeInfo = this.calculateXShapeInfo();
            if (!xShapeInfo) {
                return;
            }
            // 折线每个节点的 x 位置
            var xsLoc = xShapeInfo.xPositions;

            // 背景框，默认启用
            if (typeof sets.useBackground === "undefined" || sets.useBackground) {
                // 将背景框图形添加到模型的 shapes 数组，注意添加顺序，后添加的图形在先添加的图形之上。
                this.shapes.push(_ShapeFactory.ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
            }

            // 点状图必须使用坐标轴
            this.shapes = this.shapes.concat(_ShapeFactory.ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));

            var xPx; // 图形点 x 坐标
            var yPx; // 图形点 y 坐标
            for (var i = 0, len = fv.length; i < len; i++) {
                // 数据溢出值域检查
                if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                    //isDataEffective = false;
                    return null;
                }

                xPx = xsLoc[i];
                yPx = dvb[1] - (fv[i] - codomain[0]) / uv;

                // 图形点参数对象
                var poiSP = new _Point.Point(xPx, yPx);
                // 图形点 style
                poiSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool({ fillColor: "#ee9900" }, sets.pointStyle, sets.pointStyleByFields, sets.pointStyleByCodomain, i, fv[i]);
                // 图形点 hover 样式
                poiSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.pointHoverStyle);

                // 图形点 hover click
                if (typeof sets.pointHoverAble !== "undefined") {
                    poiSP.hoverable = sets.pointHoverAble;
                }
                if (typeof sets.pointClickAble !== "undefined") {
                    poiSP.clickable = sets.pointClickAble;
                }

                // 图形携带的数据信息
                poiSP.refDataID = this.data.id;
                poiSP.dataInfo = {
                    field: this.fields[i],
                    value: fv[i]
                };

                // 创建图形点并把此图形添加到图表图形数组
                this.shapes.push(this.shapeFactory.createShape(poiSP));
            }

            // 数据范围检测未通过，清空图形
            // if (isDataEffective === false) {
            //     this.shapes = [];
            // }

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }

        /**
         * @function SuperMap.Feature.Theme.Point.prototype.calculateXShapeInfo
         * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
         *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
         *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
         *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         *              本函数中图形配置对象 setting 可设属性：<br>
         *              xShapeBlank - {Array<number>} 水平方向上的图形空白间隔参数。
         *              长度为 2 的数组，第一元素表示第折线左端点与数据视图框左端的空白间距，第二个元素表示折线右端点右端与数据视图框右端端的空白间距 。
         * @return {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性：<br>
         *         xPositions - {Array<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。</br>
         *         width - {number}表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
         */

    }, {
        key: 'calculateXShapeInfo',
        value: function calculateXShapeInfo() {
            var dvb = this.dataViewBox; // 数据视图框
            var sets = this.setting; // 图表配置对象
            var fvc = this.dataValues.length; // 数组值个数

            if (fvc < 1) {
                return null;
            }

            var xBlank; // x 轴空白间隔参数
            var xShapePositions = []; // x 轴上图形的位置
            var xShapeWidth = 0; // x 轴上图形宽度(自适应)
            var dvbWidth = this.DVBWidth; // 数据视图框宽度
            var unitOffset = 0; // 单位偏移量

            //  x 轴空白间隔参数处理
            if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 2) {
                xBlank = sets.xShapeBlank;
                var xsLen = dvbWidth - (xBlank[0] + xBlank[1]);
                if (xsLen <= fvc) {
                    return null;
                }
                unitOffset = xsLen / (fvc - 1);
            } else {
                // 默认使用等距离空白间隔，空白间隔为图形宽度
                unitOffset = dvbWidth / (fvc + 1);
                xBlank = [unitOffset, unitOffset, unitOffset];
            }

            // 图形 x 轴上的位置计算
            var xOffset = 0;
            for (var i = 0; i < fvc; i++) {
                if (i == 0) {
                    xOffset = xBlank[0];
                } else {
                    xOffset += unitOffset;
                }

                xShapePositions.push(dvb[0] + xOffset);
            }

            return {
                "xPositions": xShapePositions,
                "width": xShapeWidth
            };
        }
    }]);

    return Point;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.Point = Point;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Ring = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _ShapeFactory = __webpack_require__(24);

var _Sector = __webpack_require__(76);

var _Graph2 = __webpack_require__(28);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Ring
 * @classdesc 环状图。
 * @description 基于路由对象计算指定点M值操作的参数类。通过该类提供参数信息。
 * 图表 Ring 配置对象 chartsSetting（SuperMap.Layer.Graph::chartsSetting） 可设属性如下：</br>
 * width - {number} 专题要素（图表）宽度，必设参数。</br>
 * height - {number} 专题要素（图表）高度，必设参数。</br>
 * codomain - {Array<number>} 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限，必设参数。</br>
 * XOffset - {number} 专题要素（图表）在 X 方向上的偏移值，单位像素。</br>
 * YOffset - {number} 专题要素（图表）在 Y 方向上的偏移值，单位像素。</br>
 * dataViewBoxParameter - {Array<number>} 数据视图框 dataViewBox 参数，
 * 它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。默认值为：[0, 0, 0, 0]。</br>
 * decimalNumber - {number} 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。</br>
 * useBackground - {boolean} 是否使用图表背景框，默认不使用。</br>
 * backgroundStyle - {Object} 背景样式，此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Rectangle::style>。</br>
 * backgroundRadius - {Array<number>} 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4 ,则 backgroundRadius 为 [r1、r2、r3、r4 ]，默认值[0, 0, 0, 0]。</br>
 *innerRingRadius - {number} 环状图内环半径，默认值: 0，取值范围大于 0，小于外环半径（外环半径：数据视图框长和宽中较小值的二分之一）。</br>
 *sectorStyle - {Object} 环状图中扇形的基础 style，此参数控制环状图扇形基础样式，优先级低于 sectorStyleByFields 和 sectorStyleByCodomain。
 * 此样式对象对象可设属性： <SuperMap.Feature.ShapeParameters.Sector::style> 。</br>
 * sectorStyleByFields - {Array<Object>} 按专题字段 themeFields（<SuperMap.Layer.Graph::themeFields>）为环状图扇形赋 style，此参数按字段控制环状图扇形样式，优先级低于 sectorStyleByCodomain，高于 sectorStyle。此数组中的元素是样式对象，其可设属性： <SuperMap.Feature.ShapeParameters.Sector::style> 。</br>
 * 此参数中的 style 与 themeFields 中的字段一一对应 。例如： themeFields（<SuperMap.Layer.Graph::themeFields>） 为 ["POP_1992", "POP_1995", "POP_1999"],sectorStyleByFields 为[style1, style2, style3]，则在图表中，字段 POP_1992 对应的环状图扇形使用 style1，字段 POP_1995 对应的环状图扇形使用 style2 ，字段 POP_1999 对应的环状图扇形使用 style3。</br>
 * sectorStyleByCodomain - {Array<Object>} 按环状图扇形代表的数据值所在值域范围控制环状图扇形样式，优先级高于 sectorStyle 和 sectorStyleByFields。</br>
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数。</br>
 * @param layer - {SuperMap.Layer.Graph} 此专题要素所在图层，必设参数。</br>
 * @param fields - {Array<string>} data 中的参与此图表生成的字段名称，必设参数。</br>
 * @param setting - {Object} 图表配置对象，必设参数。</br>
 * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。</br>
 *
 * @example
 * // sectorStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <SuperMap.Feature.ShapeParameters.Sector::style> 。
 * // sectorStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * sectorHoverStyle - {Object} 环状图扇形 hover 状态时的样式，sectorHoverAble 为 true 时有效。
 * sectorHoverAble - {Object} 是否允许环状图扇形使用 hover 状态，默认允许。同时设置 sectorHoverAble 和 sectorClickAble 为 false，可以直接屏蔽环状图扇形对专题图层事件的响应。
 * sectorClickAble - {Object} 是否允许环状图扇形被点击，默认允许。同时设置 sectorHoverAble 和 sectorClickAble 为 false，可以直接屏蔽环状图扇形对专题图层事件的响应。
 *
 * @extends {SuperMap.Feature.Theme.Graph}
 */
var Ring = exports.Ring = function (_Graph) {
    _inherits(Ring, _Graph);

    function Ring(data, layer, fields, setting, lonlat) {
        _classCallCheck(this, Ring);

        var _this = _possibleConstructorReturn(this, (Ring.__proto__ || Object.getPrototypeOf(Ring)).call(this, data, layer, fields, setting, lonlat));

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Ring";
        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Ring.prototype.destroy
     * @description 销毁此专题要素。调用 destroy 后此对象所以属性置为 null。
     */


    _createClass(Ring, [{
        key: 'destroy',
        value: function destroy() {
            _get(Ring.prototype.__proto__ || Object.getPrototypeOf(Ring.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Ring.prototype.assembleShapes
         * @description 装配图形（扩展接口）。
         */

    }, {
        key: 'assembleShapes',
        value: function assembleShapes() {
            // 重要步骤：初始化参数
            if (!this.initBaseParameter()) {
                return;
            }

            // 一个默认 style 组
            var defaultStyleGroup = [{ fillColor: "#ff9277" }, { fillColor: "#dddd00" }, { fillColor: "#ffc877" }, { fillColor: "#bbe3ff" }, { fillColor: "#d5ffbb" }, { fillColor: "#bbbbff" }, { fillColor: "#ddb000" }, { fillColor: "#b0dd00" }, { fillColor: "#e2bbff" }, { fillColor: "#ffbbe3" }, { fillColor: "#ff7777" }, { fillColor: "#ff9900" }, { fillColor: "#83dd00" }, { fillColor: "#77e3ff" }, { fillColor: "#778fff" }, { fillColor: "#c877ff" }, { fillColor: "#ff77ab" }, { fillColor: "#ff6600" }, { fillColor: "#aa8800" }, { fillColor: "#77c7ff" }, { fillColor: "#ad77ff" }, { fillColor: "#ff77ff" }, { fillColor: "#dd0083" }, { fillColor: "#777700" }, { fillColor: "#00aa00" }, { fillColor: "#0088aa" }, { fillColor: "#8400dd" }, { fillColor: "#aa0088" }, { fillColor: "#dd0000" }, { fillColor: "#772e00" }];

            // 图表配置对象
            var sets = this.setting;

            // 背景框，默认不启用
            if (sets.useBackground) {
                this.shapes.push(_ShapeFactory.ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
            }

            // 数据值数组
            var fv = this.dataValues;
            if (fv.length < 1) {
                return;
            } // 没有数据

            // 值域范围
            var codomain = this.DVBCodomain;
            // 值域范围检测
            for (var _i = 0; _i < fv.length; _i++) {
                if (fv[_i] < codomain[0] || fv[_i] > codomain[1]) {
                    return;
                }
            }

            // 值的绝对值总和
            var valueSum = 0;
            for (var _i2 = 0; _i2 < fv.length; _i2++) {
                valueSum += Math.abs(fv[_i2]);
            }

            // 重要步骤：定义图表 Ring 数据视图框中单位值的含义，单位值：每度代表的数值
            this.DVBUnitValue = 360 / valueSum;
            var uv = this.DVBUnitValue;

            var dvbCenter = this.DVBCenterPoint; // 数据视图框中心作为扇心

            var startAngle = 0; // 扇形起始边角度
            var endAngle = 0; // 扇形终止边角度
            var startAngleTmp = startAngle; // 扇形临时起始边角度
            // 扇形外环（自适应）半径
            var r = this.DVBHeight < this.DVBWidth ? this.DVBHeight / 2 : this.DVBWidth / 2;

            // 扇形内环（自适应）半径
            var isInRange = sets.innerRingRadius >= 0 && sets.innerRingRadius < r;
            var r0 = typeof sets.innerRingRadius !== "undefined" && !isNaN(sets.innerRingRadius) && isInRange ? sets.innerRingRadius : 0;

            for (var i = 0; i < fv.length; i++) {
                var fvi = Math.abs(fv[i]);

                // 计算结束角度
                if (i === 0) {
                    endAngle = startAngle + fvi * uv;
                } else if (i === fvi.length - 1) {
                    endAngle = startAngleTmp;
                } else {
                    endAngle = startAngle + fvi * uv;
                }

                // 扇形参数对象
                var sectorSP = new _Sector.Sector(dvbCenter[0], dvbCenter[1], r, startAngle, endAngle, r0);
                // 扇形样式
                if (typeof sets.sectorStyleByFields === "undefined") {
                    // 使用默认 style 组
                    var colorIndex = i % defaultStyleGroup.length;
                    sectorSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, defaultStyleGroup, null, colorIndex);
                } else {
                    sectorSP.style = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, sets.sectorStyleByFields, sets.sectorStyleByCodomain, i, fv[i]);
                }
                // 扇形 hover 样式
                sectorSP.highlightStyle = _ShapeFactory.ShapeFactory.ShapeStyleTool(null, sets.sectorHoverStyle);
                // 扇形 hover 与 click 设置
                if (typeof sets.sectorHoverAble !== "undefined") {
                    sectorSP.hoverable = sets.sectorHoverAble;
                }
                if (typeof sets.sectorClickAble !== "undefined") {
                    sectorSP.clickable = sets.sectorClickAble;
                }
                // 图形携带的数据信息
                sectorSP.refDataID = this.data.id;
                sectorSP.dataInfo = {
                    field: this.fields[i],
                    value: fv[i]
                };

                // 创建扇形并把此扇形添加到图表图形数组
                this.shapes.push(this.shapeFactory.createShape(sectorSP));

                // 把上一次的结束角度作为下一次的起始角度
                startAngle = endAngle;
            }

            // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
            // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
            this.shapesConvertToRelativeCoordinate();
        }
    }]);

    return Ring;
}(_Graph2.Graph);

_SuperMap.SuperMap.Feature.Theme.Ring = Ring;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThemeVector = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SuperMap = __webpack_require__(0);

var _Geometry = __webpack_require__(26);

var _Util = __webpack_require__(1);

var _Theme2 = __webpack_require__(77);

var _Rectangle = __webpack_require__(142);

var _Point = __webpack_require__(18);

var _Collection = __webpack_require__(27);

var _MultiPoint = __webpack_require__(38);

var _LineString = __webpack_require__(17);

var _MultiLineString = __webpack_require__(47);

var _LinearRing = __webpack_require__(31);

var _Polygon = __webpack_require__(49);

var _MultiPolygon = __webpack_require__(48);

var _Curve = __webpack_require__(90);

var _GeoText = __webpack_require__(91);

var _SmicPoint = __webpack_require__(108);

var _SmicBrokenLine = __webpack_require__(106);

var _SmicText = __webpack_require__(110);

var _SmicRectangle = __webpack_require__(109);

var _SmicPolygon = __webpack_require__(80);

var _LonLat = __webpack_require__(37);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class SuperMap.Feature.Theme.Vector
 * @classdesc 矢量专题要素类。
 * @extends SuperMap.Feature.Theme
 * @param data - {SuperMap.Feature.Vector}  用户数据，必设参数, 矢量专题要素的类型为矢量数据 feature。
 * @param layer - {SuperMap.Layer} 此专题要素所在图层，必设参数。
 * @param style - {Object} 样式。
 * @param options - {Object} 创建专题要素时的可选参数。<br>
 *        nodesClipPixel - {number}节点抽稀像素距离，默认值 2, 单位：像素。<br>
 *        isHoverAble - {boolean} 图形是否可 hover，默认 true。<br>
 *        isMultiHover - {boolean} 是否使用多图形高亮，isHoverAble 为 true 时生效 ，默认 true。<br>
 *        isClickAble - {boolean} 图形是否可点击，默认 true。<br>
 *        highlightStyle - {Object} 高亮样式。
 */
var ThemeVector = exports.ThemeVector = function (_Theme) {
    _inherits(ThemeVector, _Theme);

    function ThemeVector(data, layer, style, options, shapeOptions) {
        _classCallCheck(this, ThemeVector);

        //数据的 geometry 属性必须存在且类型是 SuperMap.Geometry 或其子类的类型
        var _this = _possibleConstructorReturn(this, (ThemeVector.__proto__ || Object.getPrototypeOf(ThemeVector)).call(this, data, layer));

        if (!data.geometry) {
            return _possibleConstructorReturn(_this);
        }
        if (!(data.geometry instanceof _Geometry.Geometry)) {
            return _possibleConstructorReturn(_this);
        }

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.dataBounds - {SuperMap.Bounds}
         * @description 用户数据的（feature.geometry）地理范围。
         */
        _this.dataBounds = data.geometry.getBounds();

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.nodesClipPixel - {number}
         * @description 节点抽稀像素距离，默认值 2。
         */
        _this.nodesClipPixel = 2;

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.isHoverAble - {boolean}
         * @description 图形是否可 hover，默认 true。
         */
        _this.isHoverAble = true;

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.isMultiHover - {boolean}
         * @description 是否使用多图形高亮，isHoverAble 为 true 时生效 ，默认 true。
         */
        _this.isMultiHover = true;

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.isClickAble - {boolean}
         * @description 图形是否可点击，默认 true。
         */
        _this.isClickAble = true;

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.highlightStyle - {Object}
         * @description 高亮样式。
         */
        _this.highlightStyle = null;

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.shapeOptions - {Object}
         * @description 添加到渲染器前修改 shape 的一些属性，非特殊情况通常不允许这么做。
         */
        _this.shapeOptions = {};

        /**
         * @member SuperMap.Feature.Theme.Vector.prototype.style - {Object}
         * @description 可视化图形的 style。在子类中规定其对象结构和默认属性值。
         */
        _this.style = style || {};

        _this.CLASS_NAME = "SuperMap.Feature.Theme.Vector";
        _this.style = style ? style : {};
        if (options) {
            _Util.Util.copyAttributesWithClip(_this, options, ["shapeOptions", "dataBounds"]);
        }
        if (shapeOptions) {
            _Util.Util.copyAttributesWithClip(_this.shapeOptions, shapeOptions);
        }

        //设置基础参数 dataBounds、lonlat、location
        var geometry = data.geometry;
        _this.lonlat = _this.dataBounds.getCenterLonLat();
        _this.location = _this.getLocalXY(_this.lonlat);

        //将地理要素转为专题要素
        if (geometry instanceof _LinearRing.LinearRing) {
            _this.lineToTF(geometry);
        } else if (geometry instanceof _LineString.LineString) {
            _this.lineToTF(geometry);
        } else if (geometry instanceof _Curve.Curve) {
            //独立几何体
        } else if (geometry instanceof _MultiPoint.MultiPoint) {
            _this.multiPointToTF(geometry);
        } else if (geometry instanceof _MultiLineString.MultiLineString) {

            _this.multiLineStringToTF(geometry);
        } else if (geometry instanceof _MultiPolygon.MultiPolygon) {
            _this.multiPolygonToTF(geometry);
        } else if (geometry instanceof _Polygon.Polygon) {
            _this.polygonToTF(geometry);
        } else if (geometry instanceof _Collection.Collection) {
            //独立几何体
        } else if (geometry instanceof _Point.Point) {
            _this.pointToTF(geometry);
        } else if (geometry instanceof _Rectangle.Rectangle) {
            _this.rectangleToTF(geometry);
        } else if (geometry instanceof _GeoText.GeoText) {
            _this.geoTextToTF(geometry);
        }

        return _this;
    }

    /**
     * @function SuperMap.Feature.Theme.Vector.prototype.destroy
     * @override
     */


    _createClass(ThemeVector, [{
        key: 'destroy',
        value: function destroy() {
            this.style = null;
            this.dataBounds = null;
            this.nodesClipPixel = null;
            this.isHoverAble = null;
            this.isMultiHover = null;
            this.isClickAble = null;
            this.highlightStyle = null;
            this.shapeOptions = null;
            _get(ThemeVector.prototype.__proto__ || Object.getPrototypeOf(ThemeVector.prototype), 'destroy', this).call(this);
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.lineToTF
         * @description 转换线和线环要素。
         * @param geometry - {SuperMap.Geometry} 用户数据几何地理信息，这里必须是 LineString 或 LineRing。
         */

    }, {
        key: 'lineToTF',
        value: function lineToTF(geometry) {
            var components = geometry.components;

            //节点像素坐标
            var localLX = [];
            //参考位置，参考中心为
            var refLocal = [];
            var location = this.location;
            var pointList = [];

            //节点抽稀距离
            var nCPx = this.nodesClipPixel;

            for (var i = 0; i < components.length; i++) {
                var components_i = components[i];
                refLocal = [];
                localLX = this.getLocalXY(components_i);

                refLocal[0] = localLX[0] - location[0];
                refLocal[1] = localLX[1] - location[1];

                //抽稀 - 2 px
                if (pointList.length > 0) {
                    var lastLocalXY = pointList[pointList.length - 1];
                    if (Math.abs(lastLocalXY[0] - refLocal[0]) <= nCPx && Math.abs(lastLocalXY[1] - refLocal[1]) <= nCPx) {
                        continue;
                    }
                }

                //使用参考点
                pointList.push(refLocal);
            }

            if (pointList.length < 2) {
                return null;
            }

            //赋 style
            var style = new Object();
            style = _Util.Util.copyAttributesWithClip(style, this.style, ['pointList']);
            style.pointList = pointList;

            //创建图形
            var shape = new _SmicBrokenLine.SmicBrokenLine({
                style: style,
                clickable: this.isClickAble,
                hoverable: this.isHoverAble
            });

            //设置高亮样式
            if (this.highlightStyle) {
                shape.highlightStyle = this.highlightStyle;
            }

            //设置参考中心，指定图形位置
            shape.refOriginalPosition = this.location;

            //储存数据 id 属性，用于事件
            shape.refDataID = this.data.id;

            //储存数据 id 属性，用于事件-多图形同时高亮
            shape.isHoverByRefDataID = this.isMultiHover;

            //添加到渲染器前修改 shape 的一些属性，非特殊情况通常不允许这么做
            if (this.shapeOptions) {
                _Util.Util.copyAttributesWithClip(shape, this.shapeOptions);
            }

            this.shapes.push(shape);
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.multiPointToTF
         * @description 转多点要素。
         * @param geometry - {SuperMap.Geometry} 用户数据几何地理信息，这里必须是 MultiPoint。
         */

    }, {
        key: 'multiPointToTF',
        value: function multiPointToTF(geometry) {
            /*   //-- 不抽稀
             var components = geometry.components;
               for(var i = 0; i < components.length; i++){
             var components_i = components[i];
             this.pointToTF(components_i);
             }
             */

            var components = geometry.components;

            //节点像素坐标
            var localLX = [];
            //参考位置，参考中心为
            var refLocal = [];
            var location = this.location;
            var pointList = [];

            //节点抽稀距离
            var nCPx = this.nodesClipPixel;

            for (var i = 0; i < components.length; i++) {
                var components_i = components[i];
                refLocal = [];
                localLX = this.getLocalXY(components_i);

                refLocal[0] = localLX[0] - location[0];
                refLocal[1] = localLX[1] - location[1];

                //抽稀
                if (pointList.length > 0) {
                    var lastLocalXY = pointList[pointList.length - 1];
                    if (Math.abs(lastLocalXY[0] - refLocal[0]) <= nCPx && Math.abs(lastLocalXY[1] - refLocal[1]) <= nCPx) {
                        continue;
                    }
                }

                //使用参考点
                pointList.push(refLocal);

                //赋 style
                var style = new Object();
                style.r = 6; //防止漏设此参数，默认 6 像素
                style = _Util.Util.copyAttributesWithClip(style, this.style);
                style.x = refLocal[0];
                style.y = refLocal[1];

                //创建图形
                var shape = new _SmicPoint.SmicPoint({
                    style: style,
                    clickable: this.isClickAble,
                    hoverable: this.isHoverAble
                });

                //设置高亮样式
                if (this.highlightStyle) {
                    shape.highlightStyle = this.highlightStyle;
                }

                //设置参考中心，指定图形位置
                shape.refOriginalPosition = location;

                //储存数据 id 属性，用于事件
                shape.refDataID = this.data.id;

                //储存数据 id 属性，用于事件-多图形同时高亮
                shape.isHoverByRefDataID = this.isMultiHover;

                //修改一些 shape 可选属性，通常不需要这么做
                if (this.shapeOptions) {
                    _Util.Util.copyAttributesWithClip(shape, this.shapeOptions);
                }

                this.shapes.push(shape);
            }
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.multiLineStringToTF
         * @description 转换多线要素。
         * @param geometry - {SuperMap.Geometry} 用户数据几何地理信息，这里必须是 MultiLineString。
         */

    }, {
        key: 'multiLineStringToTF',
        value: function multiLineStringToTF(geometry) {
            var components = geometry.components;

            for (var i = 0; i < components.length; i++) {
                var components_i = components[i];
                this.lineToTF(components_i);
            }
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.multiPolygonToTF
         * @description 转换多面要素。
         * @param geometry - {SuperMap.Geometry}  用户数据几何地理信息，这里必须是 MultiPolygon。
         */

    }, {
        key: 'multiPolygonToTF',
        value: function multiPolygonToTF(geometry) {
            var components = geometry.components;

            for (var i = 0; i < components.length; i++) {
                var components_i = components[i];
                this.polygonToTF(components_i);
            }
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.pointToTF
         * @description 转换点要素。
         * @param geometry - {SuperMap.Geometry}  用户数据几何地理信息，这里必须是 Point。
         */

    }, {
        key: 'pointToTF',
        value: function pointToTF(geometry) {
            //参考位置，参考中心为
            var location = this.location;
            //geometry 像素坐标
            var localLX = this.getLocalXY(geometry);

            //赋 style
            var style = new Object();
            style.r = 6; //防止漏设此参数，默认 6 像素
            style = _Util.Util.copyAttributesWithClip(style, this.style);
            style.x = localLX[0] - location[0];
            style.y = localLX[1] - location[1];

            //创建图形
            var shape = new _SmicPoint.SmicPoint({
                style: style,
                clickable: this.isClickAble,
                hoverable: this.isHoverAble
            });

            //设置高亮样式
            if (this.highlightStyle) {
                shape.highlightStyle = this.highlightStyle;
            }

            //设置参考中心，指定图形位置
            shape.refOriginalPosition = location;

            //储存数据 id 属性，用于事件
            shape.refDataID = this.data.id;

            //储存数据 id 属性，用于事件-多图形同时高亮
            shape.isHoverByRefDataID = this.isMultiHover;

            //修改一些 shape 可选属性，通常不需要这么做
            if (this.shapeOptions) {
                _Util.Util.copyAttributesWithClip(shape, this.shapeOptions);
            }

            this.shapes.push(shape);
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.polygonToThemeFeature
         * @description 转换面要素。
         * @param geometry - {SuperMap.Geometry} 用户数据几何地理信息，这里必须是 Polygon。
         */

    }, {
        key: 'polygonToTF',
        value: function polygonToTF(geometry) {
            var components = geometry.components;

            //节点像素坐标
            var localLX = [];
            //参考位置，参考中心为
            var refLocal = [];
            var location = this.location;
            var pointList = [];
            //岛洞
            var holePolygonPointList = [];
            var holePolygonPointLists = [];

            //节点抽稀距离
            var nCPx = this.nodesClipPixel;

            for (var i = 0; i < components.length; i++) {
                var components_i = components[i].components;

                if (i === 0) {
                    // 第一个 component 正常绘制
                    pointList = [];

                    for (var j = 0; j < components_i.length; j++) {
                        refLocal = [];
                        localLX = this.getLocalXY(components_i[j]);

                        refLocal[0] = localLX[0] - location[0];
                        refLocal[1] = localLX[1] - location[1];

                        //抽稀 - 2 px
                        if (pointList.length > 0) {
                            var lastLocalXY = pointList[pointList.length - 1];
                            if (Math.abs(lastLocalXY[0] - refLocal[0]) <= nCPx && Math.abs(lastLocalXY[1] - refLocal[1]) <= nCPx) {
                                continue;
                            }
                        }

                        //使用参考点
                        pointList.push(refLocal);
                    }
                } else {
                    // 其它 component 作为岛洞
                    holePolygonPointList = [];

                    for (var k = 0; k < components_i.length; k++) {
                        refLocal = [];
                        localLX = this.getLocalXY(components_i[k]);

                        refLocal[0] = localLX[0] - location[0];
                        refLocal[1] = localLX[1] - location[1];

                        //抽稀 - 2 px
                        if (holePolygonPointList.length > 0) {
                            var lastXY = holePolygonPointList[holePolygonPointList.length - 1];
                            if (Math.abs(lastXY[0] - refLocal[0]) <= nCPx && Math.abs(lastXY[1] - refLocal[1]) <= nCPx) {
                                continue;
                            }
                        }

                        //使用参考点
                        holePolygonPointList.push(refLocal);
                    }
                }

                if (holePolygonPointList.length < 2) {
                    continue;
                }

                holePolygonPointLists.push(holePolygonPointList);
            }

            if (pointList.length < 2) {
                return;
            }

            //赋 style
            var style = {};
            style = _Util.Util.copyAttributesWithClip(style, this.style, ['pointList']);
            style.pointList = pointList;

            //创建图形
            var shape = new _SmicPolygon.SmicPolygon({
                style: style,
                clickable: this.isClickAble,
                hoverable: this.isHoverAble
            });

            //设置高亮样式
            if (this.highlightStyle) {
                shape.highlightStyle = this.highlightStyle;
            }

            //设置参考中心，指定图形位置
            shape.refOriginalPosition = this.location;

            //储存数据 id 属性，用于事件
            shape.refDataID = this.data.id;

            //储存数据 id 属性，用于事件-多图形同时高亮
            shape.isHoverByRefDataID = this.isMultiHover;

            //岛洞面
            if (holePolygonPointLists.length > 0) {
                shape.holePolygonPointLists = holePolygonPointLists;
            }

            //修改一些 shape 可选属性，通常不需要这么做
            if (this.shapeOptions) {
                _Util.Util.copyAttributesWithClip(shape, this.shapeOptions);
            }

            this.shapes.push(shape);
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.rectangleToTF
         * @description 转换矩形要素。
         * @param geometry - {SuperMap.Geometry}  用户数据几何地理信息，这里必须是 Rectangle。
         */

    }, {
        key: 'rectangleToTF',
        value: function rectangleToTF(geometry) {
            //参考位置，参考中心为
            var location = this.location;
            var ll = new _LonLat.LonLat(geometry.x, geometry.y);

            //地图分辨率
            var res = this.layer.map.getResolution();

            //geometry 像素坐标
            var localLX = this.getLocalXY(ll);

            //赋 style
            var style = new Object();
            style.r = 6; //防止漏设此参数，默认 6 像素
            style = _Util.Util.copyAttributesWithClip(style, this.style);
            style.x = localLX[0] - location[0];
            // SuperMap.Geometry.Rectangle 使用左下角定位， SmicRectangle 使用左上角定位，需要转换
            style.y = localLX[1] - location[1] - 2 * geometry.width / res;
            style.width = geometry.width / res;
            style.height = geometry.height / res;

            //创建图形
            var shape = new _SmicRectangle.SmicRectangle({
                style: style,
                clickable: this.isClickAble,
                hoverable: this.isHoverAble
            });

            //设置高亮样式
            if (this.highlightStyle) {
                shape.highlightStyle = this.highlightStyle;
            }

            //设置参考中心，指定图形位置
            shape.refOriginalPosition = location;

            //储存数据 id 属性，用于事件
            shape.refDataID = this.data.id;

            //储存数据 id 属性，用于事件-多图形同时高亮
            shape.isHoverByRefDataID = this.isMultiHover;

            //修改一些 shape 可选属性，通常不需要这么做
            if (this.shapeOptions) {
                _Util.Util.copyAttributesWithClip(shape, this.shapeOptions);
            }

            this.shapes.push(shape);
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.geoTextToTF
         * @description 转换文本要素。
         * @param geometry - {SuperMap.Geometry}  用户数据几何地理信息，这里必须是 GeoText。
         */

    }, {
        key: 'geoTextToTF',
        value: function geoTextToTF(geometry) {
            //参考位置，参考中心为
            var location = this.location;
            //geometry 像素坐标
            var localLX = this.getLocalXY(geometry);

            //赋 style
            var style = new Object();
            style.r = 6; //防止漏设此参数，默认 6 像素
            style = _Util.Util.copyAttributesWithClip(style, this.style, ["x", "y", "text"]);
            style.x = localLX[0] - location[0];
            style.y = localLX[1] - location[1];
            style.text = geometry.text;

            //创建图形
            var shape = new _SmicText.SmicText({
                style: style,
                clickable: this.isClickAble,
                hoverable: this.isHoverAble
            });

            //设置高亮样式
            if (this.highlightStyle) {
                shape.highlightStyle = this.highlightStyle;
            }

            //设置参考中心，指定图形位置
            shape.refOriginalPosition = location;

            //储存数据 id 属性，用于事件
            shape.refDataID = this.data.id;

            //储存数据 id 属性，用于事件-多图形同时高亮
            shape.isHoverByRefDataID = this.isMultiHover;

            //修改一些 shape 可选属性，通常不需要这么做
            if (this.shapeOptions) {
                _Util.Util.copyAttributesWithClip(shape, this.shapeOptions);
            }

            this.shapes.push(shape);
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.updateAndAddShapes
         * @description 修改位置，针对地图平移操作，地图漫游操作后调用此函数。
         */

    }, {
        key: 'updateAndAddShapes',
        value: function updateAndAddShapes() {
            var newLocalLX = this.getLocalXY(this.lonlat);
            this.location = newLocalLX;

            var render = this.layer.renderer;
            for (var i = 0, len = this.shapes.length; i < len; i++) {
                var shape = this.shapes[i];
                //设置参考中心，指定图形位置
                shape.refOriginalPosition = newLocalLX;
                render.addShape(shape);
            }
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.getShapesCount
         * @description 获得专题要素中可视化图形的数量。
         * @return {number} 可视化图形的数量。
         */

    }, {
        key: 'getShapesCount',
        value: function getShapesCount() {
            return this.shapes.length;
        }

        /**
         * @function SuperMap.Feature.Theme.Vector.prototype.getLocalXY
         * @description 地理坐标转为像素坐标。
         * @param lonlat - {SuperMap.LonLat} 专题要素地理位置。
         */

    }, {
        key: 'getLocalXY',
        value: function getLocalXY(lonlat) {
            return this.layer.getLocalXY(lonlat);
        }
    }]);

    return ThemeVector;
}(_Theme2.Theme);

_SuperMap.SuperMap.Feature.Theme.ThemeVector = ThemeVector;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ShapeFactory = __webpack_require__(24);

Object.defineProperty(exports, 'ShapeFactory', {
  enumerable: true,
  get: function get() {
    return _ShapeFactory.ShapeFactory;
  }
});

var _ShapeParameters = __webpack_require__(25);

Object.defineProperty(exports, 'ShapeParameters', {
  enumerable: true,
  get: function get() {
    return _ShapeParameters.ShapeParameters;
  }
});

var _Circle = __webpack_require__(103);

Object.defineProperty(exports, 'FeatureCircle', {
  enumerable: true,
  get: function get() {
    return _Circle.Circle;
  }
});

var _Image = __webpack_require__(260);

Object.defineProperty(exports, 'Image', {
  enumerable: true,
  get: function get() {
    return _Image.Image;
  }
});

var _Label = __webpack_require__(261);

Object.defineProperty(exports, 'Label', {
  enumerable: true,
  get: function get() {
    return _Label.Label;
  }
});

var _Line = __webpack_require__(104);

Object.defineProperty(exports, 'FeatureLine', {
  enumerable: true,
  get: function get() {
    return _Line.Line;
  }
});

var _Point = __webpack_require__(74);

Object.defineProperty(exports, 'Point', {
  enumerable: true,
  get: function get() {
    return _Point.Point;
  }
});

var _Polygon = __webpack_require__(75);

Object.defineProperty(exports, 'FeaturePolygon', {
  enumerable: true,
  get: function get() {
    return _Polygon.Polygon;
  }
});

var _Rectangle = __webpack_require__(262);

Object.defineProperty(exports, 'FeatureRectangle', {
  enumerable: true,
  get: function get() {
    return _Rectangle.Rectangle;
  }
});

var _Sector = __webpack_require__(76);

Object.defineProperty(exports, 'Sector', {
  enumerable: true,
  get: function get() {
    return _Sector.Sector;
  }
});

var _Theme = __webpack_require__(77);

Object.defineProperty(exports, 'FeatureTheme', {
  enumerable: true,
  get: function get() {
    return _Theme.Theme;
  }
});

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Bar = __webpack_require__(417);

Object.defineProperty(exports, "Bar", {
  enumerable: true,
  get: function get() {
    return _Bar.Bar;
  }
});

var _Bar3D = __webpack_require__(418);

Object.defineProperty(exports, "Bar3D", {
  enumerable: true,
  get: function get() {
    return _Bar3D.Bar3D;
  }
});

var _Circle = __webpack_require__(419);

Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _Circle.Circle;
  }
});

var _Graph = __webpack_require__(28);

Object.defineProperty(exports, "Graph", {
  enumerable: true,
  get: function get() {
    return _Graph.Graph;
  }
});

var _Line = __webpack_require__(420);

Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _Line.Line;
  }
});

var _Pie = __webpack_require__(421);

Object.defineProperty(exports, "Pie", {
  enumerable: true,
  get: function get() {
    return _Pie.Pie;
  }
});

var _Point = __webpack_require__(422);

Object.defineProperty(exports, "OverlayPoint", {
  enumerable: true,
  get: function get() {
    return _Point.Point;
  }
});

var _RankSymbol = __webpack_require__(259);

Object.defineProperty(exports, "RankSymbol", {
  enumerable: true,
  get: function get() {
    return _RankSymbol.RankSymbol;
  }
});

var _Ring = __webpack_require__(423);

Object.defineProperty(exports, "Ring", {
  enumerable: true,
  get: function get() {
    return _Ring.Ring;
  }
});

var _ThemeVector = __webpack_require__(424);

Object.defineProperty(exports, "ThemeVector", {
  enumerable: true,
  get: function get() {
    return _ThemeVector.ThemeVector;
  }
});

var _feature = __webpack_require__(425);

Object.keys(_feature).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _feature[key];
    }
  });
});

var _levelRenderer = __webpack_require__(432);

Object.keys(_levelRenderer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _levelRenderer[key];
    }
  });
});

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LevelRenderer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _Render = __webpack_require__(277);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @private
 * @class  SuperMap.LevelRenderer
 * LevelRenderer 渲染器。
 *
 */
var LevelRenderer = exports.LevelRenderer = function () {

    /**
     * Constructor: SuperMap.LevelRenderer
     * 构造函数。
     *
     * (code)
     * //在渲染器上加上图形
     * var levelRenderer = new SuperMap.LevelRenderer();
     * var zr = levelRenderer.init(document.getElementById('lRendertest'));
     * zr.clear();
     * zr.addShape(new SuperMap.LevelRenderer.Shape.Circle({
     *     style:{
     *         x : 100,
     *         y : 100,
     *         r : 50,
     *         brushType: 'fill'
     *     }
     * }));
     * zr.render();
     * (end)
     */
    function LevelRenderer() {
        _classCallCheck(this, LevelRenderer);

        /**
         * Property: _instances
         * {Object} LevelRenderer 实例 map 索引。
         */
        LevelRenderer._instances = {};

        // 工具
        LevelRenderer.Tool = {};

        /**
         * Property: version
         * {String} 版本。zRender（Baidu） 的版本号，
         * 记录当前 LevelRenderer 是在 zRender 的那个版本上构建而来。
         * 在每次完整评判和实施由 zRender（Baidu）升级带来的 LevelRenderer 升级后修改。
         *
         */
        this.version = '2.0.4';

        this.CLASS_NAME = "SuperMap.LevelRenderer";
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(LevelRenderer, [{
        key: 'destroy',
        value: function destroy() {
            this.dispose();
            this.version = null;
        }

        /**
         * APIMethod: init
         * 创建 LevelRenderer 实例。
         *
         * 不让外部直接 new LevelRenderer 实例，为啥？。
         * 不为啥，提供全局可控同时减少全局污染和降低命名冲突的风险！
         *
         * Parameters:
         * dom - {HTMLElement} 绘图容器。
         *
         * Returns:
         * {<SuperMap.LevelRenderer>} LevelRenderer 实例。
         */

    }, {
        key: 'init',
        value: function init(dom) {
            var zr = new _Render.Render(_Util.Util.createUniqueID("LRenderer_"), dom);
            LevelRenderer._instances[zr.id] = zr;
            return zr;
        }

        /**
         * APIMethod: dispose
         * LevelRenderer 实例销毁。
         *
         * 在 SuperMap.LevelRenderer._instances 里的索引也会删除了。
         * 管生就得管死，可以通过 zrender.dispose(zr) 销毁指定 SuperMap.LevelRenderer.Render 实例。
         * 当然也可以直接 zr.dispose() 自己销毁
         *
         * Parameters:
         * zr - {<SuperMap.LevelRenderer.Render>} ZRender对象，不传则销毁全部。
         *
         * Returns:
         * {<SuperMap.LevelRenderer>} this。
         */

    }, {
        key: 'dispose',
        value: function dispose(zr) {
            if (zr) {
                zr.dispose();
                this.delInstance(zr.id);
            } else {
                for (var key in LevelRenderer._instances) {
                    LevelRenderer._instances[key].dispose();
                }
                LevelRenderer._instances = {};
            }

            return this;
        }

        /**
         * APIMethod: getInstance
         * 获取 SuperMap.LevelRenderer.Render 实例。
         *
         * Parameters:
         * id - {String} ZRender对象索引。
         *
         * Returns:
         * {<SuperMap.LevelRenderer.Render>} SuperMap.LevelRenderer.Render 实例。
         */

    }, {
        key: 'getInstance',
        value: function getInstance(id) {
            return LevelRenderer._instances[id];
        }

        /**
         * APIMethod: delInstance
         * 删除 zrender 实例，SuperMap.LevelRenderer.Render 实例 dispose 时会调用，
         * 删除后 getInstance 则返回 undefined
         * ps: 仅是删除，删除的实例不代表已经 dispose 了~~
         *     这是一个摆脱全局 zrender.dispose() 自动销毁的后门，
         *     take care of yourself~
         *
         *
         * Parameters:
         * id - {String} SuperMap.LevelRenderer.Render 对象索引。
         *
         * Returns:
         * {<SuperMap.LevelRenderer>} this。
         */

    }, {
        key: 'delInstance',
        value: function delInstance(id) {
            delete LevelRenderer._instances[id];
            return this;
        }
    }]);

    return LevelRenderer;
}();

_SuperMap.SuperMap.LevelRenderer = LevelRenderer;

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicEllipse = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicEllipse
 * 椭圆。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicEllipse({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           a: 40,
 *           b: 20,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'SmicEllipse'
 *       }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicEllipse = exports.SmicEllipse = function (_Shape) {
    _inherits(SmicEllipse, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 圆心 x 坐标，必设参数。
     * y - {Number} 圆心 y 坐标，必设参数。
     * a - {Number} 横轴半径，必设参数。
     * b - {Number} 纵轴半径，必设参数。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style
    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicEllipse
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicEllipse(options) {
        _classCallCheck(this, SmicEllipse);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicEllipse.__proto__ || Object.getPrototypeOf(SmicEllipse)).call(this, options));

        _this.type = 'smicellipse';

        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }

        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicEllipse";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicEllipse, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicEllipse.prototype.__proto__ || Object.getPrototypeOf(SmicEllipse.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 构建椭圆的 Path。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var k = 0.5522848;
            var x = style.x + __OP[0];
            var y = style.y + __OP[1];
            var a = style.a;
            var b = style.b;
            var ox = a * k; // 水平控制点偏移量
            var oy = b * k; // 垂直控制点偏移量
            // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
            ctx.moveTo(x - a, y);
            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
            ctx.closePath();
        }

        /**
         * APIMethod: getRect
         * 计算返回椭圆包围盒矩形
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x + __OP[0] - style.a - lineWidth / 2),
                y: Math.round(style.x + __OP[1] - style.b - lineWidth / 2),
                width: style.a * 2 + lineWidth,
                height: style.b * 2 + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicEllipse;
}(_Shape2.Shape);

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicIsogon = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicIsogon
 * 正多边形。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 */
var SmicIsogon = exports.SmicIsogon = function (_Shape) {
    _inherits(SmicIsogon, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 正 n 边形外接圆心 x 坐标，必设参数。
     * y - {Number} 正 n 边形外接圆心 y 坐标，必设参数。
     * r - {Number} 正n边形外接圆半径，必设参数。
     *ｎ - {Number} 指明正几边形，必设参数（n>=3）。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style


    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicIsogon
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicIsogon(options) {
        _classCallCheck(this, SmicIsogon);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicIsogon.__proto__ || Object.getPrototypeOf(SmicIsogon)).call(this, options));

        _this.type = 'smicisogon';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicIsogon";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicIsogon, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicIsogon.prototype.__proto__ || Object.getPrototypeOf(SmicIsogon.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建n角星（n>=3）路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var sin = _SUtil.SUtil.Util_math.sin;
            var cos = _SUtil.SUtil.Util_math.cos;
            var PI = Math.PI;

            var n = style.n;
            if (!n || n < 2) {
                return;
            }

            var x = style.x + __OP[0];
            var y = style.y + __OP[1];
            var r = style.r;

            var dStep = 2 * PI / n;
            var deg = -PI / 2;
            var xStart = x + r * cos(deg);
            var yStart = y + r * sin(deg);
            deg += dStep;

            // 记录边界点，用于判断insight
            var pointList = style.pointList = [];
            pointList.push([xStart, yStart]);
            for (var i = 0, end = n - 1; i < end; i++) {
                pointList.push([x + r * cos(deg), y + r * sin(deg)]);
                deg += dStep;
            }
            pointList.push([xStart, yStart]);

            // 绘制
            ctx.moveTo(pointList[0][0], pointList[0][1]);
            for (var _i = 0; _i < pointList.length; _i++) {
                ctx.lineTo(pointList[_i][0], pointList[_i][1]);
            }
            ctx.closePath();

            return;
        }

        /**
         * APIMethod: getRect
         * 计算返回正多边形的包围盒矩形。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x + __OP[0] - style.r - lineWidth / 2),
                y: Math.round(style.y + __OP[1] - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicIsogon;
}(_Shape2.Shape);

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicRing = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicRing
 * 圆环。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicRing({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r0: 30,
 *             r: 50
 *         }
 *     });
 *   levelRenderer.addShape(shape);
 * (end)
 */
var SmicRing = exports.SmicRing = function (_Shape) {
    _inherits(SmicRing, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} 圆心 x 坐标，必设参数。
     * y - {Number} 圆心 y 坐标，必设参数。
     * r - {Number} 外圆半径，必设参数。
     * r0 - {Number} 内圆半径，必设参数。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style

    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicRing
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicRing(options) {
        _classCallCheck(this, SmicRing);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicRing.__proto__ || Object.getPrototypeOf(SmicRing)).call(this, options));

        _this.type = 'smicring';
        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }
        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicRing";

        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicRing, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicRing.prototype.__proto__ || Object.getPrototypeOf(SmicRing.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建圆环路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            // 非零环绕填充优化
            ctx.arc(style.x + __OP[0], style.y + __OP[1], style.r, 0, Math.PI * 2, false);
            ctx.moveTo(style.x + __OP[0] + style.r0, style.y + __OP[1]);
            ctx.arc(style.x + __OP[0], style.y + __OP[1], style.r0, 0, Math.PI * 2, true);
            return;
        }

        /**
         * APIMethod: getRect
         * 计算返回圆环包围盒矩阵
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x + __OP[0] - style.r - lineWidth / 2),
                y: Math.round(style.y + __OP[1] - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicRing;
}(_Shape2.Shape);

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SmicStar = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Shape2 = __webpack_require__(13);

var _SUtil = __webpack_require__(12);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @private
 * @class  SuperMap.LevelRenderer.Shape.SmicStar
 * n 角星（n>3）。
 *
 * Inherits from:
 *  - <SuperMap.LevelRenderer.Shape>
 *
 * (code)
 *   var shape = new SuperMap.LevelRenderer.Shape.SmicStar({
 *         style: {
 *             x: 200,
 *             y: 100,
 *             r: 150,
 *             n: 5,
 *             text: '五角星'
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * (end)
 *
 */
var SmicStar = exports.SmicStar = function (_Shape) {
    _inherits(SmicStar, _Shape);

    /**
     * Property: style
     * {Object} 绘制样式。
     *
     * Symbolizer properties:
     * x - {Number} n 角星外接圆心 x 坐标，必设参数。
     * y - {Number} n 角星外接圆心 y 坐标，必设参数。
     * r - {Number} n 角星外接圆半径，必设参数。
     * r0 - {Number} n 角星内部顶点（凹点）的外接圆半径。如果不指定此参数，则自动计算：取相隔外部顶点连线的交点作内部顶点。
     * n - {Number} 指明几角星，必设参数。
     * brushType - {String} 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
     * color - {String} 填充颜色。默认值："#000000'"。
     * strokeColor - {String} 描边颜色。默认值："#000000'"。
     * lineCape - {String} 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
     * lineWidth - {Number} 描边宽度。默认值：1。
     * opacity - {Number} 绘制透明度。默认值：1。
     * shadowBlur - {Number} 阴影模糊度，大于0有效。默认值：0。
     * shadowColor - {Number} 阴影颜色。默认值："#000000'"。
     * shadowOffsetX - {Number} 阴影横向偏移。默认值：0。
     * shadowOffsetY - {Number} 阴影纵向偏移。默认值：0。
     * text - {String} 图形中的附加文本。默认值：""。
     * textColor - {String} 文本颜色。默认值："#000000'"。
     * textFont - {String} 附加文本样式。示例:'bold 18px verdana'。
     * textPosition - {String} 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
     * textAlign - {String} 附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
     * textBaseline - {String} 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
     */
    //打开接口 style


    /**
     * Constructor: SuperMap.LevelRenderer.Shape.SmicStar
     * 构造函数。
     *
     * Parameters:
     * options - {Array} shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
     *
     */
    function SmicStar(options) {
        _classCallCheck(this, SmicStar);

        /**
         * Property: type
         * {String} 图形类型。
         */
        var _this = _possibleConstructorReturn(this, (SmicStar.__proto__ || Object.getPrototypeOf(SmicStar)).call(this, options));

        _this.type = 'smicstar';

        if (!_this.refOriginalPosition || _this.refOriginalPosition.length !== 2) {
            _this.refOriginalPosition = [0, 0];
        }

        _this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicStar";
        return _this;
    }

    /**
     * APIMethod: destroy
     * 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */


    _createClass(SmicStar, [{
        key: 'destroy',
        value: function destroy() {
            this.type = null;
            _get(SmicStar.prototype.__proto__ || Object.getPrototypeOf(SmicStar.prototype), 'destroy', this).call(this);
        }

        /**
         * APIMethod: buildPath
         * 创建n  角星（n>3）路径。
         *
         * Parameters:
         * ctx - {CanvasRenderingContext2D} Context2D 上下文。
         * style - {Object} style。
         *
         */

    }, {
        key: 'buildPath',
        value: function buildPath(ctx, style) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var n = style.n;
            if (!n || n < 2) {
                return;
            }

            var sin = _SUtil.SUtil.Util_math.sin;
            var cos = _SUtil.SUtil.Util_math.cos;
            var PI = Math.PI;

            var x = style.x + __OP[0];
            var y = style.y + __OP[1];
            var r = style.r;
            var r0 = style.r0;

            // 如果未指定内部顶点外接圆半径，则自动计算
            if (r0 == null) {
                r0 = n > 4
                // 相隔的外部顶点的连线的交点，
                // 被取为内部交点，以此计算r0
                ? r * cos(2 * PI / n) / cos(PI / n)
                // 二三四角星的特殊处理
                : r / 3;
            }

            var dStep = PI / n;
            var deg = -PI / 2;
            var xStart = x + r * cos(deg);
            var yStart = y + r * sin(deg);
            deg += dStep;

            // 记录边界点，用于判断inside
            var pointList = style.pointList = [];
            pointList.push([xStart, yStart]);
            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
                ri = i % 2 === 0 ? r0 : r;
                pointList.push([x + ri * cos(deg), y + ri * sin(deg)]);
                deg += dStep;
            }
            pointList.push([xStart, yStart]);

            // 绘制
            ctx.moveTo(pointList[0][0], pointList[0][1]);
            for (var _i = 0; _i < pointList.length; _i++) {
                ctx.lineTo(pointList[_i][0], pointList[_i][1]);
            }

            ctx.closePath();

            return;
        }

        /**
         * APIMethod: getRect
         * 返回 n 角星包围盒矩形。
         *
         * Parameters:
         * style - {Object} style
         *
         * Returns:
         * {Object} 边框对象。包含属性：x，y，width，height。
         */

    }, {
        key: 'getRect',
        value: function getRect(style) {
            if (style.__rect) {
                return style.__rect;
            }

            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            var __OP = this.refOriginalPosition;

            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x + __OP[0] - style.r - lineWidth / 2),
                y: Math.round(style.y + __OP[1] - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };

            return style.__rect;
        }
    }]);

    return SmicStar;
}(_Shape2.Shape);

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _LevelRenderer = __webpack_require__(427);

Object.defineProperty(exports, 'LevelRenderer', {
  enumerable: true,
  get: function get() {
    return _LevelRenderer.LevelRenderer;
  }
});

var _Render = __webpack_require__(277);

Object.defineProperty(exports, 'Render', {
  enumerable: true,
  get: function get() {
    return _Render.Render;
  }
});

var _Animation = __webpack_require__(263);

Object.defineProperty(exports, 'Animation', {
  enumerable: true,
  get: function get() {
    return _Animation.Animation;
  }
});
Object.defineProperty(exports, 'Animator', {
  enumerable: true,
  get: function get() {
    return _Animation.Animator;
  }
});

var _Area = __webpack_require__(264);

Object.defineProperty(exports, 'Area', {
  enumerable: true,
  get: function get() {
    return _Area.Area;
  }
});

var _Clip = __webpack_require__(265);

Object.defineProperty(exports, 'Clip', {
  enumerable: true,
  get: function get() {
    return _Clip.Clip;
  }
});

var _Color = __webpack_require__(105);

Object.defineProperty(exports, 'Color', {
  enumerable: true,
  get: function get() {
    return _Color.Color;
  }
});

var _ComputeBoundingBox = __webpack_require__(266);

Object.defineProperty(exports, 'ComputeBoundingBox', {
  enumerable: true,
  get: function get() {
    return _ComputeBoundingBox.ComputeBoundingBox;
  }
});

var _Config = __webpack_require__(78);

Object.defineProperty(exports, 'Config', {
  enumerable: true,
  get: function get() {
    return _Config.Config;
  }
});

var _Curve = __webpack_require__(79);

Object.defineProperty(exports, 'LevelRendererCurve', {
  enumerable: true,
  get: function get() {
    return _Curve.Curve;
  }
});

var _Easing = __webpack_require__(267);

Object.defineProperty(exports, 'Easing', {
  enumerable: true,
  get: function get() {
    return _Easing.Easing;
  }
});

var _Env = __webpack_require__(268);

Object.defineProperty(exports, 'Env', {
  enumerable: true,
  get: function get() {
    return _Env.Env;
  }
});

var _Event = __webpack_require__(269);

Object.defineProperty(exports, 'LevelRendererEvent', {
  enumerable: true,
  get: function get() {
    return _Event.Event;
  }
});

var _Eventful = __webpack_require__(53);

Object.defineProperty(exports, 'Eventful', {
  enumerable: true,
  get: function get() {
    return _Eventful.Eventful;
  }
});

var _Group = __webpack_require__(270);

Object.defineProperty(exports, 'Group', {
  enumerable: true,
  get: function get() {
    return _Group.Group;
  }
});

var _Handler = __webpack_require__(271);

Object.defineProperty(exports, 'Handler', {
  enumerable: true,
  get: function get() {
    return _Handler.Handler;
  }
});

var _Http = __webpack_require__(272);

Object.defineProperty(exports, 'Http', {
  enumerable: true,
  get: function get() {
    return _Http.Http;
  }
});

var _Log = __webpack_require__(273);

Object.defineProperty(exports, 'Log', {
  enumerable: true,
  get: function get() {
    return _Log.Log;
  }
});

var _Math = __webpack_require__(274);

Object.defineProperty(exports, 'Math', {
  enumerable: true,
  get: function get() {
    return _Math.Math;
  }
});

var _Matrix = __webpack_require__(275);

Object.defineProperty(exports, 'Matrix', {
  enumerable: true,
  get: function get() {
    return _Matrix.Matrix;
  }
});

var _Painter = __webpack_require__(276);

Object.defineProperty(exports, 'Painter', {
  enumerable: true,
  get: function get() {
    return _Painter.Painter;
  }
});
Object.defineProperty(exports, 'PaintLayer', {
  enumerable: true,
  get: function get() {
    return _Painter.PaintLayer;
  }
});

var _Shape = __webpack_require__(13);

Object.defineProperty(exports, 'Shape', {
  enumerable: true,
  get: function get() {
    return _Shape.Shape;
  }
});

var _SmicBrokenLine = __webpack_require__(106);

Object.defineProperty(exports, 'SmicBrokenLine', {
  enumerable: true,
  get: function get() {
    return _SmicBrokenLine.SmicBrokenLine;
  }
});

var _SmicCircle = __webpack_require__(278);

Object.defineProperty(exports, 'SmicCircle', {
  enumerable: true,
  get: function get() {
    return _SmicCircle.SmicCircle;
  }
});

var _SmicEllipse = __webpack_require__(428);

Object.defineProperty(exports, 'SmicEllipse', {
  enumerable: true,
  get: function get() {
    return _SmicEllipse.SmicEllipse;
  }
});

var _SmicImage = __webpack_require__(107);

Object.defineProperty(exports, 'SmicImage', {
  enumerable: true,
  get: function get() {
    return _SmicImage.SmicImage;
  }
});

var _SmicIsogon = __webpack_require__(429);

Object.defineProperty(exports, 'SmicIsogon', {
  enumerable: true,
  get: function get() {
    return _SmicIsogon.SmicIsogon;
  }
});

var _SmicPoint = __webpack_require__(108);

Object.defineProperty(exports, 'SmicPoint', {
  enumerable: true,
  get: function get() {
    return _SmicPoint.SmicPoint;
  }
});

var _SmicPolygon = __webpack_require__(80);

Object.defineProperty(exports, 'SmicPolygon', {
  enumerable: true,
  get: function get() {
    return _SmicPolygon.SmicPolygon;
  }
});

var _SmicRectangle = __webpack_require__(109);

Object.defineProperty(exports, 'SmicRectangle', {
  enumerable: true,
  get: function get() {
    return _SmicRectangle.SmicRectangle;
  }
});

var _SmicRing = __webpack_require__(430);

Object.defineProperty(exports, 'SmicRing', {
  enumerable: true,
  get: function get() {
    return _SmicRing.SmicRing;
  }
});

var _SmicSector = __webpack_require__(279);

Object.defineProperty(exports, 'SmicSector', {
  enumerable: true,
  get: function get() {
    return _SmicSector.SmicSector;
  }
});

var _SmicStar = __webpack_require__(431);

Object.defineProperty(exports, 'SmicStar', {
  enumerable: true,
  get: function get() {
    return _SmicStar.SmicStar;
  }
});

var _SmicText = __webpack_require__(110);

Object.defineProperty(exports, 'SmicText', {
  enumerable: true,
  get: function get() {
    return _SmicText.SmicText;
  }
});

var _Storage = __webpack_require__(280);

Object.defineProperty(exports, 'Storage', {
  enumerable: true,
  get: function get() {
    return _Storage.Storage;
  }
});

var _Transformable = __webpack_require__(81);

Object.defineProperty(exports, 'Transformable', {
  enumerable: true,
  get: function get() {
    return _Transformable.Transformable;
  }
});

var _Util = __webpack_require__(29);

Object.defineProperty(exports, 'Util', {
  enumerable: true,
  get: function get() {
    return _Util.Util;
  }
});

var _Vector = __webpack_require__(82);

Object.defineProperty(exports, 'LevelRendererVector', {
  enumerable: true,
  get: function get() {
    return _Vector.Vector;
  }
});

var _SUtil = __webpack_require__(12);

Object.defineProperty(exports, 'SUtil', {
  enumerable: true,
  get: function get() {
    return _SUtil.SUtil;
  }
});

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyServiceParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.KeyServiceParameter
 * @classdesc key申请参数
 * @param options - {Object} 参数。如：<br>
 *        name - {string} 申请服务名称。<br>
 *        serviceIds - {number}服务ID。<br>
 *        clientType - {{@link SuperMap.ClientType}} 服务端类型。<br>
 *        limitation - {number}有效期
 */
var KeyServiceParameter = exports.KeyServiceParameter = function () {
    function KeyServiceParameter(options) {
        _classCallCheck(this, KeyServiceParameter);

        this.name = null;
        this.serviceIds = null;
        this.clientType = _REST.ClientType.SERVER;
        this.limitation = null;
        _Util.Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.KeyServiceParameter";
    }

    /**
     * @function SuperMap.KeyServiceParameter.prototype.toJSON
     * @description 转换成JSON对象
     * @return {Object} 参数的JSON对象
     */


    _createClass(KeyServiceParameter, [{
        key: 'toJSON',
        value: function toJSON() {
            return {
                name: this.name,
                serviceIds: this.serviceIds,
                clientType: this.clientType,
                limitation: this.limitation
            };
        }
    }]);

    return KeyServiceParameter;
}();

_SuperMap.SuperMap.KeyServiceParameter = KeyServiceParameter;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServerInfo = undefined;

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ServerInfo
 * @classdesc 服务器信息(安全相关)，包含服务器类型，服务地址，token服务地址等
 * @param type - {string} 服务器类型
 * @param options - {Object} 服务器信息相关可选参数。如：<br>
 *        server - {string} 服务器地址,如：http://supermapiserver:8090/iserver<br>
 *        tokenServiceUrl - {string} 非必填，如：http://supermapiserver:8090/iserver/services/security/tokens.json<br>
 *        keyServiceUrl - {string} 非必填，如：http://supermapiserver:8092/web/mycontent/keys/register.json
 */
var ServerInfo = exports.ServerInfo = function ServerInfo(type, options) {
    _classCallCheck(this, ServerInfo);

    /**
     * @member SuperMap.ServerInfo.prototype.type -{ServerType}
     * @description 服务器类型
     */
    this.type = type;

    /**
     * @member SuperMap.ServerInfo.prototype.server -{string}
     * @description 必填，服务器地址
     */
    this.server = null;

    /**
     * @member SuperMap.ServerInfo.prototype.tokenServiceUrl -{string}
     * @description 非必填，如：http://supermapiserver:8090/iserver/services/security/tokens.json
     */
    this.tokenServiceUrl = null;

    /**
     * @member SuperMap.ServerInfo.prototype.keyServiceUrl -{string}
     * @description 非必填。如：http://supermapiserver:8092/web/mycontent/keys/register.json
     */
    this.keyServiceUrl = null;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.ServerInfo";
    this.type = this.type || _REST.ServerType.ISERVER;
    if (!this.server) {
        console.error('server url require is not  undefined');
    }
    // var patten = /http:\/\/([^\/]+)/i;
    //this.server = this.server.match(patten)[0];

    var tokenServiceSuffix = "/services/security/tokens.json";
    if (this.type === _REST.ServerType.ISERVER && this.server.indexOf("iserver") < 0) {
        tokenServiceSuffix = "/iserver" + tokenServiceSuffix;
    }

    if (!this.tokenServiceUrl) {
        this.tokenServiceUrl = this.server + tokenServiceSuffix;
    }

    if (!this.keyServiceUrl) {
        if (this.type === _REST.ServerType.IPORTAL) {
            this.keyServiceUrl = this.server + "/web/mycontent/keys/register.json";
        } else if (this.type === _REST.ServerType.ONLINE) {
            this.keyServiceUrl = this.server + "/web/mycontent/keys.json";
        }
    }
};

_SuperMap.SuperMap.ServerInfo = ServerInfo;

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TokenServiceParameter = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

var _REST = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.TokenServiceParameter
 * @classdesc token申请参数
 * @param options - {Object} token申请参数。
 */
var TokenServiceParameter = exports.TokenServiceParameter = function () {
  function TokenServiceParameter(options) {
    _classCallCheck(this, TokenServiceParameter);

    /**
     * @member SuperMap.TokenServiceParameter.prototype.userName -{string}
     * @description 用户名。
     */
    this.userName = null;

    /**
     * @member SuperMap.TokenServiceParameter.prototype.password -{string}
     * @description 密码。
     */
    this.password = null;

    /**
     * @member SuperMap.TokenServiceParameter.prototype.clientType -{string}
     * @description token申请的客户端标识类型。
     */
    this.clientType = _REST.ClientType.NONE;

    /**
     * @member SuperMap.TokenServiceParameter.prototype.ip -{string}
     * @description clientType=Referer 时，必选。如果按照指定 URL 的方式申请令牌，则传递相应的 URL。
     */

    this.ip = null;
    /**
     * @member SuperMap.TokenServiceParameter.prototype.referer -{string}
     * @description clientType=Referer 时，必选。如果按照指定 URL 的方式申请令牌，则传递相应的 URL。
     */
    this.referer = null;

    /**
     * @member SuperMap.TokenServiceParameter.prototype.expiration -{number}
     * @description 申请令牌的有效期，从发布令牌的时间开始计算，单位为分钟。
     */
    this.expiration = 60;

    _Util.Util.extend(this, options);

    this.CLASS_NAME = "SuperMap.TokenServiceParameter";
  }

  /**
   * @function SuperMap.TokenServiceParameter.prototype.toJSON
   * @description 将所有信息转成JSON字符串
   * @return {string} 参数的JSON字符串
   */


  _createClass(TokenServiceParameter, [{
    key: 'toJSON',
    value: function toJSON() {
      return {
        userName: this.userName,
        password: this.password,
        clientType: this.clientType,
        ip: this.ip,
        referer: this.referer,
        expiration: this.expiration
      };
    }
  }]);

  return TokenServiceParameter;
}();

_SuperMap.SuperMap.TokenServiceParameter = TokenServiceParameter;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _KeyServiceParameter = __webpack_require__(433);

Object.defineProperty(exports, 'KeyServiceParameter', {
  enumerable: true,
  get: function get() {
    return _KeyServiceParameter.KeyServiceParameter;
  }
});

var _SecurityManager = __webpack_require__(35);

Object.defineProperty(exports, 'SecurityManager', {
  enumerable: true,
  get: function get() {
    return _SecurityManager.SecurityManager;
  }
});

var _ServerInfo = __webpack_require__(434);

Object.defineProperty(exports, 'ServerInfo', {
  enumerable: true,
  get: function get() {
    return _ServerInfo.ServerInfo;
  }
});

var _TokenServiceParameter = __webpack_require__(435);

Object.defineProperty(exports, 'TokenServiceParameter', {
  enumerable: true,
  get: function get() {
    return _TokenServiceParameter.TokenServiceParameter;
  }
});

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CartoCSS = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _SuperMap = __webpack_require__(0);

var _toPairs = __webpack_require__(495);

var _toPairs2 = _interopRequireDefault(_toPairs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.CartoCSS
 * @classdesc CartoCSS解析类，其主要功能为将CartoCSS字符串解析为CartoCSS的shader属性风格对象。
 * @param cartoStr - {string} CartoCSS样式表字符串
 * @example
 * var cartocss = "@provinceLineColor:#ddd;
 *                 #China_Provinces_L___China400{
 *                      line-dasharray:10,10;
 *                      line-color:@provinceLineColor;
 *                      line-width:1;
 *                 }";
 * new SuperMap.CartoCSS(cartocss);
 */
/*eslint no-useless-escape: "off"*/
var CartoCSS = exports.CartoCSS = function () {
    function CartoCSS(cartoStr) {
        _classCallCheck(this, CartoCSS);

        this.env = null;

        /**
         * @member SuperMap.CartoCSS.prototype.parser
         * @description 解析器
         */
        this.parser = null;

        /**
         * @member SuperMap.CartoCSS.prototype.ruleSet
         * @description CartoCSS规则对象
         */
        this.ruleSet = null;

        /**
         * @member SuperMap.CartoCSS.prototype.cartoStr
         * @description CartoCSS样式表字符串
         */
        this.cartoStr = "";

        /**
         * @member SuperMap.CartoCSS.prototype.shaders
         * @description Carto着色器集
         */
        this.shaders = null;

        if (typeof cartoStr === "string") {
            this.cartoStr = cartoStr;
            this.env = {
                frames: [],
                errors: [],
                error: function error(obj) {
                    this.errors.push(obj);
                }
            };
            this.parser = this.getParser(this.env);
            this.parse(cartoStr);
            this.shaders = this.toShaders();
        }
    }

    /**
     * @function SuperMap.CartoCSS.prototype.getParser
     * @description 获取CartoCSS解析器
     */


    _createClass(CartoCSS, [{
        key: 'getParser',
        value: function getParser(env) {
            var input, // LeSS input string
            i, // current index in `input`
            j, // current chunk
            temp, // temporarily holds a chunk's state, for backtracking
            memo, // temporarily holds `i`, when backtracking
            furthest, // furthest index the parser has gone to
            chunks, // chunkified input
            current, // index of current chunk, in `input`
            parser;

            var that = this;

            // This function is called after all files
            // have been imported through `@import`.
            var finish = function finish() {//NOSONAR
                //所有文件导入完成之后调用
            };

            function save() {
                temp = chunks[j];
                memo = i;
                current = i;
            }

            function restore() {
                chunks[j] = temp;
                i = memo;
                current = i;
            }

            function sync() {
                if (i > current) {
                    chunks[j] = chunks[j].slice(i - current);
                    current = i;
                }
            }

            //
            // Parse from a token, regexp or string, and move forward if match
            //
            function $(tok) {
                var match, length, c, endIndex;

                // Non-terminal
                if (tok instanceof Function) {
                    return tok.call(parser.parsers);
                    // Terminal
                    // Either match a single character in the input,
                    // or match a regexp in the current chunk (chunk[j]).
                } else if (typeof tok === 'string') {
                    match = input.charAt(i) === tok ? tok : null;
                    length = 1;
                    sync();
                } else {
                    sync();

                    match = tok.exec(chunks[j]);
                    if (match) {
                        length = match[0].length;
                    } else {
                        return null;
                    }
                }

                // The match is confirmed, add the match length to `i`,
                // and consume any extra white-space characters (' ' || '\n')
                // which come after that. The reason for this is that LeSS's
                // grammar is mostly white-space insensitive.
                if (match) {
                    var mem = i += length;
                    endIndex = i + chunks[j].length - length;

                    while (i < endIndex) {
                        c = input.charCodeAt(i);
                        if (!(c === 32 || c === 10 || c === 9)) {
                            break;
                        }
                        i++;
                    }
                    chunks[j] = chunks[j].slice(length + (i - mem));
                    current = i;

                    if (chunks[j].length === 0 && j < chunks.length - 1) {
                        j++;
                    }

                    if (typeof match === 'string') {
                        return match;
                    } else {
                        return match.length === 1 ? match[0] : match;
                    }
                }
            }

            // Same as $(), but don't change the state of the parser,
            // just return the match.
            function peek(tok) {
                if (typeof tok === 'string') {
                    return input.charAt(i) === tok;
                } else {
                    return !!tok.test(chunks[j]);
                }
            }

            // Make an error object from a passed set of properties.
            // Accepted properties:
            // - `message`: Text of the error message.
            // - `filename`: Filename where the error occurred.
            // - `index`: Char. index where the error occurred.
            function makeError(err) {
                var einput;

                var defautls = {
                    index: furthest,
                    filename: env.filename,
                    message: 'Parse error.',
                    line: 0,
                    column: -1
                };
                if (defautls) {
                    for (var prop in defautls) {
                        if (err[prop] === 0) {
                            err[prop] = defautls[prop];
                        }
                    }
                }

                if (err.filename && that.env.inputs && that.env.inputs[err.filename]) {
                    einput = that.env.inputs[err.filename];
                } else {
                    einput = input;
                }

                err.line = (einput.slice(0, err.index).match(/\n/g) || '').length + 1;
                for (var n = err.index; n >= 0 && einput.charAt(n) !== '\n'; n--) {
                    err.column++;
                }
                return new Error([err.filename, err.line, err.column, err.message].join(";"));
            }

            this.env = env = env || {};
            this.env.filename = this.env.filename || null;
            this.env.inputs = this.env.inputs || {};

            // The Parser
            parser = {

                // Parse an input string into an abstract syntax tree.
                // Throws an error on parse errors.
                parse: function parse(str) {
                    var root,
                        error = null;

                    i = j = current = furthest = 0;
                    chunks = [];
                    input = str.replace(/\r\n/g, '\n');
                    if (env.filename) {
                        that.env.inputs[env.filename] = input;
                    }

                    // Split the input into chunks.
                    chunks = function (chunks) {
                        var j = 0,
                            skip = /(?:@\{[\w-]+\}|[^"'`\{\}\/\(\)\\])+/g,
                            comment = /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g,
                            string = /"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'|`((?:[^`]|\\.)*)`/g,
                            level = 0,
                            match,
                            chunk = chunks[0],
                            inParam;

                        for (var i = 0, c, cc; i < input.length;) {
                            skip.lastIndex = i;
                            if (match = skip.exec(input)) {
                                if (match.index === i) {
                                    i += match[0].length;
                                    chunk.push(match[0]);
                                }
                            }
                            c = input.charAt(i);
                            comment.lastIndex = string.lastIndex = i;

                            if (match = string.exec(input)) {
                                if (match.index === i) {
                                    i += match[0].length;
                                    chunk.push(match[0]);
                                    continue;
                                }
                            }

                            if (!inParam && c === '/') {
                                cc = input.charAt(i + 1);
                                if (cc === '/' || cc === '*') {
                                    if (match = comment.exec(input)) {
                                        if (match.index === i) {
                                            i += match[0].length;
                                            chunk.push(match[0]);
                                            continue;
                                        }
                                    }
                                }
                            }

                            switch (c) {
                                case '{':
                                    //NOSONAR
                                    if (!inParam) {
                                        level++;
                                        chunk.push(c);
                                        break;
                                    }
                                case '}':
                                    //NOSONAR
                                    if (!inParam) {
                                        level--;
                                        chunk.push(c);
                                        chunks[++j] = chunk = [];
                                        break;
                                    }
                                case '(':
                                    //NOSONAR
                                    if (!inParam) {
                                        inParam = true;
                                        chunk.push(c);
                                        break;
                                    }
                                case ')':
                                    //NOSONAR
                                    if (inParam) {
                                        inParam = false;
                                        chunk.push(c);
                                        break;
                                    }
                                default:
                                    chunk.push(c);
                                    break;
                            }

                            i++;
                        }
                        if (level !== 0) {
                            error = {
                                index: i - 1,
                                type: 'Parse',
                                message: level > 0 ? "missing closing `}`" : "missing opening `{`"
                            };
                        }

                        return chunks.map(function (c) {
                            return c.join('');
                        });
                    }([[]]);

                    if (error) {
                        throw makeError(error);
                    }

                    // Sort rules by specificity: this function expects selectors to be
                    // split already.
                    //
                    // Written to be used as a .sort(Function);
                    // argument.
                    //
                    // [1, 0, 0, 467] > [0, 0, 1, 520]
                    var specificitySort = function specificitySort(a, b) {
                        var as = a.specificity;
                        var bs = b.specificity;

                        if (as[0] != bs[0]) {
                            return bs[0] - as[0];
                        }
                        if (as[1] != bs[1]) {
                            return bs[1] - as[1];
                        }
                        if (as[2] != bs[2]) {
                            return bs[2] - as[2];
                        }
                        return bs[3] - as[3];
                    };

                    // Start with the primary rule.
                    // The whole syntax tree is held under a Ruleset node,
                    // with the `root` property set to true, so no `{}` are
                    // output.
                    root = new _SuperMap.SuperMap.CartoCSS.Tree.Ruleset([], $(this.parsers.primary));
                    root.root = true;

                    // Get an array of Ruleset objects, flattened
                    // and sorted according to specificitySort
                    root.toList = function () {
                        return function (env) {
                            env.error = function (e) {
                                if (!env.errors) {
                                    env.errors = new Error('');
                                }
                                if (env.errors.message) {
                                    env.errors.message += '\n' + makeError(e).message;
                                } else {
                                    env.errors.message = makeError(e).message;
                                }
                            };
                            env.frames = env.frames || [];

                            // call populates Invalid-caused errors
                            var definitions = this.flatten([], [], env);
                            definitions.sort(specificitySort);
                            return definitions;
                        };
                    }();

                    return root;
                },

                // Here in, the parsing rules/functions
                //
                // The basic structure of the syntax tree generated is as follows:
                //
                //   Ruleset ->  Rule -> Value -> Expression -> Entity
                //
                //  In general, most rules will try to parse a token with the `$()` function, and if the return
                //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
                //  first, before parsing, that's when we use `peek()`.
                parsers: {
                    // The `primary` rule is the *entry* and *exit* point of the parser.
                    // The rules here can appear at any level of the parse tree.
                    //
                    // The recursive nature of the grammar is an interplay between the `block`
                    // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
                    // as represented by this simplified grammar:
                    //
                    //     primary  →  (ruleset | rule)+
                    //     ruleset  →  selector+ block
                    //     block    →  '{' primary '}'
                    //
                    // Only at one point is the primary rule not called from the
                    // block rule: at the root level.
                    primary: function primary() {
                        var node,
                            root = [];

                        while ((node = $(this.rule) || $(this.ruleset) || $(this.comment)) || $(/^[\s\n]+/) || (node = $(this.invalid))) {
                            if (node) {
                                root.push(node);
                            }
                        }
                        return root;
                    },

                    invalid: function invalid() {
                        var chunk = $(/^[^;\n]*[;\n]/);

                        // To fail gracefully, match everything until a semicolon or linebreak.
                        if (chunk) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Invalid(chunk, memo);
                        }
                    },

                    // We create a Comment node for CSS comments `/* */`,
                    // but keep the LeSS comments `//` silent, by just skipping
                    // over them.
                    comment: function comment() {
                        var comment;

                        if (input.charAt(i) !== '/') {
                            return;
                        }

                        if (input.charAt(i + 1) === '/') {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Comment($(/^\/\/.*/), true);
                        } else if (comment = $(/^\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/)) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Comment(comment);
                        }
                    },

                    // Entities are tokens which can be found inside an Expression
                    entities: {

                        // A string, which supports escaping " and ' "milky way" 'he\'s the one!'
                        quoted: function quoted() {
                            if (input.charAt(i) !== '"' && input.charAt(i) !== "'") {
                                return;
                            }
                            var str = $(/^"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'/);
                            if (str) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Quoted(str[1] || str[2]);
                            }
                        },

                        // A reference to a Mapnik field, like [NAME]
                        // Behind the scenes, this has the same representation, but Carto
                        // needs to be careful to warn when unsupported operations are used.
                        field: function field() {
                            var l = '[',
                                r = ']';
                            if (!$(l)) {
                                return;
                            }
                            var field_name = $(/(^[^\]]+)/);
                            if (!$(r)) {
                                return;
                            }
                            if (field_name) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Field(field_name[1]);
                            }
                        },

                        // This is a comparison operator
                        comparison: function comparison() {
                            var str = $(/^=~|=|!=|<=|>=|<|>/);
                            if (str) {
                                return str;
                            }
                        },

                        // A catch-all word, such as: hard-light
                        // These can start with either a letter or a dash (-),
                        // and then contain numbers, underscores, and letters.
                        keyword: function keyword() {
                            var k = $(/^[A-Za-z\u4e00-\u9fa5-]+[A-Za-z-0-9\u4e00-\u9fa5_]*/);
                            if (k) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Keyword(k);
                            }
                        },

                        // A function call like rgb(255, 0, 255)
                        // The arguments are parsed with the `entities.arguments` parser.
                        call: function call() {
                            var name, args;

                            if (!(name = /^([\w\-]+|%)\(/.exec(chunks[j]))) {
                                return;
                            }

                            name = name[1];

                            if (name === 'url') {
                                // url() is handled by the url parser instead
                                return null;
                            } else {
                                i += name.length;
                            }

                            var l = '(',
                                r = ')';
                            $(l); // Parse the '(' and consume whitespace.

                            args = $(this.entities['arguments']);

                            if (!$(r)) {
                                return;
                            }

                            if (name) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Call(name, args, i);
                            }
                        },
                        // Arguments are comma-separated expressions
                        'arguments': function _arguments() {
                            var args = [],
                                arg;

                            while (arg = $(this.expression)) {
                                args.push(arg);
                                var q = ',';
                                if (!$(q)) {
                                    break;
                                }
                            }

                            return args;
                        },
                        literal: function literal() {
                            return $(this.entities.dimension) || $(this.entities.keywordcolor) || $(this.entities.hexcolor) || $(this.entities.quoted);
                        },

                        // Parse url() tokens
                        //
                        // We use a specific rule for urls, because they don't really behave like
                        // standard function calls. The difference is that the argument doesn't have
                        // to be enclosed within a string, so it can't be parsed as an Expression.
                        url: function url() {
                            var value;

                            if (input.charAt(i) !== 'u' || !$(/^url\(/)) {
                                return;
                            }
                            value = $(this.entities.quoted) || $(this.entities.variable) || $(/^[\-\w%@$\/.&=:;#+?~]+/) || '';
                            var r = ')';
                            if (!$(r)) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Invalid(value, memo, 'Missing closing ) in URL.');
                            } else {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.URL(typeof value.value !== 'undefined' || value instanceof _SuperMap.SuperMap.CartoCSS.Tree.Variable ? value : new _SuperMap.SuperMap.CartoCSS.Tree.Quoted(value));
                            }
                        },

                        // A Variable entity, such as `@fink`, in
                        //
                        //     width: @fink + 2px
                        //
                        // We use a different parser for variable definitions,
                        // see `parsers.variable`.
                        variable: function variable() {
                            var name,
                                index = i;

                            if (input.charAt(i) === '@' && (name = $(/^@[\w-]+/))) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Variable(name, index, env.filename);
                            }
                        },

                        hexcolor: function hexcolor() {
                            var rgb;
                            if (input.charAt(i) === '#' && (rgb = $(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/))) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Color(rgb[1]);
                            }
                        },

                        keywordcolor: function keywordcolor() {
                            var rgb = chunks[j].match(/^[a-z]+/);
                            if (rgb && rgb[0] in _SuperMap.SuperMap.CartoCSS.Tree.Reference.data.colors) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Color(_SuperMap.SuperMap.CartoCSS.Tree.Reference.data.colors[$(/^[a-z]+/)]);
                            }
                        },

                        // A Dimension, that is, a number and a unit. The only
                        // unit that has an effect is %
                        dimension: function dimension() {
                            var c = input.charCodeAt(i);
                            if (c > 57 || c < 45 || c === 47) {
                                return;
                            }
                            var value = $(/^(-?\d*\.?\d+(?:[eE][-+]?\d+)?)(\%|\w+)?/);
                            if (value) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(value[1], value[2], memo);
                            }
                        }
                    },

                    // The variable part of a variable definition.
                    // Used in the `rule` parser. Like @fink:
                    variable: function variable() {
                        var name;

                        if (input.charAt(i) === '@' && (name = $(/^(@[\w-]+)\s*:/))) {
                            return name[1];
                        }
                    },

                    // Entities are the smallest recognized token,
                    // and can be found inside a rule's value.
                    entity: function entity() {
                        var property1 = $(this.entities.call) || $(this.entities.literal);
                        var property2 = $(this.entities.field) || $(this.entities.variable);
                        var property3 = $(this.entities.url) || $(this.entities.keyword);
                        return property1 || property2 || property3;
                    },

                    // A Rule terminator. Note that we use `peek()` to check for '}',
                    // because the `block` rule will be expecting it, but we still need to make sure
                    // it's there, if ';' was ommitted.
                    end: function end() {
                        var q = ';';
                        return $(q) || peek('}');
                    },

                    // Elements are the building blocks for Selectors. They consist of
                    // an element name, such as a tag a class, or `*`.
                    //增加对中文的支持，[\u4e00-\u9fa5]
                    element: function element() {
                        var e = $(/^(?:[.#][\w\u4e00-\u9fa5\-]+|\*|Map)/);
                        if (e) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Element(e);
                        }
                    },

                    // Attachments allow adding multiple lines, polygons etc. to an
                    // object. There can only be one attachment per selector.
                    attachment: function attachment() {
                        var s = $(/^::([\w\-]+(?:\/[\w\-]+)*)/);
                        if (s) {
                            return s[1];
                        }
                    },

                    // Selectors are made out of one or more Elements, see above.
                    selector: function selector() {
                        var a,
                            attachment,
                            e,
                            elements = [],
                            f,
                            filters = new _SuperMap.SuperMap.CartoCSS.Tree.Filterset(),
                            z,
                            zooms = [],
                            segments = 0,
                            conditions = 0;

                        while ((e = $(this.element)) || (z = $(this.zoom)) || (f = $(this.filter)) || (a = $(this.attachment))) {
                            segments++;
                            if (e) {
                                elements.push(e);
                            } else if (z) {
                                zooms.push(z);
                                conditions++;
                            } else if (f) {
                                var err = filters.add(f);
                                if (err) {
                                    throw makeError({
                                        message: err,
                                        index: i - 1
                                    });
                                }
                                conditions++;
                            } else if (attachment) {
                                throw makeError({
                                    message: 'Encountered second attachment name.',
                                    index: i - 1
                                });
                            } else {
                                attachment = a;
                            }

                            var c = input.charAt(i);
                            if (c === '{' || c === '}' || c === ';' || c === ',') {
                                break;
                            }
                        }

                        if (segments) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Selector(filters, zooms, elements, attachment, conditions, memo);
                        }
                    },

                    filter: function filter() {
                        save();
                        var key,
                            op,
                            val,
                            l = '[',
                            r = ']';
                        if (!$(l)) {
                            return;
                        }
                        if (key = $(/^[a-zA-Z0-9\-_]+/) || $(this.entities.quoted) || $(this.entities.variable) || $(this.entities.keyword) || $(this.entities.field)) {
                            if (key instanceof _SuperMap.SuperMap.CartoCSS.Tree.Quoted) {
                                key = new _SuperMap.SuperMap.CartoCSS.Tree.Field(key.toString());
                            }
                            if ((op = $(this.entities.comparison)) && (val = $(this.entities.quoted) || $(this.entities.variable) || $(this.entities.dimension) || $(this.entities.keyword) || $(this.entities.field))) {
                                if (!$(r)) {
                                    throw makeError({
                                        message: 'Missing closing ] of filter.',
                                        index: memo - 1
                                    });
                                }
                                if (!key.is) {
                                    key = new _SuperMap.SuperMap.CartoCSS.Tree.Field(key);
                                }
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Filter(key, op, val, memo, env.filename);
                            }
                        }
                    },

                    zoom: function zoom() {
                        save();
                        var op,
                            val,
                            r = ']';
                        if ($(/^\[\s*zoom/g) && (op = $(this.entities.comparison)) && (val = $(this.entities.variable) || $(this.entities.dimension)) && $(r)) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Zoom(op, val, memo);
                        } else {
                            // backtrack
                            restore();
                        }
                    },

                    // The `block` rule is used by `ruleset`
                    // It's a wrapper around the `primary` rule, with added `{}`.
                    block: function block() {
                        var content,
                            l = '{',
                            r = '}';

                        if ($(l) && (content = $(this.primary)) && $(r)) {
                            return content;
                        }
                    },

                    // div, .class, body > p {...}
                    ruleset: function ruleset() {
                        var selectors = [],
                            s,
                            rules,
                            q = ',';
                        save();

                        while (s = $(this.selector)) {
                            selectors.push(s);
                            while ($(this.comment)) {//NOSONAR
                            }
                            if (!$(q)) {
                                break;
                            }
                            while ($(this.comment)) {//NOSONAR
                            }
                        }
                        if (s) {
                            while ($(this.comment)) {//NOSONAR
                            }
                        }

                        if (selectors.length > 0 && (rules = $(this.block))) {
                            if (selectors.length === 1 && selectors[0].elements.length && selectors[0].elements[0].value === 'Map') {
                                var rs = new _SuperMap.SuperMap.CartoCSS.Tree.Ruleset(selectors, rules);
                                rs.isMap = true;
                                return rs;
                            }
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Ruleset(selectors, rules);
                        } else {
                            // Backtrack
                            restore();
                        }
                    },

                    rule: function rule() {
                        var name,
                            value,
                            c = input.charAt(i);
                        save();

                        if (c === '.' || c === '#') {
                            return;
                        }

                        if (name = $(this.variable) || $(this.property)) {
                            value = $(this.value);

                            if (value && $(this.end)) {
                                return new _SuperMap.SuperMap.CartoCSS.Tree.Rule(name, value, memo, env.filename);
                            } else {
                                furthest = i;
                                restore();
                            }
                        }
                    },

                    font: function font() {
                        var value = [],
                            expression = [],
                            e,
                            q = ',';

                        while (e = $(this.entity)) {
                            expression.push(e);
                        }

                        value.push(new _SuperMap.SuperMap.CartoCSS.Tree.Expression(expression));

                        if ($(q)) {
                            while (e = $(this.expression)) {
                                value.push(e);
                                if (!$(q)) {
                                    break;
                                }
                            }
                        }
                        return new _SuperMap.SuperMap.CartoCSS.Tree.Value(value);
                    },

                    // A Value is a comma-delimited list of Expressions
                    // In a Rule, a Value represents everything after the `:`,
                    // and before the `;`.
                    value: function value() {
                        var e,
                            expressions = [],
                            q = ',';

                        while (e = $(this.expression)) {
                            expressions.push(e);
                            if (!$(q)) {
                                break;
                            }
                        }

                        if (expressions.length > 1) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Value(expressions.map(function (e) {
                                return e.value[0];
                            }));
                        } else if (expressions.length === 1) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Value(expressions);
                        }
                    },
                    // A sub-expression, contained by parenthensis
                    sub: function sub() {
                        var e,
                            l = '(',
                            r = ")";
                        if ($(l) && (e = $(this.expression)) && $(r)) {
                            return e;
                        }
                    },
                    // This is a misnomer because it actually handles multiplication
                    // and division.
                    multiplication: function multiplication() {
                        var m,
                            a,
                            op,
                            operation,
                            q = '/';
                        if (m = $(this.operand)) {
                            while ((op = $(q) || $('*') || $('%')) && (a = $(this.operand))) {
                                operation = new _SuperMap.SuperMap.CartoCSS.Tree.Operation(op, [operation || m, a], memo);
                            }
                            return operation || m;
                        }
                    },
                    addition: function addition() {
                        var m,
                            a,
                            op,
                            operation,
                            plus = '+';
                        if (m = $(this.multiplication)) {
                            while ((op = $(/^[-+]\s+/) || input.charAt(i - 1) != ' ' && ($(plus) || $('-'))) && (a = $(this.multiplication))) {
                                operation = new _SuperMap.SuperMap.CartoCSS.Tree.Operation(op, [operation || m, a], memo);
                            }
                            return operation || m;
                        }
                    },

                    // An operand is anything that can be part of an operation,
                    // such as a Color, or a Variable
                    operand: function operand() {
                        return $(this.sub) || $(this.entity);
                    },

                    // Expressions either represent mathematical operations,
                    // or white-space delimited Entities.  @var * 2
                    expression: function expression() {
                        var e,
                            entities = [];

                        while (e = $(this.addition) || $(this.entity)) {
                            entities.push(e);
                        }

                        if (entities.length > 0) {
                            return new _SuperMap.SuperMap.CartoCSS.Tree.Expression(entities);
                        }
                    },
                    property: function property() {
                        var name = $(/^(([a-z][-a-z_0-9]*\/)?\*?-?[-a-z_0-9]+)\s*:/);
                        if (name) {
                            return name[1];
                        }
                    }
                }
            };
            return parser;
        }

        /**
         * @function SuperMap.CartoCSS.prototype.parse
         * @description 利用CartoCSS解析器里面的parse方法，将CartoCSS样式表字符串转化为CartoCSS规则集
         * @return {Object} CartoCSS规则集
         */

    }, {
        key: 'parse',
        value: function parse(str) {
            var parser = this.parser;
            var ruleSet = this.ruleSet = parser.parse(str);
            return ruleSet;
        }

        /**
         * @function SuperMap.CartoCSS.prototype.toShaders
         * @description 将CartoCSS规则集转化为着色器
         * @return {Array} CartoCSS着色器集
         */

    }, {
        key: 'toShaders',
        value: function toShaders() {
            if (this.ruleSet) {
                var ruleset = this.ruleSet;
                if (ruleset) {
                    var defs = ruleset.toList(this.env);
                    defs.reverse();

                    var shaders = {};
                    var keys = [];
                    this._toShaders(shaders, keys, defs);

                    var ordered_shaders = [];

                    var done = {};
                    for (var i = 0, len0 = defs.length; i < len0; ++i) {
                        var def = defs[i];
                        var k = def.attachment;
                        var shader = shaders[keys[i]];
                        var shaderArray = [];
                        if (!done[k]) {
                            var j = 0;
                            for (var prop in shader) {
                                if (prop !== 'zoom' && prop !== 'frames' && prop !== "attachment" && prop != "elements") {
                                    //对layer-index作特殊处理以实现图层的控制
                                    if (prop === "layer-index") {
                                        /*var getLayerIndex = Function("attributes", "zoom", "var _value = null;" + shader[prop].join('\n') + "; return _value; ");*/
                                        var getLayerIndex = function getLayerIndex(attributes, zoom) {
                                            //NOSONAR
                                            var _value = null;
                                            shader[prop].join('\n');
                                            return _value;
                                        };
                                        var layerIndex = getLayerIndex();
                                        Object.defineProperty(shaderArray, "layerIndex", {
                                            configurable: true,
                                            enumerable: false,
                                            value: layerIndex
                                        });
                                    } else {
                                        shaderArray[j++] = function (ops, shaderArray) {
                                            //NOSONAR
                                            if (!Array.isArray(ops)) {
                                                return ops;
                                            }
                                            var body = ops.join('\n');
                                            var myKeyword = 'attributes["FEATUREID"]&&attributes["FEATUREID"]';
                                            var index = body.indexOf(myKeyword);
                                            if (index >= 0) {
                                                //对featureID作一些特殊处理，以将featureID提取出来
                                                if (!shaderArray.featureFilter) {
                                                    var featureFilterStart = index + myKeyword.length;
                                                    var featureFilterEnd = body.indexOf(")", featureFilterStart + 1);
                                                    var featureFilterStr = "featureId&&(featureId" + body.substring(featureFilterStart, featureFilterEnd) + ")";
                                                    /*var featureFilter = Function("featureId", "if(" + featureFilterStr + "){return true;}return false;");*/
                                                    var featureFilter = function featureFilter(featureId) {
                                                        if (featureFilterStr) {
                                                            return true;
                                                        }
                                                        return false;
                                                    };
                                                    Object.defineProperty(shaderArray, "featureFilter", {
                                                        configurable: true,
                                                        enumerable: false,
                                                        value: featureFilter
                                                    });
                                                }
                                                return {
                                                    "property": prop,
                                                    "getValue": Function("attributes", "zoom", "seftFilter", "var _value = null; var isExcute=typeof seftFilter=='function'?sefgFilter():seftFilter;if(isExcute){" + body + ";} return _value; ") //NOSONAR
                                                };
                                            } else {
                                                return {
                                                    "property": prop,
                                                    "getValue": Function("attributes", "zoom", "var _value = null;" + body + "; return _value; ") //NOSONAR
                                                };
                                            }
                                        }(shader[prop], shaderArray);
                                    }
                                }
                            }
                            Object.defineProperty(shaderArray, "attachment", {
                                configurable: true,
                                enumerable: false,
                                value: k
                            });
                            Object.defineProperty(shaderArray, "elements", {
                                configurable: true,
                                enumerable: false,
                                value: def.elements
                            });
                            ordered_shaders.push(shaderArray);
                            done[keys[i]] = true;
                        }
                        Object.defineProperty(shaderArray, "zoom", {
                            configurable: true,
                            enumerable: false,
                            value: def.zoom
                        });
                        //shader.frames.push(def.frame_offset);
                    }
                    return ordered_shaders;
                }
            }
            return null;
        }
    }, {
        key: '_toShaders',
        value: function _toShaders(shaders, keys, defs) {
            for (var i = 0, len0 = defs.length; i < len0; ++i) {
                var def = defs[i];
                var element_str = [];
                for (var j = 0, len1 = def.elements.length; j < len1; j++) {
                    element_str.push(def.elements[j]);
                }
                var filters = def.filters.filters;
                var filterStr = [];
                for (var attr in filters) {
                    filterStr.push(filters[attr].id);
                }
                var key = element_str.join("/") + "::" + def.attachment + "_" + filterStr.join("_");
                keys.push(key);
                var shader = shaders[key] = shaders[key] || {};
                //shader.frames = [];
                shader.zoom = _SuperMap.SuperMap.CartoCSS.Tree.Zoom.all;
                var props = def.toJS(this.env);
                for (var v in props) {
                    (shader[v] = shader[v] || []).push(props[v].join('\n'));
                }
            }
        }
        /**
         * @function SuperMap.CartoCSS.prototype.getShaders
         * @description 获取CartoCSS着色器
         * @return {Array} 着色器集
         * @example
         *   //shaders的结构大概如下：
         *   var shaders=[
         *   {
         *       attachment:"one"
         *       elements:[]
         *       zoom:23
         *       length:2
         *       0:{property:"line-color"value:function(attributezoom){var _value=null;if(zoom){_value="#123456"}return _vlaue;}}
         *       1:{preoperty:"line-width"value:function(attributezoom){var _value=null;if(zoom){_value=3}return _vlaue;}}
         *   }
         *   {
         *       attachment:"two"
         *       elements:[]
         *       zoom:23
         *       length:2
         *       0:{property:"polygon-color"value:function(attributezoom){var _value=null;if(zoom){_value="#123456"}return _vlaue;}}
         *       1:{property:"line-width"value:function(attributezoom){var _value=null;if(zoom){_value=3}return _vlaue;}}
         *   }
         *   ];
         */

    }, {
        key: 'getShaders',
        value: function getShaders() {
            return this.shaders;
        }

        /**
         * @function SuperMap.CartoCSS.prototype.destroy
         * @description CartoCSS解析对象的析构函数，用于销毁CartoCSS解析对象
         */

    }, {
        key: 'destroy',
        value: function destroy() {
            this.cartoStr = null;
            this.env = null;
            this.ruleSet = null;
            this.parser = null;
            this.shaders = null;
        }
    }]);

    return CartoCSS;
}();

_SuperMap.SuperMap._mapnik_reference_latest = {
    "version": "2.1.1",
    "style": {
        "filter-mode": {
            "type": ["all", "first"],
            "doc": "Control the processing behavior of Rule filters within a Style. If 'all' is used then all Rules are processed sequentially independent of whether any previous filters matched. If 'first' is used then it means processing ends after the first match (a positive filter evaluation) and no further Rules in the Style are processed ('first' is usually the default for CSS implementations on top of Mapnik to simplify translation from CSS to Mapnik XML)",
            "default-value": "all",
            "default-meaning": "All Rules in a Style are processed whether they have filters or not and whether or not the filter conditions evaluate to true."
        },
        "image-filters": {
            "css": "image-filters",
            "default-value": "none",
            "default-meaning": "no filters",
            "type": "functions",
            "functions": [["agg-stack-blur", 2], ["emboss", 0], ["blur", 0], ["gray", 0], ["sobel", 0], ["edge-detect", 0], ["x-gradient", 0], ["y-gradient", 0], ["invert", 0], ["sharpen", 0]],
            "doc": "A list of image filters."
        },
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
        },
        "opacity": {
            "css": "opacity",
            "type": "float",
            "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
            "default-value": 1,
            "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
        }
    },
    "layer": {
        "name": {
            "default-value": "",
            "type": "string",
            "required": true,
            "default-meaning": "No layer name has been provided",
            "doc": "The name of a layer. Can be anything you wish and is not strictly validated, but ideally unique  in the map"
        },
        "srs": {
            "default-value": "",
            "type": "string",
            "default-meaning": "No srs value is provided and the value will be inherited from the Map's srs",
            "doc": "The spatial reference system definition for the layer, aka the projection. Can either be a proj4 literal string like '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' or, if the proper proj4 epsg/nad/etc identifier files are installed, a string that uses an id like: '+init=epsg:4326'"
        },
        "status": {
            "default-value": true,
            "type": "boolean",
            "default-meaning": "This layer will be marked as active and available for processing",
            "doc": "A property that can be set to false to disable this layer from being processed"
        },
        "minzoom": {
            "default-value": "0",
            "type": "float",
            "default-meaning": "The layer will be visible at the minimum possible scale",
            "doc": "The minimum scale denominator that this layer will be visible at. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "maxzoom": {
            "default-value": "1.79769e+308",
            "type": "float",
            "default-meaning": "The layer will be visible at the maximum possible scale",
            "doc": "The maximum scale denominator that this layer will be visible at. The default is the numeric limit of the C++ double type, which may vary slightly by system, but is likely a massive number like 1.79769e+308 and ensures that this layer will always be visible unless the value is reduced. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "queryable": {
            "default-value": false,
            "type": "boolean",
            "default-meaning": "The layer will not be available for the direct querying of data values",
            "doc": "This property was added for GetFeatureInfo/WMS compatibility and is rarely used. It is off by default meaning that in a WMS context the layer will not be able to be queried unless the property is explicitly set to true"
        },
        "clear-label-cache": {
            "default-value": false,
            "type": "boolean",
            "default-meaning": "The renderer's collision detector cache (used for avoiding duplicate labels and overlapping markers) will not be cleared immediately before processing this layer",
            "doc": "This property, by default off, can be enabled to allow a user to clear the collision detector cache before a given layer is processed. This may be desirable to ensure that a given layers data shows up on the map even if it normally would not because of collisions with previously rendered labels or markers"
        },
        "group-by": {
            "default-value": "",
            "type": "string",
            "default-meaning": "No special layer grouping will be used during rendering",
            "doc": "https://github.com/mapnik/mapnik/wiki/Grouped-rendering"
        },
        "buffer-size": {
            "default-value": "0",
            "type": "float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "maximum-extent": {
            "default-value": "none",
            "type": "bbox",
            "default-meaning": "No clipping extent will be used",
            "doc": "An extent to be used to limit the bounds used to query this specific layer data during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Layer."
        }
    },
    "symbolizers": {
        "*": {
            "image-filters": {
                "css": "image-filters",
                "default-value": "none",
                "default-meaning": "no filters",
                "type": "functions",
                "functions": [["agg-stack-blur", 2], ["emboss", 0], ["blur", 0], ["gray", 0], ["sobel", 0], ["edge-detect", 0], ["x-gradient", 0], ["y-gradient", 0], ["invert", 0], ["sharpen", 0]],
                "doc": "A list of image filters."
            },
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "map": {
            "background-color": {
                "css": "background-color",
                "default-value": "none",
                "default-meaning": "transparent",
                "type": "color",
                "doc": "Map Background color"
            },
            "background-image": {
                "css": "background-image",
                "type": "uri",
                "default-value": "",
                "default-meaning": "transparent",
                "doc": "An image that is repeated below all features on a map as a background.",
                "description": "Map Background image"
            },
            "srs": {
                "css": "srs",
                "type": "string",
                "default-value": "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
                "default-meaning": "The proj4 literal of EPSG:4326 is assumed to be the Map's spatial reference and all data from layers within this map will be plotted using this coordinate system. If any layers do not declare an srs value then they will be assumed to be in the same srs as the Map and not transformations will be needed to plot them in the Map's coordinate space",
                "doc": "Map spatial reference (proj4 string)"
            },
            "buffer-size": {
                "css": "buffer-size",
                "default-value": "0",
                "type": "float",
                "default-meaning": "No buffer will be used",
                "doc": "Extra tolerance around the map (in pixels) used to ensure labels crossing tile boundaries are equally rendered in each tile (e.g. cut in each tile). Not intended to be used in combination with \"avoid-edges\"."
            },
            "maximum-extent": {
                "css": "",
                "default-value": "none",
                "type": "bbox",
                "default-meaning": "No clipping extent will be used",
                "doc": "An extent to be used to limit the bounds used to query all layers during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Map."
            },
            "base": {
                "css": "base",
                "default-value": "",
                "default-meaning": "This base path defaults to an empty string meaning that any relative paths to files referenced in styles or layers will be interpreted relative to the application process.",
                "type": "string",
                "doc": "Any relative paths used to reference files will be understood as relative to this directory path if the map is loaded from an in memory object rather than from the filesystem. If the map is loaded from the filesystem and this option is not provided it will be set to the directory of the stylesheet."
            },
            "paths-from-xml": {
                "css": "",
                "default-value": true,
                "default-meaning": "Paths read from XML will be interpreted from the location of the XML",
                "type": "boolean",
                "doc": "value to control whether paths in the XML will be interpreted from the location of the XML or from the working directory of the program that calls load_map()"
            },
            "minimum-version": {
                "css": "",
                "default-value": "none",
                "default-meaning": "Mapnik version will not be detected and no error will be thrown about compatibility",
                "type": "string",
                "doc": "The minumum Mapnik version (e.g. 0.7.2) needed to use certain functionality in the stylesheet"
            },
            "font-directory": {
                "css": "font-directory",
                "type": "uri",
                "default-value": "none",
                "default-meaning": "No map-specific fonts will be registered",
                "doc": "Path to a directory which holds fonts which should be registered when the Map is loaded (in addition to any fonts that may be automatically registered)."
            }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon"
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque"
            },
            "gamma": {
                "css": "polygon-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon edges"
            },
            "gamma-method": {
                "css": "polygon-gamma-method",
                "type": ["power", "linear", "none", "threshold", "multiply"],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "clip": {
                "css": "polygon-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]]
            },
            "comp-op": {
                "css": "polygon-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line"
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels"
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": ["miter", "round", "bevel"],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": ["butt", "round", "square"],
                "doc": "The display of line endings"
            },
            "stroke-gamma": {
                "css": "line-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of stroke line"
            },
            "stroke-gamma-method": {
                "css": "line-gamma-method",
                "type": ["power", "linear", "none", "threshold", "multiply"],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "stroke-dasharray": {
                "css": "line-dasharray",
                "type": "numbers",
                "doc": "A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-dashoffset": {
                "css": "line-dash-offset",
                "type": "numbers",
                "doc": "valid parameter but not currently used in renderers (only exists for experimental svg support in Mapnik which is not yet enabled)",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-miterlimit": {
                "css": "line-miterlimit",
                "type": "float",
                "doc": "The limit on the ratio of the miter length to the stroke-width. Used to automatically convert miter joins to bevel joins for sharp angles to avoid the miter extending beyond the thickness of the stroking path. Normally will not need to be set, but a larger value can sometimes help avoid jaggy artifacts.",
                "default-value": 4.0,
                "default-meaning": "Will auto-convert miters to bevel line joins when theta is less than 29 degrees as per the SVG spec: 'miterLength / stroke-width = 1 / sin ( theta / 2 )'"
            },
            "clip": {
                "css": "line-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "offset": {
                "css": "line-offset",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no offset",
                "doc": "Offsets a line a number of pixels parallel to its actual path. Postive values move the line left, negative values move it right (relative to the directionality of the line)."
            },
            "rasterizer": {
                "css": "line-rasterizer",
                "type": ["full", "fast"],
                "default-value": "full",
                "doc": "Exposes an alternate AGG rendering method that sacrifices some accuracy for speed."
            },
            "geometry-transform": {
                "css": "line-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]]
            },
            "comp-op": {
                "css": "line-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri"
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "placement": {
                "css": "marker-placement",
                "type": ["point", "line", "interior"],
                "default-value": "point",
                "default-meaning": "Place markers at the center point (centroid) of the geometry",
                "doc": "Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior"
            },
            "multi-policy": {
                "css": "marker-multi-policy",
                "type": ["each", "whole", "largest"],
                "default-value": "each",
                "default-meaning": "If a feature contains multiple geometries and the placement type is either point or interior then a marker will be rendered for each",
                "doc": "A special setting to allow the user to control rendering behavior for 'multi-geometries' (when a feature contains multiple geometries). This setting does not apply to markers placed along lines. The 'each' policy is default and means all geometries will get a marker. The 'whole' policy means that the aggregate centroid between all geometries will be used. The 'largest' policy means that only the largest (by bounding box areas) feature will get a rendered marker (this is how text labeling behaves by default)."
            },
            "marker-type": {
                "css": "marker-type",
                "type": ["arrow", "ellipse"],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width)"
            },
            "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "expression"
            },
            "height": {
                "css": "marker-height",
                "default-value": 10,
                "doc": "The height of the marker, if using one of the default types.",
                "type": "expression"
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color"
            },
            "allow-overlap": {
                "css": "marker-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping markers are shown or hidden.",
                "default-meaning": "Do not allow makers to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "marker-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "spacing": {
                "css": "marker-spacing",
                "doc": "Space between repeated labels",
                "default-value": 100,
                "type": "float"
            },
            "max-error": {
                "css": "marker-max-error",
                "type": "float",
                "default-value": 0.2,
                "doc": "The maximum difference between actual marker placement and the marker-spacing parameter. Setting a high value can allow the renderer to try to resolve placement conflicts with other symbolizers."
            },
            "transform": {
                "css": "marker-transform",
                "type": "functions",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "clip": {
                "css": "marker-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "marker-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "marker-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]]
            },
            "comp-op": {
                "css": "marker-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "shield": {
            "name": {
                "css": "shield-name",
                "type": "expression",
                "serialization": "content",
                "doc": "Value to use for a shield\"s text label. Data columns are specified using brackets like [column_name]"
            },
            "file": {
                "css": "shield-file",
                "required": true,
                "type": "uri",
                "default-value": "none",
                "doc": "Image file to render behind the shield text"
            },
            "face-name": {
                "css": "shield-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to use for the shield text",
                "default-value": "",
                "required": true
            },
            "unlock-image": {
                "css": "shield-unlock-image",
                "type": "boolean",
                "doc": "This parameter should be set to true if you are trying to position text beside rather than on top of the shield image",
                "default-value": false,
                "default-meaning": "text alignment relative to the shield image uses the center of the image as the anchor for text positioning."
            },
            "size": {
                "css": "shield-size",
                "type": "float",
                "doc": "The size of the shield text in pixels"
            },
            "fill": {
                "css": "shield-fill",
                "type": "color",
                "doc": "The color of the shield text"
            },
            "placement": {
                "css": "shield-placement",
                "type": ["point", "line", "vertex", "interior"],
                "default-value": "point",
                "doc": "How this shield should be placed. Point placement attempts to place it on top of points, line places along lines multiple times per feature, vertex places on the vertexes of polygons, and interior attempts to place inside of polygons."
            },
            "avoid-edges": {
                "css": "shield-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "type": "boolean",
                "default-value": false
            },
            "allow-overlap": {
                "css": "shield-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping shields are shown or hidden.",
                "default-meaning": "Do not allow shields to overlap with other map elements already placed."
            },
            "minimum-distance": {
                "css": "shield-min-distance",
                "type": "float",
                "default-value": 0,
                "doc": "Minimum distance to the next shield symbol, not necessarily the same shield."
            },
            "spacing": {
                "css": "shield-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "The spacing between repeated occurrences of the same shield on a line"
            },
            "minimum-padding": {
                "css": "shield-min-padding",
                "default-value": 0,
                "doc": "Determines the minimum amount of padding that a shield gets relative to other shields",
                "type": "float"
            },
            "wrap-width": {
                "css": "shield-wrap-width",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Length of a chunk of text in characters before wrapping text"
            },
            "wrap-before": {
                "css": "shield-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "shield-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long names."
            },
            "halo-fill": {
                "css": "shield-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "shield-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "character-spacing": {
                "css": "shield-character-spacing",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Horizontal spacing between characters (in pixels). Currently works for point placement only, not line placement."
            },
            "line-spacing": {
                "css": "shield-line-spacing",
                "doc": "Vertical spacing between lines of multiline labels (in pixels)",
                "type": "unsigned"
            },
            "dx": {
                "css": "shield-text-dx",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "shield-text-dy",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "shield-dx": {
                "css": "shield-dx",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "shield-dy": {
                "css": "shield-dy",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "opacity": {
                "css": "shield-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the image used for the shield",
                "default-value": 1
            },
            "text-opacity": {
                "css": "shield-text-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the text placed on top of the shield",
                "default-value": 1
            },
            "horizontal-alignment": {
                "css": "shield-horizontal-alignment",
                "type": ["left", "middle", "right", "auto"],
                "doc": "The shield's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "vertical-alignment": {
                "css": "shield-vertical-alignment",
                "type": ["top", "middle", "bottom", "auto"],
                "doc": "The shield's vertical alignment from its centerpoint",
                "default-value": "middle"
            },
            "text-transform": {
                "css": "shield-text-transform",
                "type": ["none", "uppercase", "lowercase", "capitalize"],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "justify-alignment": {
                "css": "shield-justify-alignment",
                "type": ["left", "center", "right", "auto"],
                "doc": "Define how text in a shield's label is justified",
                "default-value": "auto"
            },
            "clip": {
                "css": "shield-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "shield-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "line-pattern": {
            "file": {
                "css": "line-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "An image file to be repeated and warped along a line"
            },
            "clip": {
                "css": "line-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "line-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]]
            },
            "comp-op": {
                "css": "line-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "polygon-pattern": {
            "file": {
                "css": "polygon-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "Image to use as a repeated pattern fill within a polygon"
            },
            "alignment": {
                "css": "polygon-pattern-alignment",
                "type": ["local", "global"],
                "default-value": "local",
                "doc": "Specify whether to align pattern fills to the layer or to the map."
            },
            "gamma": {
                "css": "polygon-pattern-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon pattern edges"
            },
            "opacity": {
                "css": "polygon-pattern-opacity",
                "type": "float",
                "doc": "(Default 1.0) - Apply an opacity level to the image used for the pattern",
                "default-value": 1,
                "default-meaning": "The image is rendered without modifications"
            },
            "clip": {
                "css": "polygon-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]]
            },
            "comp-op": {
                "css": "polygon-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "raster": {
            "opacity": {
                "css": "raster-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float",
                "doc": "The opacity of the raster symbolizer on top of other symbolizers."
            },
            "filter-factor": {
                "css": "raster-filter-factor",
                "default-value": -1,
                "default-meaning": "Allow the datasource to choose appropriate downscaling.",
                "type": "float",
                "doc": "This is used by the Raster or Gdal datasources to pre-downscale images using overviews. Higher numbers can sometimes cause much better scaled image output, at the cost of speed."
            },
            "scaling": {
                "css": "raster-scaling",
                "type": ["near", "fast", "bilinear", "bilinear8", "bicubic", "spline16", "spline36", "hanning", "hamming", "hermite", "kaiser", "quadric", "catrom", "gaussian", "bessel", "mitchell", "sinc", "lanczos", "blackman"],
                "default-value": "near",
                "doc": "The scaling algorithm used to making different resolution versions of this raster layer. Bilinear is a good compromise between speed and accuracy, while lanczos gives the highest quality."
            },
            "mesh-size": {
                "css": "raster-mesh-size",
                "default-value": 16,
                "default-meaning": "Reprojection mesh will be 1/16 of the resolution of the source image",
                "type": "unsigned",
                "doc": "A reduced resolution mesh is used for raster reprojection, and the total image size is divided by the mesh-size to determine the quality of that mesh. Values for mesh-size larger than the default will result in faster reprojection but might lead to distortion."
            },
            "comp-op": {
                "css": "raster-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "allow-overlap": {
                "css": "point-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping points are shown or hidden.",
                "default-meaning": "Do not allow points to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "point-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            },
            "placement": {
                "css": "point-placement",
                "type": ["centroid", "interior"],
                "doc": "How this point should be placed. Centroid calculates the geometric center of a polygon, which can be outside of it, while interior always places inside of a polygon.",
                "default-value": "centroid"
            },
            "transform": {
                "css": "point-transform",
                "type": "functions",
                "functions": [["matrix", 6], ["translate", 2], ["scale", 2], ["rotate", 3], ["skewX", 1], ["skewY", 1]],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "comp-op": {
                "css": "point-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "text": {
            "name": {
                "css": "text-name",
                "type": "expression",
                "required": true,
                "default-value": "",
                "serialization": "content",
                "doc": "Value to use for a text label. Data columns are specified using brackets like [column_name]"
            },
            "face-name": {
                "css": "text-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to render a label in",
                "required": true
            },
            "size": {
                "css": "text-size",
                "type": "float",
                "default-value": 10,
                "doc": "Text size in pixels"
            },
            "text-ratio": {
                "css": "text-ratio",
                "doc": "Define the amount of text (of the total) present on successive lines when wrapping occurs",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-width": {
                "css": "text-wrap-width",
                "doc": "Length of a chunk of text in characters before wrapping text",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-before": {
                "css": "text-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "text-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long text."
            },
            "spacing": {
                "css": "text-spacing",
                "type": "unsigned",
                "doc": "Distance between repeated text labels on a line (aka. label-spacing)"
            },
            "character-spacing": {
                "css": "text-character-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "Horizontal spacing adjustment between characters in pixels"
            },
            "line-spacing": {
                "css": "text-line-spacing",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Vertical spacing adjustment between lines in pixels"
            },
            "label-position-tolerance": {
                "css": "text-label-position-tolerance",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Allows the label to be displaced from its ideal position by a number of pixels (only works with placement:line)"
            },
            "max-char-angle-delta": {
                "css": "text-max-char-angle-delta",
                "type": "float",
                "default-value": "22.5",
                "doc": "The maximum angle change, in degrees, allowed between adjacent characters in a label. This value internally is converted to radians to the default is 22.5*math.pi/180.0. The higher the value the fewer labels will be placed around around sharp corners."
            },
            "fill": {
                "css": "text-fill",
                "doc": "Specifies the color for the text",
                "default-value": "#000000",
                "type": "color"
            },
            "opacity": {
                "css": "text-opacity",
                "doc": "A number from 0 to 1 specifying the opacity for the text",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "type": "float"
            },
            "halo-fill": {
                "css": "text-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "text-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "dx": {
                "css": "text-dx",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "text-dy",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "vertical-alignment": {
                "css": "text-vertical-alignment",
                "type": ["top", "middle", "bottom", "auto"],
                "doc": "Position of label relative to point position.",
                "default-value": "auto",
                "default-meaning": "Default affected by value of dy; \"bottom\" for dy>0, \"top\" for dy<0."
            },
            "avoid-edges": {
                "css": "text-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "default-value": false,
                "type": "boolean"
            },
            "minimum-distance": {
                "css": "text-min-distance",
                "doc": "Minimum permitted distance to the next text symbolizer.",
                "type": "float"
            },
            "minimum-padding": {
                "css": "text-min-padding",
                "doc": "Determines the minimum amount of padding that a text symbolizer gets relative to other text",
                "type": "float"
            },
            "minimum-path-length": {
                "css": "text-min-path-length",
                "type": "float",
                "default-value": 0,
                "default-meaning": "place labels on all paths",
                "doc": "Place labels only on paths longer than this value."
            },
            "allow-overlap": {
                "css": "text-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping text is shown or hidden.",
                "default-meaning": "Do not allow text to overlap with other text - overlapping markers will not be shown."
            },
            "orientation": {
                "css": "text-orientation",
                "type": "expression",
                "doc": "Rotate the text."
            },
            "placement": {
                "css": "text-placement",
                "type": ["point", "line", "vertex", "interior"],
                "default-value": "point",
                "doc": "Control the style of placement of a point versus the geometry it is attached to."
            },
            "placement-type": {
                "css": "text-placement-type",
                "doc": "Re-position and/or re-size text to avoid overlaps. \"simple\" for basic algorithm (using text-placements string,) \"dummy\" to turn this feature off.",
                "type": ["dummy", "simple"],
                "default-value": "dummy"
            },
            "placements": {
                "css": "text-placements",
                "type": "string",
                "default-value": "",
                "doc": "If \"placement-type\" is set to \"simple\", use this \"POSITIONS,[SIZES]\" string. An example is `text-placements: \"E,NE,SE,W,NW,SW\";` "
            },
            "text-transform": {
                "css": "text-transform",
                "type": ["none", "uppercase", "lowercase", "capitalize"],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "horizontal-alignment": {
                "css": "text-horizontal-alignment",
                "type": ["left", "middle", "right", "auto"],
                "doc": "The text's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "justify-alignment": {
                "css": "text-align",
                "type": ["left", "right", "center", "auto"],
                "doc": "Define how text is justified",
                "default-value": "auto",
                "default-meaning": "Auto alignment means that text will be centered by default except when using the `placement-type` parameter - in that case either right or left justification will be used automatically depending on where the text could be fit given the `text-placements` directives"
            },
            "clip": {
                "css": "text-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "text-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear", "src", "dst", "src-over", "dst-over", "src-in", "dst-in", "src-out", "dst-out", "src-atop", "dst-atop", "xor", "plus", "minus", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "contrast", "invert", "invert-rgb", "grain-merge", "grain-extract", "hue", "saturation", "color", "value"]
            }
        },
        "building": {
            "fill": {
                "css": "building-fill",
                "default-value": "#FFFFFF",
                "doc": "The color of the buildings walls.",
                "type": "color"
            },
            "fill-opacity": {
                "css": "building-fill-opacity",
                "type": "float",
                "doc": "The opacity of the building as a whole, including all walls.",
                "default-value": 1
            },
            "height": {
                "css": "building-height",
                "doc": "The height of the building in pixels.",
                "type": "expression",
                "default-value": "0"
            }
        }
    },
    "colors": {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "grey": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50],
        "transparent": [0, 0, 0, 0]
    },
    "filter": {
        "value": ["true", "false", "null", "point", "linestring", "polygon", "collection"]
    }
};

CartoCSS['mapnik_reference'] = {
    version: {
        latest: _SuperMap.SuperMap._mapnik_reference_latest,
        '2.1.1': _SuperMap.SuperMap._mapnik_reference_latest
    }
};

_SuperMap.SuperMap.CartoCSS = CartoCSS;
_SuperMap.SuperMap.CartoCSS.Tree = {};
_SuperMap.SuperMap.CartoCSS.Tree.operate = function (op, a, b) {
    switch (op) {
        case '+':
            return a + b;
        case '-':
            return a - b;
        case '*':
            return a * b;
        case '%':
            return a % b;
        case '/':
            return a / b;
    }
};
_SuperMap.SuperMap.CartoCSS.Tree.functions = {
    rgb: function rgb(r, g, b) {
        return this.rgba(r, g, b, 1.0);
    },
    rgba: function rgba(r, g, b, a) {
        var me = this;
        var rgb = [r, g, b].map(function (c) {
            return me.number(c);
        });
        a = me.number(a);
        if (rgb.some(isNaN) || isNaN(a)) {
            return null;
        }
        return new _SuperMap.SuperMap.CartoCSS.Tree.Color(rgb, a);
    },
    // Only require val
    stop: function stop(val) {
        var color, mode;
        if (arguments.length > 1) {
            color = arguments[1];
        }
        if (arguments.length > 2) {
            mode = arguments[2];
        }

        return {
            is: 'tag',
            val: val,
            color: color,
            mode: mode,
            toString: function toString(env) {
                return '\n\t<stop value="' + val.ev(env) + '"' + (color ? ' color="' + color.ev(env) + '" ' : '') + (mode ? ' mode="' + mode.ev(env) + '" ' : '') + '/>';
            }
        };
    },
    hsl: function hsl(h, s, l) {
        return this.hsla(h, s, l, 1.0);
    },
    hsla: function hsla(h, s, l, a) {
        h = this.number(h) % 360 / 360;
        s = this.number(s);
        l = this.number(l);
        a = this.number(a);
        if ([h, s, l, a].some(isNaN)) {
            return null;
        }

        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            m1 = l * 2 - m2;

        return this.rgba(hue(h + 1 / 3) * 255, hue(h) * 255, hue(h - 1 / 3) * 255, a);

        function hue(h) {
            h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
            if (h * 6 < 1) {
                return m1 + (m2 - m1) * h * 6;
            } else if (h * 2 < 1) {
                return m2;
            } else if (h * 3 < 2) {
                return m1 + (m2 - m1) * (2 / 3 - h) * 6;
            } else {
                return m1;
            }
        }
    },
    hue: function hue(color) {
        if (!('toHSL' in color)) {
            return null;
        }
        return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(Math.round(color.toHSL().h));
    },
    saturation: function saturation(color) {
        if (!('toHSL' in color)) {
            return null;
        }
        return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(Math.round(color.toHSL().s * 100), '%');
    },
    lightness: function lightness(color) {
        if (!('toHSL' in color)) {
            return null;
        }
        return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(Math.round(color.toHSL().l * 100), '%');
    },
    alpha: function alpha(color) {
        if (!('toHSL' in color)) {
            return null;
        }
        return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(color.toHSL().a);
    },
    saturate: function saturate(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();

        hsl.s += amount.value / 100;
        hsl.s = this.clamp(hsl.s);
        return this.hsla_simple(hsl);
    },
    desaturate: function desaturate(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();

        hsl.s -= amount.value / 100;
        hsl.s = this.clamp(hsl.s);
        return this.hsla_simple(hsl);
    },
    lighten: function lighten(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();

        hsl.l += amount.value / 100;
        hsl.l = this.clamp(hsl.l);
        return this.hsla_simple(hsl);
    },
    darken: function darken(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();

        hsl.l -= amount.value / 100;
        hsl.l = this.clamp(hsl.l);
        return this.hsla_simple(hsl);
    },
    fadein: function fadein(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();

        hsl.a += amount.value / 100;
        hsl.a = this.clamp(hsl.a);
        return this.hsla_simple(hsl);
    },
    fadeout: function fadeout(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();

        hsl.a -= amount.value / 100;
        hsl.a = this.clamp(hsl.a);
        return this.hsla_simple(hsl);
    },
    spin: function spin(color, amount) {
        if (!('toHSL' in color)) {
            return null;
        }
        var hsl = color.toHSL();
        var hue = (hsl.h + amount.value) % 360;

        hsl.h = hue < 0 ? 360 + hue : hue;

        return this.hsla_simple(hsl);
    },
    replace: function replace(entity, a, b) {
        if (entity.is === 'field') {
            return entity.toString + '.replace(' + a.toString() + ', ' + b.toString() + ')';
        } else {
            return entity.replace(a, b);
        }
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function mix(color1, color2, weight) {
        var p = weight.value / 100.0;
        var w = p * 2 - 1;
        var a = color1.toHSL().a - color2.toHSL().a;

        var w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;

        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2, color1.rgb[1] * w1 + color2.rgb[1] * w2, color1.rgb[2] * w1 + color2.rgb[2] * w2];

        var alpha = color1.alpha * p + color2.alpha * (1 - p);

        return new _SuperMap.SuperMap.CartoCSS.Tree.Color(rgb, alpha);
    },
    greyscale: function greyscale(color) {
        return this.desaturate(color, new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(100));
    },
    '%': function _(quoted /* arg, arg, ...*/) {
        var args = Array.prototype.slice.call(arguments, 1),
            str = quoted.value;

        for (var i = 0; i < args.length; i++) {
            str = str.replace(/%s/, args[i].value).replace(/%[da]/, args[i].toString());
        }
        str = str.replace(/%%/g, '%');
        return new _SuperMap.SuperMap.CartoCSS.Tree.Quoted(str);
    },

    hsla_simple: function hsla_simple(h) {
        return this.hsla(h.h, h.s, h.l, h.a);
    },

    number: function number(n) {
        if (n instanceof _SuperMap.SuperMap.CartoCSS.Tree.Dimension) {
            return parseFloat(n.unit === '%' ? n.value / 100 : n.value);
        } else if (typeof n === 'number') {
            return n;
        } else {
            return NaN;
        }
    },

    clamp: function clamp(val) {
        return Math.min(1, Math.max(0, val));
    }
};

_SuperMap.SuperMap.CartoCSS.Tree.Call = function () {
    function Call(name, args, index) {
        _classCallCheck(this, Call);

        this.is = 'call';
        this.name = name;
        this.args = args;
        this.index = index;
    }

    // When evuating a function call,
    // we either find the function in `tree.functions` [1],
    // in which case we call it, passing the  evaluated arguments,
    // or we simply print it out as it appeared originally [2].
    // The *functions.js* file contains the built-in functions.
    // The reason why we evaluate the arguments, is in the case where
    // we try to pass a variable to a function, like: `saturate(@color)`.
    // The function should receive the value, not the variable.


    _createClass(Call, [{
        key: 'ev',
        value: function ev(env) {
            var args = this.args.map(function (a) {
                return a.ev(env);
            });

            for (var i = 0; i < args.length; i++) {
                if (args[i].is === 'undefined') {
                    return {
                        is: 'undefined',
                        value: 'undefined'
                    };
                }
            }

            if (this.name in _SuperMap.SuperMap.CartoCSS.Tree.functions) {
                if (_SuperMap.SuperMap.CartoCSS.Tree.functions[this.name].length <= args.length) {
                    var val = _SuperMap.SuperMap.CartoCSS.Tree.functions[this.name].apply(_SuperMap.SuperMap.CartoCSS.Tree.functions, args);
                    if (val === null) {
                        env.error({
                            message: 'incorrect arguments given to ' + this.name + '()',
                            index: this.index,
                            type: 'runtime',
                            filename: this.filename
                        });
                        return { is: 'undefined', value: 'undefined' };
                    }
                    return val;
                } else {
                    env.error({
                        message: 'incorrect number of arguments for ' + this.name + '(). ' + _SuperMap.SuperMap.CartoCSS.Tree.functions[this.name].length + ' expected.',
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return {
                        is: 'undefined',
                        value: 'undefined'
                    };
                }
            } else {
                var fn = _SuperMap.SuperMap.CartoCSS.Tree.Reference.mapnikFunctions[this.name];
                if (fn === undefined) {
                    var functions = (0, _toPairs2["default"])(_SuperMap.SuperMap.CartoCSS.Tree.Reference.mapnikFunctions);
                    // cheap closest, needs improvement.
                    var name = this.name;
                    var mean = functions.map(function (f) {
                        return [f[0], _SuperMap.SuperMap.CartoCSS.Tree.Reference.editDistance(name, f[0]), f[1]];
                    }).sort(function (a, b) {
                        return a[1] - b[1];
                    });
                    env.error({
                        message: 'unknown function ' + this.name + '(), did you mean ' + mean[0][0] + '(' + mean[0][2] + ')',
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return {
                        is: 'undefined',
                        value: 'undefined'
                    };
                }
                if (fn !== args.length &&
                // support variable-arg functions like `colorize-alpha`
                fn !== -1) {
                    env.error({
                        message: 'function ' + this.name + '() takes ' + fn + ' arguments and was given ' + args.length,
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return {
                        is: 'undefined',
                        value: 'undefined'
                    };
                } else {
                    // Save the evaluated versions of arguments
                    this.args = args;
                    return this;
                }
            }
        }
    }, {
        key: 'toString',
        value: function toString(env, format) {
            if (this.args.length) {
                return this.name + '(' + this.args.join(',') + ')';
            } else {
                return this.name;
            }
        }
    }]);

    return Call;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Color = function () {
    function Color(rgb, a) {
        _classCallCheck(this, Color);

        this.is = 'color';
        // The end goal here, is to parse the arguments
        // into an integer triplet, such as `128, 255, 0`
        //
        // This facilitates operations and conversions.
        if (Array.isArray(rgb)) {
            this.rgb = rgb.slice(0, 3);
        } else if (rgb.length == 6) {
            this.rgb = rgb.match(/.{2}/g).map(function (c) {
                return parseInt(c, 16);
            });
        } else {
            this.rgb = rgb.split('').map(function (c) {
                return parseInt(c + c, 16);
            });
        }

        if (typeof a === 'number') {
            this.alpha = a;
        } else if (rgb.length === 4) {
            this.alpha = rgb[3];
        } else {
            this.alpha = 1;
        }
    }

    _createClass(Color, [{
        key: 'ev',
        value: function ev() {
            return this;
        }

        // If we have some transparency, the only way to represent it
        // is via `rgba`. Otherwise, we use the hex representation,
        // which has better compatibility with older browsers.
        // Values are capped between `0` and `255`, rounded and zero-padded.

    }, {
        key: 'toString',
        value: function toString() {
            /* if (this.alpha < 1.0) {*/
            return 'rgba(' + this.rgb.map(function (c) {
                return Math.round(c);
            }).concat(this.alpha).join(', ') + ')';
            /*} else {
             return '#' + this.rgb.map(function(i) {
             i = Math.round(i);
             i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);
             return i.length === 1 ? '0' + i : i;
             }).join('');
             }*/
        }

        // Operations have to be done per-channel, if not,
        // channels will spill onto each other. Once we have
        // our result, in the form of an integer triplet,
        // we create a new Color node to hold the result.

    }, {
        key: 'operate',
        value: function operate(env, op, other) {
            var result = [];

            if (!(other instanceof _SuperMap.SuperMap.CartoCSS.Tree.Color)) {
                other = other.toColor();
            }

            for (var c = 0; c < 3; c++) {
                result[c] = _SuperMap.SuperMap.CartoCSS.Tree.operate(op, this.rgb[c], other.rgb[c]);
            }
            return new _SuperMap.SuperMap.CartoCSS.Tree.Color(result);
        }
    }, {
        key: 'toHSL',
        value: function toHSL() {
            var r = this.rgb[0] / 255,
                g = this.rgb[1] / 255,
                b = this.rgb[2] / 255,
                a = this.alpha;

            var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
            var h,
                s,
                l = (max + min) / 2,
                d = max - min;

            if (max === min) {
                h = s = 0;
            } else {
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4;
                        break;
                    default:
                        break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s, l: l, a: a };
        }
    }]);

    return Color;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Comment = function () {
    function Comment(value, silent) {
        _classCallCheck(this, Comment);

        this.value = value;
        this.silent = !!silent;
    }

    _createClass(Comment, [{
        key: 'toString',
        value: function toString(env) {
            return '<!--' + this.value + '-->';
        }
    }, {
        key: 'ev',
        value: function ev() {
            return this;
        }
    }]);

    return Comment;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Definition = function () {
    function Definition(selector, rules) {
        _classCallCheck(this, Definition);

        this.elements = selector.elements;
        //assert.ok(selector.filters instanceof SuperMap.CartoCSS.Tree.Filterset);
        this.rules = rules;
        this.ruleIndex = {};
        for (var i = 0; i < this.rules.length; i++) {
            if ('zoom' in this.rules[i]) {
                this.rules[i] = this.rules[i].clone();
            }
            this.rules[i].zoom = selector.zoom;
            this.ruleIndex[this.rules[i].updateID()] = true;
        }
        this.filters = selector.filters;
        this.zoom = selector.zoom;
        this.attachment = selector.attachment || '__default__';
        this.specificity = selector.specificity();
    }

    _createClass(Definition, [{
        key: 'toString',
        value: function toString() {
            var str = this.filters.toString();
            for (var i = 0; i < this.rules.length; i++) {
                str += '\n    ' + this.rules[i];
            }
            return str;
        }
    }, {
        key: 'toJS',
        value: function toJS(env) {
            var shaderAttrs = {};

            // merge conditions from filters with zoom condition of the
            // definition
            var zoom = this.zoom;
            //var frame_offset = this.frame_offset;
            var _if = this.filters.toJS(env);
            var filters = [zoom];
            if (_if) {
                filters.push(_if);
            }
            //if(frame_offset) filters.push('ctx["frame-offset"] === ' + frame_offset);
            _if = filters.join(" && ");

            function eachRule(rule) {
                if (rule instanceof _SuperMap.SuperMap.CartoCSS.Tree.Rule) {
                    shaderAttrs[rule.name] = shaderAttrs[rule.name] || [];
                    if (_if) {
                        shaderAttrs[rule.name].push("if(" + _if + "){" + rule.value.toJS(env) + "}");
                    } else {
                        shaderAttrs[rule.name].push(rule.value.toJS(env));
                    }
                } else {
                    if (rule instanceof _SuperMap.SuperMap.CartoCSS.Tree.Ruleset) {
                        var sh = rule.toJS(env);
                        for (var v in sh) {
                            shaderAttrs[v] = shaderAttrs[v] || [];
                            for (var attr in sh[v]) {
                                shaderAttrs[v].push(sh[v][attr]);
                            }
                        }
                    }
                }
            }
            for (var id in this.rules) {
                eachRule(this.rules[id]);
            }
            return shaderAttrs;
        }
    }]);

    return Definition;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Dimension = function () {
    function Dimension(value, unit, index) {
        _classCallCheck(this, Dimension);

        this.is = 'float';
        this.physical_units = ['m', 'cm', 'in', 'mm', 'pt', 'pc'];
        this.screen_units = ['px', '%'];
        this.all_units = ['m', 'cm', 'in', 'mm', 'pt', 'pc', 'px', '%'];
        this.densities = {
            m: 0.0254,
            mm: 25.4,
            cm: 2.54,
            pt: 72,
            pc: 6
        };
        this.value = parseFloat(value);
        this.unit = unit || null;
        this.index = index;
    }

    _createClass(Dimension, [{
        key: 'ev',
        value: function ev(env) {
            if (this.unit && this.all_units.indexOf(this.unit) < 0) {
                env.error({
                    message: "Invalid unit: '" + this.unit + "'",
                    index: this.index
                });
                return { is: 'undefined', value: 'undefined' };
            }

            // normalize units which are not px or %
            if (this.unit && this.physical_units.indexOf(this.unit) >= 0) {
                if (!env.ppi) {
                    env.error({
                        message: "ppi is not set, so metric units can't be used",
                        index: this.index
                    });
                    return { is: 'undefined', value: 'undefined' };
                }
                // convert all units to inch
                // convert inch to px using ppi
                this.value = this.value / this.densities[this.unit] * env.ppi;
                this.unit = 'px';
            }

            return this;
        }
    }, {
        key: 'toColor',
        value: function toColor() {
            return new _SuperMap.SuperMap.CartoCSS.Tree.Color([this.value, this.value, this.value]);
        }
    }, {
        key: 'round',
        value: function round() {
            this.value = Math.round(this.value);
            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.value.toString();
        }
    }, {
        key: 'operate',
        value: function operate(env, op, other) {
            if (this.unit === '%' && other.unit !== '%') {
                env.error({
                    message: 'If two operands differ, the first must not be %',
                    index: this.index
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            if (this.unit !== '%' && other.unit === '%') {
                if (op === '*' || op === '/' || op === '%') {
                    env.error({
                        message: 'Percent values can only be added or subtracted from other values',
                        index: this.index
                    });
                    return {
                        is: 'undefined',
                        value: 'undefined'
                    };
                }

                return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(_SuperMap.SuperMap.CartoCSS.Tree.operate(op, this.value, this.value * other.value * 0.01), this.unit);
            }

            //here the operands are either the same (% or undefined or px), or one is undefined and the other is px
            return new _SuperMap.SuperMap.CartoCSS.Tree.Dimension(_SuperMap.SuperMap.CartoCSS.Tree.operate(op, this.value, other.value), this.unit || other.unit);
        }
    }]);

    return Dimension;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Element = function () {
    function Element(value) {
        _classCallCheck(this, Element);

        this.value = value.trim();
        if (this.value[0] === '#') {
            this.type = 'id';
            this.clean = this.value.replace(/^#/, '');
        }
        if (this.value[0] === '.') {
            this.type = 'class';
            this.clean = this.value.replace(/^\./, '');
        }
        if (this.value.indexOf('*') !== -1) {
            this.type = 'wildcard';
        }
    }

    _createClass(Element, [{
        key: 'specificity',
        value: function specificity() {
            return [this.type === 'id' ? 1 : 0, // a
            this.type === 'class' ? 1 : 0 // b
            ];
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.value;
        }
    }]);

    return Element;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Expression = function () {
    function Expression(value) {
        _classCallCheck(this, Expression);

        this.is = 'expression';
        this.value = value;
    }

    _createClass(Expression, [{
        key: 'ev',
        value: function ev(env) {
            if (this.value.length > 1) {
                return new _SuperMap.SuperMap.CartoCSS.Tree.Expression(this.value.map(function (e) {
                    return e.ev(env);
                }));
            } else {
                return this.value[0].ev(env);
            }
        }
    }, {
        key: 'toString',
        value: function toString(env) {
            return this.value.map(function (e) {
                return e.toString(env);
            }).join(' ');
        }
    }]);

    return Expression;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Field = function () {
    function Field(content) {
        _classCallCheck(this, Field);

        this.is = 'field';
        this.value = content || '';
    }

    _createClass(Field, [{
        key: 'toString',
        value: function toString() {
            return '["' + this.value.toUpperCase() + '"]';
        }
    }, {
        key: 'ev',
        value: function ev() {
            return this;
        }
    }]);

    return Field;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Filter = function () {
    function Filter(key, op, val, index, filename) {
        _classCallCheck(this, Filter);

        this.ops = {
            '<': [' &lt; ', 'numeric'],
            '>': [' &gt; ', 'numeric'],
            '=': [' = ', 'both'],
            '!=': [' != ', 'both'],
            '<=': [' &lt;= ', 'numeric'],
            '>=': [' &gt;= ', 'numeric'],
            '=~': ['.match(', 'string', ')']
        };

        this.key = key;
        this.op = op;
        this.val = val;
        this.index = index;
        this.filename = filename;

        this.id = this.key + this.op + this.val;
    }

    _createClass(Filter, [{
        key: 'ev',
        value: function ev(env) {
            this.key = this.key.ev(env);
            this.val = this.val.ev(env);
            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return '[' + this.id + ']';
        }
    }]);

    return Filter;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Filterset = function () {
    function Filterset() {
        _classCallCheck(this, Filterset);

        this.filters = {};
    }

    _createClass(Filterset, [{
        key: 'toJS',
        value: function toJS(env) {
            function eachFilter(filter) {
                var op = filter.op;
                if (op === "=") {
                    op = "==";
                }
                var val = filter.val;
                if (filter._val !== undefined) {
                    val = filter._val.toString(true);
                }

                //对scale进行特殊处理，将值转换成数值
                if (filter.key && filter.key.value === 'scale') {
                    val = +val;
                } else if (typeof val === 'string' || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
                    val = "'" + val + "'";
                }
                var attrs = "attributes";
                return attrs + "&&" + attrs + filter.key + "&&" + attrs + filter.key + " " + op + val;
            }
            var results = [];
            for (var id in this.filters) {
                results.push(eachFilter(this.filters[id]));
            }
            return results.join(' && ');
        }
    }, {
        key: 'toString',
        value: function toString() {
            var arr = [];
            for (var id in this.filters) {
                arr.push(this.filters[id].id);
            }
            return arr.sort().join('\t');
        }
    }, {
        key: 'ev',
        value: function ev(env) {
            for (var i in this.filters) {
                this.filters[i].ev(env);
            }
            return this;
        }
    }, {
        key: 'clone',
        value: function clone() {
            var clone = new _SuperMap.SuperMap.CartoCSS.Tree.Filterset();
            for (var id in this.filters) {
                clone.filters[id] = this.filters[id];
            }
            return clone;
        }
    }, {
        key: 'cloneWith',
        value: function cloneWith(other) {
            var additions = [];
            for (var id in other.filters) {
                var status = this.addable(other.filters[id]);
                // status is true, false or null. if it's null we don't fail this
                // clone nor do we add the filter.
                if (status === false) {
                    return false;
                }
                if (status === true) {
                    // Adding the filter will override another value.
                    additions.push(other.filters[id]);
                }
            }

            // Adding the other filters doesn't make this filterset invalid, but it
            // doesn't add anything to it either.
            if (!additions.length) {
                return null;
            }

            // We can successfully add all filters. Now clone the filterset and add the
            // new rules.
            var clone = new _SuperMap.SuperMap.CartoCSS.Tree.Filterset();

            // We can add the rules that are already present without going through the
            // add function as a Filterset is always in it's simplest canonical form.
            for (id in this.filters) {
                clone.filters[id] = this.filters[id];
            }

            // Only add new filters that actually change the filter.
            while (id = additions.shift()) {
                clone.add(id);
            }

            return clone;
        }
    }, {
        key: 'addable',
        value: function addable(filter) {
            var key = filter.key.toString(),
                value = filter.val.toString();

            if (value.match(/^[0-9]+(\.[0-9]*)?$/)) {
                value = parseFloat(value);
            }

            switch (filter.op) {
                case '=':
                    // if there is already foo= and we're adding foo=
                    if (this.filters[key + '='] !== undefined) {
                        if (this.filters[key + '='].val.toString() != value) {
                            return false;
                        } else {
                            return null;
                        }
                    }
                    if (this.filters[key + '!=' + value] !== undefined) {
                        return false;
                    }
                    if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {
                        return false;
                    }
                    if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {
                        return false;
                    }
                    if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {
                        return false;
                    }
                    if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {
                        return false;
                    }
                    return true;

                case '=~':
                    return true;

                case '!=':
                    if (this.filters[key + '='] !== undefined) {
                        return this.filters[key + '='].val === value ? false : null;
                    }
                    if (this.filters[key + '!=' + value] !== undefined) {
                        return null;
                    }
                    if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {
                        return null;
                    }
                    if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {
                        return null;
                    }
                    if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {
                        return null;
                    }
                    if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {
                        return null;
                    }
                    return true;

                case '>':
                    if (key + '=' in this.filters) {
                        if (this.filters[key + '='].val <= value) {
                            return false;
                        } else {
                            return null;
                        }
                    }
                    if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {
                        return false;
                    }
                    if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) {
                        return false;
                    }
                    if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {
                        return null;
                    }
                    if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {
                        return null;
                    }
                    return true;

                case '>=':
                    if (this.filters[key + '='] !== undefined) {
                        return this.filters[key + '='].val < value ? false : null;
                    }
                    if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {
                        return false;
                    }
                    if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {
                        return false;
                    }
                    if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {
                        return null;
                    }
                    if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) {
                        return null;
                    }
                    return true;

                case '<':
                    if (this.filters[key + '='] !== undefined) {
                        return this.filters[key + '='].val >= value ? false : null;
                    }
                    if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {
                        return false;
                    }
                    if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) {
                        return false;
                    }
                    if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {
                        return null;
                    }
                    if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {
                        return null;
                    }
                    return true;

                case '<=':
                    if (this.filters[key + '='] !== undefined) {
                        return this.filters[key + '='].val > value ? false : null;
                    }
                    if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {
                        return false;
                    }
                    if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {
                        return false;
                    }
                    if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {
                        return null;
                    }
                    if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) {
                        return null;
                    }
                    return true;

                default:
                    break;
            }
        }
    }, {
        key: 'conflict',
        value: function conflict(filter) {
            var key = filter.key.toString(),
                value = filter.val.toString();

            if (!isNaN(parseFloat(value))) {
                value = parseFloat(value);
            }

            // if (a=b) && (a=c)
            // if (a=b) && (a!=b)
            // or (a!=b) && (a=b)
            if (filter.op === '=' && this.filters[key + '='] !== undefined && value != this.filters[key + '='].val.toString() || filter.op === '!=' && this.filters[key + '='] !== undefined && value == this.filters[key + '='].val.toString() || filter.op === '=' && this.filters[key + '!='] !== undefined && value === this.filters[key + '!='].val.toString()) {
                return filter.toString() + ' added to ' + this.toString() + ' produces an invalid filter';
            }

            return false;
        }
    }, {
        key: 'add',
        value: function add(filter, env) {
            var key = filter.key.toString(),
                op = filter.op,
                conflict = this.conflict(filter),
                numval;
            if (conflict) {
                return conflict;
            }

            if (op === '=') {
                for (var i in this.filters) {
                    if (this.filters[i].key === key) {
                        delete this.filters[i];
                    }
                }
                this.filters[key + '='] = filter;
            } else if (op === '!=') {
                this.filters[key + '!=' + filter.val] = filter;
            } else if (op === '=~') {
                this.filters[key + '=~' + filter.val] = filter;
            } else if (op === '>') {
                // If there are other filters that are also >
                // but are less than this one, they don't matter, so
                // remove them.
                for (var j in this.filters) {
                    if (this.filters[j].key === key && this.filters[j].val <= filter.val) {
                        delete this.filters[j];
                    }
                }
                this.filters[key + '>'] = filter;
            } else if (op === '>=') {
                for (var k in this.filters) {
                    numval = +this.filters[k].val.toString();
                    if (this.filters[k].key === key && numval < filter.val) {
                        delete this.filters[k];
                    }
                }
                if (this.filters[key + '!=' + filter.val] !== undefined) {
                    delete this.filters[key + '!=' + filter.val];
                    filter.op = '>';
                    this.filters[key + '>'] = filter;
                } else {
                    this.filters[key + '>='] = filter;
                }
            } else if (op === '<') {
                for (var l in this.filters) {
                    numval = +this.filters[l].val.toString();
                    if (this.filters[l].key === key && numval >= filter.val) {
                        delete this.filters[l];
                    }
                }
                this.filters[key + '<'] = filter;
            } else if (op === '<=') {
                for (var m in this.filters) {
                    numval = +this.filters[m].val.toString();
                    if (this.filters[m].key === key && numval > filter.val) {
                        delete this.filters[m];
                    }
                }
                if (this.filters[key + '!=' + filter.val] !== undefined) {
                    delete this.filters[key + '!=' + filter.val];
                    filter.op = '<';
                    this.filters[key + '<'] = filter;
                } else {
                    this.filters[key + '<='] = filter;
                }
            }
        }
    }]);

    return Filterset;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Fontset = function Fontset(env, fonts) {
    _classCallCheck(this, Fontset);

    this.fonts = fonts;
    this.name = 'fontset-' + env.effects.length;
};
_SuperMap.SuperMap.CartoCSS.Tree.Invalid = function () {
    function Invalid(chunk, index, message) {
        _classCallCheck(this, Invalid);

        this.is = 'invalid';
        this.chunk = chunk;
        this.index = index;
        this.type = 'syntax';
        this.message = message || "Invalid code: " + this.chunk;
    }

    _createClass(Invalid, [{
        key: 'ev',
        value: function ev(env) {
            env.error({
                chunk: this.chunk,
                index: this.index,
                type: 'syntax',
                message: this.message || "Invalid code: " + this.chunk
            });
            return {
                is: 'undefined'
            };
        }
    }]);

    return Invalid;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Keyword = function () {
    _createClass(Keyword, [{
        key: 'ev',
        value: function ev() {
            return this;
        }
    }]);

    function Keyword(value) {
        _classCallCheck(this, Keyword);

        this.value = value;
        var special = {
            'transparent': 'color',
            'true': 'boolean',
            'false': 'boolean'
        };
        this.is = special[value] ? special[value] : 'keyword';
    }

    _createClass(Keyword, [{
        key: 'toString',
        value: function toString() {
            return this.value;
        }
    }]);

    return Keyword;
}();

/*Layer:class Invalid ),*/

_SuperMap.SuperMap.CartoCSS.Tree.Literal = function () {
    function Literal(content) {
        _classCallCheck(this, Literal);

        this.value = content || '';
        this.is = 'field';
    }

    _createClass(Literal, [{
        key: 'toString',
        value: function toString() {
            return this.value;
        }
    }, {
        key: 'ev',
        value: function ev() {
            return this;
        }
    }]);

    return Literal;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Operation = function () {
    function Operation(op, operands, index) {
        _classCallCheck(this, Operation);

        this.is = 'operation';
        this.op = op.trim();
        this.operands = operands;
        this.index = index;
    }

    _createClass(Operation, [{
        key: 'ev',
        value: function ev(env) {
            var a = this.operands[0].ev(env),
                b = this.operands[1].ev(env),
                temp;

            if (a.is === 'undefined' || b.is === 'undefined') {
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            if (a instanceof _SuperMap.SuperMap.CartoCSS.Tree.Dimension && b instanceof _SuperMap.SuperMap.CartoCSS.Tree.Color) {
                if (this.op === '*' || this.op === '+') {
                    temp = b, b = a, a = temp;
                } else {
                    env.error({
                        name: "OperationError",
                        message: "Can't substract or divide a color from a number",
                        index: this.index
                    });
                }
            }

            // Only concatenate plain strings, because this is easily
            // pre-processed
            if (a instanceof _SuperMap.SuperMap.CartoCSS.Tree.Quoted && b instanceof _SuperMap.SuperMap.CartoCSS.Tree.Quoted && this.op !== '+') {
                env.error({
                    message: "Can't subtract, divide, or multiply strings.",
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            // Fields, literals, dimensions, and quoted strings can be combined.
            if (a instanceof _SuperMap.SuperMap.CartoCSS.Tree.Field || b instanceof _SuperMap.SuperMap.CartoCSS.Tree.Field || a instanceof _SuperMap.SuperMap.CartoCSS.Tree.Literal || b instanceof _SuperMap.SuperMap.CartoCSS.Tree.Literal) {
                if (a.is === 'color' || b.is === 'color') {
                    env.error({
                        message: "Can't subtract, divide, or multiply colors in expressions.",
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return {
                        is: 'undefined',
                        value: 'undefined'
                    };
                } else {
                    return new _SuperMap.SuperMap.CartoCSS.Tree.Literal(a.ev(env).toString(true) + this.op + b.ev(env).toString(true));
                }
            }

            if (a.operate === undefined) {
                env.error({
                    message: 'Cannot do math with type ' + a.is + '.',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            return a.operate(env, this.op, b);
        }
    }]);

    return Operation;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Quoted = function () {
    function Quoted(content) {
        _classCallCheck(this, Quoted);

        this.is = 'string';
        this.value = content || '';
    }

    _createClass(Quoted, [{
        key: 'toString',
        value: function toString(quotes) {
            var escapedValue = this.value.replace(/&/g, '&amp;');
            var xmlvalue = escapedValue.replace(/\'/g, '\\\'').replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/\>/g, '&gt;');
            return quotes === true ? "'" + xmlvalue + "'" : escapedValue;
        }
    }, {
        key: 'ev',
        value: function ev() {
            return this;
        }
    }, {
        key: 'operate',
        value: function operate(env, op, other) {
            return new _SuperMap.SuperMap.CartoCSS.Tree.Quoted(_SuperMap.SuperMap.CartoCSS.Tree.operate(op, this.toString(), other.toString(this.contains_field)));
        }
    }]);

    return Quoted;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Reference = {
    _validateValue: {
        'font': function font(env, value) {
            if (env.validation_data && env.validation_data.fonts) {
                return env.validation_data.fonts.indexOf(value) != -1;
            } else {
                return true;
            }
        }
    },
    setData: function setData(data) {
        this.data = data;
        this.selector_cache = generateSelectorCache(data);
        this.mapnikFunctions = generateMapnikFunctions(data);
        this.required_cache = generateRequiredProperties(data);

        function generateSelectorCache(data) {
            var index = {};
            for (var i in data.symbolizers) {
                for (var j in data.symbolizers[i]) {
                    if (data.symbolizers[i][j].hasOwnProperty('css')) {
                        index[data.symbolizers[i][j].css] = [data.symbolizers[i][j], i, j];
                    }
                }
            }
            return index;
        }

        function generateMapnikFunctions(data) {
            var functions = {};
            for (var i in data.symbolizers) {
                for (var j in data.symbolizers[i]) {
                    if (data.symbolizers[i][j].type === 'functions') {
                        for (var k = 0; k < data.symbolizers[i][j].functions.length; k++) {
                            var fn = data.symbolizers[i][j].functions[k];
                            functions[fn[0]] = fn[1];
                        }
                    }
                }
            }
            return functions;
        }

        function generateRequiredProperties(data) {
            var cache = {};
            for (var symbolizer_name in data.symbolizers) {
                cache[symbolizer_name] = [];
                for (var j in data.symbolizers[symbolizer_name]) {
                    if (data.symbolizers[symbolizer_name][j].required) {
                        cache[symbolizer_name].push(data.symbolizers[symbolizer_name][j].css);
                    }
                }
            }
            return cache;
        }
    },
    setVersion: function setVersion(version) {
        if (_SuperMap.SuperMap.CartoCSS.mapnik_reference.version.hasOwnProperty(version)) {
            this.setData(_SuperMap.SuperMap.CartoCSS.mapnik_reference.version[version]);
            return true;
        }
        return false;
    },
    selectorData: function selectorData(selector, i) {
        if (this.selector_cache && this.selector_cache[selector]) {
            return this.selector_cache[selector][i];
        }
    },
    validSelector: function validSelector(selector) {
        return !!this.selector_cache[selector];
    },
    selectorName: function selectorName(selector) {
        return this.selectorData(selector, 2);
    },
    selector: function selector(_selector) {
        return this.selectorData(_selector, 0);
    },
    symbolizer: function symbolizer(selector) {
        return this.selectorData(selector, 1);
    },
    requiredProperties: function requiredProperties(symbolizer_name, rules) {
        var req = this.required_cache[symbolizer_name];
        for (var i in req) {
            if (!(req[i] in rules)) {
                return 'Property ' + req[i] + ' required for defining ' + symbolizer_name + ' styles.';
            }
        }
    },
    isFont: function isFont(selector) {
        return this.selector(selector).validate === 'font';
    },
    editDistance: function editDistance(a, b) {
        if (a.length === 0) {
            return b.length;
        }
        if (b.length === 0) {
            return a.length;
        }
        var matrix = [];
        for (var i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }
        for (var j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }
        for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
                    Math.min(matrix[i][j - 1] + 1, // insertion
                    matrix[i - 1][j] + 1)); // deletion
                }
            }
        }
        return matrix[b.length][a.length];
    },
    validValue: function validValue(env, selector, value) {
        function validateFunctions(value, selector) {
            if (value.value[0].is === 'string') {
                return true;
            }
            for (var i in value.value) {
                for (var j in value.value[i].value) {
                    if (value.value[i].value[j].is !== 'call') {
                        return false;
                    }
                    var f = find(this.selector(selector).functions, function (x) {
                        //NOSONAR
                        return x[0] === value.value[i].value[j].name;
                    });
                    if (!(f && f[1] === -1)) {
                        // This filter is unknown or given an incorrect number of arguments
                        if (!f || f[1] !== value.value[i].value[j].args.length) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function validateKeyword(value, selector) {
            if (_typeof(this.selector(selector).type) === 'object') {
                return this.selector(selector).type.indexOf(value.value[0].value) !== -1;
            } else {
                // allow unquoted keywords as strings
                return this.selector(selector).type === 'string';
            }
        }

        var i;
        if (!this.selector(selector)) {
            return false;
        } else if (value.value[0].is === 'keyword') {
            return validateKeyword(value, selector);
        } else if (value.value[0].is === 'undefined') {
            // caught earlier in the chain - ignore here so that
            // error is not overridden
            return true;
        } else if (this.selector(selector).type === 'numbers') {
            for (i in value.value) {
                if (value.value[i].is !== 'float') {
                    return false;
                }
            }
            return true;
        } else if (this.selector(selector).type === 'tags') {
            if (!value.value) {
                return false;
            }
            if (!value.value[0].value) {
                return value.value[0].is === 'tag';
            }
            for (i = 0; i < value.value[0].value.length; i++) {
                if (value.value[0].value[i].is !== 'tag') {
                    return false;
                }
            }
            return true;
        } else if (this.selector(selector).type == 'functions') {
            // For backwards compatibility, you can specify a string for `functions`-compatible
            // values, though they will not be validated.
            return validateFunctions(value, selector);
        } else if (this.selector(selector).type === 'expression') {
            return true;
        } else if (this.selector(selector).type === 'unsigned') {
            if (value.value[0].is === 'float') {
                value.value[0].round();
                return true;
            } else {
                return false;
            }
        } else {
            if (this.selector(selector).validate) {
                var valid = false;
                for (i = 0; i < value.value.length; i++) {
                    if (this.selector(selector).type === value.value[i].is && this._validateValue[this.selector(selector).validate](env, value.value[i].value)) {
                        return true;
                    }
                }
                return valid;
            } else {
                return this.selector(selector).type === value.value[0].is;
            }
        }
    }
};
_SuperMap.SuperMap.CartoCSS.Tree.Reference.setVersion("latest");

_SuperMap.SuperMap.CartoCSS.Tree.Rule = function () {
    function Rule(name, value, index, filename) {
        _classCallCheck(this, Rule);

        this.is = 'rule';
        var parts = name.split('/');
        this.name = parts.pop();
        this.instance = parts.length ? parts[0] : '__default__';
        this.value = value instanceof _SuperMap.SuperMap.CartoCSS.Tree.Value ? value : new _SuperMap.SuperMap.CartoCSS.Tree.Value([value]);
        this.index = index;
        this.symbolizer = _SuperMap.SuperMap.CartoCSS.Tree.Reference.symbolizer(this.name);
        this.filename = filename;
        this.variable = name.charAt(0) === '@';
    }

    _createClass(Rule, [{
        key: 'clone',
        value: function clone() {
            var clone = Object.create(_SuperMap.SuperMap.CartoCSS.Tree.Rule.prototype);
            clone.name = this.name;
            clone.value = this.value;
            clone.index = this.index;
            clone.instance = this.instance;
            clone.symbolizer = this.symbolizer;
            clone.filename = this.filename;
            clone.variable = this.variable;
            return clone;
        }
    }, {
        key: 'updateID',
        value: function updateID() {
            return this.id = this.zoom + '#' + this.instance + '#' + this.name;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return '[' + _SuperMap.SuperMap.CartoCSS.Tree.Zoom.toString(this.zoom) + '] ' + this.name + ': ' + this.value;
        }
    }, {
        key: 'ev',
        value: function ev(context) {
            return new _SuperMap.SuperMap.CartoCSS.Tree.Rule(this.name, this.value.ev(context), this.index, this.filename);
        }
    }]);

    return Rule;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Ruleset = function () {
    function Ruleset(selectors, rules) {
        _classCallCheck(this, Ruleset);

        this.is = 'ruleset';
        this.selectors = selectors;
        this.rules = rules;
        // static cache of find() function
        this._lookups = {};
    }

    _createClass(Ruleset, [{
        key: 'ev',
        value: function ev(env) {
            var i,
                rule,
                ruleset = new _SuperMap.SuperMap.CartoCSS.Tree.Ruleset(this.selectors, this.rules.slice(0));
            ruleset.root = this.root;

            // push the current ruleset to the frames stack
            env.frames.unshift(ruleset);

            // Evaluate everything else
            for (i = 0, rule; i < ruleset.rules.length; i++) {
                rule = ruleset.rules[i];
                ruleset.rules[i] = rule.ev ? rule.ev(env) : rule;
            }

            // Pop the stack
            env.frames.shift();

            return ruleset;
        }
    }, {
        key: 'match',
        value: function match(args) {
            return !args || args.length === 0;
        }
    }, {
        key: 'variables',
        value: function variables() {
            if (this._variables) {
                return this._variables;
            } else {
                return this._variables = this.rules.reduce(function (hash, r) {
                    if (r instanceof _SuperMap.SuperMap.CartoCSS.Tree.Rule && r.variable === true) {
                        hash[r.name] = r;
                    }
                    return hash;
                }, {});
            }
        }
    }, {
        key: 'variable',
        value: function variable(name) {
            return this.variables()[name];
        }
    }, {
        key: 'rulesets',
        value: function rulesets() {
            if (this._rulesets) {
                return this._rulesets;
            } else {
                return this._rulesets = this.rules.filter(function (r) {
                    return r instanceof _SuperMap.SuperMap.CartoCSS.Tree.Ruleset;
                });
            }
        }
    }, {
        key: 'find',
        value: function find(selector, self) {
            self = self || this;
            var rules = [],
                match,
                key = selector.toString();

            if (key in this._lookups) {
                return this._lookups[key];
            }

            this.rulesets().forEach(function (rule) {
                if (rule !== self) {
                    for (var j = 0; j < rule.selectors.length; j++) {
                        match = selector.match(rule.selectors[j]);
                        if (match) {
                            if (selector.elements.length > 1) {
                                Array.prototype.push.apply(rules, rule.find(new _SuperMap.SuperMap.CartoCSS.Tree.Selector(null, null, selector.elements.slice(1)), self));
                            } else {
                                rules.push(rule);
                            }
                            break;
                        }
                    }
                }
            });
            return this._lookups[key] = rules;
        }

        // Zooms can use variables. This replaces SuperMap.CartoCSS.Tree.Zoom objects on selectors
        // with simple bit-arrays that we can compare easily.

    }, {
        key: 'evZooms',
        value: function evZooms(env) {
            for (var i = 0; i < this.selectors.length; i++) {
                var zval = _SuperMap.SuperMap.CartoCSS.Tree.Zoom.all;
                for (var z = 0; z < this.selectors[i].zoom.length; z++) {
                    zval = this.selectors[i].zoom[z].ev(env).zoom;
                }
                this.selectors[i].zoom = zval;
            }
        }
    }, {
        key: 'flatten',
        value: function flatten(result, parents, env) {
            var selectors = [],
                i,
                j;
            if (this.selectors.length === 0) {
                env.frames = env.frames.concat(this.rules);
            }
            // evaluate zoom variables on this object.
            this.evZooms(env);
            for (i = 0; i < this.selectors.length; i++) {
                var child = this.selectors[i];

                if (!child.filters) {
                    // This is an invalid filterset.
                    continue;
                }

                if (parents.length) {
                    for (j = 0; j < parents.length; j++) {
                        var parent = parents[j];

                        var mergedFilters = parent.filters.cloneWith(child.filters);
                        if (mergedFilters === null) {
                            // Filters could be added, but they didn't change the
                            // filters. This means that we only have to clone when
                            // the zoom levels or the attachment is different too.
                            if (parent.zoom === child.zoom && parent.attachment === child.attachment && parent.elements.join() === child.elements.join()) {
                                selectors.push(parent);
                                continue;
                            } else {
                                mergedFilters = parent.filters;
                            }
                        } else if (!mergedFilters) {
                            // The merged filters are invalid, that means we don't
                            // have to clone.
                            continue;
                        }

                        var clone = Object.create(_SuperMap.SuperMap.CartoCSS.Tree.Selector.prototype);
                        clone.filters = mergedFilters;
                        clone.zoom = child.zoom;
                        clone.elements = parent.elements.concat(child.elements);
                        if (parent.attachment && child.attachment) {
                            clone.attachment = parent.attachment + '/' + child.attachment;
                        } else {
                            clone.attachment = child.attachment || parent.attachment;
                        }
                        clone.conditions = parent.conditions + child.conditions;
                        clone.index = child.index;
                        selectors.push(clone);
                    }
                } else {
                    selectors.push(child);
                }
            }

            var rules = [];
            for (i = 0; i < this.rules.length; i++) {
                var rule = this.rules[i];

                // Recursively flatten any nested rulesets
                if (rule instanceof _SuperMap.SuperMap.CartoCSS.Tree.Ruleset) {
                    rule.flatten(result, selectors, env);
                } else if (rule instanceof _SuperMap.SuperMap.CartoCSS.Tree.Rule) {
                    rules.push(rule);
                } else if (rule instanceof _SuperMap.SuperMap.CartoCSS.Tree.Invalid) {
                    env.error(rule);
                }
            }

            var index = rules.length ? rules[0].index : false;
            for (i = 0; i < selectors.length; i++) {
                // For specificity sort, use the position of the first rule to allow
                // defining attachments that are under current element as a descendant
                // selector.
                if (index !== false) {
                    selectors[i].index = index;
                }
                result.push(new _SuperMap.SuperMap.CartoCSS.Tree.Definition(selectors[i], rules.slice()));
            }

            return result;
        }
    }]);

    return Ruleset;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Selector = function () {
    function Selector(filters, zoom, elements, attachment, conditions, index) {
        _classCallCheck(this, Selector);

        this.elements = elements || [];
        this.attachment = attachment;
        this.filters = filters || {};
        this.zoom = typeof zoom !== 'undefined' ? zoom : _SuperMap.SuperMap.CartoCSS.Tree.Zoom.all;
        this.conditions = conditions;
        this.index = index;
    }

    _createClass(Selector, [{
        key: 'specificity',
        value: function specificity() {
            return this.elements.reduce(function (memo, e) {
                var spec = e.specificity();
                memo[0] += spec[0];
                memo[1] += spec[1];
                return memo;
            }, [0, 0, this.conditions, this.index]);
        }
    }]);

    return Selector;
}();

/*style:class Invalid ),*/

_SuperMap.SuperMap.CartoCSS.Tree.URL = function () {
    function URL(val, paths) {
        _classCallCheck(this, URL);

        this.is = 'uri';
        this.value = val;
        this.paths = paths;
    }

    _createClass(URL, [{
        key: 'toString',
        value: function toString() {
            return this.value.toString();
        }
    }, {
        key: 'ev',
        value: function ev(ctx) {
            return new _SuperMap.SuperMap.CartoCSS.Tree.URL(this.value.ev(ctx), this.paths);
        }
    }]);

    return URL;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Value = function () {
    function Value(value) {
        _classCallCheck(this, Value);

        this.is = 'value';
        this.value = value;
    }

    _createClass(Value, [{
        key: 'ev',
        value: function ev(env) {
            if (this.value.length === 1) {
                return this.value[0].ev(env);
            } else {
                return new _SuperMap.SuperMap.CartoCSS.Tree.Value(this.value.map(function (v) {
                    return v.ev(env);
                }));
            }
        }
    }, {
        key: 'toJS',
        value: function toJS(env) {
            //var v = this.value[0].value[0];
            var val = this.ev(env);
            var v = val.toString();
            if (val.is === "color" || val.is === 'uri' || val.is === 'string' || val.is === 'keyword') {
                v = "'" + v + "'";
            } else if (val.is === 'field') {
                // replace [varuable] by ctx['variable']
                v = v.replace(/\[(.*)\]/g, "attributes['\$1']");
            } else if (val.value && _typeof(val.value) === "object") {
                v = "[" + v + "]";
            }

            return "_value = " + v + ";";
        }
    }, {
        key: 'toString',
        value: function toString(env, selector, sep, format) {
            return this.value.map(function (e) {
                return e.toString(env, format);
            }).join(sep || ', ');
        }
    }, {
        key: 'clone',
        value: function clone() {
            var obj = Object.create(_SuperMap.SuperMap.CartoCSS.Tree.Value.prototype);
            if (Array.isArray(obj)) {
                obj.value = this.value.slice();
            } else {
                obj.value = this.value;
            }
            obj.is = this.is;
            return obj;
        }
    }]);

    return Value;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Variable = function () {
    function Variable(name, index, filename) {
        _classCallCheck(this, Variable);

        this.is = 'variable';
        this.name = name;
        this.index = index;
        this.filename = filename;
    }

    _createClass(Variable, [{
        key: 'toString',
        value: function toString() {
            return this.name;
        }
    }, {
        key: 'ev',
        value: function ev(env) {
            if (this._css) {
                return this._css;
            }

            var thisframe = env.frames.filter(function (f) {
                return f.name === this.name;
            }.bind(this));
            if (thisframe.length) {
                return thisframe[0].value.ev(env);
            } else {
                env.error({
                    message: 'variable ' + this.name + ' is undefined',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        }
    }]);

    return Variable;
}();

_SuperMap.SuperMap.CartoCSS.Tree.Zoom = function () {
    function Zoom(op, value, index) {
        _classCallCheck(this, Zoom);

        this.op = op;
        this.value = value;
        this.index = index;
    }

    _createClass(Zoom, [{
        key: 'setZoom',
        value: function setZoom(zoom) {
            this.zoom = zoom;
            return this;
        }
    }, {
        key: 'ev',
        value: function ev(env) {
            var value = parseInt(this.value.ev(env).toString(), 10);

            if (value > _SuperMap.SuperMap.CartoCSS.Tree.Zoom.maxZoom || value < 0) {
                env.error({
                    message: 'Only zoom levels between 0 and ' + _SuperMap.SuperMap.CartoCSS.Tree.Zoom.maxZoom + ' supported.',
                    index: this.index
                });
            }

            switch (this.op) {
                case '=':
                    this.zoom = "zoom && zoom === " + value;
                    return this;
                case '>':
                    this.zoom = "zoom && zoom > " + value;
                    break;
                case '>=':
                    this.zoom = "zoom && zoom >= " + value;
                    break;
                case '<':
                    this.zoom = "zoom && zoom < " + value;
                    break;
                case '<=':
                    this.zoom = "zoom && zoom <= " + value;
                    break;
                default:
                    return this;
                    break;
            }
            /*
             for (var i = 0; i <= SuperMap.CartoCSS.Tree.Zoom.maxZoom; i++) {
             if (i >= start && i <= end) {
             zoom |= (1 << i);
             }
             }
             this.zoom = zoom;
             this.zoom=value+this.op+"zoom";*/
            return this;
        }
    }, {
        key: 'toString',
        value: function toString() {
            var str = '';
            for (var i = 0; i <= _SuperMap.SuperMap.CartoCSS.Tree.Zoom.maxZoom; i++) {
                str += this.zoom & 1 << i ? 'X' : '.';
            }
            return str;
        }
    }]);

    return Zoom;
}();

// Covers all zoomlevels from 0 to 22
_SuperMap.SuperMap.CartoCSS.Tree.Zoom.all = 23;

_SuperMap.SuperMap.CartoCSS.Tree.Zoom.maxZoom = 22;

_SuperMap.SuperMap.CartoCSS.Tree.Zoom.ranges = {
    0: 1000000000,
    1: 500000000,
    2: 200000000,
    3: 100000000,
    4: 50000000,
    5: 25000000,
    6: 12500000,
    7: 6500000,
    8: 3000000,
    9: 1500000,
    10: 750000,
    11: 400000,
    12: 200000,
    13: 100000,
    14: 50000,
    15: 25000,
    16: 12500,
    17: 5000,
    18: 2500,
    19: 1500,
    20: 750,
    21: 500,
    22: 250,
    23: 100
};

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ThemeStyle = undefined;

var _SuperMap = __webpack_require__(0);

var _Util = __webpack_require__(1);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class SuperMap.ThemeStyle
 * @classdesc 客户端专题图风格类
 * @param options -{Object} 可选参数。如：<br>
 *         fill - {boolean} 是否填充，不需要填充则设置为 false，默认值为 true。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。<br>
 *         fillColor - {string} 十六进制填充颜色。默认值为 "#000000"。<br>
 *         fillOpacity - {number} 填充不透明度。取值范围[0, 1]，默认值 1。<br>
 *         stroke - {boolean} 是否描边，不需要描边则设置为false，默认值为 false。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。<br>
 *         strokeColor - {string} 十六进制描边颜色。默认值为 "#000000"。<br>
 *         strokeOpacity - {number} 描边的不透明度。取值范围[0, 1]，默认值 1。<br>
 *         strokeWidth - {number} 线宽度/描边宽度，默认值 1。<br>
 *         strokeLinecap - {string} 线帽样式。strokeLinecap 有三种类型 “butt", "round", "square"; 默认为"butt"。<br>
 *         strokeLineJoin - {string} 线段连接样式。strokeLineJoin 有三种类型 “miter", "round", "bevel"; 默认为"miter"。<br>
 *         strokeDashstyle - {string} 虚线类型。strokeDashstyle 有八种类型 “dot",“dash",“dashot",“longdash",“longdashdot",“solid", "dashed", "dotted"。默认值 "solid"。solid 表示实线。<br>
 *         pointRadius - {number} 点半径，默认为 6 （像素）。<br>
 *         shadowBlur - {number} 阴影模糊度，（大于 0 有效; 默认值 0）。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。<br>
 *         shadowColor - {string} 阴影颜色; 默认值 '#000000'。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。<br>
 *         shadowOffsetX - {number} 阴影 X 方向偏移值; 默认值 0。<br>
 *         shadowOffsetY - {number} 阴影 Y 方向偏移值; 默认值 0。<br>
 *         label - {string} 专题要素附加文本标签内容。<br>
 *         fontColor - {string} 附加文本字体颜色。<br>
 *         fontSize - {number} 附加文本字体大小。默认值 12，单位是像素。<br>
 *         fontStyle - {string} 附加文本字体样式。可设值："normal", "italic", "oblique"; 默认值："normal"。<br>
 *         fontVariant - {string} 附加文本字体变体。可设值："normal", "small-caps"; 默认值："normal"。<br>
 *         fontWeight - {string} 附加文本字体粗细。可设值："normal", "bold", "bolder", "lighter"; 默认值："normal"。<br>
 *         fontFamily - {string} 附加文本字体系列。fontFamily 值是字体族名称或/及类族名称的一个优先表，每个值逗号分割，
 *                               浏览器会使用它可识别的第一个可以使用具体的字体名称（"times"、"courier"、"arial"）或字体系列名称
 *                               （"serif"、"sans-serif"、"cursive"、"fantasy"、"monospace"）。默认值："arial,sans-serif"。<br>
 *         labelPosition - {string} 附加文本位置, 可以是 'inside', 'left', 'right', 'top', 'bottom'; 默认值 'top'。<br>
 *         labelAlign - {string} 附加文本水平对齐。可以是 'left', 'right', 'center'; 默认值 'center'。<br>
 *         labelBaseline - {string} 附加文本垂直对齐。 可以是 'top', 'bottom', 'middle';默认值 'middle'。<br>
 *         labelXOffset - {number} 附加文本在x轴方向的偏移量; 默认值 0。<br>
 *         labelYOffset - {number} 附加文本在y轴方向的偏移量; 默认值 0。<br>
 */
var ThemeStyle = exports.ThemeStyle = function ThemeStyle(options) {
  _classCallCheck(this, ThemeStyle);

  options = options || {};
  /**
   * @member SuperMap.ThemeStyle.prototype.fill - {boolean}
   * @description 是否填充，不需要填充则设置为 false，默认值为 true。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。
   */
  this.fill = true;
  /**
   * @member SuperMap.ThemeStyle.prototype.fillColor -{string}
   * @description 十六进制填充颜色。默认值为 "#000000"。
   */
  this.fillColor = "#000000";
  /**
   *  @member SuperMap.ThemeStyle.prototype.fillOpacity -{number}
   *  @description 填充不透明度。取值范围[0, 1]，默认值 1。
   */
  this.fillOpacity = 1;
  /**
   * @member SuperMap.ThemeStyle.prototype.stroke -{boolean}
   * @description  是否描边，不需要描边则设置为false，默认值为 false。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。
   */
  this.stroke = false;
  /**
   * @member SuperMap.ThemeStyle.prototype.strokeColor -{string}
   * @description  十六进制描边颜色。默认值为 "#000000"。
   */
  this.strokeColor = "#000000";
  /**
   * @member SuperMap.ThemeStyle.prototype.strokeOpacity -{number}
   * @description  描边的不透明度。取值范围[0, 1]，默认值 1。
   */
  this.strokeOpacity = 1;
  /**
   * @member SuperMap.ThemeStyle.prototype.strokeWidth -{number}
   * @description  线宽度/描边宽度，默认值 1。
   */
  this.strokeWidth = 1;
  /**
   * @member SuperMap.ThemeStyle.prototype.strokeLinecap -{string}
   * @description  线帽样式；strokeLinecap 有三种类型 “butt", "round", "square"; 默认为"butt"。
   */
  this.strokeLinecap = "butt";
  /**
   * @member SuperMap.ThemeStyle.prototype.strokeLineJoin -{string}
   * @description  线段连接样式；strokeLineJoin 有三种类型 “miter", "round", "bevel"; 默认为"miter"。
   */
  this.strokeLineJoin = "miter";
  /**
   * @member SuperMap.ThemeStyle.prototype.strokeDashstyle -{string}
   * @description   虚线类型； strokeDashstyle 有八种类型 “dot",“dash",“dashot",“longdash",“longdashdot",“solid", "dashed", "dotted";
   * 默认值 "solid"。solid 表示实线。
   */
  this.strokeDashstyle = "solid";
  /**
   * @member SuperMap.ThemeStyle.prototype.pointRadius -{number}
   * @description   点半径，默认为 6 （像素）。
   */
  this.pointRadius = 6;
  /**
   * @member SuperMap.ThemeStyle.prototype.shadowBlur -{number}
   * @description   阴影模糊度，（大于 0 有效; 默认值 0）。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。
   */
  this.shadowBlur = 0;
  /**
   * @member SuperMap.ThemeStyle.prototype.shadowColor -{string}
   * @description  阴影颜色; 默认值 '#000000'。  注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。
   */
  this.shadowColor = "#000000";
  /**
   * @member SuperMap.ThemeStyle.prototype.shadowOffsetX -{number}
   * @description 阴影 X 方向偏移值; 默认值 0。
   */
  this.shadowOffsetX = 0;
  /**
   * @member SuperMap.ThemeStyle.prototype.shadowOffsetY -{number}
   * @description Y 方向偏移值; 默认值 0。
   */
  this.shadowOffsetY = 0;
  /**
   * @member SuperMap.ThemeStyle.prototype.label -{string}
   * @description 专题要素附加文本标签内容。
   */
  this.label = "";
  /**
   * @member SuperMap.ThemeStyle.prototype.labelRect -boolean
   * @description 是否显示文本标签矩形背景。
   */
  this.labelRect = false;
  /**
   * @member SuperMap.ThemeStyle.prototype.fontColor -{string}
   * @description 附加文本字体颜色。
   */
  this.fontColor = "";
  /**
   * @member SuperMap.ThemeStyle.prototype.fontSize -{number}
   * @description 附加文本字体大小。默认值 12，单位是像素。
   */
  this.fontSize = 12;
  /**
   * @member SuperMap.ThemeStyle.prototype.fontStyle -{string}
   * @description 附加文本字体样式。可设值："normal", "italic", "oblique"; 默认值："normal" 。
   */
  this.fontStyle = "normal";
  /**
   * @member SuperMap.ThemeStyle.prototype.fontVariant -{string}
   * @description 附加文本字体变体。可设值："normal", "small-caps"; 默认值："normal" 。
   */
  this.fontVariant = "normal";
  /**
   * @member SuperMap.ThemeStyle.prototype.fontWeight -{string}
   * @description 附加文本字体粗细。可设值："normal", "bold", "bolder", "lighter"; 默认值："normal" 。
   */
  this.fontWeight = "normal";
  /**
   * @member SuperMap.ThemeStyle.prototype.fontFamily -{string}
   * @description 附加文本字体系列。fontFamily 值是字体族名称或/及类族名称的一个优先表，每个值逗号分割，浏览器会使用它可识别的第一个
   * 可以使用具体的字体名称（"times"、"courier"、"arial"）或字体系列名称（"serif"、"sans-serif"、"cursive"、"fantasy"、"monospace"）。
   * 默认值："arial,sans-serif".
   */
  this.fontFamily = "arial,sans-serif";
  /**
   * @member SuperMap.ThemeStyle.prototype.labelPosition -{string}
   * @description 附加文本位置, 可以是 'inside', 'left', 'right', 'top', 'bottom'; 默认值 'top'。
   */
  this.labelPosition = "top";
  /**
   * @member SuperMap.ThemeStyle.prototype.labelAlign -{string}
   * @description 附加文本水平对齐。可以是 'left', 'right', 'center'; 默认值 'center'。
   */
  this.labelAlign = "center";
  /**
   * @member SuperMap.ThemeStyle.prototype.labelBaseline -{string}
   * @description  附加文本垂直对齐。 可以是 'top', 'bottom', 'middle';默认值 'middle'。
   */
  this.labelBaseline = "middle";
  /**
   * @member SuperMap.ThemeStyle.prototype.labelXOffset -{number}
   * @description  附加文本在x轴方向的偏移量。
   */
  this.labelXOffset = 0;
  /**
   * @member SuperMap.ThemeStyle.prototype.labelYOffset -{number}
   * @description 附加文本在y轴方向的偏移量。
   */
  this.labelYOffset = 0;

  _Util.Util.extend(this, options);
};

_SuperMap.SuperMap.ThemeStyle = ThemeStyle;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CartoCSS = __webpack_require__(437);

Object.defineProperty(exports, 'CartoCSS', {
  enumerable: true,
  get: function get() {
    return _CartoCSS.CartoCSS;
  }
});

var _ThemeStyle = __webpack_require__(438);

Object.defineProperty(exports, 'ThemeStyle', {
  enumerable: true,
  get: function get() {
    return _ThemeStyle.ThemeStyle;
  }
});

var _supermapolIcons = __webpack_require__(306);

Object.keys(_supermapolIcons).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _supermapolIcons[key];
    }
  });
});

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ElasticSearch = __webpack_require__(123);

Object.defineProperty(exports, 'ElasticSearch', {
  enumerable: true,
  get: function get() {
    return _ElasticSearch.ElasticSearch;
  }
});

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _elasticsearch = __webpack_require__(440);

Object.keys(_elasticsearch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _elasticsearch[key];
    }
  });
});

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _promisePolyfill = __webpack_require__(499);

var _promisePolyfill2 = _interopRequireDefault(_promisePolyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

window.Promise = _promisePolyfill2["default"];

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _FetchRequest = __webpack_require__(21);

Object.defineProperty(exports, 'CORS', {
  enumerable: true,
  get: function get() {
    return _FetchRequest.CORS;
  }
});
Object.defineProperty(exports, 'RequestTimeout', {
  enumerable: true,
  get: function get() {
    return _FetchRequest.RequestTimeout;
  }
});
Object.defineProperty(exports, 'FetchRequest', {
  enumerable: true,
  get: function get() {
    return _FetchRequest.FetchRequest;
  }
});

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TianDiTu_MercatorCRS = exports.TianDiTu_WGS84CRS = exports.BaiduCRS = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @constant L.CRS.BaiduCRS
 * @description 百度的坐标对象
 */
var BaiduCRS = exports.BaiduCRS = _leaflet2["default"].CRS.Baidu = _leaflet2["default"].extend({}, _leaflet2["default"].CRS.EPSG3857, {
    code: 'Baidu',
    scale: function scale(zoom) {
        return 6378137 * Math.PI * 2 / Math.pow(2, 18 - zoom);
    },

    transformation: function () {
        var scale = 0.5 / (Math.PI * 6378137);
        return new _leaflet2["default"].Transformation(scale, 0, -scale, 0);
    }()
});

var tdt_WGS84_resolutions = [];

for (var i = 1; i < 19; i++) {
    tdt_WGS84_resolutions.push(0.703125 * 2 / Math.pow(2, i));
}

/**
 * @constant L.CRS.TianDiTu_WGS84CRS
 * @description 天地图WGS84坐标对象
 */
var TianDiTu_WGS84CRS = exports.TianDiTu_WGS84CRS = _leaflet2["default"].CRS.TianDiTu_WGS84 = _leaflet2["default"].Proj.CRS("EPSG:4326", {
    origin: [-180, 90],
    resolutions: tdt_WGS84_resolutions,
    bounds: _leaflet2["default"].bounds([-180, -90], [180, 90])
});

var tdt_Mercator_resolutions = [];
for (var _i = 1; _i < 19; _i++) {
    tdt_Mercator_resolutions.push(78271.5169640203125 * 2 / Math.pow(2, _i));
}

/**
 * @constant L.CRS.TianDiTu_MercatorCRS
 * @description 天地图墨卡托坐标对象
 */
var TianDiTu_MercatorCRS = exports.TianDiTu_MercatorCRS = _leaflet2["default"].CRS.TianDiTu_Mercator = _leaflet2["default"].Proj.CRS("EPSG:3857", {
    origin: [-20037508.3427892, 20037508.3427892],
    resolutions: tdt_Mercator_resolutions,
    bounds: _leaflet2["default"].bounds([-20037508.3427892, -20037508.3427892], [20037508.3427892, 20037508.3427892])
});
_leaflet2["default"].CRS.BaiduCRS = BaiduCRS;
_leaflet2["default"].CRS.TianDiTu_WGS84CRS = TianDiTu_WGS84CRS;
_leaflet2["default"].CRS.TianDiTu_MercatorCRS = TianDiTu_MercatorCRS;

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crs = exports.CRS = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _proj = __webpack_require__(301);

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * Inspired by https://github.com/kartena/Proj4Leaflet
 */
window.proj4 = _proj2["default"];
window.Proj4js = _proj2["default"];
_leaflet2["default"].Proj = {};

_leaflet2["default"].Proj._isProj4Obj = function (a) {
    return typeof a.inverse !== 'undefined' && typeof a.forward !== 'undefined';
};

/**
 * @class L.Proj.Projection
 * @private
 * @classdesc Proj投影定义类
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param code - {number}地理编码
 * @param def - {string} 定位
 * @param bounds - {L.bounds} 投影范围参数
 */
_leaflet2["default"].Proj.Projection = _leaflet2["default"].Class.extend({

    initialize: function initialize(code, def, bounds) {
        var isP4 = _leaflet2["default"].Proj._isProj4Obj(code);
        this._proj = isP4 ? code : this._projFromCodeDef(code, def);
        var boundsOption = bounds;
        if (_leaflet2["default"].Util.isArray(bounds)) {
            boundsOption = _leaflet2["default"].bounds(bounds);
        }
        this.bounds = isP4 ? def : boundsOption;
    },

    /**
     * @function L.Proj.Projection.prototype.project
     * @description 通过地理坐标得到投影坐标
     * @param latlng - {L.laylng} 经纬度坐标
     * @return {Point} 返回投影坐标点
     */
    project: function project(latlng) {
        var point = this._proj.forward([latlng.lng, latlng.lat]);
        return new _leaflet2["default"].Point(point[0], point[1]);
    },

    /**
     * @function L.Proj.Projection.prototype.unproject
     * @description 通过投影坐标得到地理坐标
     * @param point {L.Point} 地理坐标点
     * @param unbounded - {string} 坐标点高程不限
     * @return {LatLng} 返回经纬度坐标
     */
    unproject: function unproject(point, unbounded) {
        if (this.bounds) {
            point.x = point.x < this.bounds.min.x ? this.bounds.min.x : point.x > this.bounds.max.x ? this.bounds.max.x : point.x;
            point.y = point.y < this.bounds.min.y ? this.bounds.min.y : point.y > this.bounds.max.y ? this.bounds.max.y : point.y;
        }
        var point2 = this._proj.inverse([point.x, point.y]);
        return new _leaflet2["default"].LatLng(point2[1], point2[0], unbounded);
    },

    _projFromCodeDef: function _projFromCodeDef(code, def) {
        if (def) {
            _proj2["default"].defs(code, def);
        } else if (_proj2["default"].defs[code] === undefined) {
            var urn = code.split(':');
            if (urn.length > 3) {
                code = urn[urn.length - 3] + ':' + urn[urn.length - 1];
            }
            if (_proj2["default"].defs[code] === undefined) {
                throw 'No projection definition for code ' + code;
            }
        }

        return (0, _proj2["default"])(code);
    },
    getUnits: function getUnits() {
        return this._proj.oProj.units;
    }
});

/**
 * @class L.Proj.CRS
 * @classdesc Proj坐标系统定义类
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param srsCode -{string} proj srsCode。
 * @param options -{Object} options。可选参数：<br>
 *                     def -{string} 投影的proj4定义。<br>
 *                     origin -{Array|L.Point} 原点。必填<br>
 *                     scales -{Array} 比例尺数组 <br>
 *                     scaleDenominators -{Array} 比例尺分母数组 <br>
 *                     resolutions -{Array} 分辨率数组 <br>
 *                     bounds -{Array|L.Bounds} 范围
 * @example
 * 用法：
 *    var crs =L.Proj.CRS("EPSG:4326",{
 *          origin: [-180,90],
 *          scaleDenominators: [2000,1000,500,200,100,50,20,10],
 *    });
 *    var map=L.map('map', {
 *       crs: crs
 *      ...
 *    })
 */
var CRS = exports.CRS = _leaflet2["default"].Class.extend({
    includes: _leaflet2["default"].CRS,

    options: {
        transformation: new _leaflet2["default"].Transformation(1, 0, -1, 0)
    },

    initialize: function initialize(srsCode, options) {
        var code, proj, def;

        if (_leaflet2["default"].Proj._isProj4Obj(srsCode)) {
            proj = srsCode;
            code = proj.srsCode;
            options = options || {};

            this.projection = new _leaflet2["default"].Proj.Projection(proj, options.bounds);
        } else {
            code = srsCode;
            options = options || {};
            def = options.def || '';
            this.projection = new _leaflet2["default"].Proj.Projection(code, def, options.bounds);
        }

        _leaflet2["default"].Util.setOptions(this, options);
        this.code = code;
        this.transformation = this.options.transformation;

        if (this.options.bounds) {
            this.options.bounds = _leaflet2["default"].bounds(this.options.bounds);
        }
        if (!this.options.origin && this.options.bounds) {
            this.options.origin = [this.options.bounds.min.x, this.options.bounds.max.y];
        }
        if (this.options.origin) {
            if (this.options.origin instanceof _leaflet2["default"].Point) {
                this.options.origin = [this.options.origin.x, this.options.origin.y];
            }
            this.transformation = new _leaflet2["default"].Transformation(1, -this.options.origin[0], -1, this.options.origin[1]);
        }

        if (this.options.scales && this.options.scales.length > 0) {
            this._scales = this._toProj4Scales(this.options.scales);
        } else if (this.options.scaleDenominators && this.options.scaleDenominators.length > 0) {
            var scales = [];
            for (var i = 0; i < this.options.scaleDenominators.length; i++) {
                scales[i] = 1 / this.options.scaleDenominators[i];
            }
            this._scales = this._toProj4Scales(scales);
        } else if (this.options.resolutions && this.options.resolutions.length > 0) {
            this._scales = [];
            for (var _i = this.options.resolutions.length - 1; _i >= 0; _i--) {
                if (this.options.resolutions[_i]) {
                    this._scales[_i] = 1 / this.options.resolutions[_i];
                }
            }
        } else if (this.options.bounds) {
            this._scales = this._getDefaultProj4ScalesByBounds(this.options.bounds);
        }

        this.infinite = !this.options.bounds;
    },

    /**
     * @function L.Proj.CRS.prototype.scale
     * @description 通过缩放级别获取比例尺值
     * @param zoom - {number}缩放级别
     * @return 比例尺值
     */
    scale: function scale(zoom) {
        var iZoom = Math.floor(zoom),
            baseScale,
            nextScale,
            scaleDiff,
            zDiff;
        if (zoom === iZoom) {
            return this._scales[zoom];
        } else {
            // Non-integer zoom, interpolate
            baseScale = this._scales[iZoom];
            nextScale = this._scales[iZoom + 1];
            scaleDiff = nextScale - baseScale;
            zDiff = zoom - iZoom;
            return baseScale + scaleDiff * zDiff;
        }
    },

    /**
     * @function L.Proj.CRS.prototype.zoom
     * @description 根据比例尺返回缩放级别
     * @param scale - {number}比例尺
     * @return {number} 缩放级别
     */
    zoom: function zoom(scale) {
        // Find closest number in this._scales, down
        var downScale = this._closestElement(this._scales, scale),
            downZoom = this._scales.indexOf(downScale),
            nextScale,
            nextZoom,
            scaleDiff;
        // Check if scale is downScale => return array index
        if (scale === downScale) {
            return downZoom;
        }
        // Interpolate
        nextZoom = downZoom + 1;
        nextScale = this._scales[nextZoom];
        if (nextScale === undefined) {
            return Infinity;
        }
        scaleDiff = nextScale - downScale;
        return (scale - downScale) / scaleDiff + downZoom;
    },

    distance: _leaflet2["default"].CRS.Earth.distance,

    R: _leaflet2["default"].CRS.Earth.R,

    /* Get the closest lowest element in an array */
    _closestElement: function _closestElement(array, element) {
        var low;
        for (var i = array.length; i--;) {
            if (array[i] <= element && (low === undefined || low < array[i])) {
                low = array[i];
            }
        }
        return low;
    },

    _toProj4Scales: function _toProj4Scales(scales) {
        var proj4Scales = [];
        if (!scales) {
            return proj4Scales;
        }
        for (var i = 0; i < scales.length; i++) {
            var a = this.projection ? this._getMeterPerMapUnit(this.projection.getUnits()) : 1;
            proj4Scales[i] = 1 / (0.0254 / (96 * scales[i]) / a);
        }
        return proj4Scales;
    },
    _getMeterPerMapUnit: function _getMeterPerMapUnit(mapUnit) {
        var earchRadiusInMeters = 6378137;
        var meterPerMapUnit = 1;
        if (mapUnit === "meter") {
            meterPerMapUnit = 1;
        } else if (mapUnit === "degrees") {
            // 每度表示多少米。
            meterPerMapUnit = Math.PI * 2 * earchRadiusInMeters / 360;
        } else if (mapUnit === "kilometer") {
            meterPerMapUnit = 1.0E-3;
        } else if (mapUnit === "inch") {
            meterPerMapUnit = 1 / 2.5399999918E-2;
        } else if (mapUnit === "feet") {
            meterPerMapUnit = 0.3048;
        }
        return meterPerMapUnit;
    },
    _getDefaultProj4ScalesByBounds: function _getDefaultProj4ScalesByBounds(bounds) {
        if (!bounds) {
            return [];
        }
        var boundsSize = bounds.getSize();
        var extendsSize = Math.max(boundsSize.x, boundsSize.y);
        var resolution = extendsSize / 256;
        var scales = [];
        var maxZoom = 23;
        for (var i = 0; i < maxZoom; i++) {
            scales[i] = Math.pow(2, i) / resolution;
        }
        return scales;
    }
});
var crs = exports.crs = function crs(srsCode, options) {
    return new CRS(srsCode, options);
};
_leaflet2["default"].Proj.CRS = crs;

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DefaultStyle = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @constant L.supermap.DefaultStyle
 * @description 这个style对应的是默认设置
 * @private
 */
var DefaultStyle = exports.DefaultStyle = {

    /**
     * @constant L.supermap.DefaultStyle.prototype.TEXT
     * @description 默认文本样式
     */
    "TEXT": {
        fontSize: "14px",
        fontFamily: "Arial Unicode MS Regular,Microsoft YaHei",
        textAlign: "left",
        color: "rgba(255,255,255,0)",
        fillColor: "rgba(80,80,80,1)",
        weight: 1,
        globalAlpha: 1
    },

    /**
     * @constant L.supermap.DefaultStyle.prototype.POINT
     * @description 默认点样式
     */
    "POINT": {
        fillColor: "#ffcc00",
        color: "#cc3333",
        weight: 1,
        radius: 3,
        opacity: 1
    },

    /**
     * @constant L.supermap.DefaultStyle.prototype.LINE
     * @description 默认线样式
     */
    "LINE": {
        color: "rgba(0,0,0,0)",
        weight: 1,
        lineCap: "butt",
        lineJoin: "round",

        dashOffset: 0,
        dashArray: [],
        opacity: 1
    },

    /**
     * @constant L.supermap.DefaultStyle.prototype.REGION
     * @description 默认多边形样式
     */
    "REGION": {
        color: "rgba(0,0,0,0)",
        fillColor: "rgba(0,0,0,0)",
        weight: 1,
        lineCap: "butt",
        lineJoin: "round",
        dashOffset: 0,
        opacity: 1,
        fillOpacity: 1,
        dashArray: []
    }
};

_leaflet2["default"].supermap.DefaultStyle = DefaultStyle;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CompOpMap = exports.ServerStyleMap = exports.CartoStyleMap = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

__webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @constant L.supermap.CartoStyleMap
 * @description CartoCSS中的style属性名与leaflet的style属性名的对应表
 * @private
 */
var CartoStyleMap = exports.CartoStyleMap = {

    /*
     * @constant L.supermap.CartoStyleMap.prototype.TEXT
     * @description 默认文本样式
     */
    "TEXT": {
        "text-size": "fontSize",
        "text-face-name": "fontFamily",
        "text-align": "textAlign",
        "text-name": "textName",
        'text-weight': 'fontWeight',
        "text-halo-color": "color",
        "text-fill": "fillColor",
        "text-comp-op": "globalCompositeOperation"
    },

    /*
     * @constant L.supermap.CartoStyleMap.prototype.POINT
     * @description 默认点样式
     */
    "POINT": {
        "point-file": "iconUrl",
        "point-fill": "fillColor",
        "point-radius": "radius",
        "point-halo-color": "color",
        "point-comp-op": "globalCompositeOperation"
    },

    /*
     * @constant L.supermap.CartoStyleMap.prototype.LINE
     * @description 默认线样式
     */
    "LINE": {
        "line-color": "color",
        "line-width": "weight",
        "line-cap": "lineCap",
        "line-join": "lineJoin",
        "line-dash-offset": "dashOffset",
        "line-opacity": "opacity",
        "line-dasharray": "dashArray",
        "line-comp-op": "globalCompositeOperation"
    },

    /*
     * @constant L.supermap.CartoStyleMap.prototype.REGION
     * @description 默认多边形样式
     */
    "REGION": {
        "line-color": "color",
        "line-width": "weight",
        "line-cap": "lineCap",
        "line-join": "lineJoin",
        "line-dash-offset": "dashOffset",
        "line-opacity": "opacity",
        "line-dasharray": "dashArray",
        "polygon-fill": "fillColor",
        "polygon-opacity": "fillOpacity",
        "polygon-comp-op": "globalCompositeOperation"
    }
};

/**
 * @constant L.supermap.ServerStyleMap
 * @description 服务端传过来的style属性名与leaflet的style属性名的对应表
 * @private
 */
var ServerStyleMap = exports.ServerStyleMap = {

    /**
     * @member L.supermap.ServerStyleMap.prototype.lineWidth
     * @description 线宽
     */
    lineWidth: {
        leafletStyle: "weight",
        type: "number",
        unit: "mm",
        defaultValue: 0.1
    },

    /**
     * @member L.supermap.ServerStyleMap.prototype.fillForeColor
     * @description 填充前景色
     */
    fillForeColor: {
        leafletStyle: "fillColor",
        type: "color",
        defaultValue: "rgba(0,0,0,0)"
    },

    /**
     * @member L.supermap.ServerStyleMap.prototype.foreColor
     * @description 前景色
     */
    foreColor: {
        leafletStyle: "color",
        type: "color",
        defaultValue: "rgba(0,0,0,0)"
    },

    /**
     * @member L.supermap.ServerStyleMap.prototype.markerSize
     * @description 图标大小
     */
    markerSize: {
        leafletStyle: "markerSize",
        type: "number",
        unit: "mm",
        defaultValue: 2.4
    },

    /**
     * @member L.supermap.ServerStyleMap.prototype.lineColor
     * @description 线要素颜色
     */
    lineColor: {
        leafletStyle: "color",
        type: "color",
        defaultValue: "#000000"
    }
};

/**
 * @constant L.supermap.CompOpMap
 * @description Canvas中的globalCompositeOperation属性值与CartoCSS中的CompOp属性值对照表
 * @private
 */
var CompOpMap = exports.CompOpMap = {
    "clear": "",
    "src": "",
    "dst": "",
    "src-over": "source-over",
    "dst-over": "destination-over",
    "src-in": "source-in",
    "dst-in": "destination-in",
    "src-out": "source-out",
    "dst-out": "destination-out",
    "src-atop": "source-atop",
    "dst-atop": "destination-atop",
    "xor": "xor",
    "plus": "lighter",
    "minus": "",
    "multiply": "",
    "screen": "",
    "overlay": "",
    "darken": "",
    "lighten": "lighter",
    "color-dodge": "",
    "color-burn": "",
    "hard-light": "",
    "soft-light": "",
    "difference": "",
    "exclusion": "",
    "contrast": "",
    "invert": "",
    "invert-rgb": "",
    "grain-merge": "",
    "grain-extract": "",
    "hue": "",
    "saturation": "",
    "color": "",
    "value": ""
};

_leaflet2["default"].supermap.CartoStyleMap = CartoStyleMap;
_leaflet2["default"].supermap.ServerStyleMap = ServerStyleMap;
_leaflet2["default"].supermap.CompOpMap = CompOpMap;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MapVRenderer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _mapv = __webpack_require__(548);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BaseLayer = _mapv.baiduMapLayer ? _mapv.baiduMapLayer.__proto__ : Function;

/**
 * @class L.supermap.MapVRenderer
 * @classdesc 地图渲染类
 * @private
 * @extends mapv.BaseLayer
 * @param map - {L.map} 待渲染的地图
 * @param layer - {L.Layer} 待渲染的图层
 * @param dataSet - {DataSet} 待渲染的数据集
 * @param options - {Object} 渲染的参数
 */

var MapVRenderer = exports.MapVRenderer = function (_BaseLayer) {
    _inherits(MapVRenderer, _BaseLayer);

    function MapVRenderer(map, layer, dataSet, options) {
        _classCallCheck(this, MapVRenderer);

        var _this = _possibleConstructorReturn(this, (MapVRenderer.__proto__ || Object.getPrototypeOf(MapVRenderer)).call(this, map, dataSet, options));

        if (!BaseLayer) {
            return _possibleConstructorReturn(_this);
        }

        var self = _this;
        options = options || {};

        self.init(options);
        self.argCheck(options);
        _this.canvasLayer = layer;
        _this.clickEvent = _this.clickEvent.bind(_this);
        _this.mousemoveEvent = _this.mousemoveEvent.bind(_this);
        _this._moveStartEvent = _this.moveStartEvent.bind(_this);
        _this._moveEndEvent = _this.moveEndEvent.bind(_this);
        _this._zoomstart = _this.zoomStartEvent.bind(_this);
        _this.bindEvent();
        return _this;
    }

    /**
     * @function L.supermap.MapVRenderer.prototype.clickEvent
     * @description 点击事件
     * @param e - {Object} 触发对象
     */


    _createClass(MapVRenderer, [{
        key: 'clickEvent',
        value: function clickEvent(e) {
            var pixel = e.layerPoint;
            _get(MapVRenderer.prototype.__proto__ || Object.getPrototypeOf(MapVRenderer.prototype), 'clickEvent', this).call(this, pixel, e);
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.mousemoveEvent
         * @description 鼠标移动事件
         * @param  e - {Object} 触发对象
         */

    }, {
        key: 'mousemoveEvent',
        value: function mousemoveEvent(e) {
            var pixel = e.layerPoint;
            _get(MapVRenderer.prototype.__proto__ || Object.getPrototypeOf(MapVRenderer.prototype), 'mousemoveEvent', this).call(this, pixel, e);
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.bindEvent
         * @description 绑定鼠标移动和鼠标点击事件
         * @param e - {Object} 触发对象
         */

    }, {
        key: 'bindEvent',
        value: function bindEvent() {
            var map = this.map;

            if (this.options.methods) {
                if (this.options.methods.click) {
                    map.on('click', this.clickEvent);
                }
                if (this.options.methods.mousemove) {
                    map.on('mousemove', this.mousemoveEvent);
                }
            }
            this.map.on('movestart', this._moveStartEvent);
            this.map.on('moveend', this._moveEndEvent);
            this.map.on('zoomstart', this._zoomstart);
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.unbindEvent
         * @description 解绑鼠标移动和鼠标滑动触发的事件
         * @param e - {Object} 触发对象
         */

    }, {
        key: 'unbindEvent',
        value: function unbindEvent() {
            var map = this.map;

            if (this.options.methods) {
                if (this.options.methods.click) {
                    map.off('click', this.clickEvent);
                }
                if (this.options.methods.mousemove) {
                    map.off('mousemove', this.mousemoveEvent);
                }
            }
            this.map.off('movestart', this._moveStartEvent);
            this.map.off('moveend', this._moveEndEvent);
            this.map.off('zoomstart', this._zoomStartEvent);
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.getContext
         * @description 获取信息
         */

    }, {
        key: 'getContext',
        value: function getContext() {
            return this.canvasLayer.getCanvas().getContext(this.context);
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.addData
         * @description 添加数据
         * @param data - {oject} 待添加的数据
         * @param options - {oject} 待添加的数据信息
         */

    }, {
        key: 'addData',
        value: function addData(data, options) {
            var _data = data;
            if (data && data.get) {
                _data = data.get();
            }
            this.dataSet.add(_data);
            this.update({ options: options });
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.update
         * @description 更新图层
         * @param opt - {Object} 待更新的数据<br>
         *        data -{Object} mapv数据集<br>
         *        options -{Object} mapv绘制参数<br>
         */

    }, {
        key: 'update',
        value: function update(opt) {
            var update = opt || {};
            var _data = update.data;
            if (_data && _data.get) {
                _data = _data.get();
            }
            if (_data != undefined) {
                this.dataSet.set(_data);
            }
            _get(MapVRenderer.prototype.__proto__ || Object.getPrototypeOf(MapVRenderer.prototype), 'update', this).call(this, { options: update.options });
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.getData
         * @description 获取数据
         */

    }, {
        key: 'getData',
        value: function getData() {
            return this.dataSet;
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.removeData
         * @description 删除符合过滤条件的数据
         * @param filter - {function} 过滤条件。条件参数为数据项，返回值为true表示删除该元素；否则表示不删除
         */

    }, {
        key: 'removeData',
        value: function removeData(_filter) {
            if (!this.dataSet) {
                return;
            }
            var newData = this.dataSet.get({
                filter: function filter(data) {
                    return _filter != null && typeof _filter === "function" ? !_filter(data) : true;
                }
            });
            this.dataSet.set(newData);
            this.update({ options: null });
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.clearData
         * @description 清除数据
         */

    }, {
        key: 'clearData',
        value: function clearData() {
            this.dataSet && this.dataSet.clear();
            this.update({ options: null });
        }
    }, {
        key: '_canvasUpdate',
        value: function _canvasUpdate(time) {
            if (!this.canvasLayer) {
                return;
            }

            var self = this;

            var animationOptions = self.options.animation;

            var context = this.getContext();
            var map = this.map;
            if (self.isEnabledTime()) {
                if (time === undefined) {
                    this.clear(context);
                    return;
                }
                if (this.context === '2d') {
                    context.save();
                    context.globalCompositeOperation = 'destination-out';
                    context.fillStyle = 'rgba(0, 0, 0, .1)';
                    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
                    context.restore();
                }
            } else {
                this.clear(context);
            }

            if (this.context === '2d') {
                for (var key in self.options) {
                    context[key] = self.options[key];
                }
            } else {
                context.clear(context.COLOR_BUFFER_BIT);
            }

            if (self.options.minZoom && map.getZoom() < self.options.minZoom || self.options.maxZoom && map.getZoom() > self.options.maxZoom) {
                return;
            }

            var offset = map.latLngToAccurateContainerPoint(this.canvasLayer.getTopLeft());
            var dataGetOptions = {
                transferCoordinate: function transferCoordinate(coordinate) {
                    var worldPoint = map.latLngToAccurateContainerPoint(_leaflet2["default"].latLng(coordinate[1], coordinate[0]));
                    var pixel = {
                        x: worldPoint.x - offset.x,
                        y: worldPoint.y - offset.y
                    };
                    return [pixel.x, pixel.y];
                }
            };

            if (time !== undefined) {
                dataGetOptions.filter = function (item) {
                    var trails = animationOptions.trails || 10;
                    return time && item.time > time - trails && item.time < time;
                };
            }

            var data = self.dataSet.get(dataGetOptions);

            this.processData(data);

            self.options._size = self.options.size;

            var worldPoint = map.latLngToContainerPoint(_leaflet2["default"].latLng(0, 0));
            var pixel = {
                x: worldPoint.x - offset.x,
                y: worldPoint.y - offset.y
            };
            this.drawContext(context, new _mapv.DataSet(data), self.options, pixel);

            self.options.updateCallback && self.options.updateCallback(time);
        }
    }, {
        key: 'init',
        value: function init(options) {

            var self = this;

            self.options = options;

            this.initDataRange(options);

            this.context = self.options.context || '2d';

            if (self.options.zIndex) {
                this.canvasLayer && this.canvasLayer.setZIndex(self.options.zIndex);
            }

            this.initAnimator();
        }
    }, {
        key: 'addAnimatorEvent',
        value: function addAnimatorEvent() {}

        /**
         * @function L.supermap.MapVRenderer.prototype.moveStartEvent
         * @description 开始移动事件
         */

    }, {
        key: 'moveStartEvent',
        value: function moveStartEvent() {
            var animationOptions = this.options.animation;
            if (this.isEnabledTime() && this.animator) {
                this.steps.step = animationOptions.stepsRange.start;
                this._hide();
            }
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.moveEndEvent
         * @description 结束移动事件
         */

    }, {
        key: 'moveEndEvent',
        value: function moveEndEvent() {
            this.canvasLayer.draw();
            this._show();
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.zoomStartEvent
         * @description 隐藏渲染样式
         */

    }, {
        key: 'zoomStartEvent',
        value: function zoomStartEvent() {
            this._hide();
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.clear
         * @description 清除信息
         * @param context - {string} 指定要清除的信息
         */

    }, {
        key: 'clear',
        value: function clear(context) {
            context && context.clearRect && context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        }
    }, {
        key: '_hide',
        value: function _hide() {
            this.canvasLayer.canvas.style.display = 'none';
        }
    }, {
        key: '_show',
        value: function _show() {
            this.canvasLayer.canvas.style.display = 'block';
        }

        /**
         * @function L.supermap.MapVRenderer.prototype.draw
         * @description 绘制渲染
         */

    }, {
        key: 'draw',
        value: function draw() {
            this.canvasLayer.draw();
        }
    }]);

    return MapVRenderer;
}(BaseLayer);

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineSymbolizer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _Symbolizer = __webpack_require__(83);

var _SymbolizerPolyBase = __webpack_require__(287);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.LineSymbolizer
 * @classdesc 线符号类
 * @private
 * @extends L.Polyline{@linkdoc-leaflet/#polyline}
 * @param feature - {L.feature} 线要素
 * @param pxPerExtent - {number}线长
 */
var LineSymbolizer = exports.LineSymbolizer = _leaflet2["default"].Polyline.extend({

    /**
     * @member L.supermap.LineSymbolizer.prototype.includes
     * @description 包含符号
     */
    includes: [_Symbolizer.Symbolizer.prototype, _SymbolizerPolyBase.PolyBase],

    initialize: function initialize(feature, pxPerExtent) {
        _Symbolizer.Symbolizer.prototype.initialize.call(this, feature);
        this._makeFeatureParts(feature, pxPerExtent);
    },

    /**
     * @function L.supermap.LineSymbolizer.prototype.render
     * @description 绘制线符号
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    render: function render(renderer, style) {
        style.fill = false;
        _Symbolizer.Symbolizer.prototype.render.call(this, renderer, style);
        this._updatePath();
    },

    /**
     * @function L.supermap.LineSymbolizer.prototype.updateStyle
     * @description 更新替换符号样式
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    updateStyle: function updateStyle(renderer, style) {
        style.fill = false;
        _Symbolizer.Symbolizer.prototype.updateStyle.call(this, renderer, style);
    }
});

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PointSymbolizer = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Symbolizer = __webpack_require__(83);

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.PointSymbolizer
 * @classdesc 点符号类
 * @private
 * @extends L.CircleMarker{@linkdoc-leaflet/#circlemarker}
 * @param feature - {L.feature} 点要素
 * @param pxPerExtent - {number}点符号大小
 */
var PointSymbolizer = exports.PointSymbolizer = _leaflet2["default"].CircleMarker.extend({

    /**
     * @member L.supermap.PointSymbolizer.prototype.includes
     * @description 包含符号
     */
    includes: _Symbolizer.Symbolizer.prototype,

    statics: {
        iconCache: {}
    },

    initialize: function initialize(feature, pxPerExtent) {
        _Symbolizer.Symbolizer.prototype.initialize.call(this, feature);
        this._makeFeatureParts(feature, pxPerExtent);
    },

    /**
     * @function L.supermap.PointSymbolizer.prototype.render
     * @description 绘制点符号
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    render: function render(renderer, style) {
        _Symbolizer.Symbolizer.prototype.render.call(this, renderer, style);
        this._radius = style.radius || _leaflet2["default"].CircleMarker.prototype.options.radius;
        this._updatePath();
    },

    _makeFeatureParts: function _makeFeatureParts(feat, pxPerExtent) {
        pxPerExtent = pxPerExtent || { x: 1, y: 1 };
        var coord = feat.geometry[0];
        if (_typeof(coord[0]) === 'object' && 'x' in coord[0]) {
            this._point = _leaflet2["default"].point(coord[0]).scaleBy(pxPerExtent);
            this._empty = _leaflet2["default"].Util.falseFn;
        } else {
            this._point = _leaflet2["default"].point(coord).scaleBy(pxPerExtent);
            this._empty = _leaflet2["default"].Util.falseFn;
        }
    },

    /**
     * @function L.supermap.PointSymbolizer.prototype.makeInteractive
     * @description 设置交互
     */
    makeInteractive: function makeInteractive() {
        this._updateBounds();
    },

    /**
     * @function L.supermap.PointSymbolizer.prototype.updateStyle
     * @description 更新替换符号样式
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    updateStyle: function updateStyle(renderer, style) {
        this._radius = style.radius || this._radius;
        this._updateBounds();
        return _Symbolizer.Symbolizer.prototype.updateStyle.call(this, renderer, style);
    },

    _updateBounds: function _updateBounds() {
        var icon = this.options.iconUrl;
        if (icon && this.options.iconSize) {
            var size = _leaflet2["default"].point(this.options.iconSize),
                anchor = size && size.divideBy(2, true),
                p = this._point.subtract(anchor);
            this._pxBounds = new _leaflet2["default"].Bounds(p, p.add(size));
        } else {
            _leaflet2["default"].CircleMarker.prototype._updateBounds.call(this);
        }
    },

    _updatePath: function _updatePath() {
        if (this.options.iconUrl) {
            this._renderer._updateIcon(this);
        } else {
            _leaflet2["default"].CircleMarker.prototype._updatePath.call(this);
        }
    },

    _getImage: function _getImage() {
        if (!this.options.iconUrl) {
            return null;
        }
        var url = this.options.iconUrl,
            img = PointSymbolizer.iconCache[url];
        if (!img) {
            var iconSize = this.options.iconSize || [50, 50];
            img = PointSymbolizer.iconCache[url] = this._createIcon(url, iconSize);
        }
        return img;
    },

    _createIcon: function _createIcon(url, iconSize) {
        var src = url;

        if (!src) {
            throw new Error('iconUrl not set in Icon options (see the docs).');
        }

        var img = document.createElement('img'),
            name = "icon";
        img.src = src;
        img.className = 'leaflet-marker-' + name + ' ' + (this.layerName || '');

        // var options = this.options;
        var sizeOption = iconSize;

        if (typeof sizeOption === 'number') {
            sizeOption = [sizeOption, sizeOption];
        }
        if (sizeOption) {
            var size = _leaflet2["default"].point(sizeOption),
                anchor = _leaflet2["default"].point(size && size.divideBy(2, true));

            if (size) {
                img.style.width = size.x + 'px';
                img.style.height = size.y + 'px';
            }
            if (anchor) {
                img.style.marginLeft = -anchor.x + 'px';
                img.style.marginTop = -anchor.y + 'px';
            }
        }

        img.onload = function () {
            if (!sizeOption) {
                img.style.width = this.width + 'px';
                img.style.height = this.height + 'px';
            }
        };

        return img;
    },

    _containsPoint: function _containsPoint(p) {
        var icon = this.options.iconUrl;
        if (icon) {
            return this._pxBounds.contains(p);
        } else {
            return _leaflet2["default"].CircleMarker.prototype._containsPoint.call(this, p);
        }
    }
});

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RegionSymbolizer = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _Symbolizer = __webpack_require__(83);

var _SymbolizerPolyBase = __webpack_require__(287);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.RegionSymbolizer
 * @classdesc 面符号类
 * @private
 * @extends L.Polygon{@linkdoc-leaflet/#polygon}
 * @param feature - {L.feature} 面要素
 * @param pxPerExtent - {number}面积像素大小
 */
var RegionSymbolizer = exports.RegionSymbolizer = _leaflet2["default"].Polygon.extend({

    /**
     * @member L.supermap.RegionSymbolizer.prototype.includes
     * @description 包含符号
     */
    includes: [_Symbolizer.Symbolizer.prototype, _SymbolizerPolyBase.PolyBase],

    initialize: function initialize(feature, pxPerExtent) {
        _Symbolizer.Symbolizer.prototype.initialize.call(this, feature);
        this._makeFeatureParts(feature, pxPerExtent);
    },

    /**
     * @function L.supermap.RegionSymbolizer.prototype.render
     * @description 绘制面符号
     * @param renderer - {Object} 渲染器
     * @param style - {string} 符号样式
     */
    render: function render(renderer, style) {
        _Symbolizer.Symbolizer.prototype.render.call(this, renderer, style);
        this._updatePath();
    }
});

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorGrid = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _SVGRenderer = __webpack_require__(286);

var _CanvasRenderer = __webpack_require__(285);

var _VectorTile = __webpack_require__(453);

var _TextSymbolizer = __webpack_require__(288);

var _VectorTileFormat = __webpack_require__(282);

var _VectorFeatureType = __webpack_require__(84);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.VectorGrid
 * @classdesc 矢量瓦片图层基类
 * @private
 * @extends L.GridLayer{@linkdoc-leaflet/#gridlayer}
 * @param options - {Object} 矢量瓦片图层基类参数。如：<br>
 *        vectorTileLayerStyles - {Object} 矢量网片图层风格。<br>
 *        renderer - {string} 渲染器类型。<br>
 *        format - {L.supermap.VectorTileFormat} 矢量瓦片格式。<br>
 *        interactive - {boolean} 是否可交互 。
 */
var VectorGrid = exports.VectorGrid = _leaflet2["default"].GridLayer.extend({

    options: {
        vectorTileLayerStyles: null,
        //SVG or Canvas
        renderer: "SVG",
        format: _VectorTileFormat.VectorTileFormat.JSON,
        interactive: true
    },

    initialize: function initialize(options) {
        var me = this;
        _leaflet2["default"].setOptions(me, options);
        _leaflet2["default"].GridLayer.prototype.initialize.call(me, options);
        me._vectorTiles = {};
        //交互事件使用,键值为id_layerName
        me._overriddenStyles = {};
        me.vectorTileLayerStyles = me.options.vectorTileLayerStyles;
        me.on('tileunload', function (e) {
            var key = me._tileCoordsToKey(e.coords),
                tile = me._vectorTiles[key];

            if (tile && me._map) {
                tile.removeFrom(me._map);
            }
            delete me._vectorTiles[key];
        }, me);
        me.on('tileerror ', me._renderText, me);
        me.on('load', me._renderText, me);
        me._dataLayerNames = {};
    },

    /**
     * @private
     * @function L.supermap.VectorGrid.prototype.createTile
     * @description 创建切片图层
     * @param coords - {Object} 切片坐标参数对象
     * @param done - {} todo
     */
    createTile: function createTile(coords, done) {
        var me = this;

        var tileSize = me.getTileSize();
        var renderer = null;

        if (me.options.renderer === "Canvas") {
            renderer = new _CanvasRenderer.CanvasRenderer(coords, tileSize, me.options);
        } else {
            renderer = new _SVGRenderer.SVGRenderer(coords, tileSize, me.options);
        }

        me._vectorTiles[me._tileCoordsToKey(coords)] = renderer;
        renderer._features = {};

        new _VectorTile.VectorTile({
            layer: me,
            format: me.options.format,
            coords: coords,
            renderer: renderer
        }, done).renderTile();

        return renderer.getContainer();
    },

    /**
     * @function L.supermap.VectorGrid.prototype.getStyles
     * @description 获取图层样式
     * @return {Object} 所有图层的样式
     */
    getStyles: function getStyles() {
        return this.vectorTileLayerStyles;
    },

    /**
     * @function L.supermap.VectorGrid.prototype.getStyle
     * @description 获取指定图层样式
     * @param layerName - {string} 图层名称
     * @return {Object} 指定图层的样式
     */
    getStyle: function getStyle(layerName) {
        return this.vectorTileLayerStyles && this.vectorTileLayerStyles[layerName];
    },

    /**
     * @function L.supermap.VectorGrid.prototype.setFeatureStyle
     * @description 设置要素风格，需要id和layerName才能确定一个要素
     * @param id - {number}要素id
     * @param layerName - {string} 图层名称
     * @param layerStyle - {Array|function} 图层样式
     * @return {this} this
     */
    setFeatureStyle: function setFeatureStyle(id, layerName, layerStyle) {
        var featureKey = this._getFeatureKey(id, layerName);
        this._overriddenStyles[featureKey] = layerStyle;

        for (var tileKey in this._vectorTiles) {
            var tile = this._vectorTiles[tileKey];
            var features = tile._features;
            var data = features[featureKey];
            if (data) {
                var feat = data.feature;
                this._updateStyles(feat, tile, layerStyle);
            }
        }
        return this;
    },

    /**
     * @function L.supermap.VectorGrid.prototype.resetFeatureStyle
     * @description 重绘要素风格，需要id和layerName才能确定一个要素
     * @param id - {number}要素id
     * @param layerName - {string} 图层名称
     * @return {this} this
     */
    resetFeatureStyle: function resetFeatureStyle(id, layerName) {
        var featureKey = this._getFeatureKey(id, layerName);
        delete this._overriddenStyles[featureKey];

        for (var tileKey in this._vectorTiles) {
            var tile = this._vectorTiles[tileKey];
            var data = tile._features[featureKey];
            if (data) {
                var feat = data.feature;
                var styleOptions = this.vectorTileLayerStyles[data.layerName];
                this._updateStyles(feat, tile, styleOptions);
            }
        }
        return this;
    },

    /**
     * @function L.supermap.VectorGrid.prototype.getDataLayerNames
     * @description 获取数据图层名字
     * @return {Array} 返回数据图层名数组
     */
    getDataLayerNames: function getDataLayerNames() {
        return Object.keys(this._dataLayerNames);
    },

    _removeAllTiles: function _removeAllTiles() {
        _leaflet2["default"].GridLayer.prototype._removeAllTiles.call(this);
        this._textVectorTiles = {};
    },

    _renderText: function _renderText() {
        var textVectorTiles = this._textVectorTiles;
        for (var key in textVectorTiles) {
            var textTiles = textVectorTiles[key];
            var renderer = textTiles.renderer;

            for (var layerId in textTiles.layers) {
                var tile = textTiles.layers[layerId];
                var styleOptions = tile.style,
                    featureLayer = tile.layer;
                for (var j = 0; j < styleOptions.length; j++) {
                    featureLayer.render(renderer, styleOptions[j]);
                    renderer._addPath(featureLayer);
                }

                if (this.options.interactive) {
                    featureLayer.makeInteractive();
                }
            }
        }
    },

    _getFeatureKey: function _getFeatureKey(id, layerName) {
        id = id || 0;
        layerName = layerName || "null";
        return id + "_" + layerName;
    },

    _updateStyles: function _updateStyles(feat, renderer, styleOptions) {
        styleOptions = styleOptions instanceof Function ? styleOptions(feat.properties, renderer.getCoord().z) : styleOptions;

        if (!(styleOptions instanceof Array)) {
            styleOptions = [styleOptions];
        }

        for (var j = 0; j < styleOptions.length; j++) {
            var style = this._extendStyle(styleOptions[j], feat.type);
            feat.updateStyle(renderer, style);
        }
    },

    //矫正一些参数
    _extendStyle: function _extendStyle(style, type) {
        switch (type) {
            case _VectorFeatureType.VectorFeatureType.POINT:
                return _leaflet2["default"].extend({}, _leaflet2["default"].CircleMarker.prototype.options, style);
            case _VectorFeatureType.VectorFeatureType.LINE:
                return _leaflet2["default"].extend({}, _leaflet2["default"].Polyline.prototype.options, style);
            case _VectorFeatureType.VectorFeatureType.REGION:
                return _leaflet2["default"].extend({}, _leaflet2["default"].Polygon.prototype.options, style);
            case _VectorFeatureType.VectorFeatureType.TEXT:
                return _leaflet2["default"].extend({}, _TextSymbolizer.TextSymbolizer.prototype.options, style);
            default:
                break;
        }
    }

}); /**
     * Inspired by https://github.com/Leaflet/Leaflet.VectorGrid
     */

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorTile = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _VectorFeatureType = __webpack_require__(84);

var _TextSymbolizer = __webpack_require__(288);

var _PointSymbolizer = __webpack_require__(450);

var _LineSymbolizer = __webpack_require__(449);

var _RegionSymbolizer = __webpack_require__(451);

var _VectorTilePBF = __webpack_require__(455);

var _VectorTileJSON = __webpack_require__(454);

var _VectorTileFormat = __webpack_require__(282);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.VectorTile
 * @classdesc 矢量瓦片图层基类
 * @private
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param options - {Object} 矢量瓦片类构造可选参数。如：<br>
 *        layer - {string} 图层名称。<br>
 *        tileSize - {number} 瓦片大小。<br>
 *        format - {string} 返回值类型。<br>
 *        coords - {Object} 坐标系统对象。<br>
 *        renderer - {Object} 渲染器对象。
 * @param done - {function} 回调函数。
 */
var VectorTile = exports.VectorTile = _leaflet2["default"].Class.extend({

    initialize: function initialize(options, done) {
        this.layer = options.layer;
        this.tileSize = options.layer.getTileSize();
        this.format = options.format;
        this.coords = options.coords;
        this.renderer = options.renderer;
        this.done = done;
        this.layer._textVectorTiles = {};
    },

    /**
     * @function L.supermap.VectorTile.prototype.renderTile
     * @description 渲染切片
     */
    renderTile: function renderTile() {
        var me = this,
            layer = me.layer,
            coords = me.coords;
        var tileFeatureUrl = layer._getTileUrl(coords);

        var format = [_VectorTileFormat.VectorTileFormat.MVT, _VectorTileFormat.VectorTileFormat.PBF];

        var tileFeaturePromise;
        if (format.indexOf(me.format.toUpperCase()) > -1) {
            tileFeaturePromise = new _VectorTilePBF.VectorTilePBF(tileFeatureUrl);
        } else {
            tileFeaturePromise = new _VectorTileJSON.VectorTileJSON(tileFeatureUrl);
        }

        tileFeaturePromise.getTile().then(function (tileFeature) {
            me.render(tileFeature, coords);
        });
    },

    /**
     * @function L.supermap.VectorTile.prototype.render
     * @description 渲染切片要素
     * @param tileFeature - {L.feature} 要渲染的切片要素
     * @param coords - {Object} 切片坐标参数对象
     */
    render: function render(tileFeature, coords) {
        if (!tileFeature) {
            return;
        }
        var me = this,
            renderer = me.renderer,
            tileLayer = me.layer;

        for (var k = 0; k < tileFeature.length; k++) {
            var layer = tileFeature[k],
                layerName = layer.layerName;
            tileLayer._dataLayerNames[layerName] = true;
            var pxPerExtent = me.tileSize.divideBy(layer.extent);
            var layerStyleInfo = tileLayer.getLayerStyleInfo(layer.layerName);

            for (var i = 0; i < layer.features.length; i++) {
                var feat = layer.features[i];
                if (!feat) {
                    continue;
                }

                //标签图层处理为文本
                if (layerStyleInfo.type === _VectorFeatureType.VectorFeatureType.LABEL && feat.type === _VectorFeatureType.VectorFeatureType.POINT && feat.properties.attributes) {
                    feat.type = _VectorFeatureType.VectorFeatureType.TEXT;
                }

                var styleOptions = me._getStyleOptions(coords, feat, layerName, me);
                if (!styleOptions.length) {
                    continue;
                }

                var featureLayer = me._createFeatureLayer(feat, pxPerExtent);

                if (!featureLayer) {
                    continue;
                }

                // 保存文本图层单独绘制，避免被压盖
                var param = { scope: me, coords: coords, renderer: renderer };
                if (me._extractTextLayer(feat, featureLayer, styleOptions, param)) {
                    continue;
                }

                for (var j = 0; j < styleOptions.length; j++) {
                    var style = me._validateStyle(styleOptions[j], feat.type);
                    featureLayer.render(renderer, style);
                    renderer._addPath(featureLayer);
                }

                if (tileLayer.options.interactive) {
                    featureLayer.makeInteractive();
                }

                var featureKey = tileLayer._getFeatureKey(feat.id, layerName);
                renderer._features[featureKey] = {
                    layerName: layerName,
                    feature: featureLayer
                };
            }
        }

        if (tileLayer._map) {
            renderer.addTo(tileLayer._map);
        }

        _leaflet2["default"].Util.requestAnimFrame(me.done.bind(coords, null, me.layer._vectorTiles[me.layer._tileCoordsToKey(coords)]));
    },

    // 保存文本图层单独绘制，避免被压盖
    _extractTextLayer: function _extractTextLayer(feat, featureLayer, style, param) {

        if (feat.type !== _VectorFeatureType.VectorFeatureType.TEXT) {
            return false;
        }

        var me = param.scope,
            coords = param.coords,
            tileLayer = me.layer,
            key = tileLayer._tileCoordsToKey(coords);

        var id = feat.id,
            layerName = feat.layerName;

        var textTileLayers = tileLayer._textVectorTiles[key];
        if (!textTileLayers) {
            textTileLayers = {
                layers: {},
                coords: coords,
                renderer: param.renderer
            };
        }

        // 不同瓦片可能请求到同一个文本图层，为避免重复绘制，只保存绘制最后一个
        textTileLayers.layers[id] = {
            layer: featureLayer,
            style: style,
            layerName: layerName
        };
        tileLayer._textVectorTiles[key] = textTileLayers;
        return true;
    },

    _getStyleOptions: function _getStyleOptions(coords, feature, layerName, scope) {
        var me = scope;
        var tileLayer = me.layer;
        var styleOptions = tileLayer.getVectorTileLayerStyle(coords, feature) || me._defaultStyle(feature.type);

        //根据id和layerName识别唯一要素
        var id = feature.id,
            styleKey = tileLayer._getFeatureKey(id, layerName),
            styleOverride = tileLayer._overriddenStyles[styleKey];

        styleOptions = styleOverride ? styleOverride : styleOptions;
        styleOptions = styleOptions instanceof Function ? styleOptions(feature.properties, coords.z) : styleOptions;
        styleOptions = !(styleOptions instanceof Array) ? [styleOptions] : styleOptions;
        return styleOptions;
    },

    _createFeatureLayer: function _createFeatureLayer(feat, pxPerExtent) {
        var layer;
        switch (feat.type) {
            case _VectorFeatureType.VectorFeatureType.POINT:
                layer = new _PointSymbolizer.PointSymbolizer(feat, pxPerExtent);
                break;
            case _VectorFeatureType.VectorFeatureType.LINE:
                layer = new _LineSymbolizer.LineSymbolizer(feat, pxPerExtent);
                break;
            case _VectorFeatureType.VectorFeatureType.REGION:
                layer = new _RegionSymbolizer.RegionSymbolizer(feat, pxPerExtent);
                break;
            case _VectorFeatureType.VectorFeatureType.TEXT:
                layer = new _TextSymbolizer.TextSymbolizer(feat, pxPerExtent);
                break;
            default:
                break;
        }
        var vectorLayer = this.layer;

        if (layer && vectorLayer.options.interactive) {
            layer.addEventParent(vectorLayer);
        }

        return layer;
    },

    //矫正一些参数
    _validateStyle: function _validateStyle(style, type) {
        //默认leaflet path的边宽为3，矩形颜色填充透明度为0.2，跟iClient不一样，故作调整
        _leaflet2["default"].Path.prototype.options.weight = 1;
        _leaflet2["default"].Path.prototype.options.fillOpacity = 1;
        switch (type) {
            case _VectorFeatureType.VectorFeatureType.POINT:
                return _leaflet2["default"].extend({}, _leaflet2["default"].CircleMarker.prototype.options, style);
            case _VectorFeatureType.VectorFeatureType.LINE:
                return _leaflet2["default"].extend({}, _leaflet2["default"].Polyline.prototype.options, style);
            case _VectorFeatureType.VectorFeatureType.REGION:
                return _leaflet2["default"].extend({}, _leaflet2["default"].Polygon.prototype.options, style);
            case _VectorFeatureType.VectorFeatureType.TEXT:
                return _leaflet2["default"].extend({}, _TextSymbolizer.TextSymbolizer.prototype.options, style);
            default:
                break;
        }
    },

    //如果cartoCSS和layerInfo都没有得到样式，则使用该默认样式
    _defaultStyle: function _defaultStyle(type) {
        var defaultOptions = _leaflet2["default"].Path.prototype.options;
        defaultOptions.weight = 1;
        defaultOptions.fillOpacity = 1;
        defaultOptions.radius = 3;
        switch (type) {
            case _VectorFeatureType.VectorFeatureType.POINT:
                return _leaflet2["default"].extend({}, defaultOptions, _leaflet2["default"].CircleMarker.prototype.options);
            case _VectorFeatureType.VectorFeatureType.LINE:
                return _leaflet2["default"].extend({}, defaultOptions, _leaflet2["default"].Polyline.prototype.options);
            case _VectorFeatureType.VectorFeatureType.REGION:
                return _leaflet2["default"].extend({}, defaultOptions, _leaflet2["default"].Polygon.prototype.options);
            case _VectorFeatureType.VectorFeatureType.TEXT:
                return _leaflet2["default"].extend({}, defaultOptions, _TextSymbolizer.TextSymbolizer.prototype.options);
            default:
                break;
        }
    }

});

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorTileJSON = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _VectorFeatureType = __webpack_require__(84);

var _Util = __webpack_require__(43);

var Util = _interopRequireWildcard(_Util);

var _iclientCommon = __webpack_require__(5);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.VectorTileJSON
 * @classdesc iServer 矢量瓦片json表述出图
 * @private
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param url - {string} 矢量瓦片json表述服务地址
 */
var VectorTileJSON = exports.VectorTileJSON = _leaflet2["default"].Class.extend({

    initialize: function initialize(url) {
        this.url = url;
    },

    /**
     * @function L.supermap.VectorTileJSON.prototype.getTile
     * @description 获取瓦片
     * @return {Promise} 返回包含矢量瓦片信息(js对象)的Promise对象
     */
    getTile: function getTile() {
        var me = this;
        return _iclientCommon.FetchRequest.get(me.url, null, {
            timeout: 10000
        }).then(function (response) {
            return response.json();
        }).then(function (json) {
            return me._processRecordSets(json, me);
        });
    },

    _processRecordSets: function _processRecordSets(records, scope) {
        var recordsets = records.recordsets;
        // 如果iServer支持了tileFeature geojson表述则不需要此步骤
        recordsets = scope._convertToGeoJSON(recordsets);
        if (!recordsets) {
            return null;
        }

        //类似VT标准的数据格式,并为每个要素添加一个layerName字段
        for (var i = 0; i < recordsets.length; i++) {
            var recordset = recordsets[i];
            for (var j = 0; j < recordset.features.length; j++) {
                var feature = recordset.features[j];
                feature = scope._convertToVectorLayerFeature(feature, scope);
                feature.layerName = recordset.layerName;
                recordset.features[j] = feature;
            }
            recordset.extent = 256;
            delete recordset.fieldTypes;
            delete recordset.fields;
        }
        return recordsets;
    },

    _convertToVectorLayerFeature: function _convertToVectorLayerFeature(feature, scope) {
        if (!feature.geometry) {
            return;
        }
        var newFeature = {};

        var geom = feature.geometry,
            type = geom.type,
            coords = geom.coordinates,
            tags = feature.properties,
            id = tags.id,
            i,
            j,
            rings,
            projectedRing;

        if (type === 'Point') {
            newFeature = tags && tags.texts ? scope._createFeature(id, _VectorFeatureType.VectorFeatureType.TEXT, [coords], tags) : scope._createFeature(id, _VectorFeatureType.VectorFeatureType.POINT, [coords], tags);
        } else if (type === 'MultiPoint') {
            newFeature = scope._createFeature(id, _VectorFeatureType.VectorFeatureType.POINT, coords, tags);
        } else if (type === 'LineString') {
            newFeature = scope._createFeature(id, _VectorFeatureType.VectorFeatureType.LINE, [coords], tags);
        } else if (type === 'MultiLineString' || type === 'Polygon') {
            rings = [];
            for (i = 0; i < coords.length; i++) {
                projectedRing = coords[i];
                if (type === 'Polygon') {
                    projectedRing.outer = i === 0;
                }
                rings.push(projectedRing);
            }
            var featureType = type === 'Polygon' ? _VectorFeatureType.VectorFeatureType.REGION : _VectorFeatureType.VectorFeatureType.LINE;
            newFeature = scope._createFeature(id, featureType, rings, tags);
        } else if (type === 'MultiPolygon') {
            rings = [];
            for (i = 0; i < coords.length; i++) {
                for (j = 0; j < coords[i].length; j++) {
                    projectedRing = coords[i][j];
                    projectedRing.outer = j === 0;
                    rings.push(projectedRing);
                }
            }
            newFeature = scope._createFeature(id, _VectorFeatureType.VectorFeatureType.REGION, rings, tags);
        } else {
            throw new Error('不合法的GeoJSON对象');
        }
        return newFeature;
    },

    _convertToGeoJSON: function _convertToGeoJSON(recordsets) {
        if (!recordsets) {
            return;
        }
        for (var i = 0; i < recordsets.length; i++) {
            var recordset = recordsets[i];
            for (var j = 0; j < recordset.features.length; j++) {
                var feature = recordset.features[j];
                var points = [];
                var startIndex = 0;

                for (var k = 0; k < feature.geometry.parts.length; k++) {
                    var partPointsLength = feature.geometry.parts[k] * 2;
                    for (var l = 0, index = startIndex; l < partPointsLength; l += 2, index += 2) {
                        var x = feature.geometry.points[index];
                        var y = feature.geometry.points[index + 1];
                        points.push({ x: x, y: y });
                    }
                    startIndex += partPointsLength;
                }
                feature.geometry.points = points;
            }
            recordset.features = Util.toGeoJSON(recordset.features).features;
        }
        return recordsets;
    },

    _createFeature: function _createFeature(id, type, geometry, properties) {
        return {
            id: id,
            type: type,
            geometry: geometry,
            properties: properties
        };
    }

});

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VectorTilePBF = undefined;

var _leaflet = __webpack_require__(2);

var _leaflet2 = _interopRequireDefault(_leaflet);

var _pbf = __webpack_require__(497);

var _pbf2 = _interopRequireDefault(_pbf);

var _vectorTile = __webpack_require__(334);

var _vectorTile2 = _interopRequireDefault(_vectorTile);

var _VectorFeatureType = __webpack_require__(84);

var _iclientCommon = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @class L.supermap.VectorTilePBF
 * @classdesc 矢量瓦片PBF(MVT)表述出图
 * @private
 * @extends L.Class{@linkdoc-leaflet/#class}
 * @param url - {string} 矢量瓦片PBF(MVT)表述出图服务地址
 */
var VectorTilePBF = exports.VectorTilePBF = _leaflet2["default"].Class.extend({

    initialize: function initialize(url) {
        this.url = url;
    },

    /**
     * @function L.supermap.VectorTilePBF.prototype.getTile
     * @description 获取瓦片PBF(MVT)
     * @return {Promise} 返回包含矢量瓦片信息(js对象)的Promise对象
     */
    getTile: function getTile() {
        var me = this;
        return _iclientCommon.FetchRequest.get(me.url, null, {
            timeout: 10000
        }).then(function (response) {
            if (!response.ok) {
                return { layers: [] };
            }
            return response.blob().then(function (blob) {
                var reader = new FileReader();
                return new Promise(function (resolve) {
                    reader.addEventListener("loadend", function () {
                        var pbf = new _pbf2["default"](reader.result);
                        return resolve(new _vectorTile2["default"](pbf));
                    });
                    reader.readAsArrayBuffer(blob);
                });
            });
        }).then(function (json) {
            return me._processVectorTileSpec(json);
        });
    },

    _processVectorTileSpec: function _processVectorTileSpec(vectorTile) {
        var layers = [];
        for (var layerName in vectorTile.layers) {
            var feats = [];
            for (var i = 0; i < vectorTile.layers[layerName].length; i++) {
                var feat = vectorTile.layers[layerName].feature(i);
                feat.geometry = feat.loadGeometry();
                feat.layerName = layerName;
                feat.properties = { attributes: _leaflet2["default"].Util.extend({}, feat.properties), id: feat.id };
                switch (feat.type) {
                    case 1:
                        feat.type = _VectorFeatureType.VectorFeatureType.POINT;
                        break;
                    case 2:
                        feat.type = _VectorFeatureType.VectorFeatureType.LINE;
                        break;
                    case 3:
                        feat.type = _VectorFeatureType.VectorFeatureType.REGION;
                        break;
                    default:
                        break;
                }
                feats.push(feat);
            }
            var layer = {};
            layer.features = feats;
            layer.layerName = layerName;
            layer.extent = vectorTile.layers[layerName].extent;
            layers.push(layer);
        }
        return layers;
    }

});

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
    factory(exports, module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, mod);
    global.fetchJsonp = mod.exports;
  }
})(undefined, function (exports, module) {
  'use strict';

  var defaultOptions = {
    timeout: 5000,
    jsonpCallback: 'callback',
    jsonpCallbackFunction: null
  };

  function generateCallbackFunction() {
    return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);
  }

  // Known issue: Will throw 'Uncaught ReferenceError: callback_*** is not defined'
  // error if request timeout
  function clearFunction(functionName) {
    // IE8 throws an exception when you try to delete a property on window
    // http://stackoverflow.com/a/1824228/751089
    try {
      delete window[functionName];
    } catch (e) {
      window[functionName] = undefined;
    }
  }

  function removeScript(scriptId) {
    var script = document.getElementById(scriptId);
    document.getElementsByTagName('head')[0].removeChild(script);
  }

  function fetchJsonp(_url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // to avoid param reassign
    var url = _url;
    var timeout = options.timeout || defaultOptions.timeout;
    var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;

    var timeoutId = undefined;

    return new Promise(function (resolve, reject) {
      var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();
      var scriptId = jsonpCallback + '_' + callbackFunction;

      window[callbackFunction] = function (response) {
        resolve({
          ok: true,
          // keep consistent with fetch API
          json: function json() {
            return Promise.resolve(response);
          }
        });

        if (timeoutId) clearTimeout(timeoutId);

        removeScript(scriptId);

        clearFunction(callbackFunction);
      };

      // Check if the user set their own params, and if not add a ? to start a list of params
      url += url.indexOf('?') === -1 ? '?' : '&';

      var jsonpScript = document.createElement('script');
      jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);
      jsonpScript.id = scriptId;
      document.getElementsByTagName('head')[0].appendChild(jsonpScript);

      timeoutId = setTimeout(function () {
        reject(new Error('JSONP request to ' + _url + ' timed out'));

        clearFunction(callbackFunction);
        removeScript(scriptId);
      }, timeout);
    });
  }

  // export as global function
  /*
  let local;
  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }
  local.fetchJsonp = fetchJsonp;
  */

  module.exports = fetchJsonp;
});

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var utils = __webpack_require__(459);

var AND = '&&',
    OR = '||',
    AND_STR = 'and',
    OR_STR = 'or',
    NOT = '!',
    EQUAL = '=',
    LIKE = '~',
    NOTEQUAL = NOT + EQUAL,
    NOTLIKE = NOT + LIKE,
    GT = '>',
    GE = '>=',
    LT = '<',
    LE = '<=',
    WILDCARD = '*',
    COMMA = ',',
    DELIMITER = '.',
    LEFT = '(',
    RIGHT = ')',
    WHERE = 'where',
    synopsis = {
  pathway: [],
  groups: {}
},
    AST = {},
    options = {};

var print = console.log;
// ------------------ splitter -------------------- //

function Tokenize(query) {
  var parts = __splitTrim(query, WHERE);
  var pathway = parts[0];
  var where = parts[1];

  synopsis.pathway = __splitTrim(pathway, COMMA);
  for (var i = 0, len = synopsis.pathway.length; i < len; i++) {
    synopsis.pathway[i] = __splitTrim(synopsis.pathway[i], DELIMITER);
    if (synopsis.pathway[i][0] == WILDCARD) synopsis.pathway[i].shift();
    if (synopsis.pathway[i].length === 0) synopsis.pathway.splice(i, 1);
  }

  var lastLeft = -1,
      lastRight = -1,
      current = 0;
  while (current < where.length) {
    if (where[current] === LEFT) {
      lastLeft = current;
    } else if (where[current] === RIGHT) {
      lastRight = current;
      if (lastRight > lastLeft && lastLeft !== -1) {
        var k = 'gr' + '_' + new Date().getTime();
        synopsis.groups[k] = where.substring(lastLeft + 1, lastRight);
        where = where.replace(LEFT + synopsis.groups[k] + RIGHT, k);
        current = -1;
      }
    }
    current += 1;
  }
  LogicalGrouping(AST, where);
}
function LogicalGrouping(current, where) {
  var lastAnd = __findIndex(where, AND),
      lastOr = __findIndex(where, OR);

  if (lastAnd !== Number.MAX_VALUE || lastOr !== Number.MAX_VALUE) {
    if (lastAnd < lastOr) {
      current.and = current.and || [];
      var parts = __splitTrim(where, AND);
      current.and.push(parts[0]);
      LogicalGrouping(current.and, parts[1]);
    } else {
      current.or = current.or || [];
      var parts = __splitTrim(where, OR);
      current.or.push(parts[0]);
      LogicalGrouping(current.or, parts[1]);
    }
  } else {
    if (synopsis.groups[where]) {
      where = synopsis.groups[where];
      LogicalGrouping(current, where);
    } else {
      if (Array.isArray(current)) current.push(where);else current.or = [where];
      ExtractExpression(AST.or ? AST.or : AST.and);
    }
  }
}
function ExtractExpression(logicalGroup) {
  for (var k in logicalGroup) {
    if (logicalGroup.hasOwnProperty(k)) {
      if (Array.isArray(logicalGroup[k])) {
        ExtractExpression(logicalGroup[k]);
      } else if (typeof logicalGroup[k] === 'string') {
        if (__contains(logicalGroup[k], NOTEQUAL)) {
          var parts = __splitTrim(logicalGroup[k], NOTEQUAL);
          logicalGroup[k] = {
            ne: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], NOTLIKE)) {
          var parts = __splitTrim(logicalGroup[k], NOTLIKE);
          logicalGroup[k] = {
            nreq: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], LIKE)) {
          var parts = __splitTrim(logicalGroup[k], LIKE);
          logicalGroup[k] = { // rough eq
            req: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], GE)) {
          var parts = __splitTrim(logicalGroup[k], GE);
          logicalGroup[k] = { // greater than or equal
            ge: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], GT)) {
          var parts = __splitTrim(logicalGroup[k], GT);
          logicalGroup[k] = { // greater than
            gt: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], LE)) {
          var parts = __splitTrim(logicalGroup[k], LE);
          logicalGroup[k] = { // less than or equal
            le: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], LT)) {
          var parts = __splitTrim(logicalGroup[k], LT);
          logicalGroup[k] = { // less than
            lt: [parts[0], parts[1]]
          };
        } else if (__contains(logicalGroup[k], EQUAL)) {
          var parts = __splitTrim(logicalGroup[k], EQUAL);
          logicalGroup[k] = {
            eq: [parts[0], parts[1]]
          };
        }
      }
    }
  }
}

function __findIndex(str, token) {
  var index = str.indexOf(token);
  return index === -1 ? Number.MAX_VALUE : index;
}
function __splitTrim(str, token) {
  return str.split(token).map(function (p) {
    return p.trim();
  });
}
function __contains(a, b) {
  return a.indexOf(b) > -1;
}
function __hierarchize(obj, dottedPath) {
  var parts = __splitTrim(dottedPath, DELIMITER);
  var res = obj;
  for (var p in parts) {
    if (res.hasOwnProperty(parts[p])) res = res[parts[p]];else return '';
  }
  // support comparison for Date/DateString
  if (utils.isDate(res)) res = res.valueOf();else if (utils.isDateString(res)) res = utils.parseDateFromString(res);else res = res.toString();

  return res;
}

function FilterOR(ASTNode, row) {
  var res = false;
  for (var k in ASTNode) {
    var filterFunc = k === AND_STR ? FilterAND : k === OR_STR ? FilterOR : Filter;
    res = res || filterFunc(ASTNode[k], row);
    if (options.trace) print(synopsis.step, '======((( or', ASTNode[k], res);
    if (res) return res;
  }
  return res;
}
function FilterAND(ASTNode, row) {
  var res = true;
  for (var k in ASTNode) {
    var filterFunc = k === AND_STR ? FilterAND : k === OR_STR ? FilterOR : Filter;
    res = res && filterFunc(ASTNode[k], row);
    if (options.trace) print(synopsis.step, '======((( and', ASTNode[k], res);
    if (!res) return res;
  }
  return res;
}
function Filter(ASTNode, row) {
  synopsis.step += 1;
  if (ASTNode.or) {
    var res = FilterOR(ASTNode.or, row);
    if (options.trace) print(synopsis.step, 'OR', ASTNode, res);
    return res;
  } else if (ASTNode.and) {
    var res = FilterAND(ASTNode.and, row);
    if (options.trace) print(synopsis.step, 'AND', ASTNode, res);
    return res;
  } else if ((typeof ASTNode === 'undefined' ? 'undefined' : _typeof(ASTNode)) === 'object') {
    if (ASTNode.eq) {
      // =
      return __hierarchize(row, ASTNode.eq[0]) === ASTNode.eq[1];
    } else if (ASTNode.ne) {
      // !=
      return __hierarchize(row, ASTNode.ne[0]) !== ASTNode.ne[1];
    } else if (ASTNode.req) {
      // ~
      return __contains(__hierarchize(row, ASTNode.req[0]), ASTNode.req[1]);
    } else if (ASTNode.nreq) {
      // ~
      return !__contains(__hierarchize(row, ASTNode.nreq[0]), ASTNode.nreq[1]);
    } else if (ASTNode.gt) {
      // >
      return __hierarchize(row, ASTNode.gt[0]) > ASTNode.gt[1];
    } else if (ASTNode.ge) {
      // >=
      return __hierarchize(row, ASTNode.ge[0]) >= ASTNode.ge[1];
    } else if (ASTNode.lt) {
      // <
      return __hierarchize(row, ASTNode.lt[0]) < ASTNode.lt[1];
    } else if (ASTNode.le) {
      // <=
      return __hierarchize(row, ASTNode.le[0]) <= ASTNode.le[1];
    } else {
      return Filter(ASTNode, row);
    }
  }
}
function Parse(dataSource) {
  var result = [];
  for (var k in dataSource) {
    if (Filter(AST, dataSource[k])) result.push(dataSource[k]);
  }return result;
}
function Fields(result) {
  if (result && synopsis.pathway.length > 0) {
    //print(synopsis.pathway);
    return result.map(function (ele) {
      var res = {};
      for (var i = 0, len = synopsis.pathway.length; i < len; i++) {
        var key = synopsis.pathway[i].join(DELIMITER);
        res[key] = __hierarchize(ele, key);
      }
      return res;
    });
  }
  return result;
}
function Query(dataSource, query, opts) {
  synopsis = {
    pathway: [],
    groups: {},
    step: 0
  };
  AST = {};
  opts = opts || {
    trace: false
  };
  options = opts;
  Tokenize(query);
  return Fields(Parse(dataSource));
}

if (typeof module != 'undefined' && typeof module.exports != 'undefined') module.exports = Query;
if (typeof window != 'undefined') window.Query = Query;

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getObjectType(obj) {
  return Object.prototype.toString.call(obj);
}
function isDate(obj) {
  return getObjectType(obj) === '[object Date]';
}
function isString(obj) {
  return getObjectType(obj) === '[object String]';
}
function isDateString(obj) {
  return isString(obj) && !isNaN(Date.parse(obj));
}
function isNumber(obj) {
  return typeof obj === 'number';
}
function parseDateFromString(str) {
  return Date.parse(str);
}
module.exports = {
  getObjectType: getObjectType,
  isDate: isDate,
  isString: isString,
  isDateString: isDateString,
  parseDateFromString: parseDateFromString,
  isNumber: isNumber
};

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(54),
    root = __webpack_require__(30);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(54),
    root = __webpack_require__(30);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(54),
    root = __webpack_require__(30);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(54),
    root = __webpack_require__(30);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(54),
    root = __webpack_require__(30);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTimes = __webpack_require__(471),
    isArguments = __webpack_require__(488),
    isArray = __webpack_require__(489),
    isBuffer = __webpack_require__(491),
    isIndex = __webpack_require__(479),
    isTypedArray = __webpack_require__(492);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(85),
    isObjectLike = __webpack_require__(113);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(292),
    isMasked = __webpack_require__(480),
    isObject = __webpack_require__(294),
    toSource = __webpack_require__(291);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(85),
    isLength = __webpack_require__(293),
    isObjectLike = __webpack_require__(113);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(481),
    nativeKeys = __webpack_require__(483);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 472 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(466);

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function (key) {
    return [key, object[key]];
  });
}

module.exports = baseToPairs;

/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(30);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseToPairs = __webpack_require__(472),
    getTag = __webpack_require__(477),
    mapToArray = __webpack_require__(482),
    setToPairs = __webpack_require__(487);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function (object) {
    var tag = getTag(object);
    if (tag == mapTag) {
      return mapToArray(object);
    }
    if (tag == setTag) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

module.exports = createToPairs;

/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(289);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataView = __webpack_require__(460),
    Map = __webpack_require__(461),
    Promise = __webpack_require__(462),
    Set = __webpack_require__(463),
    WeakMap = __webpack_require__(464),
    baseGetTag = __webpack_require__(85),
    toSource = __webpack_require__(291);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
            switch (ctorString) {
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}

module.exports = getTag;

/***/ }),
/* 478 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 480 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreJsData = __webpack_require__(474);

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 481 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 482 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var overArg = __webpack_require__(486);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(290);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(297)(module)))

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = [value, value];
  });
  return result;
}

module.exports = setToPairs;

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsArguments = __webpack_require__(467),
    isObjectLike = __webpack_require__(113);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(292),
    isLength = __webpack_require__(293);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(30),
    stubFalse = __webpack_require__(494);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(297)(module)))

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsTypedArray = __webpack_require__(469),
    baseUnary = __webpack_require__(473),
    nodeUtil = __webpack_require__(484);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeKeys = __webpack_require__(465),
    baseKeys = __webpack_require__(470),
    isArrayLike = __webpack_require__(490);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createToPairs = __webpack_require__(475),
    keys = __webpack_require__(493);

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

module.exports = toPairs;

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(500);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Pbf;

var ieee754 = __webpack_require__(457);

function Pbf(buf) {
    this.buf = ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function destroy() {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function readFields(readField, result, end) {
        end = end || this.length;

        while (this.pos < end) {
            var val = this.readVarint(),
                tag = val >> 3,
                startPos = this.pos;

            this.type = val & 0x7;
            readField(tag, result, this);

            if (this.pos === startPos) this.skip(val);
        }
        return result;
    },

    readMessage: function readMessage(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function readFixed32() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function readSFixed32() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function readFixed64() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function readSFixed64() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function readFloat() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function readDouble() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function readVarint(isSigned) {
        var buf = this.buf,
            val,
            b;

        b = buf[this.pos++];val = b & 0x7f;if (b < 0x80) return val;
        b = buf[this.pos++];val |= (b & 0x7f) << 7;if (b < 0x80) return val;
        b = buf[this.pos++];val |= (b & 0x7f) << 14;if (b < 0x80) return val;
        b = buf[this.pos++];val |= (b & 0x7f) << 21;if (b < 0x80) return val;
        b = buf[this.pos];val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function readVarint64() {
        // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function readSVarint() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function readBoolean() {
        return Boolean(this.readVarint());
    },

    readString: function readString() {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function readBytes() {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function readPackedVarint(arr, isSigned) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readVarint(isSigned));
        }return arr;
    },
    readPackedSVarint: function readPackedSVarint(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readSVarint());
        }return arr;
    },
    readPackedBoolean: function readPackedBoolean(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readBoolean());
        }return arr;
    },
    readPackedFloat: function readPackedFloat(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readFloat());
        }return arr;
    },
    readPackedDouble: function readPackedDouble(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readDouble());
        }return arr;
    },
    readPackedFixed32: function readPackedFixed32(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readFixed32());
        }return arr;
    },
    readPackedSFixed32: function readPackedSFixed32(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readSFixed32());
        }return arr;
    },
    readPackedFixed64: function readPackedFixed64(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readFixed64());
        }return arr;
    },
    readPackedSFixed64: function readPackedSFixed64(arr) {
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) {
            arr.push(this.readSFixed64());
        }return arr;
    },

    skip: function skip(val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {} else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;else if (type === Pbf.Fixed32) this.pos += 4;else if (type === Pbf.Fixed64) this.pos += 8;else throw new Error('Unimplemented type: ' + type);
    },

    // === WRITING =================================================================

    writeTag: function writeTag(tag, type) {
        this.writeVarint(tag << 3 | type);
    },

    realloc: function realloc(min) {
        var length = this.length || 16;

        while (length < this.pos + min) {
            length *= 2;
        }if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function finish() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function writeFixed32(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function writeSFixed32(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function writeFixed64(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function writeSFixed64(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function writeVarint(val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] = val & 0x7f | (val > 0x7f ? 0x80 : 0);if (val <= 0x7f) return;
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);if (val <= 0x7f) return;
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);if (val <= 0x7f) return;
        this.buf[this.pos++] = val >>> 7 & 0x7f;
    },

    writeSVarint: function writeSVarint(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function writeBoolean(val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function writeString(str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function writeFloat(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function writeDouble(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function writeBytes(buffer) {
        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) {
            this.buf[this.pos++] = buffer[i];
        }
    },

    writeRawMessage: function writeRawMessage(fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function writeMessage(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint: function writePackedVarint(tag, arr) {
        this.writeMessage(tag, _writePackedVarint, arr);
    },
    writePackedSVarint: function writePackedSVarint(tag, arr) {
        this.writeMessage(tag, _writePackedSVarint, arr);
    },
    writePackedBoolean: function writePackedBoolean(tag, arr) {
        this.writeMessage(tag, _writePackedBoolean, arr);
    },
    writePackedFloat: function writePackedFloat(tag, arr) {
        this.writeMessage(tag, _writePackedFloat, arr);
    },
    writePackedDouble: function writePackedDouble(tag, arr) {
        this.writeMessage(tag, _writePackedDouble, arr);
    },
    writePackedFixed32: function writePackedFixed32(tag, arr) {
        this.writeMessage(tag, _writePackedFixed, arr);
    },
    writePackedSFixed32: function writePackedSFixed32(tag, arr) {
        this.writeMessage(tag, _writePackedSFixed, arr);
    },
    writePackedFixed64: function writePackedFixed64(tag, arr) {
        this.writeMessage(tag, _writePackedFixed2, arr);
    },
    writePackedSFixed64: function writePackedSFixed64(tag, arr) {
        this.writeMessage(tag, _writePackedSFixed2, arr);
    },

    writeBytesField: function writeBytesField(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function writeFixed32Field(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function writeSFixed32Field(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function writeFixed64Field(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function writeSFixed64Field(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function writeVarintField(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function writeSVarintField(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function writeStringField(tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function writeFloatField(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function writeDoubleField(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function writeBooleanField(tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h,
        b;

    b = buf[p.pos++];h = (b & 0x70) >> 4;if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];h |= (b & 0x7f) << 3;if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];h |= (b & 0x7f) << 10;if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];h |= (b & 0x7f) << 17;if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];h |= (b & 0x7f) << 24;if (b < 0x80) return toNum(l, h, s);
    b = buf[p.pos++];h |= (b & 0x01) << 31;if (b < 0x80) return toNum(l, h, s);

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return (high >>> 0) * 0x100000000 + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low = val % 0x100000000 | 0;
        high = val / 0x100000000 | 0;
    } else {
        low = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = low + 1 | 0;
        } else {
            low = 0;
            high = high + 1 | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos] = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 0x80 : 0);if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) return;
    pbf.buf[pbf.pos++] = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen = len <= 0x3fff ? 1 : len <= 0x1fffff ? 2 : len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) {
        pbf.buf[i + extraLen] = pbf.buf[i];
    }
}

function _writePackedVarint(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeVarint(arr[i]);
    }
}
function _writePackedSVarint(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeSVarint(arr[i]);
    }
}
function _writePackedFloat(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeFloat(arr[i]);
    }
}
function _writePackedDouble(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeDouble(arr[i]);
    }
}
function _writePackedBoolean(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeBoolean(arr[i]);
    }
}
function _writePackedFixed(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeFixed32(arr[i]);
    }
}
function _writePackedSFixed(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeSFixed32(arr[i]);
    }
}
function _writePackedFixed2(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeFixed64(arr[i]);
    }
}
function _writePackedSFixed2(arr, pbf) {
    for (var i = 0; i < arr.length; i++) {
        pbf.writeSFixed64(arr[i]);
    }
}

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 0x1000000;
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = val >>> 8;
    buf[pos + 2] = val >>> 16;
    buf[pos + 3] = val >>> 24;
}

function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence = b0 > 0xEF ? 4 : b0 > 0xDF ? 3 : b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) break;

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | b1 & 0x3F;
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | b2 & 0x3F;
                if (c <= 0x7FF || c >= 0xD800 && c <= 0xDFFF) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | b3 & 0x3F;
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;
        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || i + 1 === str.length) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}

  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function () {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new this.constructor(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = typeof setImmediate === 'function' && function (fn) {
    setImmediate(fn);
  } || function (fn) {
    setTimeoutFunc(fn, 0);
  };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };

  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }
})(undefined);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(496).setImmediate))

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(296), __webpack_require__(498)))

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var whatwgFetch = function (self) {
  'use strict';

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && function () {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value;
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function next() {
        var value = items.shift();
        return { done: value === undefined, value: value };
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function () {
        return iterator;
      };
    }

    return iterator;
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        this.append(name, value);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function (name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var list = this.map[name];
    if (!list) {
      list = [];
      this.map[name] = list;
    }
    list.push(value);
  };

  Headers.prototype['delete'] = function (name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function (name) {
    var values = this.map[normalizeName(name)];
    return values ? values[0] : null;
  };

  Headers.prototype.getAll = function (name) {
    return this.map[normalizeName(name)] || [];
  };

  Headers.prototype.has = function (name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };

  Headers.prototype.set = function (name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)];
  };

  Headers.prototype.forEach = function (callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function (name) {
      this.map[name].forEach(function (value) {
        callback.call(thisArg, value, name, this);
      }, this);
    }, this);
  };

  Headers.prototype.keys = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };

  Headers.prototype.values = function () {
    var items = [];
    this.forEach(function (value) {
      items.push(value);
    });
    return iteratorFor(items);
  };

  Headers.prototype.entries = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function (resolve, reject) {
      reader.onload = function () {
        resolve(reader.result);
      };
      reader.onerror = function () {
        reject(reader.error);
      };
    });
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    reader.readAsArrayBuffer(blob);
    return fileReaderReady(reader);
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    reader.readAsText(blob);
    return fileReaderReady(reader);
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function (body) {
      this._bodyInit = body;
      if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (!body) {
        this._bodyText = '';
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type');
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob');
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };

      this.arrayBuffer = function () {
        return this.blob().then(readBlobAsArrayBuffer);
      };

      this.text = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
    } else {
      this.text = function () {
        var rejected = consumed(this);
        return rejected ? rejected : Promise.resolve(this._bodyText);
      };
    }

    if (support.formData) {
      this.formData = function () {
        return this.text().then(decode);
      };
    }

    this.json = function () {
      return this.text().then(JSON.parse);
    };

    return this;
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = input;
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    this._initBody(body);
  }

  Request.prototype.clone = function () {
    return new Request(this);
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }

  function headers(xhr) {
    var head = new Headers();
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n');
    pairs.forEach(function (header) {
      var split = header.trim().split(':');
      var key = split.shift().trim();
      var value = split.join(':').trim();
      head.append(key, value);
    });
    return head;
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText;
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };

  Response.error = function () {
    var response = new Response(null, { status: 0, statusText: '' });
    response.type = 'error';
    return response;
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function (url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code');
    }

    return new Response(null, { status: status, headers: { location: url } });
  };

  // self.Headers = Headers
  // self.Request = Request
  // self.Response = Response

  var fetch = function fetch(input, init) {
    // console.log('whatwgFetchWidthTimeout--->'+input, init);
    init = init || { timeout: 30000 };
    return new Promise(function (resolve, reject) {
      var request;
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input;
      } else {
        request = new Request(input, init);
      }

      var xhr = new XMLHttpRequest();

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL;
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL');
        }

        return;
      }

      xhr.onload = function () {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        };
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request failed due to timeout'));
      };

      xhr.open(request.method, request.url, true);
      xhr.timeout = init.timeout || 30000;

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    });
  };
  return fetch;
}(typeof self !== 'undefined' ? self : undefined);

module.exports = whatwgFetch;

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

var mgrs = __webpack_require__(295);

function Point(x, y, z) {
  if (!(this instanceof Point)) {
    return new Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

Point.fromMGRS = function(mgrsStr) {
  return new Point(mgrs.toPoint(mgrsStr));
};
Point.prototype.toMGRS = function(accuracy) {
  return mgrs.forward([this.x, this.y], accuracy);
};
module.exports = Point;


/***/ }),
/* 503 */
/***/ (function(module, exports) {

module.exports = function(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      t = 'x';
    }
    else if (i === 1) {
      v = yin;
      t = 'y';
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      point[t] = v;
      break;
    case 'w':
      point[t] = -v;
      break;
    case 'n':
      point[t] = v;
      break;
    case 's':
      point[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        point.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        point.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return point;
};


/***/ }),
/* 504 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;

module.exports = function(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * HALF_PI);
    }
    else {
      return HALF_PI;
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
};

/***/ }),
/* 505 */
/***/ (function(module, exports) {

var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

module.exports = function(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
};

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

var pj_mlfn = __webpack_require__(298);
var EPSLN = 1.0e-10;
var MAX_ITER = 20;
module.exports = function(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
};

/***/ }),
/* 507 */
/***/ (function(module, exports) {

module.exports = function(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
};

/***/ }),
/* 508 */
/***/ (function(module, exports) {

exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};
exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};
exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};
exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};
exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};
exports.potsdam = {
  towgs84: "606.0,23.0,413.0",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};
exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};
exports.hermannskogel = {
  towgs84: "653.0,-212.0,449.0",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};
exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};
exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};
exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};
exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};
exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};
exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};
exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};
exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};

/***/ }),
/* 509 */
/***/ (function(module, exports) {

exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};
exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};
exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};
exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};
exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};
exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};
exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};
exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};
exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};
exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};
exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};
exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};
exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};
exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};
exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};
exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};
exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};
exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};
exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};
exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};
exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};
exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};
exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};
exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};
exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};
exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};
exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};
exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};
exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};
exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};
exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};
exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};
exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};
exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};
exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};
exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};
exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};
exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};
exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};
exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};
exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};
exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};
exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};

/***/ }),
/* 510 */
/***/ (function(module, exports) {

exports.greenwich = 0.0; //"0dE",
exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
exports.paris = 2.337229166667; //"2d20'14.025\"E",
exports.bogota = -74.080916666667; //"74d04'51.3\"W",
exports.madrid = -3.687938888889; //"3d41'16.58\"W",
exports.rome = 12.452333333333; //"12d27'8.4\"E",
exports.bern = 7.439583333333; //"7d26'22.5\"E",
exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
exports.ferro = -17.666666666667; //"17d40'W",
exports.brussels = 4.367975; //"4d22'4.71\"E",
exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
exports.athens = 23.7163375; //"23d42'58.815\"E",
exports.oslo = 10.722916666667; //"10d43'22.5\"E"

/***/ }),
/* 511 */
/***/ (function(module, exports) {

exports.ft = {to_meter: 0.3048};
exports['us-ft'] = {to_meter: 1200 / 3937};


/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

var proj = __webpack_require__(114);
var transform = __webpack_require__(304);
var wgs84 = proj('WGS84');

function transformer(from, to, coords) {
  var transformedArray;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords);
    if (coords.length === 3) {
      return [transformedArray.x, transformedArray.y, transformedArray.z];
    }
    else {
      return [transformedArray.x, transformedArray.y];
    }
  }
  else {
    return transform(from, to, coords);
  }
}

function checkProj(item) {
  if (item instanceof proj) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return proj(item);
}
function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  }
  else {
    obj = {
      forward: function(coords) {
        return transformer(fromProj, toProj, coords);
      },
      inverse: function(coords) {
        return transformer(toProj, fromProj, coords);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
module.exports = proj4;

/***/ }),
/* 513 */
/***/ (function(module, exports) {

var HALF_PI = Math.PI/2;
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var AD_C = 1.0026000;
var COS_67P5 = 0.38268343236508977;
var datum = function(proj) {
  if (!(this instanceof datum)) {
    return new datum(proj);
  }
  this.datum_type = PJD_WGS84; //default setting
  if (!proj) {
    return;
  }
  if (proj.datumCode && proj.datumCode === 'none') {
    this.datum_type = PJD_NODATUM;
  }

  if (proj.datum_params) {
    this.datum_params = proj.datum_params.map(parseFloat);
    if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {
      this.datum_type = PJD_3PARAM;
    }
    if (this.datum_params.length > 3) {
      if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {
        this.datum_type = PJD_7PARAM;
        this.datum_params[3] *= SEC_TO_RAD;
        this.datum_params[4] *= SEC_TO_RAD;
        this.datum_params[5] *= SEC_TO_RAD;
        this.datum_params[6] = (this.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  // DGR 2011-03-21 : nadgrids support
  this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;

  this.a = proj.a; //datum object also uses these values
  this.b = proj.b;
  this.es = proj.es;
  this.ep2 = proj.ep2;
  if (this.datum_type === PJD_GRIDSHIFT) {
    this.grids = proj.grids;
  }
};
datum.prototype = {


  /****************************************************************/
  // cs_compare_datums()
  //   Returns TRUE if the two datums match, otherwise FALSE.
  compare_datums: function(dest) {
    if (this.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    }
    else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {
      // the tolerence for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    }
    else if (this.datum_type === PJD_3PARAM) {
      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2]);
    }
    else if (this.datum_type === PJD_7PARAM) {
      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6]);
    }
    else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {
      //alert("ERROR: Grid shift transformations are not implemented.");
      //return false
      //DGR 2012-07-29 lazy ...
      return this.nadgrids === dest.nadgrids;
    }
    else {
      return true; // datums are equal
    }
  }, // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  geodetic_to_geocentric: function(p) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied
    var X; // output
    var Y;
    var Z;

    var Error_Code = 0; //  GEOCENT_NO_ERROR;
    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    }
    else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    }
    else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return null;
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = this.a / (Math.sqrt(1.0e0 - this.es * Sin2_Lat));
    X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);
    Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);
    Z = ((Rn * (1 - this.es)) + Height) * Sin_Lat;

    p.x = X;
    p.y = Y;
    p.z = Z;
    return Error_Code;
  }, // cs_geodetic_to_geocentric()


  geocentric_to_geodetic: function(p) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var At_Pole; /* indicates location is in polar region */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    At_Pole = false;
    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / this.a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      At_Pole = true;
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / this.a < genau) {
        Latitude = HALF_PI;
        Height = -this.b;
        return;
      }
    }
    else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);
    CPHI0 = ST * (1.0 - this.es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);

      RK = this.es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));

    p.x = Longitude;
    p.y = Latitude;
    p.z = Height;
    return p;
  }, // cs_geocentric_to_geodetic()

  /** Convert_Geocentric_To_Geodetic
   * The method used here is derived from 'An Improved Algorithm for
   * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996
   */
  geocentric_to_geodetic_noniter: function(p) {
    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    var W; /* distance from Z axis */
    var W2; /* square of distance from Z axis */
    var T0; /* initial estimate of vertical component */
    var T1; /* corrected estimate of vertical component */
    var S0; /* initial estimate of horizontal component */
    var S1; /* corrected estimate of horizontal component */
    var Sin_B0; /* Math.sin(B0), B0 is estimate of Bowring aux variable */
    var Sin3_B0; /* cube of Math.sin(B0) */
    var Cos_B0; /* Math.cos(B0) */
    var Sin_p1; /* Math.sin(phi1), phi1 is estimated latitude */
    var Cos_p1; /* Math.cos(phi1) */
    var Rn; /* Earth radius at location */
    var Sum; /* numerator of Math.cos(phi1) */
    var At_Pole; /* indicates location is in polar region */

    X = parseFloat(X); // cast from string to float
    Y = parseFloat(Y);
    Z = parseFloat(Z);

    At_Pole = false;
    if (X !== 0.0) {
      Longitude = Math.atan2(Y, X);
    }
    else {
      if (Y > 0) {
        Longitude = HALF_PI;
      }
      else if (Y < 0) {
        Longitude = -HALF_PI;
      }
      else {
        At_Pole = true;
        Longitude = 0.0;
        if (Z > 0.0) { /* north pole */
          Latitude = HALF_PI;
        }
        else if (Z < 0.0) { /* south pole */
          Latitude = -HALF_PI;
        }
        else { /* center of earth */
          Latitude = HALF_PI;
          Height = -this.b;
          return;
        }
      }
    }
    W2 = X * X + Y * Y;
    W = Math.sqrt(W2);
    T0 = Z * AD_C;
    S0 = Math.sqrt(T0 * T0 + W2);
    Sin_B0 = T0 / S0;
    Cos_B0 = W / S0;
    Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;
    T1 = Z + this.b * this.ep2 * Sin3_B0;
    Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;
    S1 = Math.sqrt(T1 * T1 + Sum * Sum);
    Sin_p1 = T1 / S1;
    Cos_p1 = Sum / S1;
    Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);
    if (Cos_p1 >= COS_67P5) {
      Height = W / Cos_p1 - Rn;
    }
    else if (Cos_p1 <= -COS_67P5) {
      Height = W / -Cos_p1 - Rn;
    }
    else {
      Height = Z / Sin_p1 + Rn * (this.es - 1.0);
    }
    if (At_Pole === false) {
      Latitude = Math.atan(Sin_p1 / Cos_p1);
    }

    p.x = Longitude;
    p.y = Latitude;
    p.z = Height;
    return p;
  }, // geocentric_to_geodetic_noniter()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)
  geocentric_to_wgs84: function(p) {

    if (this.datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      p.x += this.datum_params[0];
      p.y += this.datum_params[1];
      p.z += this.datum_params[2];

    }
    else if (this.datum_type === PJD_7PARAM) {
      var Dx_BF = this.datum_params[0];
      var Dy_BF = this.datum_params[1];
      var Dz_BF = this.datum_params[2];
      var Rx_BF = this.datum_params[3];
      var Ry_BF = this.datum_params[4];
      var Rz_BF = this.datum_params[5];
      var M_BF = this.datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;
      var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;
      var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;
      p.x = x_out;
      p.y = y_out;
      p.z = z_out;
    }
  }, // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  geocentric_from_wgs84: function(p) {

    if (this.datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      p.x -= this.datum_params[0];
      p.y -= this.datum_params[1];
      p.z -= this.datum_params[2];

    }
    else if (this.datum_type === PJD_7PARAM) {
      var Dx_BF = this.datum_params[0];
      var Dy_BF = this.datum_params[1];
      var Dz_BF = this.datum_params[2];
      var Rx_BF = this.datum_params[3];
      var Ry_BF = this.datum_params[4];
      var Rz_BF = this.datum_params[5];
      var M_BF = this.datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;
      p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;
      p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;
    } //cs_geocentric_from_wgs84()
  }
};

/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
module.exports = datum;


/***/ }),
/* 514 */
/***/ (function(module, exports) {

var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29
module.exports = function(source, dest, point) {
  var wp, i, l;

  function checkParams(fallback) {
    return (fallback === PJD_3PARAM || fallback === PJD_7PARAM);
  }
  // Short cut if the datums are identical.
  if (source.compare_datums(dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }

  //DGR: 2012-07-29 : add nadgrids support (begin)
  var src_a = source.a;
  var src_es = source.es;

  var dst_a = dest.a;
  var dst_es = dest.es;

  var fallback = source.datum_type;
  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  if (fallback === PJD_GRIDSHIFT) {
    if (this.apply_gridshift(source, 0, point) === 0) {
      source.a = SRS_WGS84_SEMIMAJOR;
      source.es = SRS_WGS84_ESQUARED;
    }
    else {
      // try 3 or 7 params transformation or nothing ?
      if (!source.datum_params) {
        source.a = src_a;
        source.es = source.es;
        return point;
      }
      wp = 1;
      for (i = 0, l = source.datum_params.length; i < l; i++) {
        wp *= source.datum_params[i];
      }
      if (wp === 0) {
        source.a = src_a;
        source.es = source.es;
        return point;
      }
      if (source.datum_params.length > 3) {
        fallback = PJD_7PARAM;
      }
      else {
        fallback = PJD_3PARAM;
      }
    }
  }
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest.a = SRS_WGS84_SEMIMAJOR;
    dest.es = SRS_WGS84_ESQUARED;
  }
  // Do we need to go through geocentric coordinates?
  if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {
    //DGR: 2012-07-29 : add nadgrids support (end)
    // Convert to geocentric coordinates.
    source.geodetic_to_geocentric(point);
    // CHECK_RETURN;
    // Convert between datums
    if (checkParams(source.datum_type)) {
      source.geocentric_to_wgs84(point);
      // CHECK_RETURN;
    }
    if (checkParams(dest.datum_type)) {
      dest.geocentric_from_wgs84(point);
      // CHECK_RETURN;
    }
    // Convert back to geodetic coordinates
    dest.geocentric_to_geodetic(point);
    // CHECK_RETURN;
  }
  // Apply grid shift to destination if required
  if (dest.datum_type === PJD_GRIDSHIFT) {
    this.apply_gridshift(dest, 1, point);
    // CHECK_RETURN;
  }

  source.a = src_a;
  source.es = src_es;
  dest.a = dst_a;
  dest.es = dst_es;

  return point;
};



/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

var Datum = __webpack_require__(508);
var Ellipsoid = __webpack_require__(509);
var extend = __webpack_require__(118);
var datum = __webpack_require__(513);
var EPSLN = 1.0e-10;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
module.exports = function(json) {
  // DGR 2011-03-20 : nagrids -> nadgrids
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = Datum[json.datumCode];
    if (datumDef) {
      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  if (!json.a) { // do we have an ellipsoid?
    var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;
    extend(json, ellipse);
  }
  if (json.rf && !json.b) {
    json.b = (1.0 - 1.0 / json.rf) * json.a;
  }
  if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {
    json.sphere = true;
    json.b = json.a;
  }
  json.a2 = json.a * json.a; // used in geocentric
  json.b2 = json.b * json.b; // used in geocentric
  json.es = (json.a2 - json.b2) / json.a2; // e ^ 2
  json.e = Math.sqrt(json.es); // eccentricity
  if (json.R_A) {
    json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));
    json.a2 = json.a * json.a;
    json.b2 = json.b * json.b;
    json.es = 0;
  }
  json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric
  if (!json.k0) {
    json.k0 = 1.0; //default value
  }
  //DGR 2010-11-12: axis
  if (!json.axis) {
    json.axis = "enu";
  }

  if (!json.datum) {
    json.datum = datum(json);
  }
  return json;
};


/***/ }),
/* 516 */
/***/ (function(module, exports) {

module.exports = function(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
};


/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

var projs = [
  __webpack_require__(303),
  __webpack_require__(542),
  __webpack_require__(541),
  __webpack_require__(540),
  __webpack_require__(539),
  __webpack_require__(536),
  __webpack_require__(530),
  __webpack_require__(528),
  __webpack_require__(522),
  __webpack_require__(529),
  __webpack_require__(520),
  __webpack_require__(527),
  __webpack_require__(523),
  __webpack_require__(524),
  __webpack_require__(537),
  __webpack_require__(535),
  __webpack_require__(533),
  __webpack_require__(538),
  __webpack_require__(534),
  __webpack_require__(525),
  __webpack_require__(543),
  __webpack_require__(521)
];
module.exports = function(proj4){
  projs.forEach(function(proj){
    proj4.Proj.projections.add(proj);
  });
};

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

var defs = __webpack_require__(300);
var wkt = __webpack_require__(305);
var projStr = __webpack_require__(302);
function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in defs;
}
function testWKT(code){
  var codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];
  return codeWords.reduce(function(a,b){
    return a+1+code.indexOf(b);
  },0);
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return defs[code];
    }
    else if (testWKT(code)) {
      return wkt(code);
    }
    else if (testProj(code)) {
      return projStr(code);
    }
  }else{
    return code;
  }
}

module.exports = parse;

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

var projs = [
  __webpack_require__(532),
  __webpack_require__(531)
];
var names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    names[n.toLowerCase()] = len;
  });
  return this;
}

exports.add = add;

exports.get = function(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {
    return projStore[names[n]];
  }
};
exports.start = function() {
  projs.forEach(add);
};


/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

var EPSLN = 1.0e-10;
var msfnz = __webpack_require__(45);
var qsfnz = __webpack_require__(117);
var adjust_lon = __webpack_require__(7);
var asinz = __webpack_require__(44);
exports.init = function() {

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
};

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
};


exports.inverse = function(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
};

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
exports.phi1z = function(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
};
exports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];


/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var mlfn = __webpack_require__(60);
var e0fn = __webpack_require__(56);
var e1fn = __webpack_require__(57);
var e2fn = __webpack_require__(58);
var e3fn = __webpack_require__(59);
var gN = __webpack_require__(115);
var asinz = __webpack_require__(44);
var imlfn = __webpack_require__(116);
exports.init = function() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
};

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c / Math.sin(c);
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


};

exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * HALF_PI * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    }
    else {
      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

};
exports.names = ["Azimuthal_Equidistant", "aeqd"];


/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

var mlfn = __webpack_require__(60);
var e0fn = __webpack_require__(56);
var e1fn = __webpack_require__(57);
var e2fn = __webpack_require__(58);
var e3fn = __webpack_require__(59);
var gN = __webpack_require__(115);
var adjust_lon = __webpack_require__(7);
var adjust_lat = __webpack_require__(55);
var imlfn = __webpack_require__(116);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
exports.init = function() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
};



/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;

};
exports.names = ["Cassini", "Cassini_Soldner", "cass"];

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var qsfnz = __webpack_require__(117);
var msfnz = __webpack_require__(45);
var iqsfnz = __webpack_require__(504);
/*
  reference:  
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
exports.init = function() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
};


/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
};

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["cea"];


/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var adjust_lat = __webpack_require__(55);
exports.init = function() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
};


// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
};

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
exports.inverse = function(p) {

  var x = p.x;
  var y = p.y;

  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
};
exports.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];


/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

var e0fn = __webpack_require__(56);
var e1fn = __webpack_require__(57);
var e2fn = __webpack_require__(58);
var e3fn = __webpack_require__(59);
var msfnz = __webpack_require__(45);
var mlfn = __webpack_require__(60);
var adjust_lon = __webpack_require__(7);
var adjust_lat = __webpack_require__(55);
var imlfn = __webpack_require__(116);
var EPSLN = 1.0e-10;
exports.init = function() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
};


/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

};
exports.names = ["Equidistant_Conic", "eqdc"];


/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

var FORTPI = Math.PI/4;
var srat = __webpack_require__(507);
var HALF_PI = Math.PI/2;
var MAX_ITER = 20;
exports.init = function() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
};

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
};

exports.inverse = function(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["gauss"];


/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var EPSLN = 1.0e-10;
var asinz = __webpack_require__(44);

/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
exports.init = function() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
};


/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
exports.forward = function(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project 
    // to infinity, on a bearing 
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that 
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
};


exports.inverse = function(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["gnom"];


/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
exports.init = function() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
};

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
exports.forward = function(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
};

/* calculate lat/lon from xy */
exports.inverse = function(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
};
exports.names = ["Krovak", "krovak"];


/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

var HALF_PI = Math.PI/2;
var FORTPI = Math.PI/4;
var EPSLN = 1.0e-10;
var qsfnz = __webpack_require__(117);
var adjust_lon = __webpack_require__(7);
/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

exports.S_POLE = 1;
exports.N_POLE = 2;
exports.EQUIT = 3;
exports.OBLIQ = 4;


/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
exports.init = function() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = this.authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
};

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.phi0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = HALF_PI + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - HALF_PI;
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
};

/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;

  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = HALF_PI - phi;
      break;
    case this.S_POLE:
      phi -= HALF_PI;
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = 0;
        p.y = this.phi0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = this.authlat(Math.asin(ab), this.apa);
  }


  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
};

/* determine latitude from authalic latitude */
exports.P00 = 0.33333333333333333333;
exports.P01 = 0.17222222222222222222;
exports.P02 = 0.10257936507936507936;
exports.P10 = 0.06388888888888888888;
exports.P11 = 0.06640211640211640211;
exports.P20 = 0.01641501294219154443;

exports.authset = function(es) {
  var t;
  var APA = [];
  APA[0] = es * this.P00;
  t = es * es;
  APA[0] += t * this.P01;
  APA[1] = t * this.P10;
  t *= es;
  APA[0] += t * this.P02;
  APA[1] += t * this.P11;
  APA[2] = t * this.P20;
  return APA;
};

exports.authlat = function(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
};
exports.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];


/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

var EPSLN = 1.0e-10;
var msfnz = __webpack_require__(45);
var tsfnz = __webpack_require__(87);
var HALF_PI = Math.PI/2;
var sign = __webpack_require__(61);
var adjust_lon = __webpack_require__(7);
var phi2z = __webpack_require__(86);
exports.init = function() {

  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
  //double c_lat;                   /* center latitude                      */
  //double c_lon;                   /* center longitude                     */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);

  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
};


// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
};

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
exports.inverse = function(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
};

exports.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];


/***/ }),
/* 531 */
/***/ (function(module, exports) {

exports.init = function() {
  //no-op for longlat
};

function identity(pt) {
  return pt;
}
exports.forward = identity;
exports.inverse = identity;
exports.names = ["longlat", "identity"];


/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

var msfnz = __webpack_require__(45);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var R2D = 57.29577951308232088;
var adjust_lon = __webpack_require__(7);
var FORTPI = Math.PI/4;
var tsfnz = __webpack_require__(87);
var phi2z = __webpack_require__(86);
exports.init = function() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
};

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
};


/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
exports.inverse = function(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
};

exports.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];


/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
exports.init = function() {
  //no-op
};


/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
};

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Miller_Cylindrical", "mill"];


/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var EPSLN = 1.0e-10;
exports.init = function() {};

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
exports.forward = function(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  for (var i = 0; true; i++) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
};

exports.inverse = function(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Mollweide", "moll"];


/***/ }),
/* 535 */
/***/ (function(module, exports) {

var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
exports.iterations = 1;

exports.init = function() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
};

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
exports.forward = function(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
};


/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
exports.inverse = function(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
};
exports.names = ["New_Zealand_Map_Grid", "nzmg"];

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

var tsfnz = __webpack_require__(87);
var adjust_lon = __webpack_require__(7);
var phi2z = __webpack_require__(86);
var HALF_PI = Math.PI/2;
var FORTPI = Math.PI/4;
var EPSLN = 1.0e-10;

/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
exports.init = function() {
  this.no_off = this.no_off || false;
  this.no_rot = this.no_rot || false;

  if (isNaN(this.k0)) {
    this.k0 = 1;
  }
  var sinlat = Math.sin(this.lat0);
  var coslat = Math.cos(this.lat0);
  var con = this.e * sinlat;

  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
  var t0 = tsfnz(this.e, this.lat0, sinlat);
  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
  if (dl * dl < 1) {
    dl = 1;
  }
  var fl;
  var gl;
  if (!isNaN(this.longc)) {
    //Central point and azimuth method

    if (this.lat0 >= 0) {
      fl = dl + Math.sqrt(dl * dl - 1);
    }
    else {
      fl = dl - Math.sqrt(dl * dl - 1);
    }
    this.el = fl * Math.pow(t0, this.bl);
    gl = 0.5 * (fl - 1 / fl);
    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

  }
  else {
    //2 points method
    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
    if (this.lat0 >= 0) {
      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    else {
      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
    }
    var hl = Math.pow(t1, this.bl);
    var ll = Math.pow(t2, this.bl);
    fl = this.el / hl;
    gl = 0.5 * (fl - 1 / fl);
    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
    var pl = (ll - hl) / (ll + hl);
    var dlon12 = adjust_lon(this.long1 - this.long2);
    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
    this.long0 = adjust_lon(this.long0);
    var dlon10 = adjust_lon(this.long1 - this.long0);
    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
  }

  if (this.no_off) {
    this.uc = 0;
  }
  else {
    if (this.lat0 >= 0) {
      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
    else {
      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
    }
  }

};


/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var dlon = adjust_lon(lon - this.long0);
  var us, vs;
  var con;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    if (lat > 0) {
      con = -1;
    }
    else {
      con = 1;
    }
    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
    us = -1 * con * HALF_PI * this.al / this.bl;
  }
  else {
    var t = tsfnz(this.e, lat, Math.sin(lat));
    var ql = this.el / Math.pow(t, this.bl);
    var sl = 0.5 * (ql - 1 / ql);
    var tl = 0.5 * (ql + 1 / ql);
    var vl = Math.sin(this.bl * (dlon));
    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
      vs = Number.POSITIVE_INFINITY;
    }
    else {
      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
    }
    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
      us = this.al * this.bl * (dlon);
    }
    else {
      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
    }
  }

  if (this.no_rot) {
    p.x = this.x0 + us;
    p.y = this.y0 + vs;
  }
  else {

    us -= this.uc;
    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
  }
  return p;
};

exports.inverse = function(p) {
  var us, vs;
  if (this.no_rot) {
    vs = p.y - this.y0;
    us = p.x - this.x0;
  }
  else {
    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
    us += this.uc;
  }
  var qp = Math.exp(-1 * this.bl * vs / this.al);
  var sp = 0.5 * (qp - 1 / qp);
  var tp = 0.5 * (qp + 1 / qp);
  var vp = Math.sin(this.bl * us / this.al);
  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
  if (Math.abs(up - 1) < EPSLN) {
    p.x = this.long0;
    p.y = HALF_PI;
  }
  else if (Math.abs(up + 1) < EPSLN) {
    p.x = this.long0;
    p.y = -1 * HALF_PI;
  }
  else {
    p.y = phi2z(this.e, ts);
    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
  }
  return p;
};

exports.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

var e0fn = __webpack_require__(56);
var e1fn = __webpack_require__(57);
var e2fn = __webpack_require__(58);
var e3fn = __webpack_require__(59);
var adjust_lon = __webpack_require__(7);
var adjust_lat = __webpack_require__(55);
var mlfn = __webpack_require__(60);
var EPSLN = 1.0e-10;
var gN = __webpack_require__(115);
var MAX_ITER = 20;
exports.init = function() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
};


/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
};


/* Inverse equations
  -----------------*/
exports.inverse = function(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Polyconic", "poly"];

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var adjust_lat = __webpack_require__(55);
var pj_enfn = __webpack_require__(505);
var MAX_ITER = 20;
var pj_mlfn = __webpack_require__(298);
var pj_inv_mlfn = __webpack_require__(506);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var asinz = __webpack_require__(44);
exports.init = function() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

};

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
exports.forward = function(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
};

exports.inverse = function(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  }
  else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    }
    else if ((s - EPSLN) < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Sinusoidal", "sinu"];

/***/ }),
/* 539 */
/***/ (function(module, exports) {

/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */
exports.init = function() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
};


exports.forward = function(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
};

exports.inverse = function(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
};

exports.names = ["somerc"];


/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var sign = __webpack_require__(61);
var msfnz = __webpack_require__(45);
var tsfnz = __webpack_require__(87);
var phi2z = __webpack_require__(86);
var adjust_lon = __webpack_require__(7);
exports.ssfn_ = function(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
};

exports.init = function() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
};

// Stereographic forward equations--mapping lat,long to x,y
exports.forward = function(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
};


//* Stereographic inverse equations--mapping x,y to lat/long
exports.inverse = function(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

};
exports.names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];


/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

var gauss = __webpack_require__(526);
var adjust_lon = __webpack_require__(7);
exports.init = function() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
};

exports.forward = function(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
};

exports.inverse = function(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
};

exports.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];


/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

var D2R = 0.01745329251994329577;
var tmerc = __webpack_require__(303);
exports.dependsOn = 'tmerc';
exports.init = function() {
  if (!this.zone) {
    return;
  }
  this.lat0 = 0;
  this.long0 = ((6 * Math.abs(this.zone)) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  tmerc.init.apply(this);
  this.forward = tmerc.forward;
  this.inverse = tmerc.inverse;
};
exports.names = ["Universal Transverse Mercator System", "utm"];


/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

var adjust_lon = __webpack_require__(7);
var HALF_PI = Math.PI/2;
var EPSLN = 1.0e-10;
var asinz = __webpack_require__(44);
/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
exports.init = function() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
};

exports.forward = function(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
};

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
exports.inverse = function(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  }
  else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
};
exports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];

/***/ }),
/* 544 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 545 */
/***/ (function(module, exports) {

module.exports = {"_from":"proj4@2.3.15","_id":"proj4@2.3.15","_inBundle":false,"_integrity":"sha1-WtBui8owvg/6OJpJ5FZfUfBtCJ4=","_location":"/proj4","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"proj4@2.3.15","name":"proj4","escapedName":"proj4","rawSpec":"2.3.15","saveSpec":null,"fetchSpec":"2.3.15"},"_requiredBy":["/"],"_resolved":"http://registry.npm.taobao.org/proj4/download/proj4-2.3.15.tgz","_shasum":"5ad06e8bca30be0ffa389a49e4565f51f06d089e","_spec":"proj4@2.3.15","_where":"F:\\codes\\iClient9","author":"","bugs":{"url":"https://github.com/proj4js/proj4js/issues"},"bundleDependencies":false,"contributors":[{"name":"Mike Adair","email":"madair@dmsolutions.ca"},{"name":"Richard Greenwood","email":"rich@greenwoodmap.com"},{"name":"Calvin Metcalf","email":"calvin.metcalf@gmail.com"},{"name":"Richard Marsden","url":"http://www.winwaed.com"},{"name":"T. Mittan"},{"name":"D. Steinwand"},{"name":"S. Nelson"}],"dependencies":{"mgrs":"~0.0.2"},"deprecated":false,"description":"Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.","devDependencies":{"browserify":"~12.0.1","chai":"~1.8.1","curl":"git://github.com/cujojs/curl.git","grunt":"~0.4.2","grunt-browserify":"~4.0.1","grunt-cli":"~0.1.13","grunt-contrib-connect":"~0.6.0","grunt-contrib-jshint":"~0.8.0","grunt-contrib-uglify":"~0.11.1","grunt-mocha-phantomjs":"~0.4.0","istanbul":"~0.2.4","mocha":"~1.17.1","tin":"~0.4.0"},"directories":{"test":"test","doc":"docs"},"homepage":"https://github.com/proj4js/proj4js#readme","jam":{"main":"dist/proj4.js","include":["dist/proj4.js","README.md","AUTHORS","LICENSE.md"]},"license":"MIT","main":"lib/index.js","name":"proj4","repository":{"type":"git","url":"git://github.com/proj4js/proj4js.git"},"scripts":{"test":"./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"},"version":"2.3.15"}

/***/ }),
/* 546 */
/***/ (function(module, exports) {

module.exports = function(){try{return echarts}catch(e){return {}}}();

/***/ }),
/* 547 */
/***/ (function(module, exports) {

module.exports = function(){try{return elasticsearch}catch(e){return {}}}();

/***/ }),
/* 548 */
/***/ (function(module, exports) {

module.exports = function(){try{return mapv}catch(e){return {}}}();

/***/ }),
/* 549 */
/***/ (function(module, exports) {

module.exports = function(){try{return turf}catch(e){return {}}}();

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(127);
__webpack_require__(310);
__webpack_require__(124);
__webpack_require__(125);
__webpack_require__(88);
__webpack_require__(126);
__webpack_require__(311);
__webpack_require__(136);
__webpack_require__(329);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(321);
__webpack_require__(135);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(331);
__webpack_require__(327);
__webpack_require__(326);
__webpack_require__(330);
__webpack_require__(332);
__webpack_require__(328);
__webpack_require__(121);
__webpack_require__(122);
__webpack_require__(120);
__webpack_require__(320);
__webpack_require__(119);
__webpack_require__(123);
__webpack_require__(134);
__webpack_require__(312);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(319);
__webpack_require__(133);
__webpack_require__(317);
__webpack_require__(132);
__webpack_require__(130);
__webpack_require__(316);
__webpack_require__(128);
__webpack_require__(129);
__webpack_require__(315);
__webpack_require__(318);
__webpack_require__(131);
__webpack_require__(308);
module.exports = __webpack_require__(309);


/***/ })
/******/ ]);